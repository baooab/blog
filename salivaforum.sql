-- MySQL dump 10.13  Distrib 5.7.19, for Linux (x86_64)
--
-- Host: localhost    Database: salivaforum
-- ------------------------------------------------------
-- Server version	5.7.19-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `salivaforum`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `salivaforum` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;

USE `salivaforum`;

--
-- Table structure for table `categories`
--

DROP TABLE IF EXISTS `categories`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `categories` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `slug` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `categories_name_unique` (`name`),
  UNIQUE KEY `categories_slug_unique` (`slug`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `categories`
--

LOCK TABLES `categories` WRITE;
/*!40000 ALTER TABLE `categories` DISABLE KEYS */;
INSERT INTO `categories` VALUES (1,'Laravel','laravel',NULL,NULL),(2,'Python','python',NULL,NULL),(3,'Telsafe','telsafe',NULL,NULL),(4,'文学','literature',NULL,NULL),(5,'ELK Stack','elk_stack',NULL,NULL),(6,'Java','java',NULL,NULL),(7,'JavaScript','javascript',NULL,NULL),(8,'HTML','html',NULL,NULL),(9,'CSS','css',NULL,NULL),(11,'PHP','php','2017-08-08 00:38:04',NULL),(12,'Linux','linux',NULL,NULL),(13,'SQL Server','sql_server',NULL,NULL),(14,'MySQL','mysql',NULL,NULL),(15,'Docker','docker',NULL,NULL),(16,'CSS深入理解','rich-understading-css',NULL,NULL),(17,'罗永浩·干货日记','luoyonghao',NULL,NULL),(18,'JavaScript Tips','javascript-tips',NULL,NULL),(19,'大数据','big-data',NULL,NULL),(20,'专栏','column',NULL,NULL),(21,'译文','translation',NULL,NULL);
/*!40000 ALTER TABLE `categories` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `body` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `user_id` int(10) unsigned NOT NULL,
  `discussion_id` int(10) unsigned NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `comments_user_id_foreign` (`user_id`),
  KEY `comments_discussion_id_foreign` (`discussion_id`)
) ENGINE=MyISAM AUTO_INCREMENT=45 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments`
--

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;
INSERT INTO `comments` VALUES (1,'![](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=4121011084,2283410513&fm=80&w=179&h=119&img.JPEG)',5,2,'2017-06-14 00:36:50','2017-06-14 00:36:50'),(2,'![](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=343974559,780603549&fm=26&gp=0.jpg)',5,5,'2017-06-14 00:42:03','2017-06-14 00:42:03'),(3,'![](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=343974559,780603549&fm=26&gp=0.jpg)',5,6,'2017-06-14 00:42:34','2017-06-14 00:42:34'),(4,'`差评`',7,6,'2017-06-14 00:42:35','2017-06-14 00:42:35'),(5,'**真好**',6,3,'2017-06-14 01:01:37','2017-06-14 01:01:37'),(6,'sb',8,2,'2017-06-14 01:03:08','2017-06-14 01:03:08'),(7,'Markdown 不是 XML 也不是编程语言，就是一种书写形式，全世界程序员都喜欢用它！\r\n\r\n当你要输入标题时，键入\r\n\r\n# H1\r\n## H2\r\n### H3\r\n#### H4\r\n##### H5\r\n###### H6\r\n你会看到这个结果。\r\n\r\nH1\r\nH2\r\nH3\r\nH4\r\n\r\nH5\r\n\r\nH6',8,8,'2017-06-14 01:10:26','2017-06-14 01:10:26'),(8,'小伙 牛逼啊? 这么勤奋！',3,2,'2017-06-14 04:24:26','2017-06-14 04:24:26'),(9,'写得不好啊?',3,6,'2017-06-14 04:50:47','2017-06-14 04:50:47'),(10,'如果大家发现什么BUG或者类似BUG的事情出现，在这里提出呦。',3,10,'2017-06-14 05:02:30','2017-06-14 05:02:30'),(11,'真扯',3,4,'2017-06-14 05:03:11','2017-06-14 05:03:11'),(12,'**文艺女青年**\r\n\r\n![大图片](http://img1.3lian.com/2015/a2/243/d/57.jpg)',3,6,'2017-06-14 16:42:14','2017-06-14 16:42:14'),(13,'[baidu](https://www.baidu.com/)',8,10,'2017-06-14 17:33:09','2017-06-14 17:33:09'),(14,'看不懂',3,3,'2017-06-15 00:15:44','2017-06-15 00:15:44'),(15,'#### ㊣',3,23,'2017-06-15 21:31:29','2017-06-15 21:31:29'),(16,'差评~',7,23,'2017-06-16 00:32:37','2017-06-16 00:32:37'),(17,'一看就知道是抄的?',3,80,'2017-06-22 06:31:10','2017-06-22 06:31:10'),(18,'高深莫测啊?',3,167,'2017-07-03 06:39:18','2017-07-03 06:39:18'),(19,'睡觉?',3,181,'2017-07-04 07:02:53','2017-07-04 07:02:53'),(20,'漫漫长夜，才刚刚开始那',7,181,'2017-07-04 07:06:08','2017-07-04 07:06:08'),(21,'你这不是每天一个命令了，是一天好几个！',3,214,'2017-07-10 06:36:11','2017-07-10 06:36:11'),(22,'太简洁了，完全看不懂！',3,265,'2017-08-10 06:10:08','2017-08-10 06:10:08'),(23,'<script>\r\nconsole.log(\'Oops!\');\r\n</script>',3,283,'2017-08-16 09:41:49','2017-08-16 09:41:49'),(24,'```\r\n<script>\r\nconsole.log(\'Oops!\');\r\n</script>\r\n```',3,283,'2017-08-16 09:43:26','2017-08-16 09:43:26'),(25,'我的代码片段：https://gist.coding.net/u/baooab',3,308,'2017-08-20 07:38:26','2017-08-20 07:38:26'),(26,'现在看起来，依然很感动。这并不是我在感怀过去，而是对担当和情谊的向往和追求。',3,37,'2017-08-27 00:05:51','2017-08-27 00:05:51'),(27,'!',15,330,'2017-08-31 06:24:54','2017-08-31 06:24:54'),(28,'孙同学，出差还不忘学习，值得钦佩啊，哈哈！',3,361,'2017-09-12 06:30:08','2017-09-12 06:30:08'),(29,'出差相当的苦恼~',7,361,'2017-09-12 07:35:29','2017-09-12 07:35:29'),(30,'? 没事 很快就会过去的 不过不要放弃学习啊',3,361,'2017-09-12 11:18:09','2017-09-12 11:18:09'),(31,'我要把你置顶了！',3,328,'2017-10-25 04:22:52','2017-10-25 04:22:52'),(32,'坚持是关键。往往你需要数月的时间才能看到结果。',3,427,'2017-10-25 11:23:17','2017-10-25 11:23:17'),(33,'有些内容已经过时了，但这对了解开始时的情况有用。以此类推至今。',3,436,'2017-10-25 11:24:58','2017-10-25 11:24:58'),(34,'OK？',3,328,'2017-10-25 11:27:21','2017-10-25 11:27:21'),(35,'冒泡',3,361,'2017-10-25 11:28:01','2017-10-25 11:28:01'),(36,'怎么回事？',3,428,'2017-10-25 11:28:31','2017-10-25 11:28:31'),(37,'~\\(≧▽≦)/~',3,33,'2017-11-08 06:42:23','2017-11-08 06:42:23'),(38,'> 我就编了一个故事，描写他从尾骨开始一寸寸变成了一条驴，并且把它写出来，以泄心头之愤。',3,32,'2017-11-08 06:44:21','2017-11-08 06:44:21'),(39,'> 现在的世界太不成话，儿子打老子……',3,68,'2017-11-08 06:45:38','2017-11-08 06:45:38'),(40,'顶！d=====(￣▽￣*)b',3,37,'2017-11-08 08:08:20','2017-11-08 08:08:20'),(41,'高手！',3,523,'2017-12-11 04:03:04','2017-12-11 04:03:04'),(42,'对象转换为字符换的情况，比较复杂，需要谨记。',3,539,'2017-12-16 08:45:34','2017-12-16 08:45:34'),(43,'差评',7,591,'2018-01-10 09:03:30','2018-01-10 09:03:30'),(44,'来来来，一起来唱！',3,353,'2018-01-13 13:49:22','2018-01-13 13:49:22');
/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `discussion_category`
--

DROP TABLE IF EXISTS `discussion_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `discussion_category` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `category_id` int(10) unsigned NOT NULL,
  `discussion_id` int(10) unsigned NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `discussion_category_category_id_foreign` (`category_id`),
  KEY `discussion_category_discussion_id_foreign` (`discussion_id`)
) ENGINE=MyISAM AUTO_INCREMENT=284 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `discussion_category`
--

LOCK TABLES `discussion_category` WRITE;
/*!40000 ALTER TABLE `discussion_category` DISABLE KEYS */;
INSERT INTO `discussion_category` VALUES (1,1,1,'2017-06-14 03:43:32','2017-06-14 03:43:32'),(2,1,12,'2017-06-14 18:29:23','2017-06-14 18:29:23'),(3,1,13,'2017-06-14 18:48:18','2017-06-14 18:48:18'),(4,1,16,'2017-06-14 19:03:28','2017-06-14 19:03:28'),(5,3,18,'2017-06-14 20:05:38','2017-06-14 20:05:38'),(6,3,17,'2017-06-14 20:05:44','2017-06-14 20:05:44'),(7,4,15,'2017-06-14 20:06:15','2017-06-14 20:06:15'),(8,1,19,'2017-06-14 22:08:53','2017-06-14 22:08:53'),(9,6,20,'2017-06-14 22:15:18','2017-06-14 22:15:18'),(10,5,3,'2017-06-15 00:10:58','2017-06-15 00:10:58'),(11,1,21,'2017-06-15 00:21:27','2017-06-15 00:21:27'),(12,3,23,'2017-06-15 20:21:44','2017-06-15 20:21:44'),(13,1,24,'2017-06-15 20:36:06','2017-06-15 20:36:06'),(14,1,25,'2017-06-15 21:54:41','2017-06-15 21:54:41'),(15,1,26,'2017-06-16 00:43:25','2017-06-16 00:43:25'),(16,7,38,'2017-06-16 01:43:59','2017-06-16 01:43:59'),(17,4,39,'2017-06-16 04:42:32','2017-06-16 04:42:32'),(18,4,40,'2017-06-16 05:25:31','2017-06-16 05:25:31'),(19,4,41,'2017-06-16 05:39:20','2017-06-16 05:39:20'),(20,4,37,'2017-06-16 05:43:07','2017-06-16 05:43:07'),(21,1,29,'2017-06-16 05:51:56','2017-06-16 05:51:56'),(22,4,33,'2017-06-16 05:52:19','2017-06-16 05:52:19'),(23,4,32,'2017-06-16 05:53:08','2017-06-16 05:53:08'),(24,7,43,'2017-06-17 06:56:33','2017-06-17 06:56:33'),(25,7,44,'2017-06-17 07:17:26','2017-06-17 07:17:26'),(26,7,45,'2017-06-17 07:25:57','2017-06-17 07:25:57'),(27,7,46,'2017-06-17 19:11:24','2017-06-17 19:11:24'),(28,7,47,'2017-06-17 19:27:18','2017-06-17 19:27:18'),(29,7,48,'2017-06-17 19:47:51','2017-06-17 19:47:51'),(30,7,49,'2017-06-17 22:07:59','2017-06-17 22:07:59'),(31,7,50,'2017-06-17 22:33:46','2017-06-17 22:33:46'),(32,7,51,'2017-06-17 22:43:00','2017-06-17 22:43:00'),(33,7,52,'2017-06-18 00:22:26','2017-06-18 00:22:26'),(34,4,54,'2017-06-18 16:12:49','2017-06-18 16:12:49'),(35,3,56,'2017-06-18 17:48:44','2017-06-18 17:48:44'),(36,4,57,'2017-06-19 06:21:14','2017-06-19 06:21:14'),(37,2,58,'2017-06-20 00:36:27','2017-06-20 00:36:27'),(38,2,61,'2017-06-20 00:46:42','2017-06-20 00:46:42'),(39,2,60,'2017-06-20 00:56:51','2017-06-20 00:56:51'),(40,2,59,'2017-06-20 00:57:00','2017-06-20 00:57:00'),(41,2,62,'2017-06-20 00:58:33','2017-06-20 00:58:33'),(42,2,63,'2017-06-20 00:59:20','2017-06-20 00:59:20'),(43,2,64,'2017-06-20 01:00:06','2017-06-20 01:00:06'),(44,2,65,'2017-06-20 01:01:04','2017-06-20 01:01:04'),(45,4,67,'2017-06-20 15:42:37','2017-06-20 15:42:37'),(46,4,68,'2017-06-20 16:04:12','2017-06-20 16:04:12'),(47,7,69,'2017-06-20 17:15:11','2017-06-20 17:15:11'),(48,1,70,'2017-06-20 17:25:36','2017-06-20 17:25:36'),(49,1,71,'2017-06-20 17:29:50','2017-06-20 17:29:50'),(50,1,72,'2017-06-20 17:32:51','2017-06-20 17:32:51'),(51,1,74,'2017-06-20 18:08:36','2017-06-20 18:08:36'),(52,1,75,'2017-06-20 18:22:22','2017-06-20 18:22:22'),(53,7,76,'2017-06-20 18:33:26','2017-06-20 18:33:26'),(54,1,77,'2017-06-20 18:47:54','2017-06-20 18:47:54'),(55,1,78,'2017-06-20 21:00:27','2017-06-20 21:00:27'),(56,1,79,'2017-06-20 21:09:02','2017-06-20 21:09:02'),(57,1,82,'2017-06-20 22:21:31','2017-06-20 22:21:31'),(58,1,81,'2017-06-20 22:35:43','2017-06-20 22:35:43'),(59,7,81,'2017-06-20 22:36:28','2017-06-20 22:36:28'),(60,2,80,'2017-06-21 04:03:01','2017-06-21 04:03:01'),(61,4,83,'2017-06-21 15:03:02','2017-06-21 15:03:02'),(62,2,86,'2017-06-21 21:49:17','2017-06-21 21:49:17'),(63,1,87,'2017-06-21 22:52:29','2017-06-21 22:52:29'),(64,2,66,'2017-06-21 23:35:21','2017-06-21 23:35:21'),(65,4,90,'2017-06-22 06:24:55','2017-06-22 06:24:55'),(66,4,91,'2017-06-22 06:44:30','2017-06-22 06:44:30'),(67,3,92,'2017-06-22 18:08:50','2017-06-22 18:08:50'),(68,1,93,'2017-06-22 20:32:35','2017-06-22 20:32:35'),(69,8,94,'2017-06-22 20:37:21','2017-06-22 20:37:21'),(70,9,94,'2017-06-22 20:37:21','2017-06-22 20:37:21'),(71,1,95,'2017-06-22 21:57:05','2017-06-22 21:57:05'),(72,1,96,'2017-06-22 22:19:17','2017-06-22 22:19:17'),(73,7,97,'2017-06-23 00:48:58','2017-06-23 00:48:58'),(74,7,98,'2017-06-23 01:12:27','2017-06-23 01:12:27'),(75,4,99,'2017-06-23 02:32:24','2017-06-23 02:32:24'),(76,4,100,'2017-06-23 08:09:33','2017-06-23 08:09:33'),(77,4,101,'2017-06-24 06:11:32','2017-06-24 06:11:32'),(78,1,103,'2017-06-25 03:39:26','2017-06-25 03:39:26'),(79,1,104,'2017-06-25 04:36:46','2017-06-25 04:36:46'),(80,1,105,'2017-06-25 04:50:27','2017-06-25 04:50:27'),(81,4,106,'2017-06-25 06:53:30','2017-06-25 06:53:30'),(82,1,108,'2017-06-25 15:43:03','2017-06-25 15:43:03'),(83,1,109,'2017-06-25 15:54:44','2017-06-25 15:54:44'),(84,1,111,'2017-06-25 16:08:23','2017-06-25 16:08:23'),(85,1,112,'2017-06-25 16:14:38','2017-06-25 16:14:38'),(86,1,113,'2017-06-25 16:23:10','2017-06-25 16:23:10'),(87,1,114,'2017-06-25 18:19:15','2017-06-25 18:19:15'),(88,1,115,'2017-06-25 21:02:32','2017-06-25 21:02:32'),(89,2,116,'2017-06-25 21:22:10','2017-06-25 21:22:10'),(90,1,117,'2017-06-26 00:09:24','2017-06-26 00:09:24'),(91,1,118,'2017-06-26 00:27:42','2017-06-26 00:27:42'),(92,4,119,'2017-06-26 07:17:42','2017-06-26 07:17:42'),(93,11,121,'2017-06-26 22:54:22','2017-06-26 22:54:22'),(94,1,124,'2017-06-27 00:39:37','2017-06-27 00:39:37'),(95,4,125,'2017-06-27 06:24:47','2017-06-27 06:24:47'),(96,1,126,'2017-06-27 17:54:15','2017-06-27 17:54:15'),(97,4,127,'2017-06-28 05:53:47','2017-06-28 05:53:47'),(98,1,129,'2017-06-28 17:51:27','2017-06-28 17:51:27'),(99,1,130,'2017-06-28 18:17:50','2017-06-28 18:17:50'),(100,1,131,'2017-06-28 21:40:31','2017-06-28 21:40:31'),(101,3,132,'2017-06-28 22:45:07','2017-06-28 22:45:07'),(102,1,133,'2017-06-28 23:20:45','2017-06-28 23:20:45'),(103,4,134,'2017-06-29 14:47:06','2017-06-29 14:47:06'),(104,11,136,'2017-06-29 15:57:44','2017-06-29 15:57:44'),(105,1,137,'2017-06-29 16:20:34','2017-06-29 16:20:34'),(106,1,138,'2017-06-29 17:19:55','2017-06-29 17:19:55'),(107,1,139,'2017-06-29 17:36:37','2017-06-29 17:36:37'),(108,1,142,'2017-06-29 23:32:11','2017-06-29 23:32:11'),(109,4,143,'2017-06-30 05:32:41','2017-06-30 05:32:41'),(110,4,144,'2017-06-30 06:12:30','2017-06-30 06:12:30'),(111,1,145,'2017-06-30 06:39:11','2017-06-30 06:39:11'),(112,1,146,'2017-07-01 00:42:24','2017-07-01 00:42:24'),(113,1,147,'2017-07-01 01:04:54','2017-07-01 01:04:54'),(114,1,148,'2017-07-01 01:33:07','2017-07-01 01:33:07'),(115,4,149,'2017-07-01 14:06:19','2017-07-01 14:06:19'),(116,1,150,'2017-07-01 18:23:01','2017-07-01 18:23:01'),(117,1,151,'2017-07-01 18:51:02','2017-07-01 18:51:02'),(118,1,153,'2017-07-02 02:21:23','2017-07-02 02:21:23'),(119,1,154,'2017-07-02 02:22:21','2017-07-02 02:22:21'),(120,1,155,'2017-07-02 02:22:54','2017-07-02 02:22:54'),(121,1,158,'2017-07-02 17:02:13','2017-07-02 17:02:13'),(122,1,159,'2017-07-02 17:48:45','2017-07-02 17:48:45'),(123,1,160,'2017-07-02 17:55:18','2017-07-02 17:55:18'),(124,1,161,'2017-07-02 17:59:53','2017-07-02 17:59:53'),(125,1,162,'2017-07-02 18:35:33','2017-07-02 18:35:33'),(126,1,163,'2017-07-02 18:45:08','2017-07-02 18:45:08'),(127,1,164,'2017-07-02 21:19:49','2017-07-02 21:19:49'),(128,1,165,'2017-07-02 22:15:03','2017-07-02 22:15:03'),(129,1,166,'2017-07-02 22:51:43','2017-07-02 22:51:43'),(130,1,168,'2017-07-02 23:35:35','2017-07-02 23:35:35'),(131,1,169,'2017-07-03 01:05:03','2017-07-03 01:05:03'),(132,2,167,'2017-07-03 01:20:16','2017-07-03 01:20:16'),(133,1,170,'2017-07-03 06:32:25','2017-07-03 06:32:25'),(134,1,172,'2017-07-03 17:42:43','2017-07-03 17:42:43'),(135,1,174,'2017-07-03 20:30:08','2017-07-03 20:30:08'),(136,3,175,'2017-07-04 00:45:25','2017-07-04 00:45:25'),(137,4,182,'2017-07-04 07:03:31','2017-07-04 07:03:31'),(138,1,176,'2017-07-04 21:33:27','2017-07-04 21:33:27'),(139,4,183,'2017-07-05 06:19:55','2017-07-05 06:19:55'),(140,7,189,'2017-07-07 00:40:32','2017-07-07 00:40:32'),(141,7,190,'2017-07-07 00:41:20','2017-07-07 00:41:20'),(142,7,192,'2017-07-07 00:42:28','2017-07-07 00:42:28'),(143,4,195,'2017-07-07 07:04:53','2017-07-07 07:04:53'),(144,3,204,'2017-07-09 17:39:19','2017-07-09 17:39:19'),(145,12,206,'2017-07-09 18:23:54','2017-07-09 18:23:54'),(146,12,207,'2017-07-09 18:24:58','2017-07-09 18:24:58'),(147,12,208,'2017-07-09 18:38:26','2017-07-09 18:38:26'),(148,12,209,'2017-07-09 18:55:55','2017-07-09 18:55:55'),(149,12,210,'2017-07-09 19:10:21','2017-07-09 19:10:21'),(150,12,211,'2017-07-09 21:17:20','2017-07-09 21:17:20'),(151,12,212,'2017-07-09 21:53:44','2017-07-09 21:53:44'),(152,12,213,'2017-07-09 22:00:58','2017-07-09 22:00:58'),(153,12,214,'2017-07-09 22:08:47','2017-07-09 22:08:47'),(154,8,216,'2017-07-10 05:30:25','2017-07-10 05:30:25'),(155,9,216,'2017-07-10 05:30:37','2017-07-10 05:30:37'),(156,8,217,'2017-07-10 06:26:16','2017-07-10 06:26:16'),(157,12,219,'2017-07-10 17:12:40','2017-07-10 17:12:40'),(158,12,220,'2017-07-10 17:14:55','2017-07-10 17:14:55'),(159,12,221,'2017-07-10 17:17:23','2017-07-10 17:17:23'),(160,12,222,'2017-07-10 17:19:51','2017-07-10 17:19:51'),(161,12,223,'2017-07-10 17:21:39','2017-07-10 17:21:39'),(162,1,225,'2017-07-11 00:34:36','2017-07-11 00:34:36'),(163,1,226,'2017-07-11 00:38:14','2017-07-11 00:38:14'),(164,4,235,'2017-07-14 07:29:19','2017-07-14 07:29:19'),(165,3,239,'2017-07-19 00:59:12','2017-07-19 00:59:12'),(166,4,240,'2017-07-22 07:56:39','2017-07-22 07:56:39'),(167,1,243,'2017-08-08 06:25:28','2017-08-08 06:25:28'),(168,1,244,'2017-08-08 06:35:40','2017-08-08 06:35:40'),(169,1,246,'2017-08-08 08:09:45','2017-08-08 08:09:45'),(170,9,248,'2017-08-09 05:24:12','2017-08-09 05:24:12'),(171,2,249,'2017-08-09 07:53:39','2017-08-09 07:53:39'),(172,2,250,'2017-08-09 07:57:57','2017-08-09 07:57:57'),(173,2,251,'2017-08-09 07:58:55','2017-08-09 07:58:55'),(174,2,252,'2017-08-09 08:00:13','2017-08-09 08:00:13'),(175,2,253,'2017-08-09 08:03:02','2017-08-09 08:03:02'),(176,2,254,'2017-08-09 08:04:31','2017-08-09 08:04:31'),(177,2,255,'2017-08-09 08:05:32','2017-08-09 08:05:32'),(178,2,256,'2017-08-09 08:06:20','2017-08-09 08:06:20'),(179,2,257,'2017-08-09 08:10:34','2017-08-09 08:10:34'),(180,2,258,'2017-08-09 08:14:23','2017-08-09 08:14:23'),(181,2,259,'2017-08-09 08:15:30','2017-08-09 08:15:30'),(182,2,260,'2017-08-09 08:16:29','2017-08-09 08:16:29'),(183,2,238,'2017-08-09 08:44:25','2017-08-09 08:44:25'),(184,15,264,'2017-08-10 02:53:24','2017-08-10 02:53:24'),(185,15,265,'2017-08-10 02:56:43','2017-08-10 02:56:43'),(186,13,180,'2017-08-10 02:57:36','2017-08-10 02:57:36'),(187,13,263,'2017-08-10 02:57:50','2017-08-10 02:57:50'),(188,13,262,'2017-08-10 02:58:00','2017-08-10 02:58:00'),(189,13,261,'2017-08-10 02:58:11','2017-08-10 02:58:11'),(190,1,266,'2017-08-10 04:54:02','2017-08-10 04:54:02'),(191,9,267,'2017-08-10 09:01:52','2017-08-10 09:01:52'),(192,1,268,'2017-08-11 01:50:14','2017-08-11 01:50:14'),(193,1,269,'2017-08-11 01:51:51','2017-08-11 01:51:51'),(194,9,273,'2017-08-12 03:18:50','2017-08-12 03:18:50'),(195,16,275,'2017-08-15 02:08:51','2017-08-15 02:08:51'),(196,3,276,'2017-08-15 05:38:43','2017-08-15 05:38:43'),(197,16,277,'2017-08-15 08:43:56','2017-08-15 08:43:56'),(198,9,278,'2017-08-16 03:13:20','2017-08-16 03:13:20'),(199,9,279,'2017-08-16 03:56:17','2017-08-16 03:56:17'),(200,9,280,'2017-08-16 04:46:14','2017-08-16 04:46:14'),(201,9,281,'2017-08-16 06:21:11','2017-08-16 06:21:11'),(202,9,282,'2017-08-16 07:03:15','2017-08-16 07:03:15'),(203,9,283,'2017-08-16 09:33:40','2017-08-16 09:33:40'),(204,17,288,'2017-08-17 05:15:24','2017-08-17 05:15:24'),(205,17,289,'2017-08-17 05:45:33','2017-08-17 05:45:33'),(206,1,290,'2017-08-17 06:37:26','2017-08-17 06:37:26'),(207,1,291,'2017-08-17 07:42:47','2017-08-17 07:42:47'),(208,1,292,'2017-08-17 08:14:26','2017-08-17 08:14:26'),(209,16,293,'2017-08-18 02:35:08','2017-08-18 02:35:08'),(210,9,294,'2017-08-18 02:59:46','2017-08-18 02:59:46'),(211,9,295,'2017-08-18 03:14:20','2017-08-18 03:14:20'),(212,9,296,'2017-08-18 04:52:28','2017-08-18 04:52:28'),(213,9,297,'2017-08-18 05:51:33','2017-08-18 05:51:33'),(214,9,298,'2017-08-18 07:53:41','2017-08-18 07:53:41'),(215,9,299,'2017-08-18 08:47:05','2017-08-18 08:47:05'),(216,1,300,'2017-08-18 09:38:59','2017-08-18 09:38:59'),(217,1,301,'2017-08-19 06:35:59','2017-08-19 06:35:59'),(218,14,303,'2017-08-20 01:35:21','2017-08-20 01:35:21'),(219,1,304,'2017-08-20 01:38:49','2017-08-20 01:38:49'),(220,1,305,'2017-08-20 05:41:54','2017-08-20 05:41:54'),(221,1,306,'2017-08-20 06:02:52','2017-08-20 06:02:52'),(222,1,307,'2017-08-20 07:15:44','2017-08-20 07:15:44'),(223,1,308,'2017-08-20 07:34:38','2017-08-20 07:34:38'),(224,1,309,'2017-08-21 01:36:57','2017-08-21 01:36:57'),(225,1,311,'2017-08-24 02:32:01','2017-08-24 02:32:01'),(226,1,313,'2017-08-25 05:05:48','2017-08-25 05:05:48'),(227,4,314,'2017-08-26 01:26:30','2017-08-26 01:26:30'),(228,1,315,'2017-08-27 04:51:40','2017-08-27 04:51:40'),(229,14,316,'2017-08-27 05:29:46','2017-08-27 05:29:46'),(230,1,319,'2017-08-28 00:39:01','2017-08-28 00:39:01'),(231,9,320,'2017-08-28 03:00:31','2017-08-28 03:00:31'),(232,18,323,'2017-08-28 08:56:10','2017-08-28 08:56:10'),(233,1,325,'2017-08-29 04:26:35','2017-08-29 04:26:35'),(234,1,326,'2017-08-30 07:26:24','2017-08-30 07:26:24'),(235,19,328,'2017-08-31 02:58:29','2017-08-31 02:58:29'),(236,17,330,'2017-08-31 06:23:11','2017-08-31 06:23:11'),(237,1,329,'2017-08-31 06:46:01','2017-08-31 06:46:01'),(238,9,335,'2017-09-01 08:32:18','2017-09-01 08:32:18'),(239,1,339,'2017-09-07 02:20:43','2017-09-07 02:20:43'),(240,1,336,'2017-09-07 04:06:45','2017-09-07 04:06:45'),(241,15,361,'2017-09-12 05:46:50','2017-09-12 05:46:50'),(242,1,364,'2017-09-13 00:10:08','2017-09-13 00:10:08'),(243,9,384,'2017-09-24 00:24:47','2017-09-24 00:24:47'),(244,9,388,'2017-09-26 02:39:33','2017-09-26 02:39:33'),(245,7,407,'2017-10-01 12:57:19','2017-10-01 12:57:19'),(246,1,448,'2017-10-29 07:25:38','2017-10-29 07:25:38'),(247,1,449,'2017-10-29 07:26:34','2017-10-29 07:26:34'),(248,21,436,'2017-11-03 08:22:20','2017-11-03 08:22:20'),(249,21,461,'2017-11-08 00:46:17','2017-11-08 00:46:17'),(250,21,462,'2017-11-08 02:56:11','2017-11-08 02:56:11'),(251,21,463,'2017-11-08 03:07:33','2017-11-08 03:07:33'),(252,4,237,'2017-11-08 06:49:11','2017-11-08 06:49:11'),(253,4,465,'2017-11-09 01:47:57','2017-11-09 01:47:57'),(254,21,470,'2017-11-10 09:18:15','2017-11-10 09:18:15'),(255,21,471,'2017-11-10 09:18:28','2017-11-10 09:18:28'),(256,21,472,'2017-11-10 09:40:03','2017-11-10 09:40:03'),(257,20,523,'2017-12-05 03:23:18','2017-12-05 03:23:18'),(258,7,539,'2017-12-11 01:34:48','2017-12-11 01:34:48'),(259,21,545,'2017-12-16 08:39:30','2017-12-16 08:39:30'),(260,7,458,'2017-12-16 14:07:52','2017-12-16 14:07:52'),(261,21,547,'2017-12-17 04:06:14','2017-12-17 04:06:14'),(262,21,548,'2017-12-17 05:08:14','2017-12-17 05:08:14'),(263,7,549,'2017-12-18 04:05:47','2017-12-18 04:05:47'),(264,7,484,'2017-12-18 07:32:55','2017-12-18 07:32:55'),(265,7,551,'2017-12-19 02:00:52','2017-12-19 02:00:52'),(266,7,554,'2017-12-20 04:33:40','2017-12-20 04:33:40'),(269,7,555,'2017-12-20 05:17:37','2017-12-20 05:17:37'),(270,7,560,'2017-12-21 02:05:42','2017-12-21 02:05:42'),(271,18,574,'2017-12-25 13:20:19','2017-12-25 13:20:19'),(272,18,581,'2018-01-05 06:19:11','2018-01-05 06:19:11'),(273,20,583,'2018-01-05 07:44:18','2018-01-05 07:44:18'),(274,7,584,'2018-01-06 03:46:33','2018-01-06 03:46:33'),(275,7,586,'2018-01-08 01:47:50','2018-01-08 01:47:50'),(276,12,587,'2018-01-08 07:23:54','2018-01-08 07:23:54'),(277,2,590,'2018-01-09 08:11:05','2018-01-09 08:11:05'),(278,15,594,'2018-01-11 08:08:53','2018-01-11 08:08:53'),(279,4,597,'2018-01-13 16:26:42','2018-01-13 16:26:42'),(280,7,600,'2018-01-15 01:39:41','2018-01-15 01:39:41'),(281,7,601,'2018-01-15 02:30:19','2018-01-15 02:30:19'),(282,21,601,'2018-01-15 04:52:23','2018-01-15 04:52:23'),(283,21,600,'2018-01-15 04:52:35','2018-01-15 04:52:35');
/*!40000 ALTER TABLE `discussion_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `discussions`
--

DROP TABLE IF EXISTS `discussions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `discussions` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(10) unsigned NOT NULL,
  `last_user_id` int(10) unsigned NOT NULL,
  `title` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `body` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `slug` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `discussions_user_id_foreign` (`user_id`),
  KEY `discussions_last_user_id_foreign` (`last_user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=605 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `discussions`
--

LOCK TABLES `discussions` WRITE;
/*!40000 ALTER TABLE `discussions` DISABLE KEYS */;
INSERT INTO `discussions` VALUES (1,3,3,'Eloquent：关联','<a name=\"introduction\"></a>\r\n## 简介\r\n\r\n数据库表之间通常存在关联。例如：一篇博客有许多评论（有的话），一个订单对应一个用户。Eloquent 提供如下几个关联类型的支持：\r\n\r\n- [一对一](#one-to-one)\r\n- [一对多](#one-to-many)\r\n- [多对多](#many-to-many)\r\n- [Has-Many-Through](#has-many-through)\r\n- [多态关联](#polymorphic-relations)\r\n- [多对多的多态关联](#many-to-many-polymorphic-relations)\r\n\r\n<a name=\"defining-relationships\"></a>\r\n## 定义关联\r\n\r\nEloquent 关联本质是定义在 Model 类里的一个方法，同时提供了强大的 [查询构造器](/docs/{{version}}/queries) 支持。下面是一个例子：\r\n\r\n```php\r\n// 找到某个用户所有的博客文章，并且这些文章的 active 字段值为 1。\r\n$user->posts()->where(\'active\', 1)->get();\r\n```\r\n\r\n千里之行，始于足下。下面，我们一个一个看。\r\n\r\n<a name=\"one-to-one\"></a>\r\n### 一对一\r\n\r\n一对一是最基本的关联关系。比如：一个 `User` 有一部 `Phone`。这种关系体现在代码上，是下面这样的：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass User extends Model\r\n{\r\n    /**\r\n    * 取得用户使用的手机\r\n    */\r\n    public function phone()\r\n    {\r\n        return $this->hasOne(\'App\\Phone\');\r\n    }\r\n}\r\n```\r\n\r\n`hasOne` 方法接收的参数是 Model 的全名，比如 `App\\Phone`。一旦关联关系建立，就能用 Eloquent 的动态属性检索数据了：\r\n\r\n```php\r\n// 这里的 phone 就是动态属性，它对应 User Model 中关系映射方法phone()\r\n$phone = User::find(1)->phone;\r\n```\r\n\r\n那么 User Model 是怎么取到 Phone 的呢？Eloquent 假设 `phones` 表里有一个外键 `user_id`（这个拼凑的外键名，基于 `User` Model 的名字 `User` 得到的），它就是 `phones` 表中关联 `users` 表的外键。\r\n\r\n当然你可以通过设定 `hasOne` 方法的第二个参数，自定义 `phones` 表的外键名。\r\n\r\n```php\r\nreturn $this->hasOne(\'App\\Phone\', \'foreign_key\');\r\n```\r\n\r\n当执行 `User::find(1)->phone` 代码时，Eloquent 比对 `phones` 表的 `user_id` 字段和 `users` 表的 `id` 字段是否相等，来准确找到用户的手机信息。\r\n\r\n设定 `hasOne` 方法的第三个参数，可以自定义与 `phones` 表 `user_id` 字段比对的本表字段是什么（默认是 `id`）。\r\n\r\n```php\r\nreturn $this->hasOne(\'App\\Phone\', \'foreign_key\', \'local_key\');\r\n```\r\n\r\n#### 一对一（逆向）\r\n\r\n已经可以通过 `User` Model 找到 `Phone` Model。现在再实现通过 `Phone` Model 找到 `User` Model，这里使用了 `belongsTo` 方法，实现的代码如下：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Phone extends Model\r\n{\r\n    /**\r\n     * 获得手机的主人\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(\'App\\User\');\r\n    }\r\n}\r\n```\r\n\r\nEloquent 默认使用 `user_id` （实际就是 Model 名小写形式 + `_id` 得到的结果）作为本表关联 `users` 表的外键名。设定 `belongsTo` 方法的第二个参数可自定义本表的外键名：\r\n\r\n```php\r\n/**\r\n * 获得手机的主人\r\n */\r\npublic function user()\r\n{\r\n    return $this->belongsTo(\'App\\User\', \'foreign_key\');\r\n}\r\n```\r\n\r\n如果父 Model（相对 `Phone` Model 而言，这里指 `User` Model）主键名不叫 `id`，你可以设定 `belongsTo` 方法的第三个参数自定义：\r\n\r\n```php\r\n/**\r\n * 获得手机的主人\r\n */\r\npublic function user()\r\n{\r\n    return $this->belongsTo(\'App\\User\', \'foreign_key\', \'other_key\');\r\n}\r\n```\r\n\r\n<a name=\"one-to-many\"></a>\r\n### 一对多\r\n\r\n这个关联关系一个最直接的体现——一篇博客可以有好多评论。\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Post extends Model\r\n{\r\n    /**\r\n     * 获得博客的所有评论\r\n     */\r\n    public function comments()\r\n    {\r\n        return $this->hasMany(\'App\\Comment\'); \r\n    }\r\n}\r\n```\r\n\r\nEloquent 默认会找 `comments` 表中一个叫 `post_id` 的外键（外键名采用“snake_case”形式，内容由“Model 名小写形式 + `_id`”拼凑而成），SQL 语句通过它来找博客下的所有评论。\r\n\r\n关联关系一旦建立，就可以用动态属性 `comments` 获得某篇博客下的所有评论了：\r\n\r\n```php\r\n$comments = App\\Post::find(1)->comments;\r\n\r\nforeach ($comments as $comment) {\r\n    //\r\n}\r\n```\r\n\r\n所有的关联也可以作为“查询构造器”使用，通过为“查询构造器”添加额外约束可以过滤返回的结果集：\r\n\r\n```php\r\n$comments = App\\Post::find(1)->comments()->where(\'title\', \'foo\')->first();\r\n```\r\n\r\n:::info\r\n注意：这里使用的是 `comments()` 关联方法，而不是使用 `comments` 动态属性。\r\n:::\r\n\r\n`hasMany` 方法自定义外键名、本表键名的方式与 `hasOne` 方法一样，这里不再赘述。\r\n\r\n    return $this->hasMany(\'App\\Comment\', \'foreign_key\');\r\n\r\n    return $this->hasMany(\'App\\Comment\', \'foreign_key\', \'local_key\');\r\n\r\n<a name=\"one-to-many-inverse\"></a>\r\n### 一对多（逆向）\r\n\r\n在 `Comment` Model 里使用 `belongsTo` 方法，就能根据评论找到博客了。\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Comment extends Model\r\n{\r\n    /**\r\n     * 找到这条评论是属于哪个博客的\r\n     */\r\n    public function post()\r\n    {\r\n        return $this->belongsTo(\'App\\Post\');\r\n    }\r\n}\r\n```\r\n\r\n然后可以这样使用：\r\n\r\n```php\r\n$comment = App\\Comment::find(1);\r\n\r\necho $comment->post->title;\r\n```\r\n\r\n上面的查找，默认使用了外键名 `post_id`，也可以自定义：\r\n\r\n```php\r\n/**\r\n * 找到这条评论是属于哪个博客的\r\n */\r\npublic function post()\r\n{\r\n    return $this->belongsTo(\'App\\Post\', \'foreign_key\');\r\n}\r\n```\r\n\r\n同样如果父 Model （相对于 `Comment` Model，这里指 `Blog` Model）的主键不叫 `id`，也可以自定义：\r\n\r\n```php\r\n/**\r\n * 找到这条评论是属于哪个博客的\r\n */\r\npublic function post()\r\n{\r\n    return $this->belongsTo(\'App\\Post\', \'foreign_key\', \'other_key\');\r\n}\r\n```\r\n\r\n<a name=\"many-to-many\"></a>\r\n### 多对多\r\n\r\n一个用户有多个角色，一个角色可被多个用户使用，这是典型的多对多关系。这种情况下，数据库里通常会有三张表：`users`，`roles` 和 `role_user`。`role_user` 称关系表，包含 `user_id` 和 `role_id` 两个字段。\r\n\r\n多对多关系使用了 `belongsToMany` 方法，具体的使用看下面的代码：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass User extends Model\r\n{\r\n    /**\r\n     * 获得用户的角色\r\n     */\r\n    public function roles()\r\n    {\r\n        return $this->belongsToMany(\'App\\Role\');\r\n    }\r\n}\r\n```\r\n\r\n关联关系一旦建立，就可以使用动态属性 `roles` 取得用户的角色了：\r\n\r\n```php\r\n$user = App\\User::find(1);\r\n\r\nforeach ($user->roles as $role) {\r\n    //\r\n}\r\n```\r\n\r\n类似一对一、一对多关系类型，`roles()` 关联方法也可以作“查询构造器”使用。\r\n\r\n```php\r\n$roles = App\\User::find(1)->roles()->orderBy(\'name\')->get();\r\n```\r\n\r\n默认使用的关系表名是 `role_user`，是两个关联 Model 的名字按字母表顺序组合而成的。设定 `belongsToMany` 方法第二个参数可以自定义查询使用的关系表名：\r\n\r\n```php\r\nreturn $this->belongsToMany(\'App\\Role\', \'role_user\');\r\n\r\nreturn $this->belongsToMany(\'App\\Role\', \'role_user\', \'user_id\', \'role_id\');\r\n```\r\n\r\n`belongsToMany` 的第三个参数代表 `$this` 所指代的 Model 在关系表中的字段名（也就是在关系表中关联当前 Model 所使用的外键名）， 第四个参数就是“对方表”在关系表中的字段名（也就是在关系表中关联 `Role` Model 所使用的外键名）。\r\n\r\n#### 多对多（逆向）\r\n\r\n在 `Role` Model 定义多对多关系的逆向，只要在 `users` 方法里再调用一遍 `belongsToMany` 方法就可以了。\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Role extends Model\r\n{\r\n    /**\r\n     * 取得使用了这个角色的所有用户\r\n     */\r\n    public function users()\r\n    {\r\n        return $this->belongsToMany(\'App\\User\');\r\n    }\r\n}\r\n```\r\n\r\n#### 检索中间表\r\n\r\n多对多关系需要有一个中间表（关系表），有时需要与中间表交互。使用 Model 的 `pivot` 属性就可以访问到中间表了。\r\n\r\n```php\r\n$user = App\\User::find(1);\r\n\r\nforeach ($user->roles as $role) {\r\n    // 访问中间表中这条数据创建的时间\r\n    echo $role->pivot->created_at;\r\n}\r\n```\r\n\r\n注意，检索回的 `Role` Model 自动佩戴了 `pivot` 属性，`pivot` 属性可以像 Model 一样使用，它代表中间表 Model。\r\n\r\n默认，`pivot` 对象只能取得中间表里表示 key 的字段（`role_id`、`user_id`），如果想让 `pivot` 对象包含更多的字段信息，使用 `withPivot` 方法。\r\n\r\n```php\r\nreturn $this->belongsToMany(\'App\\Role\')->withPivot(\'column1\', \'column2\');\r\n```\r\n\r\n若让 pivot 表自动维护 `created_at` 和 `updated_at` 两个时间戳字段，那么使用 `withTimestamps` 方法。\r\n\r\n```php\r\nreturn $this->belongsToMany(\'App\\Role\')->withTimestamps();\r\n```\r\n\r\n#### 过滤中间表返回的结果\r\n\r\n使用 `wherePivot` 和 `wherePivotIn` 方法可以过滤从中间表返回的结果。\r\n\r\n```php\r\nreturn $this->belongsToMany(\'App\\Role\')->wherePivot(\'approved\', 1);\r\n\r\nreturn $this->belongsToMany(\'App\\Role\')->wherePivotIn(\'priority\', [1, 2]);\r\n```\r\n\r\n<a name=\"has-many-through\"></a>\r\n### Has-Many-Through\r\n\r\n看下面的表结构：\r\n\r\n    countries\r\n        id - integer\r\n        name - string\r\n\r\n    users\r\n        id - integer\r\n        country_id - integer\r\n        name - string\r\n\r\n    posts\r\n        id - integer\r\n        user_id - integer\r\n        title - string\r\n\r\n有一个需求——要查询网站里所有中国用户发布的博客。`posts` 表里没有 `country_id` 字段，所以不能在 `posts` 表里直接查询。但我们看到 `users` 表里有 `country_id` 字段，`posts` 表里又有 `user_id` 字段。那么意味着，`countries` 表可以通过 `users`，取得网站里所有中国用户发布的博客——这就是 Has-Many-Through 关系。\r\n\r\n实现这个查询的机制是这样的：先查询中间表 `users` 的 `country_id` 字段，找到所有中国用户的 ID，再使用这些 ID 去 `posts` 表里查询，就可以正确取得网站里所有中国用户发布的博客。\r\n\r\n下面，在 `Country` Model 里设置 `hasManyThrough` 方法、代码层上实现 \"has-many-through\" 关系。\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Country extends Model\r\n{\r\n    /**\r\n     * 取得网站里特定国家的用户发布的所有博客\r\n     */\r\n    public function posts()\r\n    {\r\n        return $this->hasManyThrough(\'App\\Post\', \'App\\User\');\r\n    }\r\n}\r\n```\r\n\r\n`hasManyThrough` 方法的第一个参数是最终访问的 Model，第二个参数是“中间 Model”（这里指 `User` Model）的名字。“has-many-through” 可以这样理解——Through `App\\User`，取得 Many `App\\Post`。\r\n\r\n可以通过给 `hasManyThrough` 方法赋值额外参数，自定义外键名：\r\n\r\n```php\r\nclass Country extends Model\r\n{\r\n    public function posts()\r\n    {\r\n        return $this->hasManyThrough(\r\n            \'App\\Post\', \'App\\User\',\r\n            \'country_id\', \'user_id\', \'id\'\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n第三个参数是代表“中间表”的外键名，第四个参数是最终查询表的外键名，最后的参数代表本表主键名。\r\n\r\n<a name=\"polymorphic-relations\"></a>\r\n### 多态关联\r\n\r\n#### 表结构\r\n\r\n看下面的表结构：\r\n\r\n    posts\r\n        id - integer\r\n        title - string\r\n        body - text\r\n\r\n    videos\r\n        id - integer\r\n        title - string\r\n        url - string\r\n\r\n    comments\r\n        id - integer\r\n        body - text\r\n        commentable_id - integer\r\n        commentable_type - string\r\n\r\n`comments` 表里的评论，有对博客的，也有对视频的。一个 Model belong to 不止一个 Model，这就是多态关系了。\r\n\r\n`comments` 表里有两个字段：`commentable_id` 和 `commentable_type`。`commentable_id` 字段存储博客 ID 或视频 ID，而 `commentable_type` 字段存储的是 Model 的全名，ORM 根据 `commentable_type` 字段决定这是博客还是视频的评论。\r\n\r\n#### Model 中定义多态关系\r\n\r\n下面在 Model 中定义多态关系：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Comment extends Model\r\n{\r\n    /**\r\n     * 取得这条评论的评论实例（博客和视频）\r\n     */\r\n    public function commentable()\r\n    {\r\n        return $this->morphTo();\r\n    }\r\n}\r\n\r\nclass Post extends Model\r\n{\r\n    /**\r\n     * 取得博客的所有评论\r\n     */\r\n    public function comments()\r\n    {\r\n        return $this->morphMany(\'App\\Comment\', \'commentable\');\r\n    }\r\n}\r\n\r\nclass Video extends Model\r\n{\r\n    /**\r\n     * 取得视频的所有评论\r\n     */\r\n    public function comments()\r\n    {\r\n        return $this->morphMany(\'App\\Comment\', \'commentable\');\r\n    }\r\n}\r\n```\r\n\r\n#### 检索多态关系\r\n\r\n使用 `Post` Model 实例的 `comments` 动态属性，检索博客的所有评论：\r\n\r\n```php\r\n$post = App\\Post::find(1);\r\n\r\nforeach ($post->comments as $comment) {\r\n    //\r\n}\r\n```\r\n\r\n相反，也可以在 `Comment` Model 中访问动态属性`commentable` 检索出评论得是哪种类型的实例：\r\n\r\n```php\r\n$comment = App\\Comment::find(1);\r\n\r\n$commentable = $comment->commentable;\r\n```\r\n\r\n`commentable` 返回的结果有两种可能，`Post` 或 `Video` Model 实例，取决于 `commentable_type` 的值为何。\r\n\r\n#### 自定义多态关联关系\r\n\r\n在上面多态关系的定义里，Laravel 使用 Model 的全名存入数据库。比如：`Comment` 内容属于 `Post` 或 `Video`，那么默认的 `commentable_type` 字段存储的是 `App\\Post` 或 `App\\Video`。\r\n\r\n但你可能想让数据库与项目内部解耦，一个可行的方案是在 `AppServiceProvider` 的 `boot` 方法里设定一个映射图(`morph map`），指明相关类在数据库中的存入的名字：\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\Relations\\Relation;\r\n\r\nRelation::morphMap([\r\n    \'posts\' => App\\Post::class,\r\n    \'videos\' => App\\Video::class,\r\n]);\r\n```\r\n\r\n如果你愿意，也可以创建一个单独的服务提供者设定映射图。\r\n\r\n<a name=\"many-to-many-polymorphic-relations\"></a>\r\n### 多对多的多态关联\r\n\r\n#### 表结构\r\n\r\n下面是表结构：\r\n\r\n    posts\r\n        id - integer\r\n        name - string\r\n\r\n    videos\r\n        id - integer\r\n        name - string\r\n\r\n    tags\r\n        id - integer\r\n        name - string\r\n\r\n    taggables\r\n        tag_id - integer\r\n        taggable_id - integer\r\n        taggable_type - string\r\n\r\n`Post` Model 和 `Video` Model 共享 `Tag` Model。这种情况下，就避免了单独给`Post` 建立一个标签表，再单独给 `Video` 建立一个标签表带来的冗余，因为所有标签数据是共享的。\r\n\r\n#### 定义多对多多态关系\r\n\r\n下面在 Model 中定义多对多多态关系。`Post` Model 和 `Video` Model 都有一个 `tags` 方法，方法里面调用了 `morphToMany` 方法： \r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Post extends Model\r\n{\r\n    /**\r\n     * 取得这篇博客的所有标签\r\n     */\r\n    public function tags()\r\n    {\r\n        return $this->morphToMany(\'App\\Tag\', \'taggable\');\r\n    }\r\n}\r\n```\r\n\r\n#### 定义多对多多态关系（逆向）\r\n\r\n其次是 `Tag` Model，要为与它相关的每个 Model 都定义方法。比如，现在需要在 `Tag` Model 中定义 `posts` 方法和 `videos` 方法：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Tag extends Model\r\n{\r\n    /**\r\n     * 取得这个标签下的所有博客\r\n     */\r\n    public function posts()\r\n    {\r\n        return $this->morphedByMany(\'App\\Post\', \'taggable\');\r\n    }\r\n\r\n    /**\r\n     * 取得这个标签下的所有视频\r\n     */\r\n    public function videos()\r\n    {\r\n        return $this->morphedByMany(\'App\\Video\', \'taggable\');\r\n    }\r\n}\r\n```\r\n\r\n#### 检索多对多多态关系\r\n\r\n至此多对多多态关联关系定义完毕。可以使用 `Post` Model 实例对象的动态属性 `tags` 检索某篇博客的所有标签：\r\n\r\n```php\r\n$post = App\\Post::find(1);\r\n\r\nforeach ($post->tags as $tag) {\r\n    //\r\n}\r\n```\r\n\r\n利用 `morphedByMany` 方法，`Tag` Model 现在可以使用 `posts` 或 `videos` 动态属性查询到某个标签下的博客或视频了：\r\n\r\n```php\r\n$tag = App\\Tag::find(1);\r\n\r\nforeach ($tag->videos as $video) {\r\n    //\r\n}\r\n```\r\n\r\n<a name=\"querying-relations\"></a>\r\n## 查询关联\r\n\r\nEloquent 关联可以作 [查询构造器](/docs/{{version}}/queries) 使用，意味着你可以在查询时设置约束来限制得到的结果。\r\n\r\n比如，一个 `User` Model 对应多个 `Post` Model:\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass User extends Model\r\n{\r\n    /**\r\n     * 获得用户的所有博客\r\n     */\r\n    public function posts()\r\n    {\r\n        return $this->hasMany(\'App\\Post\');\r\n    }\r\n}\r\n```\r\n\r\n可以为 `posts` 关联方法添加额外约束，来查询需要的结果：\r\n\r\n```php\r\n$user = App\\User::find(1);\r\n\r\n$user->posts()->where(\'active\', 1)->get();\r\n```\r\n\r\n既然关联方法可以作 [查询构造器](/docs/{{version}}/queries) 用，那么查询构造器上的任何方法在这里同样适应。\r\n\r\n<a name=\"relationship-methods-vs-dynamic-properties\"></a>\r\n### 关联方法 Vs. 动态属性\r\n\r\n如果 Eloquent 关联查询不需要添加额外约束，那么直接使用动态属性即可。继续以 `User` 和 `Post` 为例进行说明——获得某个用户的所有博客：\r\n\r\n```php\r\n$user = App\\User::find(1);\r\n\r\nforeach ($user->posts as $post) {\r\n    //\r\n}\r\n```\r\n\r\n动态属性是“懒加载”的——只在你实际取用时，向数据库发送 SQL 查询得到数据。因为这，开发者经常用 [热加载](#eager-loading) 提前将 Model 的关联数据取到，这大大减少了 SQL 语句的执行次数。\r\n\r\n<a name=\"querying-relationship-existence\"></a>\r\n### 基于存在的关联查询\r\n\r\n可能有这样的需求：查询所有有评论的博客。这时就需要用 `has` 方法了：\r\n\r\n```php\r\n// 查询所有有评论（至少有一条）的博客\r\n$posts = App\\Post::has(\'comments\')->get();\r\n```\r\n\r\n现在要查询所有至少有 3 条评论的博客。\r\n\r\n```php\r\n// 查询所有至少有 3 条评论的博客\r\n$posts = Post::has(\'comments\', \'>=\', 3)->get();\r\n```\r\n\r\n`has` 方法的参数还可以用“点”符号构建。例如：我要查询的博客，至少有一条评论和一个投票。\r\n\r\n```php\r\n// 查询至少有一条评论和一个投票的博客\r\n$posts = Post::has(\'comments.votes\')->get();\r\n```\r\n\r\n`whereHas` 和 `orWhereHas` 方法在 `has` 方法的基础上使用了“where”子查询，它们提供了更强大的功能——允许自定义约束——比如找只包含特定内容的评论：\r\n\r\n```php\r\n// 查询所有至少有 1 条评论的博客，并且评论的内容符合模糊搜索条件 foo%\r\n$posts = Post::whereHas(\'comments\', function ($query) {\r\n    $query->where(\'content\', \'like\', \'foo%\');\r\n})->get();\r\n```\r\n\r\n<a name=\"querying-relationship-absence\"></a>\r\n### 基于不存在的关联查询\r\n\r\n现在你改变主意，要查询所有**没有**评论的博客，这时就要使用 `doesntHave` 方法了：\r\n\r\n```php\r\n$posts = App\\Post::doesntHave(\'comments\')->get();\r\n```\r\n\r\n相应地，`whereDoesntHave` 方法在 `doesntHave` 方法的基础上使用了“where”子查询，它也提供了更强大的功能——允许自定义约束——比如找**不包**含特定内容的评论：\r\n\r\n```php\r\n$posts = Post::whereDoesntHave(\'comments\', function ($query) {\r\n    $query->where(\'content\', \'like\', \'foo%\');\r\n})->get();\r\n```\r\n\r\n<a name=\"counting-related-models\"></a>\r\n### 关联 Model 计数\r\n\r\n有时仅需要看一篇博客有几条评论，不需要查询完整的评论信息，那么可以就使用 `withCount` 方法，在得到的结果集里的每个 Model 实例都会佩戴一个 `{relation}_count` 属性：\r\n\r\n```php\r\n$posts = App\\Post::withCount(\'comments\')->get();\r\n\r\nforeach ($posts as $post) {\r\n    echo $post->comments_count;\r\n}\r\n```\r\n\r\n有时又需要看一篇博客有几条评论和几个投票，这就涉及到多个字段的计数，`withCount` 同样可以完成这个任务：\r\n\r\n```php\r\n$posts = Post::withCount([\'votes\', \'comments\' => function ($query) {\r\n    $query->where(\'content\', \'like\', \'foo%\');\r\n}])->get();\r\n\r\necho $posts[0]->votes_count;\r\necho $posts[0]->comments_count;\r\n```\r\n\r\n<a name=\"eager-loading\"></a>\r\n## 热加载\r\n\r\n我们已经知道，访问动态属性属于“懒加载”，意味着要到你访问的那一刻采取查询数据。然而，Eloquent 可以让你在查询父 Model 时就“热加载”关联数据。\r\n\r\n“热加载”解决了 N + 1 查询问题。要说明这个问题，需要举一个 `Book` Model 和它的关联 Model `Author` 的例子：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Book extends Model\r\n{\r\n    /**\r\n     * 获取本书的作者\r\n     */\r\n    public function author()\r\n    {\r\n        return $this->belongsTo(\'App\\Author\');\r\n    }\r\n}\r\n```\r\n\r\n现在遍历所有的图书，然后分别打印出对应图书的作者名：\r\n\r\n```php\r\n$books = App\\Book::all();\r\n\r\nforeach ($books as $book) {\r\n    echo $book->author->name;\r\n}\r\n```\r\n\r\n假如数据库里一共有 25 本图书信息，那么上面这段代码要执行 26 次 SQL 查询。1 次查询出来所有的图书，`foreach` 循环体内为了获得图书的作者名，执行了另外 25 次查询。\r\n\r\n谢天谢地，使用“热加载”，我们只需要执行 2 次 SQL 查询就可以了！你只需要在查询时使用 `with` 方法指定要“热加载”的关联即可：\r\n\r\n```php\r\n$books = App\\Book::with(\'author\')->get();\r\n\r\nforeach ($books as $book) {\r\n    echo $book->author->name;\r\n}\r\n```\r\n\r\n这次代码执行后，只发出 2 次 SQL 查询：\r\n\r\n```sql\r\nselect * from books\r\n\r\nselect * from authors where id in (1, 2, 3, 4, 5, ...)\r\n```\r\n\r\n#### 热加载多个关联\r\n\r\n热加载多个关联，只要在热加载一个关联的基础上，修改 `with` 方法即可：\r\n\r\n```php\r\n$books = App\\Book::with(\'author\', \'publisher\')->get();\r\n```\r\n\r\n#### 嵌套关联的热加载\r\n\r\n热加载嵌套关联，需要用到 `.` 语法。例如：热加载所有图书的作者以及作者的个人联系方式： \r\n\r\n```php\r\n$books = App\\Book::with(\'author.contacts\')->get();\r\n```\r\n\r\n<a name=\"constraining-eager-loads\"></a>\r\n### 热加载的约束\r\n\r\n可以对热加载的关联数据使用约束条件。这是个例子：\r\n\r\n```php\r\n$users = App\\User::with([\'posts\' => function ($query) {\r\n    $query->where(\'title\', \'like\', \'%first%\');\r\n}])->get();\r\n```\r\n\r\n这个例子里，Eloquent 只会热加载标题包含“first”的博客。当然，任何 [查询构造器](/docs/{{version}}/queries) 方法你都可以使用，因为 `$query` 就是个查询构造器实例。\r\n\r\n```php\r\n$users = App\\User::with([\'posts\' => function ($query) {\r\n    $query->orderBy(\'created_at\', \'desc\');\r\n}])->get();\r\n```\r\n\r\n<a name=\"lazy-eager-loading\"></a>\r\n### 懒惰热加载\r\n\r\n有时你可能要在父 Model 检索回结果后进行热加载，这就要用到 `load` 方法了。你可以按条件去热加载指定关联数据：\r\n\r\n```php\r\n$books = App\\Book::all();\r\n\r\nif ($someCondition) {\r\n    $books->load(\'author\', \'publisher\');\r\n}\r\n```\r\n\r\n`load` 方法同样可以使用查询约束。具体做法是传递一个数组类型的参数，数据的 key 是关联，value 是一个闭包，里面设置查询约束：\r\n\r\n```php\r\n$books->load([\'author\' => function ($query) {\r\n    $query->orderBy(\'published_date\', \'asc\');\r\n}]);\r\n```\r\n\r\n<a name=\"inserting-and-updating-related-models\"></a>\r\n## 插入 & 更新关联 Model\r\n\r\n<a name=\"the-save-method\"></a>\r\n### 保存方法\r\n\r\nEloquent 为新建关联数据提供了一个 `save` 方法。比如：你要给 `Post` Model 插入一个新的 `Comment` Model，在定义好关联关系后，你就不需要为 `comments` 表手动插入 `post_id` 字段值了。\r\n\r\n```php\r\n$comment = new App\\Comment([\'message\' => \'A new comment.\']);\r\n\r\n$post = App\\Post::find(1);\r\n\r\n$post->comments()->save($comment);\r\n```\r\n\r\n注意这里使用的是 `comments` 关联方法，而不是动态属性 `comments`。调用 `comments` 关联方法会得到一个关联实例，`save` 方法会自动为 `Comment` Model 设置正确的 `post_id` 属性值，也就是会为 `comments` 表自动插入正确的 `post_id` 字段值。\r\n\r\n如果要同时保存多个关联 Model，可使用 `saveMany` 方法。比如同时为同一篇博客保存多条评论：\r\n\r\n```php\r\n$post = App\\Post::find(1);\r\n\r\n$post->comments()->saveMany([\r\n    new App\\Comment([\'message\' => \'A new comment.\']),\r\n    new App\\Comment([\'message\' => \'Another comment.\']),\r\n]);\r\n```\r\n\r\n<a name=\"the-create-method\"></a>\r\n### 创建方法\r\n\r\n除了 `save` 和 `saveMany` 方法，也可以用 `create` 方法，它接收一个包含新 Model 属性键值的数组。`save` 与 `create` 的不同之处是 `save` 接收的是 Eloquent Model 实例，而 `create` 方法接收的是一个数组：\r\n\r\n```php\r\n$post = App\\Post::find(1);\r\n\r\n$comment = $post->comments()->create([\r\n    \'message\' => \'A new comment.\',\r\n]);\r\n```\r\n\r\n使用 `create` 方法前， 不要忘记对创建方法中涉及到的属性设置为 [可批量赋值的](/docs/{{version}}/eloquent#mass-assignment)。\r\n\r\n<a name=\"updating-belongs-to-relationships\"></a>\r\n### Belongs To 关联\r\n\r\n更新 `belongsTo` 关联，要用到 `associate` 方法，这个方法给子 Model 设置外键。\r\n\r\n```php\r\n$account = App\\Account::find(10);\r\n\r\n$user->account()->associate($account);\r\n\r\n$user->save();\r\n```\r\n\r\n删除`belongsTo` 关联，使用 `dissociate` 方法，这个方法将子 Model 的外键值设置为 `null`：\r\n\r\n```php\r\n$user->account()->dissociate();\r\n\r\n$user->save();\r\n```\r\n\r\n<a name=\"updating-many-to-many-relationships\"></a>\r\n### 多对多关联\r\n\r\n#### 附加 / 解除\r\n\r\n多对多关系需要有一个关系表。当把一个角色附加给一个用户的时候，需要在关系表里插入数据，关联两个 Model，这时就需要使用 `attach` 方法：\r\n\r\n```php\r\n$user = App\\User::find(1);\r\n\r\n$user->roles()->attach($roleId);\r\n```\r\n\r\n在关系表中插入数据时，可能需要同时插入一些额外字段，这时稍微修改 `attach` 方法即可：\r\n\r\n```php\r\n$user->roles()->attach($roleId, [\'expires\' => $expires]);\r\n```\r\n\r\n解除多对多关联使用 `detach` 方法，调用 `detach` 方法会删除关系表里的对应记录：\r\n\r\n```php\r\n// 解除单条关联……\r\n$user->roles()->detach($roleId);\r\n\r\n// 解除所有关联……\r\n$user->roles()->detach();\r\n```\r\n\r\n`attach` 和 `detach` 方法也提供了方法的 API——接收一个 ID 数组作为输入参数：\r\n\r\n```php\r\n$user = App\\User::find(1);\r\n\r\n$user->roles()->detach([1, 2, 3]);\r\n\r\n$user->roles()->attach([1 => [\'expires\' => $expires], 2, 3]);\r\n```\r\n\r\n#### 同步关联\r\n\r\n`sync` 方法用来同步关联，它相当于重置关联——`sync` 方法调用结束后，只有数组中给定的 ID 存在于关系表中：\r\n\r\n```php\r\n$user->roles()->sync([1, 2, 3]);\r\n```\r\n\r\n除了 ID，可能还要设置其它额外的字段数据：\r\n\r\n```php\r\n$user->roles()->sync([1 => [\'expires\' => true], 2, 3]);\r\n```\r\n\r\n如果你不想在同步关联的时候，影响到已存在的关联数据，那么就使用 `syncWithoutDetaching` 方法：\r\n\r\n```php\r\n$user->roles()->syncWithoutDetaching([1, 2, 3]);\r\n```\r\n\r\n#### 附加/解除关联\r\n\r\n多对多关联还有一个`toggle` 方法，用来附加/解除关联。当指定的 ID 已附加，则解除关联；否则附加关联：\r\n\r\n```php\r\n$user->roles()->toggle([1, 2, 3]);\r\n```\r\n\r\n#### 保存 Pivot 表记录时插入额外数据\r\n\r\n之前已经说过，多对多关联关系在保存时，`save`方法通过设定第二个数组类型的参数可插入额外字段数据：\r\n\r\n    App\\User::find(1)->roles()->save($role, [\'expires\' => $expires]);\r\n\r\n#### 更新 Pivot 表记录\r\n\r\n更新 Pivot 表已经存在的记录，使用 `updateExistingPivot` 方法，这个方法接收两个参数——记录中对应的另一个外键值、包含要更新信息的数组：\r\n\r\n```php\r\n$user = App\\User::find(1);\r\n\r\n$user->roles()->updateExistingPivot($roleId, $attributes);\r\n```\r\n\r\n<a name=\"touching-parent-timestamps\"></a>\r\n## 更新父 Model 时间戳\r\n\r\n当一个 Model `belongsTo` 或者 `belongsToMany` 另一个 Model。比如 `Comment` 属于 `Post`。现在有这样的需求，当一个评论发生更新时，评论对应的 `Post` 的 `updated_at` 字段也要更新。为了实现这个效果，要在 `Comment` Model 里添加 `touches` 属性，`touches` 属性输一个数组，数组元素就是你要同步更新的、定义了与父 Model 关联的关联方法名：\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Comment extends Model\r\n{\r\n    /**\r\n     * 需要被 touched 的关联方法\r\n     *\r\n     * @var array\r\n     */\r\n    protected $touches = [\'post\'];\r\n\r\n    /**\r\n     * 取得评论的博客\r\n     */\r\n    public function post()\r\n    {\r\n        return $this->belongsTo(\'App\\Post\');\r\n    }\r\n}\r\n```\r\n\r\n现在当你更新一个 `Comment` 后，对应 `Post` 将同步更新其 `updated_at` 列，方便判断是否博客还有价值：\r\n\r\n```php\r\n$comment = App\\Comment::find(1);\r\n\r\n$comment->text = \'Edit to this comment!\';\r\n\r\n$comment->save();\r\n```','2017-06-13 23:29:56','2017-06-14 03:44:44','eloquent-associated'),(9,3,3,'本站支持使用emoji表情哦~','?????✌?哈哈！','2017-06-14 04:27:12','2017-08-10 00:33:09','oh-this-website-supports-the-use-of-emoji-expression'),(2,5,5,'python3.x入门','##数据类型\r\n###整数\r\nPython可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：`1`，`100`，`-8080`，`0`，等等。\r\n###浮点数\r\n浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的浮点数可以用数学写法，如`1.23`，`3.14`，`-9.01`，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是`1.23e9`，或者`12.3e8`，0.000012可以写成`1.2e-5`，等等。\r\n###字符串\r\n字符串是以单引号\'或双引号\"括起来的任意文本，比如`\'abc\'`，`\"xyz\"`等等。请注意，`\'\'`或`\"\"`本身只是一种表示方式，不是字符串的一部分，因此，字符串`\'abc\'`只有`a`，`b`，`c`这3个字符。如果`\'`本身也是一个字符，那就可以用`\"\"`括起来，比如`\"I\'m OK\"`包含的字符是`I`，`\'`，`m`，空格，`O`，`K`这6个字符。\r\n如果字符串内部既包含`\'`又包含`\"`怎么办？可以用转义字符`\\`来标识，比如：\r\n```\r\nprint(\"I\\\'m\\\"good\\\"!\")\r\n```\r\n表示的字符串内容是：\r\n```\r\nI\'m\"good\"!\r\n```\r\n###布尔值\r\n布尔值和布尔代数的表示完全一致，一个布尔值只有`True`、`False`两种值，要么是`True`，要么是`False`，在Python中，可以直接用`True`、`False`表示布尔值（请注意大小写），也可以通过布尔运算计算出来：\r\n```\r\n>>> 3>2\r\nTrue\r\n>>> 3>5\r\nFalse\r\n```\r\n布尔值可以用`and`、`or`和`not`运算。\r\n`and`运算是与运算，只有所有都为`True`，`and`运算结果才是`True`：\r\n```\r\n>>> 10 > 2 and 4 > 2\r\nTrue\r\n```\r\n`or`运算是或运算，只要其中有一个为`True`，`or`运算结果就是`True`：\r\n```\r\n>>> 10 > 2 or 1 > 3\r\nTrue\r\n```\r\n`not`运算是非运算，它是一个单目运算符，把`True`变成`False`，`False`变成`True`：\r\n```\r\n>>> not True\r\nFalse\r\n>>> not 1 > 2\r\nTrue\r\n```\r\n布尔值经常用在条件判断中，比如：\r\n```\r\nif age >= 18:\r\n    print(\'adult\')\r\nelse:\r\n    print(\'teenager\')\r\n```\r\n\r\n##输入和输出\r\n###输出\r\n用`print()`在括号中加上字符串，就可以向屏幕上输出指定的文字。例如输出`Hello,Word!`，用代码实现如下：\r\n```\r\nprint(Hello,Word!)\r\n```\r\n`print()`函数也可以接受多个字符串，用逗号“,”隔开，就可以练成一串输出：\r\n```\r\n>>>print(\'The test\',\'web\',\'is good\')\r\nThe test web is good\r\n```\r\n`print()`函数会依次打印每个字符串，遇到逗号\",\"会输出一个空格\r\n`print()`也能打印整数，或者计算结果：\r\n```\r\n>>> print(100+300)\r\n400\r\n>>> print(100)\r\n100\r\n```\r\n我们还可以把`100+300`的计算结果打印的更漂亮：\r\n```\r\n>>> print(\"100 + 300 =\",100+300)\r\n100 + 300 = 400\r\n```\r\n###输入\r\n现在，你已经可以用`print()`输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个`input()`，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：\r\n```\r\n>>> name = input(\"your name is : \")\r\nyour name is : chenys\r\n```\r\n当你输入`name = input()`并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。\r\n输入完成后，不会有任何提示，Python交互式命令行又回到`>>>`状态了。那我们刚才输入的内容到哪去了？答案是存放到`name`变量里了。可以直接输入`name`查看变量内容\r\n```\r\n>>> name\r\n\'chenys\'\r\n```\r\n## 使用list和tuple\r\n### list列表\r\nPython内置的一种数据类型是列表：list 。 list是一种有序的合集，可用随时添加和删除其中的元素。\r\n比如，列出班里所有同学的名字，就可以用一个list表示：\r\n```\r\n>>>classmates = [\'chenys\',\'zhangb\',\'sunl\']\r\n>>>print(classmates)\r\n[\'chenys\', \'zhangb\', \'sunl\']\r\n```\r\n变量`classmates`就是一个list。用`len()`函数可以获得元素的个数：\r\n```\r\n>>>print(len(classmates))\r\n3\r\n```\r\n\r\n### list常用方法\r\n#### 索引\r\n用索引来访问list中每个位置的元素， `索引`是从`0`开始的：\r\n```\r\n>>>print(classmates[0])\r\nchenys\r\n>>>print(classmates[1])\r\nzhangb\r\n>>>print(classmates[2])\r\nsunl\r\n>>>print(classmates[3])\r\nTraceback (most recent call last):\r\n  File \"/Users/chenys/PycharmProjects/untitled/通用序列/列表.py\", line 89, in <module>\r\n    print(classmates[3])\r\nIndexError: list index out of range\r\n```\r\n当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，最后一个索引，可以用`-1`做索引\r\n```\r\n>>>print(classmates[-1])\r\nsunl\r\n```\r\n\r\n可以依次类推取倒数第2个、第3个：\r\n```\r\n>>>print(classmates[-2])\r\nzhangb\r\n>>>print(classmates[-3])\r\nchenys\r\n```\r\n\r\n#### 追加\r\nList 是一个可变的有序表，所以，可以往list中追加`append()`元素到末尾：\r\n```\r\n>>>classmates.append(\'huanghh\')\r\n>>>print(classmates)\r\n[\'chenys\', \'zhangb\', \'sunl\', \'huanghh\']\r\n```\r\n\r\n####  插入\r\n也可以把元素插入`insert()`到指定的位置，比如索引号为`0`的位置：\r\n```\r\n>>>classmates.insert(0,\'chin\')\r\n>>>print(classmates)\r\n[\'chenj\', \'chenys\', \'zhangb\', \'sunl\', \'huanghh\']\r\n```\r\n\r\n#### 删除\r\n要删除list末尾的元素用,用`pop()`方法\r\n```\r\n>>>classmates.pop()\r\n>>>print(classmates)\r\n[\'chenj\', \'chenys\', \'zhangb\', \'sunl\']\r\n```\r\n\r\n要删除指定位置的元素，用`pop(i)`方法，期中`i`是索引的位置：\r\n```\r\n>>>classmates.pop(0)\r\n>>>print(classmates)\r\n[\'chenys\', \'zhangb\', \'sun\']\r\n```\r\n\r\n#### 替换\r\n要把某个元素`替换`成别的元素，可以直接赋值给对应的索引位置：\r\n```\r\n>>>classmates[0] = \'chenys123\'\r\n>>>print(classmates)\r\n[\'chenys123\', \'zhangb\', \'sun\']\r\n```\r\n\r\nlist里面的元素的`数据类型`也可以不同，例如：\r\n```\r\n>>>s1 = [\'Apple\',123,True]\r\n>>>print(s1)\r\n[\'Apple\', 123, True]\r\n```\r\n\r\n#### 嵌套\r\nlist元素也可以`嵌套`另一个list列表，例如：\r\n```\r\n>>>s2 = [\'python\',\'java\',[\'asp\',\'php\'],\'c+\']\r\n>>>print(s2)\r\n[\'python\', \'java\', [\'asp\', \'php\'], \'c+\']\r\n```\r\n 如果要取出s2列表中的`asp`的思路\r\n```\r\n>>>print(s2[2])\r\n[\'asp\', \'php\']\r\n>>>print(s2[2][0])\r\nasp\r\n```\r\n\r\n### tuple\r\n另一种有序列表叫元组：tuple。 tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：\r\n```\r\n>>>classmates = (\'chenys\',\'zhangb\',\'sunl\')\r\n>>>print(classmates)\r\n(\'chenys\', \'zhangb\', \'sunl\')\r\n```\r\n现在，classmates这个tuple不能更改，他没有append(),pop()这样的方法。但是获取期中元素的方法和list是一样的，可以正常使用\r\n###小结\r\nlist和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。\r\n\r\n## 条件判断\r\n### if语句\r\n计算机之所以能够做很多自动化任务，因为它可以做条件判断\r\n例如，输入用户年龄，根据年龄打印不同的内容，用`if`语句判断：\r\n```\r\nage = 30\r\nif age >= 20:\r\n    print(\'your age is\',age,\'adult\')\r\nyour age is 30 adult\r\n```\r\n也可以给`if`添加一个`else`语句，意思是，如果`if`判断是`False`，不要执行`if`内容，而去执行`else`：\r\n```\r\nage = 10\r\nif age >= 20:\r\n    print(\'your age is\',age,\'adult\')\r\nelse:\r\n    print(\'your teenager!\')\r\n```\r\n还可以用`elif`做更细致的判断：\r\n```\r\n>>>age = 3\r\n>>>if age >= 20:\r\n >>>   print(\'your age is\',age,\'adult\')\r\n>>>elif age >=10:\r\n>>>    print(\'your teenager!\')\r\n>>>else:\r\n>>>    print(\'kid!\')\r\n```\r\n`elif`是`else if `的缩写，完全可以有多个`elif`，所以`if`语句的完整形式是：\r\n```\r\nif <条件判断1>:\r\n    <执行1>\r\nelif <条件判断2>:\r\n    <执行2>\r\nelif <条件判断3>:\r\n    <执行3>\r\nelse:\r\n    <执行4>\r\n```\r\n\r\n###input()\r\n学会使用`input()`读取用户的输入，这样可以使程序更有意思：\r\n```\r\nfood = input(\"your favour food: \")\r\nif food == \'apple\':\r\n    print(\"we are all the same! \")\r\nelse:\r\n    print(\"i like banana\")\r\n```\r\n\r\n## 循环\r\npython的循环有两种，一种是`for...in` 循环，一种是`while`循环\r\n### for ... in 循环\r\n依次把list或tuple中的每个元素迭代出来\r\n\r\n```\r\nnames = [\'chenys\',\'zhangb\',\'sunl\']\r\nfor name in names:\r\n    print(name)\r\n```\r\n执行这段代码，会依次打印`names`的每个元素\r\n```\r\nchenys\r\nzhangb\r\nsunl\r\n```\r\n所以 `for i in ...` 循环就是把每个元素带入变量`i`，然后执行锁进块的语句。\r\n例如，我们想计算1-10的整数之和，可以用一个`sum`变量做累加\r\n注意实例1和实例2，print的位置区别，总结\r\n```\r\n实例1: \r\nsum = 0\r\nfor i in [1,2,3,4,5,6,7,8,9,10]:\r\n    sum = sum + i\r\n    print(sum)\r\n\r\n实例2:\r\nsum = 0\r\nfor i in [1,2,3,4,5,6,7,8,9,10]:\r\n    sum = sum + i\r\nprint(sum)\r\n```\r\n如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。比如`range(5)`生成的序列是从0开始小于5的整数，`range(101)`就可以生成0-100的整数序列，计算如下\r\n```\r\nsum = 0\r\nfor i in range(101):\r\n	sum = sum + i\r\nprint(sum)\r\n```\r\n\r\n### while循环\r\n只要条件满足，就不断循环，条件不满足时就退出循环。例如我们要计算100以内的所有奇数，可以用while循环实现：\r\n```\r\nsum = 0\r\nn = 99\r\nwhile n > 0:\r\n    sum = sum + n\r\n    n = n -2\r\nprint(sum)\r\n```\r\n### break\r\n在循环中，break语句可以提前退出循环。例如循环打印1～100的数字，当n>10就退出：\r\n```\r\nn1 = 1\r\nwhile n1 <=100:\r\n    if n1 >10:        ＃当n1 ＝ 11 时，条件满足，执行break语句\r\n        break          # break 语句会结束当前循环\r\n    print(n1)\r\n    n1 = n1 +1\r\nprint(\'end\')\r\n```\r\n执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。\r\n\r\n可见`break`的作用是提前结束循环。\r\n\r\n### continue\r\n在循环中，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环\r\n```\r\nn = 0\r\nsum = 0\r\nwhile n < 100:\r\n    n = n + 1\r\n    if n % 2 == 0:\r\n        continue\r\n    sum = sum +n\r\nprint(sum)\r\n```\r\n### 小结\r\n\r\n循环是让计算机做重复任务的有效的方法。\r\n\r\n`break`语句可以在循环过程中直接退出循环，而`continue`语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。\r\n\r\n要特别注意，不要滥用`break`和`continue`语句。`break`和`continue`会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到`break`和`continue`语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉`break`和`continue`语句。\r\n\r\n有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用`Ctrl+C`退出程序，或者强制结束Python进程。\r\n\r\n\r\n## 字典（dict）\r\npython内置字典，使用键－值（key－value）存储，具有极快的查找速度。\r\n举个例子，假设要根据名字查找对应的号码，如果用list实现，需要两个list\r\n```\r\nnames = [\'chenys\',\'zhangb\',\'sunl\']\r\nnumbers = [\'123\',\'456\',\'789\']\r\n```\r\n给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从numbers取出对应的成绩，list越长，耗时越长。\r\n如果用dict实现，只需要一个“名字“－”成绩“，直接根据名字查找成绩，无论这个表有多大，查找速度都不回变慢。如下：\r\n```\r\nd = { \'chenys\':123,\'zhangb\':\'456\',\'sunl\':\'789\'}\r\nprint(d)\r\nprint(d[\'chenys\'])\r\n```\r\n为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。\r\n\r\n第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。\r\n\r\ndict就是第二种实现方式，给定一个名字，比如chenys，dict在内部就可以直接计算出chenys对应的存放成绩的“页码”，也就是123这个数字存放的内存地址，直接取出来，所以速度非常快。\r\n\r\n你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。\r\n\r\n\r\n### 字典常用方法\r\n#### 插入\r\n把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：\r\n```\r\nd[\'huanghh\'] = 123456\r\nprint(d)\r\n```\r\n\r\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\r\n```\r\nd[\'huanghh\'] = 123456\r\nprint(d[\'huanghh\')\r\n\r\nd[\'huanghh\'] = 456789\r\nprint(d[\'huanghh\')\r\n```\r\n#### 判断\r\n如果key不存在，dict就会报错。\r\n要必要key不存在的错误，有两种办法，一种是通过`in`判断key是否存在：\r\n```\r\nprint(\'chenj\' in d)\r\n```\r\n\r\n第二种方法是通过`get()`方法，如果key不存在，可以返回`None`，或者自己指定的value：\r\n```\r\nprint(d.get(\'chenj\'))\r\n\r\nprint(d.get(\'chenj\',\'不存在‘))\r\n```\r\n\r\n#### 删除\r\n要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除：\r\n```\r\nd.pop(\'zhangb\')\r\nprint(d)\r\n```\r\n\r\n请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。\r\n\r\n和list比较，dict有以下几个特点：\r\n1.查找和插入的速度极快，不会随着key的增加而变慢；\r\n2.需要占用大量的内存，内存浪费多。\r\n而list相反：\r\n1.查找和插入的时间随着元素的增加而增加；\r\n2.占用空间小，浪费内存很少。\r\n所以，dict是用空间来换取时间的一种方法。\r\n\r\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是`dict的key必须是不可变对象`。\r\n\r\n这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\r\n\r\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key\r\n\r\n\r\n## 集合(set)\r\nset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\r\n\r\n要创建一个set，需要提供一个list作为输入集合：\r\n```\r\ns = set([1,2,3])\r\nprint(s)\r\n```\r\n注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。\r\n\r\n重复元素在set中自动被过滤：\r\n```\r\ns = set([1,2,3,3,3,4,5,3])\r\nprint(s)\r\n```\r\n\r\n### 集合的常用方法\r\n#### 添加add\r\n通过`add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果：\r\n```\r\ns.add(10)\r\nprint(s)\r\n```\r\n\r\n#### 删除remove\r\n通过`remove(key)`方法可以删除元素\r\n```\r\ns.remove(3)\r\nprint(s)\r\n```\r\n\r\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\r\n```\r\ns1 = set([1,2,3])\r\ns2 = set([2,3,4])\r\nprint(s1 & s2)\r\nprint(s1 | s2)\r\n```\r\n\r\n## 编写购物车小程序\r\n```\r\n###商品列表\r\nproduct_list = [\r\n    [\'macbook\',6000],\r\n    [\'iPhone\',5000],\r\n    [\'Nike\',800],\r\n    [\'sony\',2000]\r\n]\r\n\r\nshopping_list = []    #购物列表\r\n\r\nsalary = int(input(\'请输入你的工资:\'))\r\nprint(\'----- 产品列表 -----\')\r\n\r\nwhile True:\r\n    for index,product in enumerate(product_list):\r\n        print(index,product_list[index][0],product_list[index][1])\r\n\r\n    user_choice = input(\'请输入想购买的商品序号: \')  #输入序列号\r\n    if user_choice.isdigit():\r\n        user_choice = int(user_choice)\r\n        if user_choice >=0 and user_choice < len(product_list):       #判断序列号的范围\r\n            if product_list[user_choice][1] < salary:                 #product_list[user_choice][1]取出商品价格做对比\r\n                product = product_list[user_choice]\r\n                salary = salary - product[1]\r\n                shopping_list.append(product[0])\r\n                print(\"添加%s到购物车,你的余额为%s\"%(product[0],salary))\r\n\r\n            else:\r\n                print(\"您当前剩余%s额度\"%salary)\r\n        else:\r\n            number = \"0 - \" + str(len(product_list)-1)\r\n            print(\"您输入的商品编号不存在,请从新输入%s\" %number)\r\n\r\n    elif user_choice == \'q\':\r\n        print(\"您当前的购物车列表为: \" , shopping_list)\r\n        print(\"您当前的余额%s\" %salary,\"如需购买请输入yes\")\r\n        yes = input(\'请输入:\')\r\n        if yes == \'yes\':\r\n            print(\"完成交易\")\r\n            exit()\r\n        else:\r\n            print(\"请重新选购\")\r\n    else:\r\n        print(\"bye bye!\")\r\n```\r\n\r\n\r\n\r\n\r\n## Python内置函数\r\n\r\n### `len()` 函数用法\r\n#### 描述\r\n\r\nPython len()方法返回对象（字符、列表、元组等）长度或者项目个数\r\n\r\n#### 语法    参数\r\n```\r\nleng(s) ## s是对象          \r\n```\r\n#### 返回值\r\n\r\n返回对象长度\r\n\r\n#### 实例\r\n```\r\n>>>s1 = \"runoob\"\r\n>>>print(len(s1))      ## 字符串长度\r\n6\r\n>>>classmates = [\'chenys\',\'zhangb\',\'sunl\']\r\n>>>print(len(classmates))          ## 列表元素个数 \r\n3 \r\n```\r\n\r\n### `range()` 函数用法\r\n#### 描述\r\n\r\nPython range()函数可以创建一个整数列表，一般用在for循环中。\r\n\r\n#### 语法 参数\r\n```\r\nrange(start,stop[,step])\r\n#start:计数从start开始。默认是从0开始，例如range(5)等价于range（0,5);\r\n#end: 计数到 end 结束，但不包括 end。例如：range(0,5) 是[0, 1, 2, 3, 4]没有5\r\n#step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)\r\n```\r\n\r\n#### 实例\r\n```\r\nfor i in range(10):            #从0开始到10\r\n    print(i)\r\n	\r\nfor i in range(1,11):          #从1开始到11\r\n    print(i)\r\n\r\nfor i in range(0,31,5):        #从0到31，步长为5\r\n    print(i)\r\n	\r\nfor i in range(0,-10,-1):      #负数\r\n    print(i)\r\n```\r\n\r\n### `enumerate()`  函数用法\r\n#### 描述\r\nenumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\r\n\r\n#### 语法 参数\r\n```\r\nenumerate(sequence, [start=0])    \r\n#sequence -- 一个序列、迭代器或其他支持迭代对象。\r\n#start -- 下标起始位置。\r\n```\r\n\r\n#### 返回值\r\n返回 enumerate(枚举) 对象。\r\n\r\n#### 实例\r\n```\r\nseq = [\'one\',\'two\',\'three\']\r\nfor index ,element in enumerate(seq):\r\n    print(index ,seq[index])\r\n	\r\n```','2017-06-13 23:43:48','2017-06-20 00:15:31','introduction-to-python3-x'),(3,6,6,'ELK Stack 入门（英文版）','## Overview\r\nThe Elastic Stack is made up of multiple components developed by Elastic. In no particular order, these are:\r\n\r\n- Beats 5.x\r\n- Elasticsearch 5.x\r\n- Elasticsearch Hadoop 5.x\r\n- Kibana 5.x\r\n- Logstash 5.x\r\n- X-Pack 5.x\r\n\r\nIn this guide, you learn how to install and upgrade products in the Elastic Stack.\r\n\r\n### Installing the Elastic Stack\r\nBeginning with 5.0, installing the Elastic Stack and understanding the compatibility between products has been dramatically simplified. All products are now part of a unified release process, so when any product is released, then all products are released with it. This helps to guarantee compatibility as well as avoid confusion surrounding version numbers.\r\n\r\nAs a result, when performing any Elastic Stack installation, you should always start with the same version across the entire stack. For example, if you select Elasticsearch 5.1.2, then you should also select Kibana 5.1.2, Logstash 5.1.2, and Beats 5.1.2.\r\n\r\n#### Installation Order\r\nWe recommend that you install the Elastic Stack in the following order.\r\n1. Elasticsearch\r\n        * X-Pack for Elasticsearch \r\n2.  Kibana\r\n        * X-Pack for Kibana \r\n3. Logstash\r\n4. Beats\r\n5. Elasticsearch Hadoop \r\n\r\nThis helps to ensure that the right parts of your infrastructure are running before other parts attempt to use them (e.g., Logstash sending data to Elasticsearch).\r\n\r\n### Beats Platform Reference\r\n\r\nThe binary packages of Elasticsearch have only one dependency: Java. The minimum supported version is Java 8. To download and install Elasticsearch, use the commands that work with your system (deb for Debian/Ubuntu, rpm for Redhat/Centos/Fedora, mac for OS X, and win for Windows):\r\n\r\nrpm:\r\n\r\n```\r\nsudo yum install java-1.8.0-openjdk\r\ncurl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.4.1.rpm\r\nsudo rpm -i elasticsearch-5.4.1.rpm\r\nsudo service elasticsearch start\r\n```\r\n\r\nIn this setup, the Beat sends events to Logstash. Logstash receives these events by using the Beats input plugin for Logstash and then sends the transaction to Elasticsearch by using the Elasticsearch output plugin for Logstash. The Elasticsearch output plugin uses the bulk API, making indexing very efficient.\r\n\r\nTo set up Logstash:\r\n\r\n    Make sure you have the latest compatible version of the Beats input plugin for Logstash installed.\r\n\r\n    The Beats input plugin requires Logstash 1.5.4 or later. If you are using Logstash 1.5.4, you must install the Beats input plugin before applying this configuration because the plugin is not shipped with 1.5.4.\r\n\r\n    To install the required plugin, run the following command inside the logstash directory (for deb and rpm installs, the directory is /opt/logstash).\r\n\r\n    deb, rpm, and mac:\r\n\r\n    ./bin/logstash-plugin install logstash-input-beats\r\n\r\n### Making Sure Elasticsearch is Up and Running\r\nTo test that the Elasticsearch daemon is up and running, try sending an HTTP GET request on port 9200.\r\n```\r\ncurl http://127.0.0.1:9200\r\n```\r\nYou should see a response similar to this:\r\n```\r\n{\r\n  \"name\" : \"ofgAtrJ\",\r\n  \"cluster_name\" : \"elasticsearch\",\r\n  \"cluster_uuid\" : \"3h9xSrVlRJmDHgQ8FLnByA\",\r\n  \"version\" : {\r\n    \"number\" : \"5.4.1\",\r\n    \"build_hash\" : \"db0d481\",\r\n    \"build_date\" : \"2017-02-09T22:05:32.386Z\",\r\n    \"build_snapshot\" : false,\r\n    \"lucene_version\" : \"6.4.1\"\r\n  },\r\n  \"tagline\" : \"You Know, for Search\"\r\n}\r\n```\r\n## Installing Logstash (Optional)\r\nThe simplest architecture for the Beats platform setup consists of one or more Beats, Elasticsearch, and Kibana. This architecture is easy to get started with and sufficient for networks with low traffic. It also uses the minimum amount of servers: a single machine running Elasticsearch and Kibana. The Beats insert the transactions directly into the Elasticsearch instance.\r\n\r\nIf you want to perform additional processing or buffering on the data, however, you’ll want to install Logstash.\r\n\r\nAn important advantage to this approach is that you can use Logstash to modify the data captured by Beats in any way you like. You can also use Logstash’s many output plugins to integrate with other systems.\r\n\r\nTo download and install Logstash, use the commands that work with your system:\r\n\r\nrpm:\r\n\r\n```\r\nsudo yum install java-1.8.0-openjdk\r\ncurl -L -O https://artifacts.elastic.co/downloads/logstash/logstash-5.4.1.rpm\r\nsudo rpm -i logstash-5.4.1.rpm\r\n```\r\n### Setting Up Logstash\r\nIn this setup, the Beat sends events to Logstash. Logstash receives these events by using the Beats input plugin for Logstash and then sends the transaction to Elasticsearch by using the Elasticsearch output plugin for Logstash. The Elasticsearch output plugin uses the bulk API, making indexing very efficient.\r\n\r\nTo set up Logstash:\r\n\r\n1.Make sure you have the latest compatible version of the Beats input plugin for Logstash installed.\r\n\r\nThe Beats input plugin requires Logstash 1.5.4 or later. If you are using Logstash 1.5.4, you must install the Beats input plugin before applying this configuration because the plugin is not shipped with 1.5.4.\r\n\r\nTo install the required plugin, run the following command inside the logstash directory (for deb and rpm installs, the directory is /opt/logstash).\r\n\r\ndeb, rpm, and mac:\r\n\r\n```\r\n./bin/logstash-plugin install logstash-input-beats\r\n```','2017-06-14 00:21:34','2017-06-15 00:37:46','elk-stack-introduction-english-version'),(4,7,7,'Microsoft入门','`windows`\r\n\'\'\'\r\naaaaaa\r\n\'\'\'','2017-06-14 00:26:47','2017-06-14 00:28:07','introduction-to-microsoft'),(5,7,7,'Cisco入门','`Cisco`\r\n```\r\ntest\r\n```','2017-06-14 00:29:04','2017-06-14 00:29:04','introduction-to-cisco'),(6,6,6,'泡妞指南','Come on Guys. Let\'s learn!','2017-06-14 00:40:47','2017-06-14 00:40:47','practical-guide-to'),(7,4,4,'我得沙发~~','沙发~~沙发~~沙发~~','2017-06-14 00:59:28','2017-06-14 00:59:28','i-have-to-sofa'),(8,3,3,'写字就用 Markdown！','Markdown 不是 XML 也不是编程语言，只是一种书写形式，全世界程序员都喜欢用它！\r\n\r\n## 一、标题\r\n\r\n当你要输入标题时，键入\r\n\r\n```\r\n#### H4\r\n##### H5\r\n###### H6\r\n```\r\n\r\n你会看到这个结果。\r\n\r\n#### H4\r\n##### H5\r\n###### H6\r\n\r\n## 二、文本样式\r\n\r\n```\r\n**This is bold text**\r\n\r\n__This is bold text__\r\n\r\n*This is italic text*\r\n\r\n_This is italic text_\r\n\r\n~~Deleted text~~\r\n```\r\n\r\n**This is bold text**\r\n\r\n__This is bold text__\r\n\r\n*This is italic text*\r\n\r\n_This is italic text_\r\n\r\n~~Deleted text~~\r\n\r\n## 三、列表\r\n\r\n无序列表（`-` 或者 `*`）\r\n\r\n```\r\n- George Washington\r\n- John Adams\r\n- Thomas Jefferson\r\n```\r\n\r\n- George Washington\r\n- John Adams\r\n- Thomas Jefferson\r\n\r\n有序列表\r\n\r\n```\r\n1. James Madison\r\n2. James Monroe\r\n3. John Quincy Adams\r\n```\r\n\r\n1. James Madison\r\n2. James Monroe\r\n3. John Quincy Adams\r\n\r\n嵌套列表\r\n\r\n```\r\n1. Make my changes\r\n    1. Fix bug\r\n    2. Improve formatting\r\n        - Make the headings bigger\r\n2. Push my commits to GitHub\r\n3. Open a pull request\r\n    * Describe my changes\r\n    * Mention all the members of my team\r\n        * Ask for feedback\r\n```\r\n\r\n1. Make my changes\r\n    1. Fix bug\r\n    2. Improve formatting\r\n        - Make the headings bigger\r\n2. Push my commits to GitHub\r\n3. Open a pull request\r\n    * Describe my changes\r\n    * Mention all the members of my team\r\n        * Ask for feedback\r\n\r\n## 四、链接\r\n\r\n```\r\n[GitHub Pages](https://pages.github.com/)\r\n```\r\n\r\n[GitHub Pages](https://pages.github.com/)\r\n\r\n## 五、图片\r\n\r\n```\r\n![头像](http://www.baooab.com/wp/wp-content/uploads/2017/08/avatar_2.png)\r\n```\r\n\r\n![头像](http://www.baooab.com/wp/wp-content/uploads/2017/08/avatar_2.png)','2017-06-14 01:09:56','2017-08-12 03:51:45','write-with-the-markdown'),(10,3,3,'乱炖社区BUG修复帖','## 待解决 ?\r\n\r\n✘ 全站页面的准确 title（主要是帖子详情页）\r\n\r\n✘ 网站帖子已有标签删除无效\r\n\r\n---\r\n\r\n## 已解决 ?\r\n- 2017年10月25日\r\n	* 发表评论时更新帖子的 `updated_at` 字段\r\n- 2017年6月26日\r\n	* code 满行时水平滑动查看\r\n- 2017年6月20号\r\n    * 添加Markdown 编辑器\r\n    * 首页用户排行\r\n- 2017年6月19日 \r\n    * 添加模块“采集”\r\n- 2017年6月15号\r\n    * 支持手机浏览、发帖\r\n    * 图片自适应\r\n- 2017年6月14号\r\n    * 支持帖子详情页自动目录生成','2017-06-14 04:34:11','2017-12-20 05:18:15','a-stew-community-bug-fixes'),(11,3,3,'CSS 实用代码快速查询','## 图片自适应\r\n\r\n```\r\n.post img {\r\n    max-width: 100%;\r\n}\r\n```\r\n\r\n## `textarea` 固定宽度\r\n\r\n```\r\ntextarea {\r\n    resize: vertical;\r\n    overflow: auto;\r\n}\r\n```','2017-06-14 17:39:02','2017-06-14 17:39:16','practical-css-code-query-quickly'),(12,3,3,'Laravel 上传单张图片','## `storage:link`\r\n\r\nArtisan 命令\r\n\r\n```\r\nphp artisan storage:link\r\n```\r\n\r\n会创建一个软连接将 `public/storage` 目录指向 `storage/app/public`。\r\n\r\n## Blade 页面\r\n\r\n```\r\n<form method=\"POST\" action=\"http://www.baooab.com/user/avatar\" accept-charset=\"UTF-8\" enctype=\"multipart/form-data\">       \r\n    {{ csrf_field() }}\r\n    <div class=\"form-group\">\r\n        <input class=\"form-control\" name=\"avatar\" type=\"file\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <input class=\"btn btn-primary form-control\" type=\"submit\" value=\"修改\">\r\n    </div>\r\n</form>\r\n```\r\n\r\n## Controller \r\n\r\n```\r\npublic function changeAvatar(Request $request)\r\n{\r\n    $avatar = $request->file(\'avatar\');\r\n\r\n    if ($avatar->isValid())\r\n    {\r\n        $user = Auth::user();\r\n\r\n        $originExt = $avatar->getClientOriginalExtension();\r\n        // 新文件名。例如：\'586f2d753dfbd.jpg\'\r\n        $newName = uniqid() . \'.\' . $originExt;\r\n        Storage::putFileAs(\'public/uploads/avatars\', $avatar, $newName);\r\n\r\n        $user->avatar = \'storage/uploads/avatars/\' . $newName;\r\n        $user->save();\r\n\r\n        return back();\r\n    }\r\n}\r\n```','2017-06-14 18:29:23','2017-06-14 18:29:51','laravel-upload-a-single-image'),(13,3,3,'Laravel 快速参考指南','## 一、安装 Laravel\r\n\r\n### 1.1 通过 Laravel Installer\r\n\r\n安装 Laravel 安装程序。\r\n\r\n```\r\ncomposer global require \"laravel/installer\"\r\n```\r\n\r\n然后就可以全局使用 `laravel` 命令了。比如：创建一个**基于最新的 Laravel 稳定版本**的项目“tutu”。\r\n\r\n```\r\nlaravel new tutu\r\n```\r\n\r\n查看项目使用的 Laravel 版本。\r\n\r\n```\r\n> php artisan list -V\r\nLaravel Framework 5.4.18\r\n```\r\n\r\n查看所有可以使用的 `php artisan`命令。\r\n\r\n```\r\nphp artisan list\r\n```\r\n\r\n查看 `php artisan list` 的帮准文档。\r\n\r\n```\r\nphp artisan help list\r\n```\r\n\r\n### 1.2 通过　Composer Create-Project\r\n\r\n通过 Composer Create-Project 的一个好处是可以创建一个**基于具体某个 Laravel 版本**的项目。比如：创建一个基于最新的 Laravel 5.3 版本的项目“tutu”。\r\n\r\n```\r\n> composer create-project --prefer-dist laravel/laravel tutu \"5.3.*\"\r\n\r\n> php artisan -V\r\nLaravel Framework version 5.3.31\r\n```\r\n\r\n## 中文环境配置\r\n\r\n修改 `config/app.php`，修改以下字段：\r\n\r\n```\r\n\'name\' => \'张宝的个人网站\',\r\n\'timezone\' => \'PRC\',\r\n\'locale\' => \'zh-CN\',\r\n```\r\n\r\n## 创建 Model 和迁移文件\r\n\r\n创建迁移文件\r\n\r\n```shell\r\n# 创建表的迁移文件\r\nphp artisan make:migration create_phones_table --create=phones\r\n\r\n# 更新表的迁移文件\r\nphp artisan make:migration update_users_table --table=users\r\n```\r\n\r\n在 [修改字段](https://laravel-china.org/docs/5.3/migrations#修改字段) 之前，请务必在你的 `composer.json` 中增加 `doctrine/dbal` 依赖\r\n\r\n```\r\ncomposer require doctrine/dbal\r\n```\r\n\r\n## Markdown\r\n\r\n```\r\ncomposer require erusev/parsedown\r\n```\r\n\r\n## 自定义分页样式\r\n\r\n```\r\nphp artisan vendor:publish --tag=laravel-pagination\r\n```\r\n\r\n## link\r\n\r\n使用命令`php artisan storage:link` 将 `public/storage` 指向 `storage/app/public`。\r\n\r\n## 文件上传\r\n\r\n前台：\r\n\r\n```javascript=\r\n// see http://blog.teamtreehouse.com/uploading-files-ajax\r\nvar fileSelect = document.getElementById(\'images\');\r\nvar files = fileSelect.files;\r\nvar formData = new FormData();\r\nvar file = null;\r\nfor (var i = 0; i < files.length; i++) {\r\n    file = files[i];\r\n    if (file.type.indexOf(\'image\') === -1) {\r\n        continue;\r\n    }\r\n    formData.append(\'images[]\', file, file.name);\r\n}\r\n\r\n$.ajax({\r\n    url: \"{{ url(\'image/upload\') }}\",\r\n    type: \'POST\',\r\n    data: formData,\r\n    cache: false,\r\n    contentType: false,\r\n    processData: false\r\n})\r\n.done(...)\r\n.fail(...);\r\n```\r\n\r\n后台：\r\n\r\n```javascript=\r\npublic function upload(Request $request) {\r\n    $images = $request->file(\'images\');\r\n    $updatedRows = 0;\r\n    $updateUrls = [];\r\n    foreach ($images as $file) {\r\n        if ($file->isValid()) {\r\n            $originName = $file->getClientOriginalName();\r\n            $originExt = $file->getClientOriginalExtension();\r\n            $size = $file->getClientSize();\r\n\r\n            // 存储路径，含新文件名。例如：\'2017/01/586f2d753dfbd.jpg\'\r\n            $path = date(\'Y/m/\') . uniqid() . \'.\' . $originExt;\r\n            // 上传文件临时路径\r\n            $realPath = $file->getRealPath();\r\n            Storage::put($path, file_get_contents($realPath));\r\n\r\n            $updateUrls[] = [\r\n                \'originName\' => $originName,\r\n                \'originExt\' => $originExt,\r\n                \'size\' => $size,\r\n                \'path\' => $path,\r\n            ];\r\n\r\n            $updatedRows++;\r\n        }\r\n    }\r\n\r\n    $updated = (count($images) === $updatedRows) ? true : false;\r\n\r\n    return response()->json([\r\n        \'successed\' => $updated,\r\n        \'message\' => \'update successfully!\',\r\n        \'urls\' => $updateUrls,\r\n    ]);\r\n}\r\n```\r\n\r\n## 数据库迁移\r\n\r\n### 列类型创建和修改方法（Available Column Types & Column Modifiers）\r\n\r\nhttps://laravel.com/docs/5.4/migrations#columns\r\n\r\n### 列修改方法（Modifying Columns）\r\n\r\n```\r\ncomposer require doctrine/dbal\r\n```\r\n\r\n提供了 `change()`、`renameColumn(\'from\', \'to\')` 和 `dropColumn(\'votes\')` 方法。\r\n\r\n### 创建索引\r\n\r\nhttps://laravel.com/docs/5.4/migrations#indexes\r\n\r\n外键约束\r\n\r\n```\r\n$table->foreign(\'user_id\')\r\n      ->references(\'id\')->on(\'users\')\r\n      ->onDelete(\'cascade\');\r\n```\r\n\r\n### Index Lengths & MySQL / MariaDB\r\n\r\n从 Laravel 5.4 起，数据库编码采用 `utf8mb4`。这就存在一个问题：如果运行与 MySQL 5.7.7- 和 MariaDB 10.2.2-，会报错误“[Specified key was too long error](https://laravel-news.com/laravel-5-4-key-too-long-error)” 。此时，要在 `AppServiceProvider` 设置 `Schema::defaultStringLength` 方法，方可正常使用。\r\n\r\n```\r\nuse Illuminate\\Support\\Facades\\Schema;\r\n\r\npublic function boot()\r\n{\r\n    Schema::defaultStringLength(191);\r\n}\r\n```\r\n\r\n## 表单验证规则\r\n\r\nhttps://laravel.com/docs/5.4/validation#available-validation-rules\r\n\r\n\r\n\r\n## Gates & Policies\r\n\r\nhttps://laravel.com/docs/5.4/authorization\r\n\r\n## Markdown\r\n\r\nLaravel 5.4- 需要下载依赖包。\r\n\r\n```\r\ncomposer require erusev/parsedown\r\n```\r\n\r\n在 Blade 模板中这样使用\r\n\r\n```\r\n{!! Parsedown::instance()->text($post->body) !!}\r\n```\r\n\r\n具体教程看[这里](https://github.com/erusev/parsedown/wiki/Tutorial:-Get-Started)。\r\n\r\n## 权限管理系统\r\n\r\nUser Model\r\n\r\n```\r\n/**\r\n * The roles that belong to the User.\r\n */\r\npublic function roles()\r\n{\r\n    return $this->belongsToMany(Role::class);\r\n}\r\n\r\npublic function hasRole($role) {\r\n    if (is_string($role))\r\n    {\r\n        return $this->roles->contains(\'name\', $role);\r\n    }\r\n\r\n    return !! $role->intersect($this->roles)->count();\r\n}\r\n\r\npublic function giveRole(Role $role) \r\n{\r\n    return $this->roles()->save($role);\r\n}\r\n```\r\n\r\n_需要注意的是：`$user->roles` 返回 `Collection` 实例；`$user->roles()` 返回 Query Builder 实例。_\r\n\r\nRole Model\r\n\r\n```\r\n/**\r\n * The permissions that belong to the Role.\r\n */\r\npublic function permissions()\r\n{\r\n    return $this->belongsToMany(Permission::class);\r\n}\r\n\r\npublic function givePermission(Permission $permission)\r\n{\r\n    return $this->permissions()->save($permission);\r\n}\r\n```\r\n\r\nPermission Model\r\n\r\n```\r\n/**\r\n * The roles that belong to the Permission.\r\n */\r\npublic function roles()\r\n{\r\n    return $this->belongsToMany(Role::class);\r\n}\r\n```\r\n\r\n`AuthServiceProvider`\r\n\r\n```\r\npublic function boot()\r\n{\r\n    foreach ($this->getPermissions() as $permission) {\r\n        Gate::define($permission->name, function ($user) use ($permission) {\r\n            return $user->hasRole($permission->roles);\r\n        });\r\n    }\r\n}\r\n\r\nprotected function getPermissions()\r\n{\r\n    return Permission::with(\'roles\')->get();\r\n}\r\n```\r\n\r\n在 Blade 模板中使用\r\n\r\n```\r\n@can(\'edit—form\', $post)\r\n    <small>编辑</small>\r\n@endcan\r\n```\r\n\r\n## `laravelcollective/html`\r\n\r\n```\r\ncomposer require \"laravelcollective/html\":\"^5.4.0\"\r\n```\r\n\r\n使用方法见[这里](https://laravelcollective.com/docs/master/html#installation)。\r\n\r\n举个例子：\r\n\r\n```\r\n{!! Form::open([\'url\' => url(\'login\'), \'method\' => \'post\']) !!}\r\n<div class=\"form-group\">\r\n	{!! Form::label(\'email\', \'邮箱\') !!}\r\n	{!! Form::email(\'email\', null, [\'class\' => \'form-control\']) !!}\r\n</div>\r\n<div class=\"form-group\">\r\n	{!! Form::label(\'password\', \'密码\') !!}\r\n	{!! Form::password(\'password\', [\'class\' => \'form-control\']) !!}\r\n</div>\r\n<div class=\"form-group\">\r\n	{!! Form::submit(\'登录\', [\'class\' => \'btn btn-primary form-control\']) !!}\r\n</div>\r\n{!! Form::close() !!}\r\n```\r\n\r\n## Carbon 人性化时间显示\r\n\r\n在 `AppServiceProvider` 的 `boot` 方法中添加\r\n\r\n```\r\nuse Carbon\\Carbon;\r\n\r\npublic function boot()\r\n{\r\n	Carbon::setLocale(\'zh\');\r\n}\r\n```\r\n\r\n修改 Model\r\n\r\n```\r\npublic function getUpdatedAtAttribute($date)\r\n{\r\n	return Carbon::parse($date)->diffForHumans();\r\n}\r\n```\r\n\r\n在 Blade 模板中使用\r\n\r\n```\r\n{{ $article->updated_at }}\r\n```\r\n\r\n## 上传图片\r\n\r\n我把图片上传到 `storage/app/public` 这个目录，图片的相对路径是 `2017/04/58f76a92ade79.jpg`。如果我想使用地址 `http://localhost/storage/2017/04/58f76a92ade79.jpg`，需要将 `public/storage` 目录指向 `storage/app/public`。\r\n\r\n在 CMD 中执行下面的命令即可。\r\n\r\n```\r\nphp artisan storage:link\r\n```\r\n\r\n或者自定义将 `public/uploads` 目录指向 `storage/app/uploads`（后者需先行创建）。\r\n\r\n```\r\nE:\\wamp\\www\\discuss>mklink /D \"./public/uploads\" \"E:\\wamp\\www\\discuss\\storage\\app\\uploads\"\r\n为 ./public/uploads <<===>> E:\\wamp\\www\\discuss\\storage\\app\\uploads 创建的符号链接\r\n```\r\n\r\n###### tags: `Laravel` `参考`','2017-06-14 18:48:18','2017-10-27 04:44:21','laravel-quick-reference-guide'),(14,3,3,'Window7 下 WNMP 环境搭建','WNMP 指“Windows 下的 Nginx、MariaDB 和 PHP 环境”。\r\n\r\n## 下载\r\n\r\n1. Nginx：http://nginx.org/en/download.html\r\n2. MariaDB：https://downloads.mariadb.org/\r\n3. PHP：http://windows.php.net/download\r\n4. RunHiddenConsole：http://redmine.lighttpd.net/attachments/660/RunHiddenConsole.zip\r\n\r\n在 D 盘根目录下创建目录 wnmp。将 `nginx-1.13.0.zip`、`mariadb-10.1.23-winx64.msi` 和 `php-7.1.5-nts-Win32-VC14-x64.zip` 放在里面。\r\n\r\n```\r\nC:\\>mklink /d C:\\wnmp D:\\wnmp\r\n为 C:\\wnmp <<===>> D:\\wnmp 创建的符号链接\r\n```\r\n\r\n现在在 C 盘根目录下的 wnmp 中操作。\r\n\r\n## PHP\r\n\r\n`php.ini-development` 改为 `php.ini`、编辑它。\r\n\r\n```\r\n; On windows:\r\n; extension_dir = \"ext\"\r\n\r\n; 改为\r\n\r\n; On windows:\r\nextension_dir = \"C:/wnmp/php7.1.5/ext\"\r\n```\r\n\r\n```\r\n; Windows Extensions\r\n; Note that ODBC support is built in, so no dll is needed for it.\r\n; Note that many DLL files are located in the extensions/ (PHP 4) ext/ (PHP 5+)\r\n; extension folders as well as the separate PECL DLL download (PHP 5+).\r\n; Be sure to appropriately set the extension_dir directive.\r\n;\r\n;extension=php_bz2.dll\r\n;extension=php_curl.dll\r\n;extension=php_fileinfo.dll\r\n;extension=php_ftp.dll\r\n;extension=php_gd2.dll\r\n;extension=php_gettext.dll\r\n;extension=php_gmp.dll\r\n;extension=php_intl.dll\r\n;extension=php_imap.dll\r\n;extension=php_interbase.dll\r\n;extension=php_ldap.dll\r\n;extension=php_mbstring.dll\r\n;extension=php_exif.dll      ; Must be after mbstring as it depends on it\r\n;extension=php_mysqli.dll\r\n;extension=php_oci8_12c.dll  ; Use with Oracle Database 12c Instant Client\r\n;extension=php_openssl.dll\r\n;extension=php_pdo_firebird.dll\r\n;extension=php_pdo_mysql.dll\r\n;extension=php_pdo_oci.dll\r\n;extension=php_pdo_odbc.dll\r\n;extension=php_pdo_pgsql.dll\r\n;extension=php_pdo_sqlite.dll\r\n;extension=php_pgsql.dll\r\n;extension=php_shmop.dll\r\n\r\n; The MIBS data available in the PHP distribution must be installed.\r\n; See http://www.php.net/manual/en/snmp.installation.php\r\n;extension=php_snmp.dll\r\n\r\n;extension=php_soap.dll\r\n;extension=php_sockets.dll\r\n;extension=php_sqlite3.dll\r\n;extension=php_tidy.dll\r\n;extension=php_xmlrpc.dll\r\n;extension=php_xsl.dll\r\n\r\n; 改为\r\n\r\n; Windows Extensions\r\n; Note that ODBC support is built in, so no dll is needed for it.\r\n; Note that many DLL files are located in the extensions/ (PHP 4) ext/ (PHP 5+)\r\n; extension folders as well as the separate PECL DLL download (PHP 5+).\r\n; Be sure to appropriately set the extension_dir directive.\r\n;\r\nextension=php_bz2.dll\r\nextension=php_curl.dll\r\nextension=php_fileinfo.dll\r\n;extension=php_ftp.dll\r\nextension=php_gd2.dll\r\nextension=php_gettext.dll\r\nextension=php_gmp.dll\r\nextension=php_intl.dll\r\nextension=php_imap.dll\r\n;extension=php_interbase.dll\r\nextension=php_ldap.dll\r\nextension=php_mbstring.dll\r\nextension=php_exif.dll      ; Must be after mbstring as it depends on it\r\nextension=php_mysqli.dll\r\n;extension=php_oci8_12c.dll  ; Use with Oracle Database 12c Instant Client\r\nextension=php_openssl.dll\r\n;extension=php_pdo_firebird.dll\r\nextension=php_pdo_mysql.dll\r\n;extension=php_pdo_oci.dll\r\n;extension=php_pdo_odbc.dll\r\n;extension=php_pdo_pgsql.dll\r\nextension=php_pdo_sqlite.dll\r\n;extension=php_pgsql.dll\r\n;extension=php_shmop.dll\r\n\r\n; The MIBS data available in the PHP distribution must be installed.\r\n; See http://www.php.net/manual/en/snmp.installation.php\r\n;extension=php_snmp.dll\r\n\r\nextension=php_soap.dll\r\nextension=php_sockets.dll\r\nextension=php_sqlite3.dll\r\n;extension=php_tidy.dll\r\nextension=php_xmlrpc.dll\r\nextension=php_xsl.dll\r\n```\r\n\r\n```\r\n;cgi.fix_pathinfo=1\r\n\r\n; 改为\r\n\r\ncgi.fix_pathinfo=1\r\n```\r\n\r\n## Nginx\r\n\r\n搭建不支持 PHP 的 Nginx 服务器非常简单。那就是说搭建支持 PHP 的 Nginx 服务器就会稍微麻烦些。\r\n\r\n修改 `nginx.conf`。\r\n\r\n```\r\nlocation / {\r\n    root   html;\r\n    index  index.html index.htm;\r\n}\r\n        \r\n# 改为\r\n\r\nlocation / {\r\n    root   C:/wnmp/www;\r\n    index  index.html index.htm index.php;\r\n		try_files $uri $uri/ /index.php?$query_string;\r\n}\r\n```\r\n\r\n```\r\n# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\r\n#\r\n#location ~ \\.php$ {\r\n#    root           html;\r\n#    fastcgi_pass   127.0.0.1:9000;\r\n#    fastcgi_index  index.php;\r\n#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\r\n#    include        fastcgi_params;\r\n#}\r\n\r\n# 改为\r\n\r\n# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9002\r\n#\r\nlocation ~ \\.php$ {\r\n    root           C:/wnmp/www;\r\n    fastcgi_pass   127.0.0.1:9002;\r\n    fastcgi_index  index.php;\r\n    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\r\n    include        fastcgi_params;\r\n}\r\n```\r\n\r\n`$document_root` 就是 `C:/wnmp/www`。\r\n\r\n## 启动\r\n\r\n### 手工启动\r\n\r\n启动 php-cgi.exe，监听 9002 端口。\r\n\r\n```\r\nC:\\wnmp\\php7.1.5>php-cgi.exe -b 127.0.0.1:9002 -c C:/wnmp/php7.1.5/php.ini\r\n```\r\n\r\n另开一个 CMD，启动 Nginx。\r\n\r\n```\r\nstart nginx\r\n```\r\n\r\n### 后台启动\r\n\r\n把下载好的 RunHiddenConsole.zip 包解压到 php 目录内，RunHiddenConsole.exe 的作用是在执行完命令行脚本后自动关闭脚本，而从脚本中开启的进程不被关闭。\r\n\r\n创建启动脚本“start_nginx.bat”，内容如下。\r\n\r\n```\r\n@echo off\r\nREM Windows 下无效\r\nREM set PHP_FCGI_CHILDREN=5\r\n\r\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\r\nset PHP_FCGI_MAX_REQUESTS=1000\r\n \r\necho Starting PHP FastCGI...\r\nRunHiddenConsole C:/wnmp/php7.1.5/php-cgi.exe -b 127.0.0.1:9002 -c C:/wnmp/php7.1.5/php.ini\r\n \r\necho Starting nginx...\r\nRunHiddenConsole C:/wnmp/nginx1.13.0/nginx.exe -p C:/wnmp/nginx1.13.0\r\n```\r\n\r\n创建退出脚本“stop_nginx.bat”，内容如下。\r\n\r\n```\r\n@echo off\r\necho Stopping nginx...  \r\ntaskkill /F /IM nginx.exe > nul\r\necho Stopping PHP FastCGI...\r\ntaskkill /F /IM php-cgi.exe > nul\r\nexit\r\n```\r\n\r\n以后就可以用这两个脚本开启、关闭服务了。\r\n\r\n## MariaDB\r\n\r\nMariaDB 就是开源、无公司的 Mysql。它的安装和 MySQL 完全一样。默认服务名是 mysql，建议改为 MariaDB 以便区分。\r\n\r\n连接 MariaDB 的方式和 MySQL，如果以前用 MySQL 现在用 MariaDB，连接信息不需要更改。\r\n\r\n## 参考链接\r\n\r\n- [nginx for Windows](http://nginx.org/en/docs/windows.html)\r\n- [windows下配置nginx+php环境](http://www.cnblogs.com/huayangmeng/archive/2011/06/15/2081337.html)\r\n\r\n## 附录\r\n\r\n#### 搭建不支持 PHP 的 Nginx 服务器\r\n\r\n[下载](http://nginx.org/en/download.html) Nginx 的 Windows 版安装文件（在此以 nginx-1.13.0 为例）。\r\n\r\n1. 将 `nginx-1.13.0.zip` 放在 C 盘根目录下（即路径为 `C:\\`）。\r\n2. `nginx-1.13.0.zip` 解压到当前文件夹，得到目录 `C:\\nginx-1.13.0`。\r\n3. `cd nginx-1.13.0` 然后 `start nginx` 就开启了服务器。\r\n4. 浏览器输入 `http://localhost/` 看到“Welcome to nginx!”。\r\n\r\n查看 Nginx 进程信息\r\n\r\n```\r\ntasklist /fi \"imagename eq nginx.exe\"\r\n```\r\n\r\n杀死 Nginx 进程\r\n\r\n```\r\ntaskkill /F /IM nginx.exe > nul\r\n```\r\n\r\n启动 Nginx 服务器\r\n\r\n```\r\nstart nginx\r\n```\r\n\r\n#### 杀死 PID\r\n\r\n```\r\n# 查看占用 9002 端口的 PID\r\n> netstat -aon|findstr 9002\r\n  TCP    127.0.0.1:9002         0.0.0.0:0              LISTENING       7732\r\n  TCP    192.168.10.119:49484   120.92.58.186:9002     CLOSE_WAIT      7640\r\n\r\n# 杀死 pid 是 7732 的进程\r\ntaskkill /pid 7732\r\n```\r\n\r\n#### 为 Nginx 开 Virtual Host\r\n\r\n开放 8888 端口，根目录在 ` C:/wnmp/laravel/template/public`。\r\n\r\n```\r\nserver {\r\n    listen       8888;\r\n    server_name  localhost;\r\n\r\n    location / {\r\n        root   C:/wnmp/laravel/template/public;\r\n        index  index.html index.htm index.php;\r\n        try_files $uri $uri/ /index.php?$query_string;\r\n    }\r\n\r\n    location ~ \\.php$ {\r\n        root           C:/wnmp/laravel/template/public;\r\n        fastcgi_pass   127.0.0.1:9002;\r\n        fastcgi_index  index.php;\r\n        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\r\n        include        fastcgi_params;\r\n    }\r\n}\r\n```\r\n\r\n###### tags: `服务器` `Nginx`','2017-06-14 18:51:32','2017-06-16 05:56:41','windows-7-wnmp-environment-set-up'),(15,3,3,'世界著名文学作品简介','##  《鲁滨孙漂流记》\r\n\r\nby [英国]丹尼尔·笛福\r\n\r\n本书于1719年4月25日出版，讲述出身于商人之家的鲁滨孙，不想平庸地生活，一心向往着充满冒险与挑战的海外生活，于是毅然舍弃安逸舒适的生活，离家出海航行，去实现遨游世界的梦想，但每次都历尽艰险。有一次，风暴将船只打翻，鲁滨孙一个人被海浪抛到一座荒无人烟的海岛上，在那里度过了28年孤独的时光。\r\n\r\n> 可见，我们一般人，非要亲眼看见更恶劣的环境，就无法理解原有环境的好处；非要落到山穷水尽的地步，就不懂得珍视自己原来享受到的东西。\r\n\r\n## 《钢铁是怎样炼成的》\r\n\r\nby _[苏联]尼古拉·阿列克谢耶维奇·奥斯特洛夫斯基_\r\n\r\n这是一部长篇小说，于1933年写成。小说通过记叙保尔·柯察金的成长道路。告诉人们，一个人只有在革命的艰难困苦中战胜敌人也战胜自己，只有在把自己的追求和祖国、人民的利益联系在一起的时候，才会创造出奇迹，才会成长为钢铁战士。\r\n\r\n> 人最宝贵的是生命，生命每个人只有一次。人的一生应该这样度过：当他回首往事的时候，不因虚度年华而悔恨，也不因碌碌无为而羞愧。\r\n\r\n（待续）','2017-06-14 18:58:49','2017-06-14 18:59:16','introduction-to-the-world-famous-literary-works'),(16,3,3,'在 Laravel 中优雅处理 Form 表单','https://www.laravist.com/blog/post/elegant-form-handling-in-laravel','2017-06-14 19:03:04','2017-06-14 19:03:04','elegant-processing-in-laravel-form-form'),(17,3,3,'删除错误录入的工点测点','## 原因\r\n\r\n> 批量导入时，中间有空行，属于录入错误。\r\n\r\n## 解决方式\r\n\r\n涉及**工点库**两张表——`Svy_PointInArea` 和 `Svy_SurveyPoint`。直接删除工点库数据会报错，因为 `测点表` 受 `测点与分区关系表` 的外键约束。\r\n\r\n我删除的测点有 16 个：\r\n\r\n```\r\n\'DBC37-01\', \'DBC37-02\', \r\n\'DBC38-01\', \'DBC38-02\', \r\n\'DBC39-01\', \'DBC39-05\', \'DBC39-07\',\r\n\'DBC40-01\', \'DBC40-05\', \'DBC40-07\', \r\n\'DBC43-01\', \'DBC43-02\', \'DBC43-03\',\r\n\'DBC44-01\', \'DBC44-02\', \'DBC44-03\'\r\n```\r\n\r\n1. 删除 `测点与分区关系表` 中要删除测点对应的记录。\r\n\r\n```\r\ndelete from Svy_PointInArea where Svy_SurveyPointID in (\r\n	select Svy_SurveyPointID from Svy_SurveyPoint where SurveyPointName in \r\n	(\r\n	\'DBC37-01\', \'DBC37-02\', \r\n	\'DBC38-01\', \'DBC38-02\', \r\n	\'DBC39-01\', \'DBC39-05\', \'DBC39-07\',\r\n	\'DBC40-01\', \'DBC40-05\', \'DBC40-07\', \r\n	\'DBC43-01\', \'DBC43-02\', \'DBC43-03\',\r\n	\'DBC44-01\', \'DBC44-02\', \'DBC44-03\'\r\n	)\r\n)\r\n```\r\n\r\n2. 再删除 `测点表` 中的测点。\r\n\r\n```\r\ndelete from Svy_SurveyPoint where SurveyPointName in \r\n(\r\n\'DBC37-01\', \'DBC37-02\', \r\n\'DBC38-01\', \'DBC38-02\', \r\n\'DBC39-01\', \'DBC39-05\', \'DBC39-07\',\r\n\'DBC40-01\', \'DBC40-05\', \'DBC40-07\', \r\n\'DBC43-01\', \'DBC43-02\', \'DBC43-03\',\r\n\'DBC44-01\', \'DBC44-02\', \'DBC44-03\'\r\n);\r\n```\r\n\r\n（完）','2017-06-14 19:16:11','2017-06-14 19:16:11','delete-the-wrong-entry-worksite-measuring-point'),(18,3,3,'删除测组、测点表中所有数据','测组表 `Svy_SurveyGroup` 依赖测点表 `Svy_SurveyItem`，所以要先删除测组表，再删除测点表。\r\n\r\n删除测组：\r\n\r\n```\r\ndelete from Svy_SurveyGroup\r\n```\r\n\r\n删除测点：\r\n\r\n```\r\ndelete  from Svy_SurveyItem\r\n```','2017-06-14 19:29:26','2017-06-14 19:29:26','delete-the-test-group-the-measuring-point-all-the-data-in-the-table'),(19,3,3,'开发知乎：用户表设计、用户注册','## 用户表设计\r\n\r\n```\r\nSchema::create(\'users\', function (Blueprint $table) {\r\n    $table->increments(\'id\');\r\n    $table->string(\'name\')->unique();\r\n    $table->string(\'email\')->unique();\r\n    $table->string(\'password\');\r\n    $table->string(\'avatar\');\r\n    $table->string(\'confirmation_token\');\r\n    $table->tinyInteger(\'is_active\')->default(0);\r\n    $table->unsignedInteger(\'questions_count\')->default(0);\r\n    $table->unsignedInteger(\'answers_count\')->default(0);\r\n    $table->unsignedInteger(\'comments_count\')->default(0);\r\n    $table->unsignedInteger(\'favorites_count\')->default(0);\r\n    $table->unsignedInteger(\'likes_count\')->default(0);\r\n    $table->unsignedInteger(\'followers_count\')->default(0);\r\n    $table->unsignedInteger(\'following_count\')->default(0);\r\n    $table->json(\'settings\')->nullable();\r\n    $table->rememberToken();\r\n    $table->timestamps();\r\n});\r\n```\r\n\r\n![开发知乎之用户表设计](http://images2015.cnblogs.com/blog/683184/201706/683184-20170615131020556-1861530396.png)\r\n\r\n## 用户注册\r\n\r\n使用 SendCloud 发送用户注册时的激活邮件。\r\n\r\n### 安装依赖[ ` naux/sendcloud`](https://github.com/NauxLiu/Laravel-SendCloud)\r\n\r\n在项目目录下执行\r\n\r\n```\r\ncomposer require naux/sendcloud\r\n```\r\n\r\n修改 `config/app.php`，添加服务提供者\r\n\r\n```php\r\n\'providers\' => [\r\n   // 添加这行\r\n    Naux\\Mail\\SendCloudServiceProvider::class,\r\n];\r\n```\r\n\r\n在 `.env` 中配置你的密钥， 并修改邮件驱动为 `sendcloud`\r\n\r\n```ini\r\nMAIL_DRIVER=sendcloud\r\n\r\nSEND_CLOUD_USER=   # 创建的 api_user\r\nSEND_CLOUD_KEY=    # 分配的 api_key\r\n```\r\n\r\n### 注册用户时，发送邮件\r\n\r\n生成认证系统\r\n\r\n```\r\n$ php artisan make:auth\r\n```\r\n\r\n修改 `RegisterController` 的 `create` 方法\r\n\r\n```\r\nprotected function create(array $data)\r\n{\r\n    $user = User::create([\r\n        \'name\' => $data[\'name\'],\r\n        \'email\' => $data[\'email\'],\r\n        \'avatar\' => \'/images/avatars/default.png\',\r\n        \'confirmation_token\' => str_random(32),\r\n        \'password\' => bcrypt($data[\'password\']),\r\n    ]);\r\n\r\n    $this->sendVerifyEmailTo($user);\r\n\r\n    return $user;\r\n}\r\n\r\npublic function sendVerifyEmailTo($user)\r\n{\r\n    $data = [\'url\' => route(\'email.verify\', [\r\n        \'confirmation_token\' => $user->confirmation_token,\r\n        \'name\' => $user->name,\r\n    ])];\r\n    $template = new SendCloudTemplate(\'zhihu_app_register\', $data);\r\n\r\n    Mail::raw($template, function ($message) use ($user) {\r\n        $message->from(\'admin@baooab.com\', \'乱炖社区\');\r\n        $message->to($user->email);\r\n    });\r\n}\r\n```\r\n\r\n新增路由\r\n\r\n```\r\nRoute::get(\'/email/verify/{confirmation_token}\', \'EmailController@verify\')->name(\'email.verify\');\r\n```\r\n\r\n增加 `EmailController`，添加 `verify` 方法。\r\n\r\n```\r\n$ php artisan make:controller EmailController\r\n```\r\n\r\n```\r\npublic function verify($confirmation_token)\r\n{\r\n    $user = User::where(\'confirmation_token\', $confirmation_token)->first();\r\n\r\n    if (is_null($user))\r\n    {\r\n        redirect(\'/\');\r\n    }\r\n\r\n    $user->is_active = 1;\r\n    $user->confirmation_token = str_random(32);\r\n    $user->save();\r\n\r\n\r\n    return redirect(\'/home\');\r\n}\r\n```','2017-06-14 21:11:49','2017-06-14 23:42:26','development-on-zhihu-user-table-design-user-registration'),(20,8,8,'Java对象封装','## 一、定义一个简易的学生卡\r\n\r\n```\r\nclass StudentCard {\r\n    string number;\r\n    string name;   \r\n    int age;          \r\n}\r\n```\r\n\r\n## 二、现在我们来定义几个学生卡\r\n\r\n```\r\nStudentCard card1  =new StudentCard();\r\ncard1.number = \"A1001\";\r\ncard1.name = \"张三\";\r\ncard1.age = 19;\r\n```\r\n\r\n```\r\nStudentCard card1  =new StudentCard();\r\ncard1.number = \"A3001\";\r\ncard1.name = \"李四\";\r\ncard1.age = 21;\r\n```\r\n\r\n```\r\nStudentCard card1  =new StudentCard();\r\ncard1.number = \"A3002\";\r\ncard1.name = \"王五\";\r\ncard1.age = 21;\r\n```\r\n\r\n1.  __如果向我们这样定义是不是感觉很繁琐__\r\n2.  __这样会有很多的代码重复__\r\n3.  __现在我们可以运用构造函数来改进这个问题__\r\n\r\n```\r\nclass StudentCard {\r\n     string number;\r\n     string name;\r\n     int age;\r\n      StudentCard(string number,string name,int age) {\r\n               this.number = number;\r\n               this.name  = name;\r\n               this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n```\r\nStudentCard  card1 = new StudentCard(\"A1001\",\"张三\",19);\r\nStudentCard  card1 = new StudentCard(\"A3001\",\"李四\",21);\r\nStudentCard  card1 = new StudentCard(\"A3002\",\"王五\",21);\r\n```\r\n\r\n这样是不是感觉代码少很多了？\r\n\r\n（完）','2017-06-14 22:15:18','2017-06-15 00:26:04','java-object-encapsulation'),(21,3,3,'开发知乎：登录、汉化','## 登录\r\n\r\n### Flash 消息\r\n\r\n下载依赖包 [`laracasts/flash`][1]。\r\n\r\n```\r\n$ composer require laracasts/flash\r\n```\r\n\r\n修改 `config/app.php` 添加服务提供者。\r\n\r\n```\r\n\'providers\' => [\r\n    Laracasts\\Flash\\FlashServiceProvider::class,\r\n];\r\n```\r\n\r\n在 `layouts/app.blade.php` Blade 模板中引入\r\n\r\n```\r\n<div class=\"container\">\r\n    @include(\'flash::message\')\r\n</div>\r\n```\r\n\r\n自定义模板\r\n\r\n```\r\n$ php artisan vendor:publish --provider=\"Laracasts\\Flash\\FlashServiceProvider\"\r\n```\r\n\r\n### 重写登录\r\n\r\n重写 `LoginController` 的 `login` 方法。\r\n\r\n```\r\npublic function login(Request $request)\r\n{\r\n    ...\r\n\r\n    if ($this->attemptLogin($request)) {\r\n        flash(\'欢迎回来！\')->success()->important();\r\n\r\n        return $this->sendLoginResponse($request);\r\n    }\r\n\r\n    ...\r\n}\r\n``` \r\n\r\n再重写 `attemptLogin` 方法。\r\n\r\n```\r\nprotected function attemptLogin(Request $request)\r\n{\r\n    $credentials = array_merge($this->credentials($request), [\'is_active\' => 1]);\r\n\r\n    return $this->guard()->attempt(\r\n        $credentials, $request->has(\'remember\')\r\n    );\r\n}\r\n```\r\n\r\n修改 `resources/lang/zh-CN/auth.php` 文件（需将 `config/app.php` 文件中的 `locale` 设置为 `zh-CN`），汉化提示。\r\n\r\n```\r\n\'failed\' => \'用户名、密码错误或者邮箱未验证。\',\r\n```\r\n\r\n## 汉化\r\n\r\n汉化页面和汉化提示信息。\r\n\r\n### 页面\r\n\r\n页面包括：布局页面、登录、注册、发送密码重置链接、重置密码页面。\r\n\r\n### 提示信息\r\n\r\n提示信息包括：登录、注册页提示信息（位于 `resources/lang/zh-CN` 下）（或者下载[汉化包][2]）。\r\n\r\n1. `auth.php`\r\n\r\n```\r\n\'failed\' => \'用户名、密码错误或者邮箱未验证。\',\r\n\'throttle\' => \'登录操作过于频繁。请于 :seconds 秒钟后再试。\',\r\n```\r\n\r\n2. `validation.php`\r\n\r\n```\r\n\'custom\' => [\r\n    \'email\' => [\r\n        \'unique\' => \'邮箱已注册\',\r\n    ],\r\n    \'password\' => [\r\n        \'confirmed\' => \'两次密码输入不一致\',\r\n        \'min\' => \'密码至少 :min 位\',\r\n    ],\r\n],\r\n```\r\n\r\n[1]: https://github.com/laracasts/flash\r\n[2]: https://github.com/caouecs/Laravel-lang/tree/master/src/zh-CN','2017-06-15 00:21:27','2017-06-15 18:17:54','development-on-zhihu-login-localization'),(22,3,3,'使用 Markdown 写表格','> 参考链接：https://help.github.com/articles/organizing-information-with-tables/\r\n\r\n## 简单表格\r\n\r\n```\r\n| First Header  | Second Header |\r\n| ------------- | ------------- |\r\n| Content Cell  | Content Cell  |\r\n| Content Cell  | Content Cell  |\r\n```\r\n\r\n看起来是这样的\r\n\r\n| First Header  | Second Header |\r\n| ------------- | ------------- |\r\n| Content Cell  | Content Cell  |\r\n| Content Cell  | Content Cell  |\r\n\r\n\r\n列与列之间不需要强制对齐，比如：\r\n\r\n```\r\n| Command | Description |\r\n| --- | --- |\r\n| git status | List all new or modified files |\r\n| git diff | Show file differences that haven\'t been staged |\r\n```\r\n\r\n表现出来的效果依然很棒！\r\n\r\n| Command | Description |\r\n| --- | --- |\r\n| git status | List all new or modified files |\r\n| git diff | Show file differences that haven\'t been staged |\r\n\r\n## 带文字效果的表格\r\n\r\n### 文字效果\r\n\r\n```\r\n| Command | Description |\r\n| --- | --- |\r\n| `git status` | List all *new or modified* files |\r\n| `git diff` | Show file differences that **haven\'t been** staged |\r\n```\r\n\r\n显示为这样↓\r\n\r\n| Command | Description |\r\n| --- | --- |\r\n| `git status` | List all *new or modified* files |\r\n| `git diff` | Show file differences that **haven\'t been** staged |\r\n\r\n### 文字对齐\r\n\r\n```\r\n| Left-aligned | Center-aligned | Right-aligned |\r\n| :---         |     :---:      |          ---: |\r\n| git status   | git status     | git status    |\r\n| git diff     | git diff       | git diff      |\r\n```\r\n\r\n表现为\r\n\r\n| Left-aligned | Center-aligned | Right-aligned |\r\n| :---         |     :---:      |          ---: |\r\n| git status   | git status     | git status    |\r\n| git diff     | git diff       | git diff      |\r\n\r\n\r\n✍','2017-06-15 00:45:43','2017-06-15 00:45:58','use-the-markdown-written-form'),(23,3,3,'中午，在吃饭的路上','## 2017年9月\r\n\r\n杭州西湖\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/hangzhou.jpg)\r\n\r\n## 2017年8月\r\n\r\n在下班的路上\r\n\r\n![在下班的路上](http://www.baooab.com/wp/wp-content/uploads/2017/08/IMG_20170823_185155.jpg)\r\n\r\n## 2017年6月\r\n\r\n等待绿灯\r\n\r\n![中午，在吃饭的路上][1]\r\n\r\n## 2017年4月\r\n\r\n开心的亚松\r\n\r\n![亚松不让看][2]\r\n\r\n[1]: http://www.baooab.com/wp/wp-content/uploads/2017/08/683184-20170616122030400-959038647.jpg\r\n[2]: http://www.baooab.com/wp/wp-content/uploads/2017/08/683184-20170616122449306-1921193706.jpg','2017-06-15 20:21:44','2017-09-11 09:06:20','at-noon-in-the-way-of-eating'),(24,3,3,'开发知乎：重写找回密码功能','## 功能涉及到的路由\r\n\r\n下面是 Laravel 5.4 中找回密码功能用到的路由。\r\n\r\n| 方法  | URI | Name | Action | Middleware | \r\n| ------------- | ------------- | ------------- | ------------- | ------------- |\r\n| POST     | password/email   | password.email   | App\\Http\\Controllers\\Auth\\ForgotPasswordController@sendResetLinkEmail  | web,guest |\r\n| GET\\|HEAD | password/reset | password.request | App\\Http\\Controllers\\Auth\\ForgotPasswordController@showLinkRequestForm | web,guest |\r\n| POST     | password/reset  |                  | App\\Http\\Controllers\\Auth\\ResetPasswordController@reset | web,guest    |\r\n| GET\\|HEAD | password/reset/{token}            | password.reset   | App\\Http\\Controllers\\Auth\\ResetPasswordController@showResetForm | web,guest |\r\n\r\n发送重置密码邮箱的是 `password/email` 这个路由。\r\n\r\n## 发送邮箱的过程\r\n\r\n`password/email` 路由调用了 `ForgotPasswordController` 的 `sendResetLinkEmail` 方法，这个方法来自 `SendsPasswordResetEmails` trait。\r\n\r\n```\r\npublic function sendResetLinkEmail(Request $request)\r\n{\r\n    $this->validateEmail($request);\r\n\r\n    $response = $this->broker()->sendResetLink(\r\n        $request->only(\'email\')\r\n    );\r\n\r\n    return $response == Password::RESET_LINK_SENT\r\n                ? $this->sendResetLinkResponse($response)\r\n                : $this->sendResetLinkFailedResponse($request, $response);\r\n}\r\n```\r\n\r\n第一部分是*验证邮箱*，第二步是*发送邮件*，第三步是*给出响应结果*。**重点是第二步**——也就是代码 `$this->broker()->sendResetLink(...)`。\r\n\r\n## `sendResetLink`\r\n\r\n这个方法是 `Illuminate\\Auth\\Passwords\\PasswordBroker` 类实例的方法，这个类继承自 `Illuminate\\Contracts\\Auth\\PasswordBroker` 这个接口。\r\n\r\n这个方法的实现如下：\r\n\r\n```\r\npublic function sendResetLink(array $credentials)\r\n{\r\n    $user = $this->getUser($credentials);\r\n\r\n    if (is_null($user)) {\r\n        return static::INVALID_USER;\r\n    }\r\n\r\n    $user->sendPasswordResetNotification(\r\n        $this->tokens->create($user)\r\n    );\r\n\r\n    return static::RESET_LINK_SENT;\r\n}\r\n```\r\n\r\n只要看这一部分代码\r\n\r\n```\r\n$user->sendPasswordResetNotification(\r\n    $this->tokens->create($user)\r\n);\r\n```\r\n\r\n就知道本质上是调用 User Model 的 `sendPasswordResetNotification` 实现邮箱发送的！也就是说，**在 User Model 中覆盖 `sendPasswordResetNotification`  方法**，就能实现自定义邮件发送逻辑了！！\r\n\r\n注意：`sendPasswordResetNotification()` 方法继承自 `Notifiable` 这个 trait。\r\n\r\n## 覆盖方法\r\n\r\n在 User Model 中重写方法 `sendPasswordResetNotification`。\r\n\r\n```\r\npublic function sendPasswordResetNotification($token)\r\n{\r\n    $data = [\r\n        \'url\' => url(config(\'app.url\').route(\'password.reset\', $token, false)),\r\n        \'name\' => $this->name,\r\n    ];\r\n    $template = new SendCloudTemplate(\'zhihu_app_password_reset\', $data);\r\n\r\n    Mail::raw($template, function ($message) {\r\n        $message->from(\'admin@baooab.com\', \'乱炖社区\');\r\n        $message->to($this->email);\r\n    });\r\n}\r\n```\r\n\r\nOK了！','2017-06-15 20:36:06','2017-06-15 21:22:50','development-on-zhihu-rewrite-the-retrieve-password-function'),(25,3,3,'开发知乎：设计提问表、发布问题','## 设计提问表\r\n\r\n```\r\n$ php artisan make:model Model/Question -m\r\n```\r\n\r\n设计\r\n\r\n```\r\nSchema::create(\'questions\', function (Blueprint $table) {\r\n    $table->increments(\'id\');\r\n    $table->string(\'title\');\r\n    $table->text(\'body\');\r\n    $table->unsignedInteger(\'user_id\');\r\n    $table->unsignedInteger(\'comments_count\')->default(0);\r\n    $table->unsignedInteger(\'followers_count\')->default(1);\r\n    $table->unsignedInteger(\'answers_count\')->default(1);\r\n    $table->string(\'close_comment\', 8)->default(\'F\');\r\n    $table->string(\'is_hidden\', 8)->default(\'F\');\r\n    $table->timestamps();\r\n\r\n    $table->foreign(\'user_id\')\r\n        ->references(\'id\')->on(\'users\')\r\n        ->onDelete(\'cascade\');\r\n});\r\n```\r\n\r\n```\r\n$ php artisan migrate\r\n```\r\n\r\n表结构如下：\r\n\r\n![开发知乎之提问表设计](http://images2015.cnblogs.com/blog/683184/201706/683184-20170616135347603-1283304139.png)\r\n\r\n## 发布问题\r\n\r\n这里使用一个依赖包 [`overtrue/laravel-ueditor`](https://github.com/overtrue/laravel-ueditor)，先按照Wiki安装配置，再进行下面的操作。\r\n\r\n### 新建提问页面\r\n\r\n创建 `question/create.blade.php`：\r\n\r\n```\r\n@extends(\'layouts.app\')\r\n\r\n@section(\'content\')\r\n    @include(\'vendor.ueditor.assets\')\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div class=\"col-md-8 col-md-offset-2\">\r\n                <div class=\"panel panel-default\">\r\n                    <div class=\"panel-heading\">发布问题</div>\r\n                    <div class=\"panel-body\">\r\n                        <form action=\"{{ route(\'questions.store\') }}\" method=\"POST\">\r\n                            <div class=\"form-group\">\r\n                                <input type=\"text\" class=\"form-control\" name=\"title\" id=\"title\" placeholder=\"标题\">\r\n                            </div>\r\n                            <div class=\"form-group\">\r\n                                <script id=\"container\" name=\"body\" type=\"text/plain\"></script>\r\n                            </div>\r\n                            <div class=\"form-group\">\r\n                                <input type=\"submit\" class=\"btn btn-primary btn-block\" value=\"提交\">\r\n                            </div>\r\n                        </form>\r\n\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <script type=\"text/javascript\">\r\n        var ue = UE.getEditor(\'container\');\r\n        ue.ready(function() {\r\n            ue.execCommand(\'serverparam\', \'_token\', \'{{ csrf_token() }}\'); // 设置 CSRF token.\r\n        });\r\n    </script>\r\n@endsection\r\n```\r\n\r\n创建 `question/show.blade.php`：\r\n\r\n```\r\n@extends(\'layouts.app\')\r\n\r\n@section(\'content\')\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div class=\"col-md-8 col-md-offset-2\">\r\n                <div class=\"panel panel-default\">\r\n                    <div class=\"panel-heading\">{{ $question->title }}</div>\r\n\r\n                    <div class=\"panel-body\">\r\n                        {!! $question->body !!}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n@endsection\r\n```\r\n\r\n### 创建控制器\r\n\r\n```\r\n$ php artisan make:controller QuestionController -r\r\n```\r\n\r\n添加 `create`、`store` 和 `show` 方法。\r\n\r\n```\r\npublic function create()\r\n{\r\n    return view(\'question.create\');\r\n}\r\n\r\npublic function store(Request $request)\r\n{\r\n    $data = $request->only(\'title\', \'body\');\r\n    $data = array_merge($data, [\r\n        \'user_id\' => Auth::user()->id,\r\n    ]);\r\n\r\n    $question = Question::create($data);\r\n\r\n    return redirect()->route(\'questions.show\', [\'id\' => $question->id]);\r\n}\r\n\r\npublic function show($id)\r\n{\r\n    $question = Question::find($id);\r\n\r\n    return view(\'question.show\', compact(\'question\'));\r\n}\r\n```\r\n\r\n添加路由\r\n\r\n```\r\nRoute::resource(\'questions\', \'QuestionController\');\r\n```','2017-06-15 21:54:41','2017-06-15 23:34:15','development-on-zhihu-design-table-post-questions-to-ask-a-question'),(26,3,3,'开发一个问答社区——知乎——的系列课程','> 这是仿照**知乎**所做的一个问答社区项目。课程步骤如下：\r\n\r\n#### 一、[用户表设计、用户注册](http://www.baooab.com/discussions/development-on-zhihu-user-table-design-user-registration)\r\n\r\n#### 二、[登录、本地化](http://www.baooab.com/discussions/development-on-zhihu-login-localization)\r\n\r\n#### 三、[重写找回密码功能](http://www.baooab.com/discussions/development-on-zhihu-rewrite-the-retrieve-password-function)\r\n\r\n#### 四、[设计提问表、发布和查看问题](http://www.baooab.com/discussions/development-on-zhihu-design-table-post-questions-to-ask-a-question)\r\n\r\n#### 五、[验证问题表单字段](http://www.baooab.com/discussions/development-on-zhihu-validation-issues-form-fields)\r\n\r\n#### 六、[简化编辑器ueditor](http://www.baooab.com/discussions/development-on-zhihu-ueditor-simplified-editor)\r\n\r\n#### 七、[定义话题与问题的关系](http://www.baooab.com/discussions/development-on-zhihu-define-the-topic-and-relationship-problems)\r\n\r\n#### 八、[使用Selectize.js优化话题选择](http://www.baooab.com/discussions/development-on-zhihu-use-selectize-js-optimization-topic-choice)\r\n\r\n#### 九、[使用 Repository 模式](http://www.baooab.com/discussions/development-on-zhihu-using-the-repository-pattern)\r\n\r\n#### 十、[实现编辑问题](http://www.baooab.com/discussions/development-on-zhihu-editing-problems)\r\n\r\n#### 十一、[提问列表和删除问题功能的实现](http://www.baooab.com/discussions/development-on-zhihu-question-list-and-delete-the-realization-of-the-function-of-problem)\r\n\r\n#### 十二、[创建问题的答案](http://www.baooab.com/discussions/development-on-zhihu-create-the-answer-to-the-question)\r\n\r\n#### 十三、[实现提交答案](http://www.baooab.com/discussions/development-on-zhihu-submit-the-answer)\r\n\r\n#### 十四、[用户关注问题](http://www.baooab.com/discussions/development-on-zhihu-user-concerns)\r\n\r\n#### 十五、[使用 Vue.js 组件实现关注功能](http://www.baooab.com/discussions/development-on-zhihu-using-the-vue-js-component-implementation-focuses-on-function)\r\n\r\n#### 十六、[API token 认证](http://www.baooab.com/discussions/development-on-zhihu-api-token-authentication)\r\n\r\n（待续）','2017-06-16 00:39:46','2017-06-26 02:00:44','develop-a-question-and-answer-community-zhihu-a-series-of-courses'),(27,3,3,'Linux中使用SecureCRT上传、下载文件命令sz与rz用法实例','## 简介\r\n\r\n`sz` 和 `rz` 命令都是从 **服务器**的角度命名的。`s` 意为 send（发送），`r` 意为 received（接收）。\r\n\r\n对于客户端来说，就意味着： `sz` 是下载，`rz` 是上传。\r\n\r\n## 安装\r\n\r\n```\r\nyum install lrzsz -y\r\n```\r\n\r\n## 使用\r\n\r\n使用\r\n\r\n```\r\n#下载一个文件\r\nsz filename\r\n\r\n#下载多个文件\r\nsz filename1 filename2\r\n\r\n#下载dir目录下的所有文件，不包含dir下的文件夹\r\nsz dir/*\r\n```','2017-06-16 01:15:48','2017-06-16 01:33:33','used-in-linux-securecrt-upload-and-download-file-command-sz-and-rz-usage-examples'),(28,3,3,'MySQL 数据库备份和还原','## 备份\r\n\r\n备份使用 `mysqldump` 命令。\r\n\r\n1. 备份数据库 `salivaforum`：\r\n\r\n```\r\n# mysqldump -u root -p --databases salivaforum > salivaforum_170808.sql\r\n```\r\n\r\n2. 备份数据库 `salivaforum` 和 `test`：\r\n\r\n```\r\n# mysqldump -u root -p --databases salivaforum test > backup_170808.sql\r\n```\r\n\r\n3. 备份所有数据库：\r\n\r\n```\r\n# mysqldump -u username -p -all-databases > backup_all_170808.sql\r\n```\r\n\r\n4. 备份数据表 `discussions`\r\n\r\n```\r\n# mysqldump -uroot -p salivaforum discussions > salivaforum_discussions_170808.sql\r\n```\r\n\r\n## 还原\r\n\r\n还原使用 `mysql` 命令。\r\n\r\n```\r\n$ mysql -u root -p < backup.sql\r\n```','2017-06-16 01:26:35','2017-08-08 07:00:38','the-mysql-database-backup-and-restore'),(29,3,3,'使用 Carbon 显示人性化时间','比如一篇文章依据发表时间要这样显示出来：\r\n\r\n```\r\n**距离现在时间**      **显示格式**\r\n< 1小时                 xx分钟前\r\n1小时-24小时            xx小时前 \r\n1天-10天                xx天前\r\n>10天                   直接显示日期\r\n```\r\n\r\n在 Laravel 中，可以使用 Carbon 实现：\r\n\r\n首先：\r\n\r\n在你的`app/Providers/AppServiceProvider.php`中添` \\Carbon\\Carbon::setLocale(\'zh\');`这一行到`boot()`方法中（为了显示中文）。\r\n\r\n```\r\n public function boot()\r\n    {\r\n        \\Carbon\\Carbon::setLocale(\'zh\');\r\n    }\r\n```\r\n\r\n第二：\r\n\r\n在Article的 Model 中添加下面的方法：\r\n\r\n```\r\n  public function getCreatedAtAttribute($date)\r\n    {\r\n        if (Carbon::now() > Carbon::parse($date)->addDays(10)) {\r\n            return Carbon::parse($date);\r\n        }\r\n\r\n        return Carbon::parse($date)->diffForHumans();\r\n    }\r\n```\r\n\r\n这里注意到使用到了 Laravel 的 `getXXXAttribute()` 的特性，如果你是其他的字段，比如`published_at`，方法应该写成 `getPublishedAtAttribute($date)`，别忘了在 Article 头部`use Carbon\\Carbon;`。\r\n\r\n最后：\r\n\r\n直接显示你的日期就好:\r\n\r\n```\r\n$article = \\App\\Article::find(7);\r\n  \r\n{{ $article->created_at }}; // 视图中直接显示\r\n```\r\n\r\n（完）','2017-06-16 01:39:37','2017-06-16 05:51:56','using-carbon-display-human-time'),(42,3,3,'我眼中的中国好搜索引擎','作为一名开发者，因为不能使用google搜索，所以就现在中国的好搜索引擎，首屈一指肯定是微软[**必应搜索**](https://cn.bing.com)。\r\n\r\n次之百度、再次360搜索、最次搜狗。\r\n\r\n百度商业化气息太浓了，你每时每刻都能看到置顶的广告；搜狗最不尊重开发者，我提交了N次网站地址，都没有被收录；360这个土鳖就不提了，能用，如果不耍无赖，现在使用的人可能会更多一些。','2017-06-16 06:25:26','2017-06-16 06:25:26','me-in-the-eyes-of-the-chinese-search-engine'),(30,3,3,'启用网页右键的脚本','```\r\nfunction noMenuOne() {  \r\n    return true; \r\n} \r\ndocument.oncontextmenu = noMenuOne; \r\n```\r\n\r\n（完）','2017-06-16 01:40:07','2017-06-16 01:40:07','to-enable-web-page-right-script'),(31,3,3,'书签推荐 SQL','**1. 书签表格**\r\n\r\n```sql\r\nCREATE TABLE `bookmark` (\r\n  `username` varchar(16) NOT NULL,\r\n  `bm_URL` varchar(255) NOT NULL,\r\n  KEY `username` (`username`),\r\n  KEY `bm_URL` (`bm_URL`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\r\n```\r\n\r\n`username` 是用户名， `bm_URL` 是用户收藏的书签地址，用户和书签地址是一对多的关系。\r\n\r\n**2. 推荐书签**\r\n\r\n思考：用户“zhangb”与数据库中的其他用户收藏有一样的书签地址，那么在某种程度上，他们可能会有一样的喜好，可以把这些用户的其它书签（不包括用户“zhangb”已有的）推荐给“zhangb”。\r\n\r\n按照这种思路，来编写 SQL 语句。\r\n\r\n1). 找到与用户“zhangb”有相同收藏书签的用户集合。\r\n\r\n```sql\r\nselect distinct(b2.username) from bookmark b1, bookmark b2\r\nwhere b1.username=\'zhangb\' \r\nand b1.username != b2.username and b1.bm_URL = b2.bm_URL;\r\n```\r\n\r\n2). 从查询到的用户集合里，查询他们所有收藏的书签。\r\n\r\n```sql\r\nselect bm_URL from bookmark where username in \r\n(select distinct(b2.username) from bookmark b1, bookmark b2\r\nwhere b1.username=\'zhangb\' \r\nand b1.username != b2.username and b1.bm_URL = b2.bm_URL);\r\n```\r\n3). 所有的书签地址不能有用户“zhangb”有过的。\r\n\r\n```sql\r\nselect bm_URL from bookmark where username in \r\n(select distinct(b2.username) from bookmark b1, bookmark b2\r\nwhere b1.username=\'zhangb\' \r\nand b1.username != b2.username and b1.bm_URL = b2.bm_URL)\r\nand bm_URL not in (select bm_URL from bookmark where username=\'zhangb\');\r\n```\r\n\r\n4). 不同用户之间可能会收藏一样的书签地址，要去掉。\r\n\r\n```sql\r\nselect bm_URL from bookmark where username in \r\n(select distinct(b2.username) from bookmark b1, bookmark b2\r\nwhere b1.username=\'zhangb\' \r\nand b1.username != b2.username and b1.bm_URL = b2.bm_URL)\r\nand bm_URL not in (select bm_URL from bookmark where username=\'zhangb\')\r\ngroup by bm_url\r\nhaving count(bm_url)> 1;\r\n```\r\n\r\n这里使用了 `having` 子句进一步做限制——显示的书签地址**至少**被两个用户收藏。\r\n\r\n（完）','2017-06-16 01:40:35','2017-06-16 01:40:35','bookmarks-recommend-sql'),(32,3,3,'王小波：我为什么要写作','有人问一位登山家为什么要去登山——谁都知道登山这件事既危险，又没什么实际的好处，他回答道：“因为那座山峰在那里。”我喜欢这个答案，因为里面包含着幽默感——明明是自己想要登山，偏说是山在那里使他心里痒痒。除此之外，我还喜欢这位登山家干的事，没来由地往悬崖上爬。它会导致肌肉疼痛，还要冒摔出脑子的危险，所以一般人尽量避免爬山。用热力学的角度来看，这是个反熵的现象，所发趋害避利肯定反熵。\r\n\r\n现在把登山和写作相提并论，势必要招致反对。这是因为最近十年来中国有过小说热、诗歌热、文化热，无论哪一种热都会导致大量的人投身写作，别人常把我看成此类人士中的一个，并且告诫我说，现在都是什么年月了，你还写小说（言下之意是眼下是经商热，我该下海去经商了）？但是我的情形不一样。前三种热发生时，我正在美国念书，丝毫没有受到感染。我们家的家训是不准孩子学文科，一律去学理工。因为这些缘故，立志写作在我身上是个不折不扣的反熵过程。我到现在也弄不明白自己为什么要干这件事，除了它是个反熵过程这一点。\r\n\r\n有关我立志写作是个反熵过程，还有进一步解释的必要。写作是个笼统的字眼，还要看写什么东西。写畅销小说、爱情小诗等等热门东西，应该列入熵增过程之列。我写的东西一点不热门，不但挣不了钱，有时还要倒贴一些。严肃作家的“严肃”二字，就该做如此理解。据我所知，这世界上有名的严肃作家，大多是凑合也算不上。这样说明了以后，大家都能明白我确实在一个反熵过程中。\r\n\r\n我父亲不让我们学文科，理由显而易见。在我们成长的时代里，老舍跳了太平湖，胡风关了临狱，王实味被枪毙了。以前还有金圣叹砍脑壳等等实例。当然，他老人家也是屋内饮酒，门外劝水的人，自己也是个文科的教授，但是他坦白地承认自己择术不正，不足为训。我们兄弟姐妹五个就范此全学了理工科，只我哥哥例外。考虑到我父母脾气暴躁、吼声如雷，你得说这种选择是个熵增过程。而我哥哥那个例外是这么发生的：七八年考大学时，我哥哥是北京木城漳煤矿最强壮的青年矿工，吼起来比我爸爸音量还要大。无论是动手揍他，还是朝他吼叫，我爸爸自己都挺不好意思，所以就任凭他去学了哲学：在逻辑学界的泰斗沈有鼎先生的门下当了研究生。考虑到符号逻辑是个极专门的学科（这是从外行人看不懂得逻辑文章来说），它和理工科差不太多的。从以上的叙述，你可以弄明白我父亲的意思。他希望我们每个人都学一种外行人弄不懂而又是有功世道的专业，平平安安地度过一生。我父亲一生坎坷，他又最爱我们，这样的安排在他看来最自然不过。\r\n\r\n我自己的情形是这样的：从小到大，身体不算强壮，吼起来音量也不够大，所以一直本分为人。尽管如此，我身上总有一股要写小说的危险情绪。插队的时候，我遇上一个很坏的家伙（他还是我们的领导，属于在我国这个社会里少数坏干部之列），我就编了一个故事，描写他从尾骨开始一寸寸变成了一条驴，并且把它写出来，以泄心头之愤。后来读了一些书，发现卡夫卡也写了个类似的故事，搞得我很不好意思。还有一个故事，女主人公长了蝙蝠的翅膀，并且头发是绿色的，生活在水下。这些二十岁前的作品我都烧掉了。在此一提是要说明这种危险倾向的由来。后来我一直抑制着这种倾向，念完了本科，到美国去留学。我哥哥也念完了硕士，也到美国去留学。我在那边又开始写小说，这种危险的倾向再也不能抑制了。\r\n\r\n在美国时，我父亲去世了。回想他让我们读理科的事，觉得和美国发生的事不是一个逻辑。这让我想起了前苏联元帅图哈切夫斯基对大音乐家萧斯塔科奇说的话来：“我小的时候，很有音乐天才。只可惜我父亲没钱给我买把小提琴！假如有了那把小提琴，我现在就坐在你的乐池里。”这段话乍看不明其意，需要我提示一句：这次对话发生在苏联的三十年代，说完了没多久，图元帅就一命呜呼。那年头专毙元帅将军，不大毙小提琴手。文化革命里跳楼上吊的却是文人居多。我父亲在世时，一心一意地要给我们每人都弄把小提琴。这把小提琴就是理工农医任一门，只有文科不在其内，这和美国发生的事不一样，但是结论还是同一个——我该去干点别的，不该写小说。\r\n\r\n有关美国的一切，可以用一句话来描述：“American’s business is business.”这句话的意思就是说，那个国家永远是在经商热中，而且永远是一千度的白热。所以你要是看了前文之后以为那里有某种气氛会有助于人立志写作就错了。连我哥哥到了那里都后悔了，觉得不该学逻辑，应当学商科或者计算机。虽然他依旧未证出的逻辑定理，但是看到有钱人豪华的住房，也免不了唠叨几句他对妻儿的责任。\r\n\r\n在美国有很强大的力是促使人去挣钱，比方说洋房，有些只有一片小草坪，有的有几百亩草坪，有的有几千亩草坪，所以仅就住房一项，就能产生无穷无尽的挣钱的动力。再比方说汽车，有无穷的档次和价格。你要是真有钱，可以考虑把肯尼迪遇刺时坐的汽车买来坐。还有人买下了前苏联的战斗机，驾着飞上天。在那个社会里，没有人受得了自己的孩子对同伴说：我爸爸穷。我要是有孩子，现在也准在那里挣钱。而写书在那里也不是个挣钱的行当，不信你到美国书店里看看，各种各样的书涨了架子，和超级市场里陈列的卫生纸一样多——假如有人出售苦心积虑一页页写出的卫生纸，肯定不是好行当。除此之外，还有好多人的书没有上架，窝在他自己的家里。我没有孩子，也不准备要。作为中国人，我是个极少见的现象。但是人有一张脸，树有一张皮，别人都有钱挣，自己却在干可疑的勾当，脸面上也过不去。\r\n\r\n在美国时，有一次和一位华人教授聊天，他说他女儿很有出息，放着哈佛大学人类学系奖学金不要，自费去念一般的大学的law school，如此反潮流，真不愧是书香门第。其实这是舍小利而趋大利，受小害而避大害。不信你去问问律师挣多少钱，人类学家又挣多少钱。和我聊天的这位教授是个大学问家，特立独行之辈。一谈到了儿女，好像也不大特立独行了。\r\n\r\n说完了美国、苏联，就该谈谈自己。到现在为止，我写了八年小说，也出了几本书，但是大家没怎么看到。除此之外，我还常收到谩骂性的退稿信，这时我总善意地想：写信的人准是领导那里挨了骂，找我撒气。\r\n\r\n提起王小波，大家准会想到宋朝的四川拉杆子的那一位，想不起我身上。我还在反熵过程中。顺便说一句，人类的存在，文明的发展就是个反熵过程，但是这是说人类。具体说到自己，我的行为依旧无法解释。\r\n\r\n再顺便说一句，处于反熵过程中，绝不只是我一个人。在美国，我遇上过支起摊来卖托洛斯基、格瓦拉、毛主席等人的书的家伙，我要和他说话，他先问我怕不怕联帮调查局——别的例子还很多。\r\n\r\n在这些人身上，你就看不到水往低处流、苹果掉下地，狼把兔子吃掉的宏大的过程，看到的现象，相当于水往山上流，苹果飞上天，兔子吃掉狼。我还可以说，光有熵增现象不成。举例言之，大家都顺着一个自然的方向往下溜，最后准会在个低洼的地方汇齐，挤在一起像粪缸里的蛆。但是这也不能解释我的行为。我的行为是不能解释的，假如你把熵增现象看成金科玉律的话。\r\n\r\n当然，如果硬要我用一句话直截了当地回答这个问题，那就是：我相信我自己有文学才能，我应该做这件事。但是这句话正如一个嫌疑犯说自己没杀人一样不可信。所以信不信由你罢。\r\n\r\n（完）','2017-06-16 01:40:56','2017-11-08 06:44:21','wang-why-should-i-write'),(33,3,3,'「一个」上帝别拯救女王 - 张晓晗','*作者／张晓晗*\r\n\r\n** 0**\r\n\r\n自从写小说写剧本被大家渐渐知道后，隔三差五有一腔热血的文学青年发来私信，问我到底要怎么写作，怎么投稿，怎么考上戏，之后抱怨自己如何没有平台，怀才不遇之类的。\r\n这么多私信里，我印象最深的是，有个姑娘写了很长的一封，最后说，“我多希望我是你，受到了幸运之神的垂青。”\r\n\r\n我看了一会儿，没有回复她。但是今天我想说说，我是怎么开始走上敲键盘为生的不归路的。\r\n\r\n\r\n** 1**\r\n\r\n小时候我很喜欢看书，当然，我的爱好很多，比如和稀泥，去聊天室聊天，开卡丁车，和小男生一起做作业，看书只是其中一项。我不知道自己是怎么开始喜欢看书的，可能是我小时候住在爷爷家，我叔叔那段时间青春叛逆期末梢，泡妞不顺，一气之下与天斗与地斗与我爷爷奶奶斗其乐无穷。每天把自己反锁在房间里不吃不喝音响开得巨大声，看各种闲杂书籍，作诗，还练气功。我爷爷奶奶不太敢和他交流，就派我去询问他吃喝拉撒的事，我一进去他就瞪我一眼，我胆子巨小，被瞪之后屁都不敢放，不敢说话也不敢出去，只得坐下跟着他开始看书，或者配合他练气功。他让我站着，之后开始发功，发得满头大汗，问我感觉没感觉到热。我说热，好热啊。\r\n\r\n在我的误导之下，他一度以为自己已经走上了气功大师的巅峰，天天去朋友家组团发功，当初全国气功热，一个大院里起码得有十来个气功大师。就是那时候，我得到了阅读的启蒙，虽然都是一堆气功杂志，漫画期刊，武打小说，我一般都看带画的，全是字的也看不懂。\r\n\r\n后来我搬去和爸妈住，已经养成了阅读的习惯，每个下午会骑着自己四轮的好孩子童车去附近的儿童书店看书，一坐就是一下午，再趁我爸妈回家之前，伴着夕阳骑车回去。一次我看到一本好喜欢的童话书，看得忘了时间，我妈找到我的时候已经九点多了，当时我姥姥姥爷正好住在我家。我一进家门，姥姥就倒地痛哭，姥爷手里还攥着血压仪的那个球。那是我童年记忆里，最深刻的一次批斗，姥姥姥爷一晚上的愤怒，悲情，和对我妈放养式教育的不满集中爆发，基本涵盖了一套五十集央八电视剧的苦情力度，我妈烦躁不堪之下，打了我一耳光。我哭到两点才睡觉。\r\n\r\n本来我以为这辈子大概再也不会看书了，没想到第二天峰回路转，一睁眼我妈就诚恳地道歉，并且买下那本我好爱看的童话书。那是我拥有的第一本自己的书，一本硬皮带彩图插画的《伊索寓言》。我妈说，我反省过了，是我不对，你看我爸妈对我的方式就太极端，看书是好事，人有了见识才对有些事不那么偏激，不像你姥姥姥爷。我不知道为什么，拿着那本书，鬼使神差跟我妈说了一句，我要当写书的人。可能是怕她打我，才慌乱中表达了自己的热诚。她点点头，跟我说，你一定会成为作家的。\r\n\r\n那时我七岁，似懂非懂地明白，原来，想要坚持你喜欢的事，得到你喜欢的人，都要经历一些必不可少的痛苦。这是难免的，再幸运的人，也不例外。\r\n\r\n上学后，我从来不是一个品学兼优的学生，没因为看书造出过多优秀的句子。第一次获得高分作文，是老师让大家写一只小动物，允许同学第二天带宠物来学校。我就趁机和我妈要一只小猫，说是老师规定的。于是，妈妈就在早上五点多起床带我去英雄山市场买了一只黄色花纹的小猫，之后带去上课。\r\n\r\n那是我第一次成为全班的焦点。我有一只漂亮的黄色花纹小猫。\r\n\r\n都说猫有九条命，但我养了十天，猫死了。我奶奶趁我不注意把它埋了，之后骗我说它跑了。\r\n\r\n我问，它会跑去哪呢。奶奶说，跑去山里找它的小伙伴。我又问，它会迷路吗？奶奶说，不会的，有小伙伴来接它。我沉默了一会儿，问出最后一个问题，它会比在我们家过得快乐吗。她说，会的，就像你和小伙伴在一起玩很开心，和大人一起就很没意思。我点点头，从床上爬下去走到书桌边。\r\n\r\n一坐上椅子我就哭了。我还没来得及给它起名字，它就死了。奶奶站在香椿树下，一铲子一铲子埋小猫的时候，我爬在窗边的暖气片上偷看。我什么都知道，可还是在田字格里写下，我曾经有一只漂亮的小猫，之后它跑去山里找小伙伴了，我希望它比在我身边的时候快乐。\r\n\r\n《记一只小动物》是我第一篇被老师当着全班朗读的作文。我失去了它，并且开始不能接受所有可爱的小动物，但是我找到了写作文的秘密。\r\n\r\n**2**\r\n\r\n中学起，我因为写作文得到了语文老师的偏爱。也得到了一些小男生的偏爱，特别是成绩好的小男生，他们觉得，张晓晗真是个好酷的女生，怎么这些也敢写。其实，我只是比较懂，如何表达心里的事，痛苦也好，快乐也好，我很敏锐地去记忆那些感受，再想办法把它们表达出来。他们呢，就比较机械木讷，只懂得多看几本作文书，努力去考一百分。\r\n\r\n我们班的学习委员喜欢我，每次收到作业都会挑出各科最优秀同学的作业放在我桌上，以便于迟到的我一坐下来就能奋笔疾书抄作业，后来我得寸进尺，直接让他帮我做作业。他不肯，说这些你总是要会的。我当时还挺感动的，觉得他是真心为我好。\r\n\r\n眼看我要被他打动了，恰逢圣诞节。他把我叫到一边，送了我一份礼物，我满怀期待地拆，拆了半天，拆出一本《物理课课练》，我的惊喜还僵持在嘴角，眼神已经充满了疑惑。他说，你物理最差，多做些题对你有好处。\r\n\r\n我有点不开心，反驳他，物理差怎么了？我的作文老师会拿去全年级读。\r\n\r\n他带着好学生的优越感，小声哼了一句，写作文好又怎么了？还不是差生……\r\n\r\n还没等他说完，我已经把课课练呼到他脸上了。\r\n\r\n因为没有接受学习委员的恩泽，我再也没有作业抄了，成了不折不扣的差生，常常被老师叫去办公室骂，开家长会的时候老师就找到我爸，跟他说，你们家都是博士，怎么女儿这么不争气。\r\n\r\n一般的爸爸肯定回家揍死我了，但我爸山东大老爷们屌惯了，常年在医院作为医生代表去揍医闹。听完老师叨叨，我爸就说，老师，我女儿以后你们就不用管了，不做作业就不做，不听课就不听，我还没说什么呢，用得着你跟我说我女儿差吗！是博士还是文盲都是我们家的事，和你什么关系！说完就华丽转身，蹬着小破自行车回家了。\r\n\r\n虽然回到家，我爸也给我买课课练，但他跟我说的是，你多少要给老师一点面子，要么他老找你不自在，影响你的心情，容易抑郁，而且我们老张家有考试天赋，一到考试就超常发挥，不指望你成为多牛逼的人，考考试还是可以的吧。\r\n\r\n被我爸洗脑之后，我也真信了，果不其然，中考是我初中考得最好的一次，高考是我高中考得最好的一次。\r\n\r\n**3**\r\n\r\n我们周围的“拯救者”太多了。\r\n\r\n从学习委员开始，到之后我遇到好多人，常常打着“我为你好”的名号，让你做自己不喜欢或者不擅长的事。可是当事人，真的能就此牛逼吗？我觉得不见得，施与者又是真的爱你吗？我也觉得不见得。也是到了好久以后，我才渐渐总结出来，爱就少哔哔两句，盲目地支持，信任，陪你堕落。\r\n\r\n我考上戏戏文的时候也是，我们全家那么多人，上下数三代，没一个文艺工作者。我爸第一次听说戏文，他点点头，说好，京剧是国粹。后来才知道戏文不是去唱戏的。\r\n\r\n选择考艺术类是我自己填的志愿，我跟他们说，到现在好像就写东西看电影这两件事我能坚持下去，其他也没兴趣，就学编剧吧。我爸妈知道后鞍前马后地全力支持。我爸说，反正咱们家也没什么门路，你考上说明你能吃这口饭，考不上拉倒，去学个烹饪什么的，我和你妈上班忙，你回家做饭我们就不用找钟点工了。\r\n\r\n后来还真的被我考上了，所以我到现在也没有烹饪技能。\r\n\r\n直到我大学二年级，我们家好多亲戚还以为我学的是新闻。\r\n\r\n**4**\r\n\r\n大学老师在第一堂课上说，你们都是以后要为中国文艺事业添砖加瓦的人。老师说完，我们就马不停蹄乱搞男女关系去了。\r\n\r\n现在想起来，大学的前两年，不能说最快乐，但算得上最为潇洒的两年。我和我著名的二世祖男朋友谈恋爱，每天就奔波在饭局牌局和夜店之间。那两年我就是一个人肉的上海大众点评，最酷炫的地方一定第一时间去，微笑，自拍，发到相册里。\r\n\r\n朋友问过我，觉得当小骚的日子傻逼吗？我觉得一点也不傻逼，我全心全意爱一个人，有什么好傻逼的。我说过，青春怎么过都是浪费的，至少我把青春浪费在了一切我觉得值得浪费的地方。\r\n\r\n但是和他交往的过程中，我始终没忘记老师交付在我们肩上的重任，我很认真地跟他说，以后我过门了你要让你爸给我投资拍电影哦。他说呵呵，你过门之后还用拍电影吗？拍电影不就是为了钱，你想要的，我都能给你。\r\n\r\n当时我觉得他说得不对，可也无力反驳，难道说我不要钱，是为了理想吗？正站在柜台边看着琳琅满目的皮包，眼珠都快掉下来的我，好像也没那么高尚。\r\n\r\n我大二下学期开始接电视剧，那是我第一次正儿八经写剧本，发现之前学校里学的毫无用武之地，也可能是我光顾着搞男女关系，没好好学的缘故。是跟着公司我才知道什么是真正的写剧本，起得比鸡早，睡得比鸡晚，每天来公司开会，之后回家写，再开会再改，制片、导演、老板都有提不完的意见，仿佛这件事是没有尽头的。也是那一年，我知道原来这么多人睡在麦当劳里的，我看着流浪的人在长椅上打鼾，翻身掉下来再爬上去睡，之后默默合上电脑去公司开会。\r\n\r\n同时间，我们班也有些女孩出去写剧本，后来都决定不当编剧了，考研也好，找机关单位当个闲差也好，都比这条熬死自己的不归路好。现在毕业了，我们班三十六个人最后选择当编剧的大概一只手掌就能数清。\r\n\r\n二世祖对我工作的意见很大，他觉得我这么卖命就是不信任他可以给我一切，然后成为安心在他家洗盘子的灰姑娘。我拼命解释了半天。发现自己心里想的其实就是，我不甘心当一个灰姑娘。我坚持到现在，不管算不算理想，自己现在做的事是不是想做的，我都不能心甘情愿地这样放下，专心去做一个灰姑娘。\r\n\r\n我不要别人给我的水晶鞋，我要自己上马举枪，抢夺城池。\r\n\r\n之后我和他的圈子交集越来越少，误会和不信任越来越多，直到感情消磨干净。他离开我的时候，我在心里就埋葬了一次小猫。\r\n\r\n我希望在对方心里死一次，我们都能各自快乐。\r\n\r\n后来他找了一个愿意在他家洗盘子看电视剧的姑娘。我漫不经心笑着说，哦，那明年她在电视里估计能看到我写的电视剧吧。\r\n\r\n那天我还陷在公司无限会的怪圈中，出了电梯门我就要去开会，被老板骂写的什么一泡狗屎。但我还是这么跟他说了，留一个耀武扬威的背影，让我自己觉得，这么选择，没有做错。\r\n\r\n**5**\r\n\r\n在公司写剧本的日子我几次感觉自己要抑郁症了，压力特别大，得不到认可，起床之后坐在床上哭一会儿再去上班。之前在别的文章里我也写过自己怎么受剥削的。我感觉痛苦，却从不觉得委屈。如果没有之前老板的苛刻，我不会知道什么是专业，可能直到现在都只会是一个自视甚高的文艺青年。\r\n\r\n后来也有好多师弟妹问我，怎么和老板谈价钱，要多少价钱才合理，我说既然是第一部电视剧，贴钱都合理。他们一定觉得我特别道貌岸然，因为我以前也是这么评价跟我说这话的老板的。不过很快你就会明白，这个年纪，你一无所有，除了年轻，你得牺牲你的青春去换更多筹码，更多你可以坐在这个桌子上继续看牌的筹码。只要你人还坐在桌边，总会等来一副好牌的。\r\n\r\n那段时间我临近毕业，特别迷茫，每天都吆喝着不干了，但是第二天还是会出现在公司，抱怨再多，我心里也清楚，反正傍大款的路也断了，现在的一切都是自己选的，只有坚持下去，更加努力，才会有更多人能看到我，总会有个人知道我是颗发光的大金子。\r\n\r\n果然，我等到了神秘总。他在《女王乔安》第二篇的时候买下了影视版权，拎着现金来找我。从那以后，一切都变得不一样了，我有了主动权，写自己的小说，自己的剧本，《女王乔安》出版了，我越来越相信自己的选择没有错，这些都发生在2013年，这一年我大学毕业。\r\n\r\n写剧本的这一年也遇到诸多坎坷，神秘总从来没说过，但是我知道，他一开始也是抱着看运气的心态买下我的版权，让我写剧本。因为他盲目的信任，我更要坚持把剧本写完，我做人没有什么原则，可是底线是，在所有人不知道你行还是不行的时候，绝对不能辜负那个盲目信任你的人。\r\n\r\n写这篇稿子之前，我刚刚交上剧本的大结局。他说，你最厉害了。\r\n\r\n我看着短信哭了两个小时。\r\n\r\n只有经历过的人，才会明白。\r\n\r\n**6**\r\n\r\n我终于可以回答可爱姑娘的问题。有可能你看到的只是我有理解我支持我的家人，遇到我的编辑，遇到神秘总，你只看到了我拿过一手好牌，但你有没有看到，我失去的人生，我从七岁到明年二十三岁，整整坚持了十八年，一颗受精卵也长成了大人的过程。\r\n\r\n我像是一个逆着人群走的傲娇小妞，中间不断有人试图把我拉回正轨，拉回大家都觉得对的方向，我却始终不从。因为我知道，早晚有一天，我会站上那个他们都不曾敢尝试挑战过的山，然后对着那些曾经好心劝我的人说一句：\r\n\r\n你是谁啊。\r\n\r\n所以，在感谢所有人之前，我先感谢自己，如果不是不被拯救的张小妞，也不会有今天的风景。\r\n\r\n**7**\r\n\r\n说了这么多，好像都没有讲到书里的内容。可是好像该讲的都讲了。这就是送给偏执姑娘们的一本书。我们常常被质问：“你如此这番为哪般？”也总是被贴上物质、浮夸、刻薄、不知好歹的标签。这都不是我理解的女王，我理解的女王比所有在嘲笑的人都勇敢，总有一天，她在生活中摸爬滚打，变得攻无不克战无不胜。可能有人说，这样的女孩百年孤独。可是她们通过努力厮杀后得到的自由，你又怎么会懂？\r\n\r\n我记得，离开二世祖的时候，他问我，你到底要的是什么。\r\n\r\n我说我要自由。\r\n\r\n他问你们文艺青年就知道说这些虚头巴脑的，自由就是个屁。\r\n\r\n我说自由就是离开你。\r\n\r\n今天我才想明白，我想要的自由不过是碗筷用喜欢的颜色，窗帘挑选喜欢的款式，可以肆意妄为躺在床上吃零食看书掉一床的渣也没人指责，不用看人眼色在冬天把空调全都打开，蚊子养得老当益壮。自由就是这么肤浅。\r\n\r\n现在，我都做到了。\r\n\r\n（完）','2017-06-16 01:41:25','2017-11-08 08:09:16','god-save-the-queen'),(34,3,3,'在MySQL中使用SQL语句创建数据库和表格的最佳实践','**1. 查看字符集**\r\n\r\n查看当前 MySQL 系统环境中的字符集设置：\r\n\r\n```sql\r\nSHOW Variables like \'character_set_%\';\r\n```\r\n```\r\nmysql> SHOW Variables like \'character_set_%\';\r\n+--------------------------+-----------------------------------------------+\r\n| Variable_name            | Value                                         |\r\n+--------------------------+-----------------------------------------------+\r\n| character_set_client     | gbk                                           |\r\n| character_set_connection | gbk                                           |\r\n| character_set_database   | latin1                                        |\r\n| character_set_filesystem | binary                                        |\r\n| character_set_results    | gbk                                           |\r\n| character_set_server     | latin1                                        |\r\n| character_set_system     | utf8                                          |\r\n| character_sets_dir       | E:\\wamp\\bin\\mysql\\mysql5.7.14\\share\\charsets\\ |\r\n+--------------------------+-----------------------------------------------+\r\n8 rows in set, 1 warning (0.00 sec)\r\n```\r\n\r\n`character_set_database` 值为 `latin1`，数据库创建时默认使用的字符集为 `latin1`。\r\n\r\n**2. 默认校对（Collation）**\r\n\r\n```sql\r\nSHOW Variables like \'collation%\';\r\n```\r\n```\r\n+----------------------+-------------------+\r\n| Variable_name        | Value             |\r\n+----------------------+-------------------+\r\n| collation_connection | gbk_chinese_ci    |\r\n| collation_database   | latin1_swedish_ci |\r\n| collation_server     | latin1_swedish_ci |\r\n+----------------------+-------------------+\r\n3 rows in set, 1 warning (0.00 sec)\r\n```\r\n\r\n`collation_connection` 值为 `latin1_swedish_ci` 表示数据库使用的字符校对为 `latin1_swedish_ci`，这是 `latin1` 字符集的默认校对方式。\r\n\r\n查看数据库支持的所有字符集和对应默认的校对方式，则可以使用 ` SHOW CHARACTER SET;`。\r\n\r\n**3. 最佳实践**\r\n\r\n创建数据库时，尽量显式指出使用的字符集，而不是依赖于 MySQL 的默认设置。\r\n\r\n```sql\r\nCREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\r\n```\r\n\r\n创建表格时，显式指出使用的引擎为 `InnoDB`。\r\n\r\n```sql\r\nCREATE TABLE `users` (\r\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(255)  NOT NULL,\r\n  `email` varchar(255)  NOT NULL,\r\n  `password` varchar(255)  NOT NULL,\r\n  `remember_token` varchar(100) DEFAULT NULL,\r\n  `created_at` timestamp NULL DEFAULT NULL,\r\n  `updated_at` timestamp NULL DEFAULT NULL,\r\n  `country_id` int(10) unsigned NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `users_email_unique` (`email`)\r\n) ENGINE=InnoDB;\r\n```\r\n\r\n（完）','2017-06-16 01:41:50','2017-06-16 05:48:39','in-mysql-to-use-sql-statements-to-create-the-database-with-the-form-of-best-practices'),(35,3,3,'字符编码 utf8mb4 和 utf8 的区别','从 MySQL 5.5 开始，支持 utf8mb4 字符编码，它与 utf8 编码的主要区别如下：\r\n\r\n1. utf8 编码占 1~3 个字节，utf8mb4 编码占 1~4 个字节。\r\n2. utf8mb4 兼容 utf8。\r\n3. utf8mb4 支持 emoji 表情，utf8 不支持。\r\n\r\n再说一遍，本站支持emoji表情?。','2017-06-16 01:42:16','2017-06-16 05:47:29','the-difference-between-a-character-encoding-utf8mb4-and-utf8'),(36,3,3,'将 MySQL 创建表格时的默认存储引擎改为 InnoDB','**1.  查看数据库引擎**\r\n\r\n查看当前数据库版本支持的引擎 & 默认引擎：\r\n\r\n```sql\r\nSHOW engines;\r\n```\r\n\r\n**2. 更改默认引擎**\r\n\r\n修改 MySQL 配置文件 `my.ini`，更改 `default-storage-engine` 选项设置。比如：\r\n\r\n```\r\n; The default storage engine that will be used when create new tables\r\ndefault-storage-engine=MYISAM\r\n\r\n; 修改为\r\n\r\n; The default storage engine that will be used when create new tables\r\ndefault-storage-engine=INNODB\r\n```\r\n\r\n重启 MySQL 服务。\r\n\r\n（完）','2017-06-16 01:42:48','2017-06-16 05:45:22','to-replace-the-default-storage-engine-that-mysql-to-create-form-innodb'),(37,3,3,'「一个」那个年代，物资都很匮乏 - 杨怡倩','很多年以前有一群农村的孩子，他们捡到一个乒乓球，因为从来没见过这种东西，视若珍宝，坐了很长时间的火车，带上了半个月的干粮，要去北京把它献给毛主席。这个故事似乎有个同样情节的电影，但是我很小的时候外公给我讲过这样的事儿，真事儿。\r\n\r\n外婆年轻的时候，结婚，没有轿车迎亲，一切四个轮子的车都没有，外公载着她去了上海的外白渡桥，吃了糕点和面包就算是真正意义上你情我愿一拍即合的约会，回到乡下操办了简陋的婚礼，连结婚证都是供销社买了底板手抄上去的。\r\n\r\n然后经济条件好些了，女人们不再是灰，灰绿，灰黑色调了。我妈是22岁那年第一次买到化妆品的。好象是类似于大宝，美加净一类国货牌子出的口红。也是在供销商厦开了个一米左右的玻璃柜台，每天放货几十支，奔走相告，供不应求。妈妈那年在制衣厂，女工们一早就在传看彩芬阿姨的口红，很正的中国红，白色塑料壳，闻起来，有月季花混合着潮来花的味道。5点下班，女工们4点就换好了自己的鞋子，白色厂服的扣子也都解开了，手中攥着自行车的钥匙，生怕抢不过隔壁电机厂的女工们。\r\n\r\n我半岁，托上海某公司采购部的姨妈，捎了一桶荷兰乳牛奶粉，花了我妈半个月的工资。要兑很多水，或者米汤，我的领口系着塑料袋子，从嘴里漏出来了，外婆接着喝，因为奶粉太贵，生怕浪费了。一桶奶粉吃完了，要倒过来用勺子敲很久，直到一点渣渣都倒不出了才作罢。\r\n\r\n那些年代的人特别珍惜物件，因为物资匮乏。\r\n\r\n寒假回家，妈妈无意间打开我的化妆包，光是口红就有七个色号，我见她喜欢，网上商城一口气帮她买了一堆。我被骂了，她说口红这种东西，只要在唇上打几个点，轻轻地抿，用不了多少，一支能用好久。\r\n\r\n前几年我去上海参加一个写作比赛，外公要跟去，捎带了外婆，经过外白渡桥的时候，外婆不顾家人阻拦，执意把头探出窗外。湖面上风真大。外婆缩回头，眼眶和脸都绯如二八佳人。\r\n\r\n那个年代男人特别有担当，女人特别有情谊。\r\n\r\n我带她去了外白渡桥，她坐在车座上碰了我的腰，我怎么能不娶她？\r\n\r\n他带我去了外白渡桥，我吃了他买的玫瑰猪油糕，我怎么能不嫁他？\r\n\r\n那个年代没有网络，打电话要排队，每天能认识的人很少，一辈子能认识的人也很少。\r\n\r\n卖烧饼的王麻子媳妇儿牵了隔壁修车汉刘顺的手，王麻子自此带上绿帽子。媳妇儿是破鞋，刘顺是流氓，是奸夫，是贼。不像现在，随便上个微信，都是约炮短信。每天可以认识大把大把的人，我可以很好地预言，五年内，会有人以贩卖别人的信息而发家致富，五年后，会有人因为这个而破产，因为信息越来越不值钱。\r\n\r\n我们这代人会很频繁地换恋人，朋友，情人，炮友。因为物质生活变好了，一切唾手可得。\r\n\r\n外婆说，他们那个年代，因为贫穷，东西坏了都靠修。\r\n\r\n我们这个年代，东西坏了都直接换。\r\n\r\n我今年21，几番踌躇，谈了人生中第一个对象，我们似乎没有黏乎，彼此也没有很关心，他偶尔不理我，我也会冲他发脾气，但是我们从不吵架，我听他说，他听我说，解决问题，继续走下去。\r\n\r\n今天我说他不关心我，他说他改。他说我事儿叨叨不给他空间，我也妥协。好不容易走到一起，相互喜欢是有多难？\r\n\r\n我觉得没准我们能走得很远，似乎回到了那个年代，修修补补，鞋子大了改改继续穿着向前走。\r\n\r\n碰到了就是缘分，他们说，青春是在错误的时间遇见了对的人。其实在我们身上从来没有错误的时间，每时每刻都有它存在的道理和必然。\r\n\r\n你是我的什么？\r\n\r\n你不是我的优乐美，不是我的益达。\r\n\r\n你是我的大理石，\r\n\r\n我是你的米开朗基罗，\r\n\r\n你有先天裂痕，\r\n\r\n我有琢石执念，\r\n\r\n修修补补，\r\n\r\n直到雕琢出我的大卫。\r\n\r\n我穷得只有一块石头了，而你存在于我心里，我只是照着我的内心，每天和你说说话。\r\n\r\n我想要珍惜我的石头，我不想很多年后有人问起这个时代，我只能冷冷地说，那个年代，真情都很匮乏。\r\n\r\n（完）','2017-06-16 01:43:16','2017-11-08 08:10:49','that-s-supplies-are-scarce'),(38,3,3,'ECMAScript 文档查阅地址','ECMA-262\r\n\r\n7ᵗʰ Edition / June 2016\r\n\r\n[ECMAScript® 2016 Language Specification](http://www.ecma-international.org/ecma-262/7.0/)\r\n\r\n---\r\n\r\nStandard ECMA-262\r\n\r\n6th Edition / June 2015\r\n\r\n[ECMAScript® 2015 Language Specification](http://www.ecma-international.org/ecma-262/6.0/)\r\n\r\n---\r\n\r\nStandard ECMA-262\r\n\r\n5.1 Edition / June 2011\r\n\r\n[ECMAScript® Language Specification](http://www.ecma-international.org/ecma-262/5.1/)\r\n\r\n（完）','2017-06-16 01:43:59','2017-06-16 05:40:45','ecmascript-document-refer-to-the-address'),(39,3,3,'那么长时间过去了','那么长时间，我是指从今年年初到现在。这首歌――《亲爱的，你怎么不在我身边》――依然让我那么有感觉。\r\n\r\n年初，阿三叔家小孩剪毛头，我早上那一天起来去阿三叔家，门口吹喇叭的小孩就放这首歌，而且是循环播放，他似乎很喜欢，我听了也挺带感的――那是在冬天的一个清凉的早晨。\r\n\r\n我清明、五一和端午都回家了。家里非常安静，人也少，格外没人气。晴天的时候，会有人坐在我们家西边的那个十字路口聊天，傍晚有凉风的时候，那个地方也有人。\r\n\r\n我不会因为家里的安静环境觉得无聊，也不会因为在上海大城市感觉到热闹。端午回家的时候，晚上睡在阿文那屋里，关上灯，我就感觉自己瞎了，太黑了，也太安静了，我也就睡下了。\r\n\r\n我佩服阿爸性格上的稳重，和阿三叔性格的嬉皮，还有阿二叔和阿四叔，但我不想成为他们当中的任一个，这也不可能。\r\n\r\n我对阿三叔说的两句话印象很深刻：\r\n\r\n1. 过年翔浩剪毛头，在家里办酒桌，他说：这样热闹。\r\n2. 我五一回家，三叔在家，我吃完饭，站在门口，他也出来了，说：说现在也应该知足了，你爸我们兄弟几个过得都不差，对老的也都尽心。\r\n\r\n我感觉，阿三叔随着年龄增长，性格比以前没那么锐利了，这没什么，恰好说明我们这辈该长大了。','2017-06-16 04:42:32','2017-06-16 04:42:32','so-long-time-in-the-past'),(40,3,3,'我的大舅','> 他很爱吃醋，右手打麦时被绞掉了，胆大。\r\n\r\n我的大舅已经去世了，那是我在高中或者初中的事情。大舅快去世时，我曾去过，还记稀罕姐在那里，他躺在床上，眼睛都睁不开了，身上瘦的只剩了皮包着，屋子里有一种说不上的浓郁味道。他嘴里还叫我的名字，对我说话，我没听清。\r\n\r\n1. 看麦\r\n\r\n阿妈说，大舅起小胆大。以前收麦的时候，防止偷麦，晚上得在湖里看麦。以前乱，鬼啊、死孩个子也多。\r\n\r\n但阿大舅不怕，一个人在漫天野湖里看麦。\r\n\r\n2. 打麦\r\n\r\n以前没有联合收割机之前、有生产队那会，麦割下来之后，得用打麦机子给小麦脱粒。\r\n\r\n阿大舅年轻时就因为打麦，把右手给绞掉了。那时小麦很潮，麦把打麦机子塞麦的入口给堵住了，他逞能，去拽，最后给绞了。\r\n\r\n3. 大妗子\r\n\r\n大妗子在阿lang之前去世，大舅在阿lang之后去世的。\r\n\r\n大妗子没文化，让我记忆深刻的事情是――大妗子吃药，吃得比应该吃得要多，说这好得快。稀罕姐就和她争论，还征求我的意见，我说对，不应该多吃。\r\n\r\n大妗子是被大车蹭到死的。那时，大舅骑着三轮车带着大妗子去外面要饭，在回来的路上，有个大货车蹭到大妗子了，大舅在前面骑着车，发现大妗子不行了，就拿东西盖起来，骑车到家。\r\n\r\n我自始至终都没看到大妗子一眼。大舅那时是什么样子我也不记得。','2017-06-16 05:25:31','2017-06-16 05:28:23','my-big-jiu'),(41,3,3,'感谢时间（小诗）','感谢时间让我认识你又多一天\r\n\r\n在这样的年纪\r\n\r\n我希望是更熟悉一点\r\n\r\n而不是生疏一点\r\n\r\n你不能想象我说出这句话时\r\n\r\n是多么的真诚\r\n\r\n我们如此年轻 \r\n\r\n不知老为何物\r\n\r\n你又如此好\r\n\r\n让我觉得一切非常值得\r\n\r\n*2017.02*','2017-06-16 05:39:20','2017-10-04 11:30:51','thank-you-for-time-poem'),(43,3,3,'ES6：var、let和const','JavaScript 中声明变量有三种形式：var、let和const。\r\n\r\nvar 是 Functional Scope，也就是函数作用域的。当在函数中使用 var 声明变量时，这个变量只在函数作用域中有效；否则这个变量就是全局变量。\r\n\r\nlet 是 Block Scope，也就是块作用域的。在 {} 中声明的变量只在这个作用域中有效；否则这个变量就是全局变量。','2017-06-17 06:56:33','2017-06-17 06:57:21','es6-var-let-and-const'),(44,3,3,'ES6：let和const','let 和 const 都是 Block Scope 的，而且在同一作用域内不可使用它们声明同一个名字的变量（var 是可以的）。\r\n\r\n其次，let 声明的变量的值是可以改的。但 const 不可以，因为它表示常量。\r\n\r\nconst 声明的变量的值不可变，意味着：\r\n\r\n1. 当变量是基本类型变量时，值不可再赋了。\r\n2. 当变量是引用类型时，如对象，表示引用不可变，但是变量属性可变的。\r\n\r\n如果想让 const 声明的对象的属性也不可改变，就使用 Object.freeze()\r\n\r\n比如：\r\n\r\nperson = {name: \'zhangb\'};\r\n\r\nperson = Object.freeze(person);','2017-06-17 07:17:26','2017-06-17 07:17:47','es6-let-and-const'),(45,3,3,'ES6：let和const应用','立即执行函数\r\n\r\nforeach 循环以及循环里的ajax请求（或setTime函数）','2017-06-17 07:25:57','2017-06-17 07:25:57','es6-let-and-const-applications'),(46,3,3,'ES6：暂时性死区','## 什么是暂时性死区\r\n\r\n**暂时性死区**，是指使用 `let` 或者 `const` 声明的变量，**使用之前必须先声明**，否则报 `ReferenceError` 错误。\r\n\r\n```\r\n{\r\n    console.log(foo); // Uncaught ReferenceError: foo is not defined\r\n    let foo = \'bar\';\r\n}\r\n```\r\n\r\n如果使用 `var`，则会报 `undefined` 错误。原因就在于 `var` 声明的变量会发生**变量提升**。\r\n\r\n```\r\nconsole.log(foo); // undefined\r\nlet foo = \'bar\';\r\n\r\n// 等同于\r\nvar foo;\r\nconsole.log(foo);\r\nfoo = \'bar\';\r\n```\r\n\r\n## ES6 中使用\r\n\r\n得益于暂时性死区给我们带来的便利，声明变量时，这样选择声明方式：\r\n\r\n1. 默认都使用 `let` 声明变量\r\n2. 常量使用 `const` 声明（废话！）\r\n3. 尽量不使用 `var`（当然）','2017-06-17 19:11:24','2017-06-17 19:11:24','es6-temporary-dead-zone'),(47,3,3,'ES6：箭头函数','> 箭头函数都是匿名函数\r\n\r\n## 简介\r\n\r\n箭头函数简单点说，就是在传统函数的基础上，去掉 `function` 关键字，加上胖箭头（`=>`）。\r\n\r\n```\r\nconst arr = [2, 4, 6];\r\n\r\n// 传统函数\r\narr2 = arr.map(function (number) {\r\n    return number * 2;\r\n}); // [4, 8, 12]\r\n\r\n// 箭头函数\r\narr2 = arr.map((number) => {\r\n    return number * 2;\r\n}); // [4, 8, 12]\r\n```\r\n\r\n箭头函数口诀：\r\n\r\n> 删掉 `function` 关键字，加上一个胖箭头。\r\n> 没有参数加括号，一个参数可选择。\r\n> 多个参数括号里逗号分隔。\r\n\r\n##  隐式返回\r\n\r\n隐式返回即去掉 `return` 形式的返回语句，变为\r\n\r\n```\r\narr2 = arr.map(number => number * 2);  // [4, 8, 12]\r\n```','2017-06-17 19:27:18','2017-06-17 19:27:18','es6-arrow-function'),(48,3,3,'ES6：箭头函数中的this','在下面的代码中\r\n\r\n```\r\nconst zhangb = {\r\n    name: \'zhangbao\',\r\n    hobbies: [\'Coding\', \'Reading\'],\r\n    printHobbies: function () {\r\n        console.log(this); // Object {name: zhangbao...}\r\n        this.hobbies.map(function (hobby) {\r\n            console.log(this); // Window\r\n        });\r\n    }\r\n}\r\n\r\nzhangb.printHobbies();\r\n```\r\n\r\n我们调用的是变量 `zhangb` 的 `printHobbies` 方法，所以 `this.hobbies` 是指 `zhangb` 所代表的对象。\r\n\r\n但是，方法\r\n\r\n```\r\nfunction (hobby) {\r\n    console.log(this);\r\n}\r\n```\r\n\r\n是作为 `map` 方法的回调函数存在的，也就是说它**是单独的函数**——不是作为对象方法调用的、没有通过 `call`、`apply` 改变 `this` 值的函数——那么它的作用域就是**全局的 `Widow` 对象**了。\r\n\r\n箭头函数中的 `this` 就不一样了。\r\n\r\n```\r\nconst zhangb = {\r\n    name: \'zhangbao\',\r\n    hobbies: [\'Coding\', \'Reading\'],\r\n    printHobbies: function () {\r\n        console.log(this); // Object {name: zhangbao...}\r\n        this.hobbies.map((hobby) => {\r\n            console.log(this); // Object {name: zhangbao...}\r\n        });\r\n    }\r\n}\r\n\r\nzhangb.printHobbies();\r\n```\r\n\r\n因为箭头函数没有自己的 `this`，它的 `this` **继承自父作用域**，是在定义时就确定了的（而传统形式的函数中的 `this` 是在运行时确定的），所以上面 `map` 方法中的 `this` 也指向变量 `zhangb` 所代表的对象。','2017-06-17 19:47:51','2017-06-17 19:47:51','es6-arrow-function-in-this'),(49,3,3,'ES6：函数默认值','ES5 中写法：\r\n\r\n```\r\nfunction multiple(x, y) {\r\n    x = x || 1;\r\n    y = y || 1;\r\n    return x * y;\r\n}\r\n```\r\n\r\n\r\nES6 中写法：\r\n\r\n```\r\nfunction multiple(x = 1, y = 1) {\r\n    return x * y;\r\n}\r\n\r\nmultiple(); // 1\r\nmultiple(12); // 12\r\nmultiple(12, 2); // 24\r\nmultiple(undefined, 12); // 12\r\n```','2017-06-17 22:07:59','2017-06-17 22:07:59','the-default-value-es6-function'),(50,3,3,'ES6：不适合使用箭头函数的场景','> 构造函数、事件绑定和当要使用 `arguments` 参数\r\n\r\n## 构造函数\r\n\r\n箭头函数不能作为构造函数使用。使用构造函数生成一个实例时，会经历下面的四个步骤：\r\n\r\n1. 生成一个新的对象。\r\n2. 将构造函数内部的 `this` 指向该对象。\r\n3. 将新对象原型链指向构造函数的 `prototype` 对象。\r\n4. 返回该新对象。\r\n\r\n因为箭头函数的 `this` 在定义时就确定了，所以使用箭头函数 `new` 出一个实例时，在第二步就会报错。\r\n\r\n```\r\nconst Person = function (name, age) {\r\n	this.name = name;\r\n	this.age = age;\r\n}\r\n\r\nconst zhangb = new Person(\'zhangbao\', 25);\r\n\r\nPerson.prototype.happyNewYear = function () {\r\n	this.age++;\r\n}\r\n```\r\n\r\n## 事件绑定\r\n\r\n箭头函数不能作为事件的回调函数，因为箭头函数里的 `this` 指向全局 `Window` 对象。\r\n\r\n```\r\n<button>BUTTON</button>\r\n\r\n<script type=\"text/javascript\">\r\n	var btn = document.querySelector(\'button\');\r\n	btn.onclick = (ev) => {\r\n		console.log(this); // 这个 this 是 window 对象，而不是 btn 元素\r\n	}\r\n</script>\r\n```\r\n\r\n## `arguments` 参数\r\n\r\n箭头函数中没有 `arguments` 参数。','2017-06-17 22:33:46','2017-11-16 07:14:21','es6-not-suitable-for-use-the-arrow-function'),(51,3,3,'ES6：模板字符串','模板字符串是用 ` `` ` 包裹的字符串，在字符串内部使用 `${ }` 符号取值或调用 JavaScript 代码。\r\n\r\n下面是模板字符串的高级应用：\r\n\r\n```\r\nfunction highlight(arr, ...values) {\r\n	values = values.map((value) => {\r\n		let temp = value;\r\n		let ret;\r\n\r\n		if (value instanceof Array) {\r\n			let poped = temp.pop();\r\n			temp =  temp.join(\'、\') + \'和\' + poped;\r\n		}\r\n\r\n		ret = `<span class=\"highlighted\">${temp}</span>`;\r\n\r\n		return ret;\r\n	});\r\n\r\n	return arr.reduce(function(accumulator, currentValue, currentIndex, array) {\r\n		return accumulator + values[currentIndex-1] + currentValue;\r\n	});\r\n}\r\n\r\nlet say = \'你好\';\r\nlet user = {\r\n	name: \'张宝\',\r\n	age: 25\r\n};\r\nlet hobbys = [\'编程\', \'读书\', \'散步\'];\r\n\r\nlet result = highlight`${say}！我的名字叫${user.name}, ${user.age}岁了。我喜欢${hobbys}。`;\r\n\r\ndocument.body.innerHTML = result;\r\n```\r\n\r\n输出的结果如下（格式化后）：\r\n\r\n```\r\n<span class=\"highlighted\">你好</span>！我的名字叫\r\n<span class=\"highlighted\">张宝</span>, \r\n<span class=\"highlighted\">25</span>岁了。我喜欢\r\n<span class=\"highlighted\">编程、读书和散步</span>。\r\n```\r\n\r\nCSS 效果是这样的：\r\n\r\n```\r\n.highlighted {\r\n    padding: 2px 4px;\r\n    font-size: 100%;\r\n    color: #c7254e;\r\n    background-color: #f9f2f4;\r\n    border-radius: 4px;\r\n}\r\n```','2017-06-17 22:43:00','2017-06-17 23:58:51','es6-template-string'),(52,3,3,'purify.js：净化HTML代码，防止XSS攻击','这里会使用一个 JS 库：[DOMPurify][1]\r\n\r\n[1]: https://github.com/cure53/DOMPurify\r\n\r\n1. [引入][2]\r\n\r\n[2]: https://cure53.de/purify.js\r\n\r\n2. 使用\r\n\r\n```\r\nvar dirty = textarea.value.trim();\r\n\r\nvar clean = DOMPurify.sanitize(dirty);\r\n```\r\n\r\n一些净化前后的例子，\r\n\r\n```\r\nDOMPurify.sanitize(\'<img src=x onerror=alert(1)//>\'); // becomes <img src=\"x\">\r\nDOMPurify.sanitize(\'<svg><g/onload=alert(2)//<p>\'); // becomes <svg><g></g></svg>\r\nDOMPurify.sanitize(\'<p>abc<iframe/\\/src=jAva&Tab;script:alert(3)>def\'); // becomes <p>abc</p>\r\nDOMPurify.sanitize(\'<math><mi//xlink:href=\"data:x,<script>alert(4)</script>\">\'); // becomes <math></math>\r\nDOMPurify.sanitize(\'<TABLE><tr><td>HELLO</tr></TABL>\'); // becomes <table><tbody><tr><td>HELLO</td></tr></tbody></table>\r\nDOMPurify.sanitize(\'<UL><li><A HREF=//google.com>click</UL>\'); // becomes <ul><li><a href=\"//google.com\">click</a></li></ul>\r\n```','2017-06-18 00:22:26','2017-06-18 00:24:39','purify-js-purify-the-html-code-to-prevent-xss-attacks'),(53,3,3,'tutorialrepublic.com：PHP 教程网站','http://www.tutorialrepublic.com/php-tutorial/','2017-06-18 00:42:04','2017-06-18 00:42:04','tutorialrepubliccom-php-tutorial-site'),(54,3,3,'一千零一夜：第一夜','**（一）**\r\n\r\n我下午五点多睡下，醒来时七点半，在宿舍里，空调“滴”了一声，亮了一下，现在开了起来；我的嘴里都是辣条味。\r\n\r\n我来到阳台上，看到远处天空颇为壮观的云，在飘动。\r\n我在短裤口袋里装了一张五块钱，然后又拿了一张十块的，换了一条长裤，下楼去超市买吃的。下去后，发现钱在短裤里，于是上楼把钱装在长裤里。\r\n\r\n在《一千零一夜》里，梁文道说自己英语不好。他的节目每天都有，就是说，可能现在这个时间，他正在准备开始新一期节目的拍摄或者已经在拍摄的过程中了。\r\n\r\n梁文道说，因为把剩下的时间几乎都拿来读书了，所以其它几乎就不做了（包括运动），对他来说，读书是最重要的一件事情。\r\n\r\n我在想――特别在下楼时脖颈后面的赘肉和腰身上的赘肉跟随脚步抖动的时候――读书现在还不是我最重要的一件事情――可我又不玩游戏，又变胖了――每天抽出晚上的时间，不说坚持跑步了――坚持一边走路，一边思考事情，也许会给我带来助益。\r\n\r\n好了，我要去宿舍吃鸡爪了。\r\n\r\n**（二）**\r\n\r\n接着昨天晚上的。夏洛蒂·勃朗特写完《简·爱》，被人说是斗争者、争取者，有革命精神和色彩。不是这样的，只是天性如此。\r\n\r\n- 你没有因为我地位卑微而看低我。\r\n- 作为一个生而自由的人。\r\n\r\n在思想里，她觉得这样做是对的。还有小说中的海伦，影射死去的善良姐姐，被说成“纪念”，也不是这样，而是为了让这一部分优秀的品格“活着”，在能想起来时，知道这是在说某个人。\r\n\r\n带有“自传性质的小说”，也是作者要让自己的观念“活着”，而不是默默无声的带走。','2017-06-18 16:12:49','2017-06-18 16:12:49','one-thousand-nights-the-first-night'),(55,3,3,'Bootstrap 的 viewport breakpoints','## Bootstrap 4\r\n\r\n	// Extra small devices (portrait phones, less than 576px)\r\n	// No media query since this is the default in Bootstrap\r\n\r\n	// Small devices (landscape phones, 576px and up)\r\n	@media (min-width: 576px) { ... }\r\n\r\n	// Medium devices (tablets, 768px and up)\r\n	@media (min-width: 768px) { ... }\r\n\r\n	// Large devices (desktops, 992px and up)\r\n	@media (min-width: 992px) { ... }\r\n\r\n	// Extra large devices (large desktops, 1200px and up)\r\n	@media (min-width: 1200px) { ... }\r\n\r\n相对于 v3，最小设备变为 `<576px` 范围内，而不是 `<768px`。\r\n\r\n* E**x**tra **s**mall devices 使用 `.xs` 表示。\r\n* **Sm**all devices 使用 `.sm` 表示。\r\n* **M**e**d**ium devices 使用 `.md` 表示。\r\n* **L**ar**g**e devices 使用 `.lg` 表示。\r\n* E**x**tra ** l**arge devices 使用 `.xl` 表示。\r\n\r\n也就是说 v3 里的 `.col-md-6` 现在是 v4 里的 `.col-lg-6` 了。 \r\n\r\n也就是\r\n\r\n	// Extra small devices (portrait phones, less than 576px)\r\n	@media (max-width: 575px) { ... }\r\n\r\n	// Small devices (landscape phones, 576px and up)\r\n	@media (min-width: 576px) and (max-width: 767px) { ... }\r\n\r\n	// Medium devices (tablets, 768px and up)\r\n	@media (min-width: 768px) and (max-width: 991px) { ... }\r\n\r\n	// Large devices (desktops, 992px and up)\r\n	@media (min-width: 992px) and (max-width: 1199px) { ... }\r\n\r\n	// Extra large devices (large desktops, 1200px and up)\r\n	@media (min-width: 1200px) { ... }\r\n\r\n迁移文档：https://getbootstrap.com/docs/4.0/migration/\r\n\r\n## Bootstrap 3\r\n\r\nBootstrap 的 viewport breakpoints 有三个：768px、992px 和 1200px。\r\n\r\n1. `.col-xs-`：Extra small devices Phones (<768px)	\r\n2. `.col-sm-`：Small devices Tablets (≥768px)	\r\n3. `.col-md-`：Medium devices Desktops (≥992px)	\r\n4. `.col-lg-`：Large devices Desktops (≥1200px)\r\n\r\n也就是说设备的宽度区间：\r\n\r\n- xs：[0px, 768px)\r\n- sm：[768px, 992px)\r\n- md：[992px, 1200)\r\n- lg：[1200px, +∞)\r\n\r\n浏览器支持：https://getbootstrap.com/docs/3.3/getting-started/#support-ie8-ie9','2017-06-18 16:30:16','2017-09-15 08:02:20','the-bootstrap-the-viewport-of-breakpoints'),(56,3,3,'删除工点','```\r\ndelete from Ucf_UserInSite;\r\n\r\ndelete from Scf_SiteBasic;\r\n\r\ndelete from Scf_SiteDatabase;\r\n\r\ndelete from Scf_SiteDel;\r\n```','2017-06-18 17:48:44','2017-06-18 17:48:44','delete-the-worksite'),(57,3,3,'一千零一夜：第二夜','**（一）**\r\n\r\n我在小雨中走路，下班的路上。雨水滴在手机屏幕上。我嘴里哼着“花香”。\r\n\r\n**（二）**\r\n\r\n我终于还是出来散步了（好像很不容易似的），天上下着似有似无的毛毛雨。虽然空气不热微凉，但因为没有风，走起路来还是会出点汗。\r\n\r\n今天的一段路我准备散步。\r\n\r\n**（三）**\r\n\r\n河南中路苏州河上的桥下有人在睡觉。路上的人并不多。\r\n\r\n即使不跑步，走路同样能在一定程度上放松身心。现在的工作节奏就是一坐一天，并不好，但因为年轻，可能发现这样有问题的人并不多。\r\n\r\n我穿着白色的球鞋和黄色七分裤。在黄色路灯下看能看到下来的毛毛雨，让我感觉是落雨，不是下雨。\r\n\r\n在破旧的北苏州河宾馆门口，有两个中年老汉，我感觉他们挺惬意的。这个地方曾经有剧组拍戏，什么戏不知道。\r\n\r\n有两辆小黄车像是被扔在土堆上，我感觉人类并不是全部都有被救赎的资格。主救赎世人就是在开玩笑。想要被救赎的人，思想里都是有道德伦理的枷锁的。\r\n\r\n我突然感觉《红楼梦》开篇那回对于梦境的描写非常高妙，醒后所梦之事忘却八九，安静而内藏无声的汹涌。虽然已经忘记语言，但感觉仍在。最后贾宝玉在满天白雪的渡口，穿着猩红的披风给他爹叩头也让我印象深刻，那是静谧的沧桑、留给俗人的悲伤。\r\n\r\n始终要记得，被记录下来的故事只占实际发生的很少一部分，自我感觉的满足与足够可能少的根本就不值一提。如果这样，追求有限的足够就能富有了，对个人而言。\r\n\r\n从来都只是人类历史，没有人的历史。','2017-06-19 06:21:14','2017-06-19 06:21:14','one-thousand-nights-the-second-night'),(58,5,5,'Python教程：数据类型','## 整数\r\n\r\nPython可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：`1`，`100`，`-8080`，`0`，等等。\r\n\r\n### 浮点数\r\n\r\n浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的浮点数可以用数学写法，如`1.23`，`3.14`，`-9.01`，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是`1.23e9`，或者`12.3e8`，0.000012可以写成`1.2e-5`，等等。\r\n\r\n### 字符串\r\n\r\n字符串是以单引号\'或双引号\"括起来的任意文本，比如`\'abc\'`，`\"xyz\"`等等。请注意，`\'\'`或`\"\"`本身只是一种表示方式，不是字符串的一部分，因此，字符串`\'abc\'`只有`a`，`b`，`c`这3个字符。如果`\'`本身也是一个字符，那就可以用`\"\"`括起来，比如`\"I\'m OK\"`包含的字符是`I`，`\'`，`m`，空格，`O`，`K`这6个字符。\r\n\r\n如果字符串内部既包含`\'`又包含`\"`怎么办？可以用转义字符`\\`来标识，比如：\r\n\r\n```\r\nprint(\"I\\\'m\\\"good\\\"!\")\r\n```\r\n\r\n表示的字符串内容是：\r\n\r\n```\r\nI\'m\"good\"!\r\n```\r\n\r\n### 布尔值\r\n\r\n布尔值和布尔代数的表示完全一致，一个布尔值只有`True`、`False`两种值，要么是`True`，要么是`False`，在Python中，可以直接用`True`、`False`表示布尔值（请注意大小写），也可以通过布尔运算计算出来：\r\n\r\n```\r\n>>> 3>2\r\nTrue\r\n>>> 3>5\r\nFalse\r\n```\r\n\r\n布尔值可以用`and`、`or`和`not`运算。\r\n`and`运算是与运算，只有所有都为`True`，`and`运算结果才是`True`：\r\n\r\n```\r\n>>> 10 > 2 and 4 > 2\r\nTrue\r\n```\r\n\r\n`or`运算是或运算，只要其中有一个为`True`，`or`运算结果就是`True`：\r\n\r\n```\r\n>>> 10 > 2 or 1 > 3\r\nTrue\r\n```\r\n\r\n`not`运算是非运算，它是一个单目运算符，把`True`变成`False`，`False`变成`True`：\r\n\r\n```\r\n>>> not True\r\nFalse\r\n>>> not 1 > 2\r\nTrue\r\n```\r\n\r\n布尔值经常用在条件判断中，比如：\r\n\r\n```\r\nif age >= 18:\r\n    print(\'adult\')\r\nelse:\r\n    print(\'teenager\')\r\n```','2017-06-20 00:36:27','2017-06-20 00:36:27','python-tutorial-data-types'),(59,5,5,'Python教程：输入和输出','### 输出\r\n用`print()`在括号中加上字符串，就可以向屏幕上输出指定的文字。例如输出`Hello,Word!`，用代码实现如下：\r\n\r\n```\r\nprint(Hello,Word!)\r\n```\r\n\r\n`print()`函数也可以接受多个字符串，用逗号“,”隔开，就可以练成一串输出：\r\n\r\n```\r\n>>>print(\'The test\',\'web\',\'is good\')\r\nThe test web is good\r\n```\r\n\r\n`print()`函数会依次打印每个字符串，遇到逗号\",\"会输出一个空格\r\n`print()`也能打印整数，或者计算结果：\r\n\r\n```\r\n>>> print(100+300)\r\n400\r\n>>> print(100)\r\n100\r\n```\r\n\r\n我们还可以把`100+300`的计算结果打印的更漂亮：\r\n```\r\n>>> print(\"100 + 300 =\",100+300)\r\n100 + 300 = 400\r\n```\r\n\r\n### 输入\r\n现在，你已经可以用`print()`输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个`input()`，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：\r\n\r\n```\r\n>>> name = input(\"your name is : \")\r\nyour name is : chenys\r\n```\r\n\r\n当你输入`name = input()`并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。\r\n\r\n输入完成后，不会有任何提示，Python交互式命令行又回到`>>>`状态了。那我们刚才输入的内容到哪去了？答案是存放到`name`变量里了。可以直接输入`name`查看变量内容\r\n```\r\n>>> name\r\n\'chenys\'\r\n```','2017-06-20 00:38:12','2017-06-20 00:38:12','python-tutorial-input-and-output'),(60,5,5,'Python：列表和元组','### list列表\r\nPython内置的一种数据类型是列表：list 。 list是一种有序的合集，可用随时添加和删除其中的元素。\r\n比如，列出班里所有同学的名字，就可以用一个list表示：\r\n\r\n```\r\n>>>classmates = [\'chenys\',\'zhangb\',\'sunl\']\r\n>>>print(classmates)\r\n[\'chenys\', \'zhangb\', \'sunl\']\r\n```\r\n\r\n变量`classmates`就是一个list。用`len()`函数可以获得元素的个数：\r\n\r\n```\r\n>>>print(len(classmates))\r\n3\r\n```\r\n\r\n### list常用方法\r\n#### 索引\r\n用索引来访问list中每个位置的元素， `索引`是从`0`开始的：\r\n\r\n```\r\n>>>print(classmates[0])\r\nchenys\r\n>>>print(classmates[1])\r\nzhangb\r\n>>>print(classmates[2])\r\nsunl\r\n>>>print(classmates[3])\r\nTraceback (most recent call last):\r\n  File \"/Users/chenys/PycharmProjects/untitled/通用序列/列表.py\", line 89, in <module>\r\n    print(classmates[3])\r\nIndexError: list index out of range\r\n```\r\n\r\n当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，最后一个索引，可以用`-1`做索引\r\n\r\n```\r\n>>>print(classmates[-1])\r\nsunl\r\n```\r\n\r\n可以依次类推取倒数第2个、第3个：\r\n```\r\n>>>print(classmates[-2])\r\nzhangb\r\n>>>print(classmates[-3])\r\nchenys\r\n```\r\n\r\n#### 追加\r\nList 是一个可变的有序表，所以，可以往list中追加`append()`元素到末尾：\r\n```\r\n>>>classmates.append(\'huanghh\')\r\n>>>print(classmates)\r\n[\'chenys\', \'zhangb\', \'sunl\', \'huanghh\']\r\n```\r\n\r\n####  插入\r\n也可以把元素插入`insert()`到指定的位置，比如索引号为`0`的位置：\r\n```\r\n>>>classmates.insert(0,\'chin\')\r\n>>>print(classmates)\r\n[\'chenj\', \'chenys\', \'zhangb\', \'sunl\', \'huanghh\']\r\n```\r\n\r\n#### 删除\r\n要删除list末尾的元素用,用`pop()`方法\r\n```\r\n>>>classmates.pop()\r\n>>>print(classmates)\r\n[\'chenj\', \'chenys\', \'zhangb\', \'sunl\']\r\n```\r\n\r\n要删除指定位置的元素，用`pop(i)`方法，期中`i`是索引的位置：\r\n```\r\n>>>classmates.pop(0)\r\n>>>print(classmates)\r\n[\'chenys\', \'zhangb\', \'sun\']\r\n```\r\n\r\n#### 替换\r\n要把某个元素`替换`成别的元素，可以直接赋值给对应的索引位置：\r\n```\r\n>>>classmates[0] = \'chenys123\'\r\n>>>print(classmates)\r\n[\'chenys123\', \'zhangb\', \'sun\']\r\n```\r\n\r\nlist里面的元素的`数据类型`也可以不同，例如：\r\n```\r\n>>>s1 = [\'Apple\',123,True]\r\n>>>print(s1)\r\n[\'Apple\', 123, True]\r\n```\r\n\r\n#### 嵌套\r\nlist元素也可以`嵌套`另一个list列表，例如：\r\n```\r\n>>>s2 = [\'python\',\'java\',[\'asp\',\'php\'],\'c+\']\r\n>>>print(s2)\r\n[\'python\', \'java\', [\'asp\', \'php\'], \'c+\']\r\n```\r\n 如果要取出s2列表中的`asp`的思路\r\n```\r\n>>>print(s2[2])\r\n[\'asp\', \'php\']\r\n>>>print(s2[2][0])\r\nasp\r\n```\r\n\r\n### tuple元组\r\n另一种有序列表叫元组：tuple。 tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：\r\n```\r\n>>>classmates = (\'chenys\',\'zhangb\',\'sunl\')\r\n>>>print(classmates)\r\n(\'chenys\', \'zhangb\', \'sunl\')\r\n```\r\n现在，classmates这个tuple不能更改，他没有append(),pop()这样的方法。但是获取期中元素的方法和list是一样的，可以正常使用\r\n###小结\r\nlist和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。','2017-06-20 00:40:54','2017-06-20 00:41:16','python-lists-and-tuples'),(61,5,5,'Python：条件判断','## 条件判断\r\n### if语句\r\n计算机之所以能够做很多自动化任务，因为它可以做条件判断\r\n例如，输入用户年龄，根据年龄打印不同的内容，用`if`语句判断：\r\n```\r\nage = 30\r\nif age >= 20:\r\n    print(\'your age is\',age,\'adult\')\r\nyour age is 30 adult\r\n```\r\n也可以给`if`添加一个`else`语句，意思是，如果`if`判断是`False`，不要执行`if`内容，而去执行`else`：\r\n```\r\nage = 10\r\nif age >= 20:\r\n    print(\'your age is\',age,\'adult\')\r\nelse:\r\n    print(\'your teenager!\')\r\n```\r\n还可以用`elif`做更细致的判断：\r\n```\r\n>>>age = 3\r\n>>>if age >= 20:\r\n >>>   print(\'your age is\',age,\'adult\')\r\n>>>elif age >=10:\r\n>>>    print(\'your teenager!\')\r\n>>>else:\r\n>>>    print(\'kid!\')\r\n```\r\n`elif`是`else if `的缩写，完全可以有多个`elif`，所以`if`语句的完整形式是：\r\n```\r\nif <条件判断1>:\r\n    <执行1>\r\nelif <条件判断2>:\r\n    <执行2>\r\nelif <条件判断3>:\r\n    <执行3>\r\nelse:\r\n    <执行4>\r\n```\r\n\r\n###input()\r\n学会使用`input()`读取用户的输入，这样可以使程序更有意思：\r\n```\r\nfood = input(\"your favour food: \")\r\nif food == \'apple\':\r\n    print(\"we are all the same! \")\r\nelse:\r\n    print(\"i like banana\")\r\n```','2017-06-20 00:42:25','2017-06-20 00:46:42','python-condition-judgment'),(62,5,5,'Python：循环','## 循环\r\npython的循环有两种，一种是`for...in` 循环，一种是`while`循环\r\n### for ... in 循环\r\n依次把list或tuple中的每个元素迭代出来\r\n\r\n```\r\nnames = [\'chenys\',\'zhangb\',\'sunl\']\r\nfor name in names:\r\n    print(name)\r\n```\r\n执行这段代码，会依次打印`names`的每个元素\r\n```\r\nchenys\r\nzhangb\r\nsunl\r\n```\r\n所以 `for i in ...` 循环就是把每个元素带入变量`i`，然后执行锁进块的语句。\r\n例如，我们想计算1-10的整数之和，可以用一个`sum`变量做累加\r\n注意实例1和实例2，print的位置区别，总结\r\n```\r\n实例1: \r\nsum = 0\r\nfor i in [1,2,3,4,5,6,7,8,9,10]:\r\n    sum = sum + i\r\n    print(sum)\r\n\r\n实例2:\r\nsum = 0\r\nfor i in [1,2,3,4,5,6,7,8,9,10]:\r\n    sum = sum + i\r\nprint(sum)\r\n```\r\n如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。比如`range(5)`生成的序列是从0开始小于5的整数，`range(101)`就可以生成0-100的整数序列，计算如下\r\n```\r\nsum = 0\r\nfor i in range(101):\r\n	sum = sum + i\r\nprint(sum)\r\n```\r\n\r\n### while循环\r\n只要条件满足，就不断循环，条件不满足时就退出循环。例如我们要计算100以内的所有奇数，可以用while循环实现：\r\n```\r\nsum = 0\r\nn = 99\r\nwhile n > 0:\r\n    sum = sum + n\r\n    n = n -2\r\nprint(sum)\r\n```\r\n### break\r\n在循环中，break语句可以提前退出循环。例如循环打印1～100的数字，当n>10就退出：\r\n```\r\nn1 = 1\r\nwhile n1 <=100:\r\n    if n1 >10:        ＃当n1 ＝ 11 时，条件满足，执行break语句\r\n        break          # break 语句会结束当前循环\r\n    print(n1)\r\n    n1 = n1 +1\r\nprint(\'end\')\r\n```\r\n执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。\r\n\r\n可见`break`的作用是提前结束循环。\r\n\r\n### continue\r\n在循环中，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环\r\n```\r\nn = 0\r\nsum = 0\r\nwhile n < 100:\r\n    n = n + 1\r\n    if n % 2 == 0:\r\n        continue\r\n    sum = sum +n\r\nprint(sum)\r\n```\r\n### 小结\r\n\r\n循环是让计算机做重复任务的有效的方法。\r\n\r\n`break`语句可以在循环过程中直接退出循环，而`continue`语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。\r\n\r\n要特别注意，不要滥用`break`和`continue`语句。`break`和`continue`会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到`break`和`continue`语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉`break`和`continue`语句。\r\n\r\n有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用`Ctrl+C`退出程序，或者强制结束Python进程。','2017-06-20 00:58:33','2017-06-20 00:58:33','python-circulation'),(63,5,5,'Python：字典和集合','## 字典（dict）\r\npython内置字典，使用键－值（key－value）存储，具有极快的查找速度。\r\n举个例子，假设要根据名字查找对应的号码，如果用list实现，需要两个list\r\n```\r\nnames = [\'chenys\',\'zhangb\',\'sunl\']\r\nnumbers = [\'123\',\'456\',\'789\']\r\n```\r\n给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从numbers取出对应的成绩，list越长，耗时越长。\r\n如果用dict实现，只需要一个“名字“－”成绩“，直接根据名字查找成绩，无论这个表有多大，查找速度都不回变慢。如下：\r\n```\r\nd = { \'chenys\':123,\'zhangb\':\'456\',\'sunl\':\'789\'}\r\nprint(d)\r\nprint(d[\'chenys\'])\r\n```\r\n为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。\r\n\r\n第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。\r\n\r\ndict就是第二种实现方式，给定一个名字，比如chenys，dict在内部就可以直接计算出chenys对应的存放成绩的“页码”，也就是123这个数字存放的内存地址，直接取出来，所以速度非常快。\r\n\r\n你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。\r\n\r\n\r\n### 字典常用方法\r\n#### 插入\r\n把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：\r\n```\r\nd[\'huanghh\'] = 123456\r\nprint(d)\r\n```\r\n\r\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\r\n```\r\nd[\'huanghh\'] = 123456\r\nprint(d[\'huanghh\')\r\n\r\nd[\'huanghh\'] = 456789\r\nprint(d[\'huanghh\')\r\n```\r\n#### 判断\r\n如果key不存在，dict就会报错。\r\n要必要key不存在的错误，有两种办法，一种是通过`in`判断key是否存在：\r\n```\r\nprint(\'chenj\' in d)\r\n```\r\n\r\n第二种方法是通过`get()`方法，如果key不存在，可以返回`None`，或者自己指定的value：\r\n```\r\nprint(d.get(\'chenj\'))\r\n\r\nprint(d.get(\'chenj\',\'不存在‘))\r\n```\r\n\r\n#### 删除\r\n要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除：\r\n```\r\nd.pop(\'zhangb\')\r\nprint(d)\r\n```\r\n\r\n请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。\r\n\r\n和list比较，dict有以下几个特点：\r\n1.查找和插入的速度极快，不会随着key的增加而变慢；\r\n2.需要占用大量的内存，内存浪费多。\r\n而list相反：\r\n1.查找和插入的时间随着元素的增加而增加；\r\n2.占用空间小，浪费内存很少。\r\n所以，dict是用空间来换取时间的一种方法。\r\n\r\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是`dict的key必须是不可变对象`。\r\n\r\n这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\r\n\r\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key\r\n\r\n\r\n## 集合(set)\r\nset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\r\n\r\n要创建一个set，需要提供一个list作为输入集合：\r\n```\r\ns = set([1,2,3])\r\nprint(s)\r\n```\r\n注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。\r\n\r\n重复元素在set中自动被过滤：\r\n```\r\ns = set([1,2,3,3,3,4,5,3])\r\nprint(s)\r\n```\r\n\r\n### 集合的常用方法\r\n#### 添加add\r\n通过`add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果：\r\n```\r\ns.add(10)\r\nprint(s)\r\n```\r\n\r\n#### 删除remove\r\n通过`remove(key)`方法可以删除元素\r\n```\r\ns.remove(3)\r\nprint(s)\r\n```\r\n\r\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\r\n```\r\ns1 = set([1,2,3])\r\ns2 = set([2,3,4])\r\nprint(s1 & s2)\r\nprint(s1 | s2)\r\n```','2017-06-20 00:59:20','2017-06-20 00:59:20','python-dictionary-and-collection'),(64,5,5,'Python：内置函数','## Python内置函数\r\n\r\n### `len()` 函数用法\r\n#### 描述\r\n\r\nPython len()方法返回对象（字符、列表、元组等）长度或者项目个数\r\n\r\n#### 语法    参数\r\n```\r\nleng(s) ## s是对象          \r\n```\r\n#### 返回值\r\n\r\n返回对象长度\r\n\r\n#### 实例\r\n```\r\n>>>s1 = \"runoob\"\r\n>>>print(len(s1))      ## 字符串长度\r\n6\r\n>>>classmates = [\'chenys\',\'zhangb\',\'sunl\']\r\n>>>print(len(classmates))          ## 列表元素个数 \r\n3 \r\n```\r\n\r\n### `range()` 函数用法\r\n#### 描述\r\n\r\nPython range()函数可以创建一个整数列表，一般用在for循环中。\r\n\r\n#### 语法 参数\r\n```\r\nrange(start,stop[,step])\r\n#start:计数从start开始。默认是从0开始，例如range(5)等价于range（0,5);\r\n#end: 计数到 end 结束，但不包括 end。例如：range(0,5) 是[0, 1, 2, 3, 4]没有5\r\n#step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)\r\n```\r\n\r\n#### 实例\r\n```\r\nfor i in range(10):            #从0开始到10\r\n    print(i)\r\n	\r\nfor i in range(1,11):          #从1开始到11\r\n    print(i)\r\n\r\nfor i in range(0,31,5):        #从0到31，步长为5\r\n    print(i)\r\n	\r\nfor i in range(0,-10,-1):      #负数\r\n    print(i)\r\n```\r\n\r\n### `enumerate()`  函数用法\r\n#### 描述\r\nenumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\r\n\r\n#### 语法 参数\r\n```\r\nenumerate(sequence, [start=0])    \r\n#sequence -- 一个序列、迭代器或其他支持迭代对象。\r\n#start -- 下标起始位置。\r\n```\r\n\r\n#### 返回值\r\n返回 enumerate(枚举) 对象。\r\n\r\n#### 实例\r\n```\r\nseq = [\'one\',\'two\',\'three\']\r\nfor index ,element in enumerate(seq):\r\n    print(index ,seq[index])\r\n	\r\n```\r\n\r\n### `abs()`  函数用法\r\n#### 描述\r\nabs() 函数返回数字的绝对值。\r\n\r\n#### 语法 参数\r\n```\r\nabs(x) \r\n# x --数值表达式\r\n```\r\n\r\n#### 返回值\r\n函数返回x（数字）的绝对值\r\n\r\n#### 实例\r\n```\r\nprint(abs(-45))\r\n```\r\n\r\n### `isinstance()`  函数用法\r\n#### 描述\r\nisinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。 \r\n\r\n#### 语法 参数\r\n```\r\nisinstance(object,classinfo) \r\n#object -- 实例对象。\r\n#classinfo -- 可以是直接或间接类名、基本类型或者有它们组成的元组。\r\n```\r\n\r\n#### 返回值\r\n如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。。\r\n\r\n#### 实例\r\n```\r\na = 2\r\nprint(isinstance(a,int))\r\nb = \'abc\'\r\nprint(isinstance(b,int))\r\n```\r\n\r\n### `open()`  函数用法\r\n#### 描述\r\npython open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。\r\n\r\n#### 语法 参数\r\n```\r\nopen(name[, mode[, buffering]])\r\n\r\nname : 一个包含了你要访问的文件名称的字符串值。\r\n\r\nmode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。\r\n\r\nbuffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。\r\n```\r\n\r\n#### mode文件打开模式完全列表：\r\n![](http://www.baooab.com/storage/uploads/avatars/594b72035ccff.png)','2017-06-20 01:00:06','2017-06-21 23:32:47','python-built-in-functions'),(65,5,5,'Python：小程序练习之购物车','## 编写购物车小程序\r\n```\r\n###商品列表\r\nproduct_list = [\r\n    [\'macbook\',6000],\r\n    [\'iPhone\',5000],\r\n    [\'Nike\',800],\r\n    [\'sony\',2000]\r\n]\r\n\r\nshopping_list = []    #购物列表\r\n\r\nsalary = int(input(\'请输入你的工资:\'))\r\nprint(\'----- 产品列表 -----\')\r\n\r\nwhile True:\r\n    for index,product in enumerate(product_list):\r\n        print(index,product_list[index][0],product_list[index][1])\r\n\r\n    user_choice = input(\'请输入想购买的商品序号: \')  #输入序列号\r\n    if user_choice.isdigit():\r\n        user_choice = int(user_choice)\r\n        if user_choice >=0 and user_choice < len(product_list):       #判断序列号的范围\r\n            if product_list[user_choice][1] < salary:                 #product_list[user_choice][1]取出商品价格做对比\r\n                product = product_list[user_choice]\r\n                salary = salary - product[1]\r\n                shopping_list.append(product[0])\r\n                print(\"添加%s到购物车,你的余额为%s\"%(product[0],salary))\r\n\r\n            else:\r\n                print(\"您当前剩余%s额度\"%salary)\r\n        else:\r\n            number = \"0 - \" + str(len(product_list)-1)\r\n            print(\"您输入的商品编号不存在,请从新输入%s\" %number)\r\n\r\n    elif user_choice == \'q\':\r\n        print(\"您当前的购物车列表为: \" , shopping_list)\r\n        print(\"您当前的余额%s\" %salary,\"如需购买请输入yes\")\r\n        yes = input(\'请输入:\')\r\n        if yes == \'yes\':\r\n            print(\"完成交易\")\r\n            exit()\r\n        else:\r\n            print(\"请重新选购\")\r\n    else:\r\n        print(\"bye bye!\")\r\n```','2017-06-20 01:01:04','2017-06-20 01:01:04','python-small-application-practice-of-the-shopping-cart'),(66,5,5,'Python教程','## 目录\r\n\r\n###  一、[数据结构](http://www.baooab.com/discussions/python-tutorial-data-types)\r\n\r\n### 二、[输入和输出](http://www.baooab.com/discussions/python-tutorial-input-and-output)\r\n\r\n### 三、[列表和元祖](http://www.baooab.com/discussions/python-lists-and-tuples)\r\n\r\n### 四、[条件判断](http://www.baooab.com/discussions/python-condition-judgment)\r\n\r\n### 五、[循环](http://www.baooab.com/discussions/python-circulation)\r\n\r\n### 六、[阶段性项目－购物车编写](http://www.baooab.com:/discussions/python-small-application-practice-of-the-shopping-cart)\r\n\r\n### 七、[字典和合集](http://www.baooab.com/discussions/python-dictionary-and-collection)\r\n\r\n### 八、[函数](http://www.baooab.com/discussions/python-function)\r\n\r\n### 九、[文件操作](http://www.baooab.com/discussions/python-file-operations)\r\n\r\n\r\n### 十、\r\n\r\n### 十一、[内置函数](http://www.baooab.com/discussions/python-built-in-functions)','2017-06-20 01:06:16','2017-06-25 21:21:34','python-tutorial'),(67,3,3,'一千零一夜：第三夜','**（一）**\r\n\r\n外面有些闷热，在运动器材上炼了一下，流了几点汗，天上没有下雨。\r\n\r\n在路上并没有想多余的什么，但是嘴里没停着，哼着歌，歌词不大记得了。有《满场飞圆舞曲》《狮子座》，还有个记不得了。\r\n\r\n刚才洗澡时，哼了《超人不会飞》，现在一边听歌一边写字。\r\n\r\n我准备留下来一点时间读书，再见。\r\n\r\n**（二）**\r\n\r\n近年中了，六月、七月、八月和九月都没有法定节假日，盛夏来临，人会变得更加乏力，我继续发力就好了――读书和Coding不断，再坚持走路。\r\n\r\n**（三）**\r\n\r\n从张江地铁站来公司的路上，经一座桥。这是一个无风的早上，各种杂物变多了（多是树叶），河水也浑，好像跟浓郁似的。立在河中的警示牌上的那个大鸟不在了。','2017-06-20 15:42:37','2017-06-20 15:42:37','one-thousand-nights-the-third-night'),(68,3,3,'《阿Q正传》','## 简介\r\n\r\n鲁迅在1922年出版了《阿Q正传》，在今天早上来公司的路上，我读了一遍。这部中篇小说以辛亥革命前后，一个叫“未庄”的中国农村为背景，描写流浪雇农阿Q的故事。\r\n\r\n我不想给阿Q这个小人物贴上“劣根性”“愚昧”的标签，这样并不公平。即使把我放在那个时代，除了不至于像阿Q那样露骨的不明白，举止甚至想法上估计跟围观的群众也无大不同。\r\n\r\n在这里我只通过小说文本展示阿Q的性格、心理和经历，以此为点，往外铺开，或可窥见当时情况之一二。也许会更加清楚鲁迅先生表达的要义。\r\n\r\n## 阿Q的性格\r\n\r\n### 乐观\r\n\r\n阿Q的性格很软弱。他头上长癞子，成为旁人的谈资。他气力小，吃亏时改为怒目而视。\r\n\r\n> 我总算被儿子打了，现在的世界真不像样……\r\n> 现在的世界太不成话，儿子打老子……\r\n\r\n### 老假\r\n\r\n正式点说是“虚伪”和“仇富”。但因为表现的太露骨，逢人都能看破，所以别人不以为意。\r\n\r\n> 我们先前——比你阔得多了！你算是什么东西！\r\n\r\n### 名分\r\n\r\n阿Q追求名分，是因为他本来就没有。他只是个小人物，死后连个名字都不为人知。\r\n\r\n#### 攀亲\r\n\r\n有一回，阿Q喝了两碗黄酒，便手舞足蹈的说：\r\n\r\n> 我和赵太爷原来是本家，细细排起来我还比秀才长三辈呢。\r\n\r\n结果被赵太爷跳过去，给了一个嘴巴：“你怎么会姓赵——你那里配姓赵”。阿Q并没有抗辩他确凿姓赵，只用手摸着左颊，和地保退出去了。','2017-06-20 16:04:12','2017-11-08 06:45:38','the-true-story-of-ah-q'),(69,3,3,'使用jQuery让Bootstrap Alert弹框出现后自动消失','比如让 `.alert` 弹框显示2后在0.35秒后自动消失。\r\n\r\n```\r\n$(\'div.alert\').delay(2000).fadeOut(350);\r\n```','2017-06-20 17:15:11','2017-06-20 17:19:47','using-jquery-to-bootstrap-alert-box-appears-after-disappear-automatically'),(70,3,3,'在Laravel项目中使用sendCloud发送激活账号邮件','需要安装一个依赖包 [naux/sendcloud](https://github.com/NauxLiu/Laravel-SendCloud)。\r\n\r\n安装教程可以参考官方文档进行，需要在 sendCloud 注册账号，建立邮件模板。在 `.env` 中配置你的密钥， 并修改邮件驱动为 `sendcloud`。\r\n\r\n```\r\nMAIL_DRIVER=sendcloud\r\n\r\nSEND_CLOUD_USER=your_api_user\r\nSEND_CLOUD_KEY=your_api_key\r\n```\r\n\r\n有一篇实际开发项目的[教程](http://www.baooab.com/discussions/development-on-zhihu-user-table-design-user-registration)供你参考使用。','2017-06-20 17:25:36','2017-06-20 17:25:36','in-laravel-project-using-sendcloud-send-activate-e-mail'),(71,3,3,'将Laravel发送密码重置链接邮件的任务交给sendCloud','总的来说，就是在 User Model 中重写方法 `sendPasswordResetNotification`。\r\n\r\n下面是样例代码，具体说明看[这里](http://www.baooab.com/discussions/development-on-zhihu-rewrite-the-retrieve-password-function)。\r\n\r\n```\r\npublic function sendPasswordResetNotification($token)\r\n{\r\n    $data = [\r\n        \'url\' => url(config(\'app.url\').route(\'password.reset\', $token, false)),\r\n        \'name\' => $this->name,\r\n    ];\r\n    $template = new SendCloudTemplate(\'zhihu_app_password_reset\', $data);\r\n\r\n    Mail::raw($template, function ($message) {\r\n        $message->from(\'admin@baooab.com\', \'乱炖社区\');\r\n        $message->to($this->email);\r\n    });\r\n}\r\n```','2017-06-20 17:29:50','2017-06-20 17:30:13','will-send-the-password-reset-link-email-to-laravel-sendcloud'),(72,3,3,'Laravel 项目中文语言包','可在 [Github Laravel-lang](https://github.com/caouecs/Laravel-lang/tree/master/src/zh-CN) 上下载。','2017-06-20 17:32:51','2017-06-20 17:32:51','laravel-project-chinese-language-pack'),(73,3,3,'在Windows7下使用Ngnix为项目开启一个端口','在 `nginx.conf` 添加：\r\n\r\n```\r\nserver {\r\n	listen       8080;\r\n	server_name  localhost;\r\n\r\n	location / {\r\n		root   C:/wnmp/GithubProjects/SalivaForum/public;\r\n		index  index.php index.html index.htm;\r\n		try_files $uri $uri/ /index.php?$query_string;\r\n	}\r\n\r\n	location ~ \\.php$ {\r\n		root           C:/wnmp/GithubProjects/SalivaForum/public;\r\n		fastcgi_pass   127.0.0.1:9000;\r\n		fastcgi_index  index.php;\r\n		fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\r\n		include        fastcgi_params;\r\n	}\r\n}\r\n```\r\n\r\n即可。','2017-06-20 17:37:14','2017-06-20 17:37:14','under-windows-7-using-ngnix-open-a-port-for-the-project'),(74,3,3,'开发知乎：验证问题表单字段','## 简介\r\n\r\n验证字段可以通过两种方式完成：\r\n\r\n1.  在 Controller 内部方法中使用 `$this->vaidate()` 。\r\n2.  Controller 方法之外创建 Form Request 完成。\r\n\r\n## `$this->vaidate()` \r\n\r\n所有继承自基类`App\\Http\\Controllers\\Controller` 的类都可以使用 `vaidate()` 方法，对表单传递过来的字段进行验证。\r\n\r\n下面是在创建提问时，进行的验证过程。\r\n\r\n```\r\npublic function store(Request $request)\r\n{\r\n	$rules = [\r\n		\'title\' => \'required|max:255\',\r\n		\'body\' => \'required\',\r\n	];\r\n	$message = [\r\n		\'title.required\' => \'标题必填\',\r\n		\'title.max\' => \'标题字数不能多于 :max 个\',\r\n		\'body.required\' => \'内容必填\',\r\n	];\r\n\r\n	$this->validate($request, $rules, $message);\r\n\r\n	$data = $request->only(\'title\', \'body\');\r\n	$data = array_merge($data, [\r\n		\'user_id\' => Auth::user()->id,\r\n	]);\r\n\r\n	$question = Question::create($data);\r\n\r\n	return redirect()->route(\'questions.show\', [\'id\' => $question->id]);\r\n}\r\n```\r\n\r\n## 页面\r\n\r\n```\r\n<form action=\"{{ route(\'questions.store\') }}\" method=\"POST\">\r\n	{{ csrf_field() }}\r\n	<div class=\"form-group{{ $errors->has(\'title\') ? \' has-error\' : \'\' }}\">\r\n		<input type=\"text\" class=\"form-control\" name=\"title\" id=\"title\" placeholder=\"标题\">\r\n		@if ($errors->has(\'title\'))\r\n			<span class=\"help-block\">\r\n				<strong>{{ $errors->first(\'title\') }}</strong>\r\n			</span>\r\n		@endif\r\n	</div>\r\n	<div class=\"form-group{{ $errors->has(\'body\') ? \' has-error\' : \'\' }}\">\r\n		<script id=\"container\" name=\"body\" type=\"text/plain\"></script>\r\n		@if ($errors->has(\'body\'))\r\n			<span class=\"help-block\">\r\n				<strong>{{ $errors->first(\'body\') }}</strong>\r\n			</span>\r\n		@endif\r\n	</div>\r\n	<div class=\"form-group\">\r\n		<input type=\"submit\" class=\"btn btn-primary btn-block\" value=\"提交\">\r\n	</div>\r\n</form>\r\n\r\n<script type=\"text/javascript\">\r\n	var ue = UE.getEditor(\'container\');\r\n	ue.ready(function() {\r\n		ue.execCommand(\'serverparam\', \'_token\', \'{{ csrf_token() }}\'); // 设置 CSRF token.\r\n	});\r\n</script>\r\n```\r\n\r\n这里整合使用百度富文本编辑器 ueditor 的 Laravel 版 [laravel-ueditor](https://github.com/overtrue/laravel-ueditor)。\r\n\r\n## Form Request\r\n\r\n```\r\n$ php artisan make:request StoreQuestionRequest\r\n```\r\n\r\n修改如下：\r\n\r\n```\r\nclass StoreQuestionRequest extends FormRequest\r\n{\r\n    public function authorize()\r\n    {\r\n        return true;\r\n    }\r\n\r\n    public function rules()\r\n    {\r\n        return [\r\n            \'title\' => \'required|max:255\',\r\n            \'body\' => \'required\',\r\n        ];\r\n    }\r\n\r\n    public function messages()\r\n    {\r\n        return [\r\n            \'title.required\' => \'标题必填\',\r\n            \'title.max\' => \'标题字数不能多于 :max 个\',\r\n            \'body.required\' => \'内容必填\',\r\n        ];\r\n    }\r\n}\r\n```\r\n\r\n在 `QuestionController` 的 `store` 方法中使用 `StoreQuestionRequest`。\r\n\r\n```\r\nuse App\\Http\\Requests\\StoreQuestionRequest;\r\n\r\npublic function store(StoreQuestionRequest $request)\r\n{\r\n	...\r\n}\r\n```\r\n\r\n这样也能达到一样的效果。?','2017-06-20 18:08:36','2017-06-25 16:07:32','development-on-zhihu-validation-issues-form-fields'),(75,3,3,'开发Laravel项目时遵守的一些规则','1. Blade模板文件分模块存放在一起，一个模块对应一个文件夹，文件夹名使用**名词的复数形式**。比如：`users`、`questions`、`posts` 等；不可数名词就是本身，比如：`auth`、`vendor` 等。\r\n2. 用户名唯一、邮箱唯一。\r\n3. 在中国，使用 sendCloud发送密码重置链接。\r\n4. 为路由命名，使用 `route()` 方法定位路由。','2017-06-20 18:22:22','2017-06-22 20:54:50','laravel-project-follow-some-rules'),(76,3,3,'在Laravel项目中整合Markdown编辑器simplemde时的特殊处理','使用 Bootstrap 组织的页面在整合 Markdown 编辑器 [simplemde](https://github.com/sparksuite/simplemde-markdown-editor) 时有一个问题。\r\n\r\n1. simplemde 进入全屏编辑时，div 层级低于 `.navbar`。\r\n\r\nBootstrap 的 `.navbar` 的 `z-index` 值为 1000。那么就要保证 simplemde 全屏状态时的 **`z-index` 值高于 1000**。\r\n\r\n```\r\n.editor-toolbar.fullscreen, .CodeMirror-fullscreen, .editor-preview-side {\r\n	z-index:1001;\r\n}\r\n```\r\n\r\n为了让 simplemde 提供的 CSS 与 Bootstrap 一样，在引入的样式文件 `style.css` 里添加样式\r\n\r\n```\r\n/* 代码样式 */\r\n\r\ncode {\r\n    font-size: 100%;\r\n    background-color: rgba(27,31,35,0.05);\r\n}\r\n\r\nhr {\r\n    height: 0.25em;\r\n    padding: 0;\r\n    margin: 24px 0;\r\n    background-color: #e1e4e8;\r\n    border: 0;\r\n}\r\n\r\n.editor-preview pre, .editor-preview-side pre, pre {\r\n    background-color: #F5F2F0;\r\n    font-size: 1.35rem;\r\n    border: 3px solid #ccc;\r\n    border-radius: .718rem;\r\n    padding: .718rem;\r\n}\r\n```\r\n\r\n2. simplemde 启动配置\r\n\r\n我使用下面的配置，添加了 Code、Table 和横线。这是默认没有的。\r\n\r\n```\r\n// https://github.com/sparksuite/simplemde-markdown-editor\r\nnew SimpleMDE({\r\n	spellChecker: false,\r\n	placeholder: \"使用 Markdown 格式书写\",\r\n	promptURLs: true,\r\n	tabSize: 4,\r\n	renderingConfig: {\r\n		codeSyntaxHighlighting: false\r\n	},\r\n	styleSelectedText: false,\r\n	element: document.getElementById(\'simplemde-editor\'),\r\n	toolbar: [\r\n		\"bold\", \"italic\", \"heading\", \"|\",\r\n		\"code\", \"quote\", \"unordered-list\", \"ordered-list\", \"|\",\r\n		\"link\", \"image\", \"table\", \"horizontal-rule\", \"|\",\r\n		\"preview\", \"side-by-side\", \"fullscreen\", \"guide\"\r\n	]\r\n});\r\n```','2017-06-20 18:33:26','2017-06-20 19:15:23','in-laravel-project-integration-simplemde-markdown-editor-of-special-treatment'),(77,3,3,'开发知乎：简化编辑器ueditor','使用 [`JellyBool/simple-ueditor`][1]，它是在 [laravel-ueditor][2] 基础上修改得来的。\r\n\r\n[1]: https://github.com/JellyBool/simple-ueditor\r\n[2]: https://github.com/overtrue/laravel-ueditor\r\n\r\n## Ueditor 的简化版本\r\n\r\n项目的代码来源于百度的 ueditor 项目，JellyBool 只是做了一些微小的工作。\r\n\r\n### 效果\r\n\r\n![simple-ueditor](https://cloud.githubusercontent.com/assets/6011686/21228553/38bf2fdc-c319-11e6-9b6d-5de223bc9989.png)\r\n\r\n### 使用\r\n\r\n第一步：clone 代码\r\n\r\n```\r\ngit clone https://github.com/JellyBool/simple-ueditor.git\r\n```\r\n\r\n第二步：用此项目的 `ueditor` 目录替换原来的 `ueditor` 目录\r\n\r\n第三步：实例化编辑器的时候配置 `toolbar` ，主要是 `toolbar` 的配置\r\n\r\n```\r\nvar ue = UE.getEditor(\'editor\', {\r\n    toolbars: [\r\n            [\'bold\', \'italic\', \'underline\', \'strikethrough\', \'blockquote\', \'insertunorderedlist\', \'insertorderedlist\', \'justifyleft\',\'justifycenter\', \'justifyright\',  \'link\', \'insertimage\', \'fullscreen\']\r\n        ],\r\n    elementPathEnabled: false,\r\n    enableContextMenu: false,\r\n    autoClearEmptyNode:true,\r\n    wordCount:false,\r\n    imagePopup:false,\r\n    autotypeset:{ indent: true,imageBlockLine: \'center\' }\r\n});\r\n```\r\n\r\n## 使用 auth 中间件\r\n\r\n现在不需要登录，就可以进入到提问创建界面。所以要在 `QuestionController` 构造方法里添加中间件进行方法粒度的过滤。\r\n\r\n```\r\nclass QuestionController extends Controller\r\n{\r\n    function __construct()\r\n    {\r\n        $this->middleware(\'auth\')->except([\'index\', \'show\']);\r\n    }\r\n	\r\n	...\r\n}\r\n```','2017-06-20 18:47:54','2017-06-20 19:13:22','development-on-zhihu-ueditor-simplified-editor'),(78,3,3,'Laravel 迁移文件中外键约束的书写方式','以一张中间关系表为例。\r\n\r\n```\r\nSchema::create(\'question_topic\', function (Blueprint $table) {\r\n	$table->increments(\'id\');\r\n	$table->unsignedInteger(\'question_id\')->index();\r\n	$table->unsignedInteger(\'topic_id\')->index();\r\n	$table->timestamps();\r\n\r\n	$table->foreign(\'question_id\')\r\n		->references(\'id\')->on(\'questions\')\r\n		->onDelete(\'cascade\');\r\n	$table->foreign(\'topic_id\')\r\n		->references(\'id\')->on(\'topics\')\r\n		->onDelete(\'cascade\');\r\n});\r\n```\r\n\r\n`question_id` 和 `topic_id` 字是两个外键，分别参考了 `questions` 表和 `topics` 表的 `id` 字段。','2017-06-20 21:00:27','2017-06-20 21:00:27','in-the-writing-of-chinese-and-foreign-key-constraints-laravel-migration-documents'),(79,3,3,'开发知乎：定义话题与问题的关系','## 迁移文件\r\n\r\n```\r\n$ php artisan make:model Topic -m\r\n```\r\n\r\n```\r\nSchema::create(\'topics\', function (Blueprint $table) {\r\n	$table->increments(\'id\');\r\n	$table->string(\'name\')->unique();\r\n	$table->string(\'bio\')->nullable()->comment(\'简介\');\r\n	$table->unsignedInteger(\'questions_count\')->default(0);\r\n	$table->unsignedInteger(\'followers_count\')->default(0);\r\n	$table->timestamps();\r\n});\r\n```\r\n\r\n## Topic Model\r\n\r\n```\r\nuse App\\Model\\Question;\r\n\r\nclass Topic extends Model\r\n{\r\n    protected $fillable = [\r\n        \'name\', \'questions_count\',\r\n    ];\r\n	\r\n	public function questions()\r\n    {\r\n        $this->belongsToMany(Question::class)->withTimestamps();\r\n    }\r\n}\r\n```\r\n\r\n因为问题和话题是多对多的关系的，那么还要创建一个中间表。\r\n\r\n## 中间表 `question_topic`\r\n\r\n```\r\n$ php artisan make:migration create_questions_topics_table --create=question_topic\r\n```\r\n\r\n```\r\nSchema::create(\'question_topic\', function (Blueprint $table) {\r\n	$table->increments(\'id\');\r\n	$table->unsignedInteger(\'question_id\')->index();\r\n	$table->unsignedInteger(\'topic_id\')->index();\r\n	$table->timestamps();\r\n\r\n	$table->foreign(\'question_id\')\r\n		->references(\'id\')->on(\'questions\')\r\n		->onDelete(\'cascade\');\r\n	$table->foreign(\'topic_id\')\r\n		->references(\'id\')->on(\'topics\')\r\n		->onDelete(\'cascade\');\r\n});\r\n```\r\n\r\n## 执行迁移\r\n\r\n```\r\n$ php artisan migrate\r\n```','2017-06-20 21:09:02','2017-06-21 17:53:38','development-on-zhihu-define-the-topic-and-relationship-problems'),(80,5,5,'Python:函数','## 调用函数\r\nPython内置了很多有用的函数，我们可以直接调用。\r\n\r\n要调用一个函数，需要知道函数的名称和参数。例如`len()`函数是返回对象（字符、列表、元组等）长度或者项目个数，只有一个参数。\r\n\r\n也可以在交互式命令行通过`help(len)`查看`len`函数的帮助信息。\r\n\r\n调用`len()`函数\r\n```\r\ns = [\'abc\',1,2,\'bcde\',3]\r\nprint(len(s))\r\n```\r\n\r\n调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：len()有且仅有1个参数，但给出了两个：\r\n```\r\nprint(len(s,s1))\r\nTypeError: len() takes exactly one argument (2 given)\r\n\r\nprint(len(1))\r\nTypeError: object of type \'int\' has no len()\r\n```\r\n如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息\r\n\r\n## 定义函数\r\n在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\r\n\r\n我们以自定义一个求绝对值的`my_abs`函数为例：\r\n```\r\ndef my_abs(x):\r\n    if x >= 0:\r\n        return x\r\n    else:\r\n        return -x\r\nprint(my_abs(-1))\r\nprint(my_abs(10))\r\n```\r\n\r\n### 导入函数\r\n如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用`from abstest import my_abs`来导入my_abs()函数，注意abstest是文件名（不含`.py`扩展名）\r\n\r\n### 空函数\r\n\r\n如果想定义一个什么事也不做的空函数，可以用`pass`语句：\r\n```\r\ndef nop():\r\n    pass\r\n```\r\n`pass`语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。\r\n\r\npass还可以用在其他语句里，比如：\r\n```\r\nif age >= 18:\r\n    pass\r\n```\r\n缺少了`pass`，代码运行就会有语法错误。\r\n\r\n## 检查参数\r\n调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出`TypeError`：\r\n```\r\nTypeError: len() takes exactly one argument (2 given)\r\n```\r\n但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：\r\n```\r\nprint(my_abs(\'A\'))\r\nTypeError: unorderable types: str() >= int()\r\n\r\nprint(abs(\'a\'))\r\nTypeError: bad operand type for abs(): \'str\'\r\n```\r\n当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。\r\n\r\n让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数`isinstance()`实现：\r\n```\r\ndef my_abs(x):\r\n    if not isinstance(x, (int, float)):\r\n        raise TypeError(\'bad operand type\')\r\n    if x >= 0:\r\n        return x\r\n    else:\r\n        return -x\r\n		\r\nprint(my_abs(\'a\'))\r\nTypeError: bad operand type\r\n```\r\n\r\n## 函数的参数\r\n定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。\r\n\r\nPython的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。\r\n\r\n### 位置参数\r\n位置传参可以传递单个或者N个参数（参数位置是一一对应的）：\r\n```\r\ndef introduce_myself(name):        #设置单个参数。\r\n	print(\'my name is \' ,name)\r\n\r\nintroduce_myself(\'chenys\')\r\n\r\ndef introduce_myself1(name,age):   #设置多个参数\r\n	print(\'my name is \',name,\'age is \', age )\r\n\r\nintroduce_myself1(\'chenys\',\'20’)\r\n```\r\n\r\n对于`introduce_myself()` 函数，参数`name`就是一个位置参数。当我们调用`introduce_myself()`函数时，必须传入一个参数`name`\r\n\r\n对于修改后的`introduce_myself1()`函数，参数`name`和`age`都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数`name`和`age`.\r\n\r\n### 默认参数\r\n如果`introduce_myself1(name,age)`函数，却少一个位置参数的值，则代码运行会报错：`TypeError: introduce_myself1() takes exactly one argument (2 given)`，所以我们可以使用默认参数，把第二个位置参数`name`设置为默认值。\r\n\r\n```\r\ndef introduce_myself1(name,age＝18):\r\n	print(\'my name is \',name,\'age is \', age )\r\n\r\nintroduce_myself1(\'chenys\')         #分别运行看看结果\r\n\r\nintroduce_myself1(\'chenys\',\'20‘)    #分别运行看看结果\r\n```\r\n从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：\r\n1. 必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）\r\n2. 如何设置默认参数。\r\n\r\n\r\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\r\n\r\n使用默认参数有什么好处？最大的好处是能降低调用函数的难度。\r\n\r\n### 可变参数\r\n在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。\r\n我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。\r\n要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：\r\n```\r\ndef calc(numbers):\r\n	sum = 0\r\n	for n in numbers:\r\n		sum = sum + n * n\r\n	return sum\r\n	\r\n#但是调用的时候，需要先组装出一个list或tuple：\r\ncalc([1,2,3])     #列表\r\ncalc((1,2,3,4))   #元组\r\n```\r\n如果利用可变参数，调用函数的方式可以简化成这样：\r\n```\r\ncalc(1,2,3)\r\ncalc(1,2,3,4)\r\n```\r\n所以，我们把函数的参数修改为可变参数：\r\n```\r\ndef calc(*numbers):\r\n	sum = 0\r\n	for n in numbers:\r\n		sum = sum + n * n\r\n	return sum\r\n```\r\n定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数numbers接收到的是`一个tuple`，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：\r\n```\r\ncalc(1,2,3,4,5)\r\ncalc(1,2)\r\n```\r\n如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：\r\n```\r\nnums = [1,2,3]\r\ncalc(nums[0],nums[1],nums[2])\r\n```\r\n这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个`*`号，把list或tuple的元素变成可变参数传进去：\r\n```\r\nnums = [1,2,3]\r\ncalc(*nums)\r\n```\r\n`*nums`表示把`nums`这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\r\n\r\n### 关键字参数\r\n`可变参数`允许你传入0个或任意个参数，这些可变参数在函数调用时`自动组装为一个tuple`。而`关键字参数`允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部`自动组装为一个dict`。请看示例：\r\n```\r\ndef person (name,age,**kwargs):\r\n    print(\'name:\',name,\'age:\',age,\'other:\',kwargs)\r\n\r\nperson(\'chenys\',18)\r\n\r\nperson(\'chenys\',18,hometown=\'hn\')\r\n```\r\n关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。\r\n\r\n和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\r\n```\r\ndef person (name,age,**other):\r\n    print(\'name:\',name,\'age:\',age,\'other:\',other)\r\n\r\nother = {\'hometown:\'hn\',\'job\':\'worker\'}\r\n\r\nperson(\'chenys\',\'18,hometown=other[\'hometown\'],job=other[\'job\'])\r\n\r\n```\r\n也可以简写为：\r\n```\r\ndef person (name,age,**other):\r\n    print(\'name:\',name,\'age:\',age,\'other:\',other)\r\n\r\nother = {\'hometown:\'hn\',\'job\':\'worker\'}\r\n\r\nperson(\'chenys\',18,**other)\r\n```\r\n\r\n`**other`表示把`other`这个dict的所有key-value用关键字参数传入到函数的`**kwargs`参数，`kwargs`将获得一个dict，注意kwargs获得的dict是other的一份拷贝，对kwargs的改动不会影响到函数外的other。\r\n    \r\n### 命名关键字参数\r\n如果要`限制关键字参数`的名字，就可以用`命名关键字参数`，例如，只接收`hometown`和`job`作为关键字参数。这种方式定义的函数如下：\r\n```\r\ndef person(name,age,*,hometown,job):\r\n	print(name,age,hometown,job)\r\n	\r\nperson(\'chenys\',18,hometown=\'hn\',job=\'worker\')\r\n```\r\n和关键字参数`**kwargs`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。\r\n\r\n使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：\r\n\r\n### 参数组合\r\n\r\nPython中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的`顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。`\r\n\r\n比如定义一个函数，包含上述若干种参数：\r\n```\r\ndef f1(a,b,c=0,*args,**kwargs):\r\n	print(\'a=\', a, \'b=\', b, \'c=\', c, \'args=\', args, \'kwargs=\', kwargs)\r\n	\r\ndef f2(a,b,c=0,*,d,**kwargs):\r\n	print(\'a=\',a, \'b=\' , b, \'c=\', c, \'d=\', d,  \'kwargs=\', kwargs)\r\n	\r\n```\r\n在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。\r\n```\r\nf1(1,2)\r\nf1(1,2,c=3)\r\nf1(1,2,3,\'a\',\'b\')\r\nf1(1,2,3,\'a\',\'b\',x=123)\r\n```\r\n\r\n## 小结\r\nPython的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。\r\n\r\n默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！\r\n\r\n要注意定义可变参数和关键字参数的语法：\r\n\r\n*args是可变参数，args接收的是一个tuple；\r\n\r\n**kwargs是关键字参数，kw接收的是一个dict。\r\n\r\n以及调用函数时如何传入可变参数和关键字参数的语法：\r\n\r\n可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；\r\n\r\n关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kwargs传入：func(**{\'a\': 1, \'b\': 2})。\r\n\r\n使用*args和**kwargs是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。\r\n\r\n命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。\r\n\r\n定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数','2017-06-20 21:19:28','2017-06-21 21:36:20','python-function'),(81,3,3,'开发知乎：使用Selectize.js优化话题选择','## 引入\r\n\r\n引入 [Selectize.js][1] 的 JS 和 CSS 文件。\r\n\r\n[1]: https://github.com/selectize/selectize.js/\r\n\r\n## 编译文件\r\n\r\n在 `resources/assets` 下创建 `css` 文件夹，放入 `selectize.css`；然后在 `js` 文件夹里放入 `selectize.js` 文件。\r\n\r\n修改 `resources/assets/js/app.js`  文件，添加\r\n\r\n```\r\n require(\'./selectize\'); // 添加这一行，引入selectize.js\r\n```\r\n\r\n在 `resources/assets/sass/app.scss` 中引入 `selectize.css`、`selectize.default.css`。\r\n\r\n```\r\n@import \"./../css/selectize\";\r\n@import \"./../css/selectize.default\";\r\n```\r\n\r\n编译即可。\r\n\r\n```\r\n$ npm run dev\r\n\r\n// 或者\r\n\r\n$npm run production\r\n```\r\n\r\n## 整合 `Selectize.js`\r\n\r\n### 页面\r\n\r\n允许用户自定义话题。\r\n\r\n```\r\n<style>\r\n	.selectize-dropdown.multi {\r\n		z-index: 1000;\r\n	}\r\n\r\n	.selectize-input input {\r\n		font-size: 14px;\r\n	}\r\n</style>\r\n\r\n<select id=\"topics\" name=\"topics[]\" multiple>\r\n	<option value=\"\">搜索话题，最多添加5个</option>\r\n</select>\r\n\r\n$(\'#topics\').selectize({\r\n	plugins: [\'remove_button\'],\r\n	valueField: \'id\',\r\n	labelField: \'name\',\r\n	searchField: \'name\',\r\n	options: [],\r\n	create: true,\r\n	render: {\r\n		option: function(item, escape) {\r\n			return \'<div>\' +\r\n				\'<span class=\"name\">\' + escape(item.name) + \'</span>\' +\r\n				\'</div>\';\r\n		}\r\n	},\r\n	load: function(query, callback) {\r\n		if (!query.length) return callback();\r\n		$.ajax({\r\n			url: \'{{ url(\'api/topics\') }}?query=\' + encodeURIComponent(query),\r\n			type: \'GET\',\r\n			error: function() {\r\n				callback();\r\n			},\r\n			success: function(res) {\r\n				callback(res);\r\n			}\r\n		});\r\n	},\r\n	maxItems: 5,\r\n	persist: false\r\n});\r\n```\r\n\r\n### 保存提问（带话题）\r\n\r\n1. 在 `routes/api.php` 中定义查询话题的逻辑\r\n\r\n```\r\nRoute::middleware(\'api\')->get(\'/topics\', function (Request $request) {\r\n    $query = $request->input(\'query\');\r\n\r\n    if (is_null($query))\r\n    {\r\n        return \\App\\Topic::select(\'name\', \'id\')->get();\r\n    }\r\n\r\n    return \\App\\Topic::select(\'name\', \'id\')->where(\'name\', \'like\', \"%$query%\")->get();\r\n});\r\n```\r\n\r\n2. 修改 `QuestionController` 的保存提问的方法，引入对话题的保存。\r\n\r\n```\r\nuse App\\Topic;\r\nuse App\\Model\\Question;\r\n\r\npublic function store(StoreQuestionRequest $request)\r\n{\r\n	$data = $request->only(\'title\', \'body\');\r\n	$data = array_merge($data, [\r\n		\'user_id\' => Auth::user()->id,\r\n	]);\r\n\r\n	$question = Question::create($data);\r\n\r\n	$topics = $request->input(\'topics\');\r\n	if (! is_null($topics))\r\n	{\r\n		$topics = $this->normallizeTopic($topics);\r\n		$question->topics()->attach($topics);\r\n	}\r\n\r\n	return redirect()->route(\'questions.show\', [\'id\' => $question->id]);\r\n}\r\n\r\nprivate function normallizeTopic(array $topics)\r\n{\r\n	return collect($topics)->map(function ($topic) {\r\n		if (is_numeric($topic))\r\n		{\r\n			Topic::find($topic)->increment(\'questions_count\');\r\n			return (int) $topic;\r\n		}\r\n\r\n		$newTopic = Topic::create([\'name\' => $topic, \'questions_count\' => 1]);\r\n		return $newTopic->id;\r\n	})->toArray();\r\n}\r\n```','2017-06-20 21:37:40','2017-06-21 21:41:03','development-on-zhihu-use-selectize-js-optimization-topic-choice'),(82,3,3,'Laravel-mix：新的前端构建工具','## 介绍\r\n\r\n在 Laravel 5.4 版本前，使用 Gulp 构建工具组织前端资源，而在之后使用了 Laravel Mix 这个新的构建工具。\r\n\r\n首先需要在机子里安装  Node，然后安装 Webpack。\r\n\r\n```\r\n$ npm install webpack -g\r\n```\r\n\r\n再 `npm install` 一下。\r\n\r\n## 使用\r\n\r\n编译出开发（未压缩）环境代码。\r\n\r\n```\r\nnpm run dev\r\n```\r\n\r\n编译出生产（压缩过的）环境代码。\r\n\r\n```\r\nnpm run production\r\n```\r\n\r\n详细参考 [这里](https://laravel.com/docs/5.4/mix)。','2017-06-20 22:21:31','2017-06-20 22:21:31','laravel-mix-new-front-end-build-tools'),(83,3,3,'一千零一夜：第四夜','刚才在外面跑步回来，流汗可就多啦。还没有位子洗澡。\r\n\r\n之前想过，如果跑步回来还记得耿路路的话，就记下来：\r\n\r\n1. 他说买的外卖很朴素，就是说便宜。\r\n2. （不记得了）\r\n\r\n想到其实每个人认为的世界都是不一样的。认同感只是占生活里的一小部分的情感。\r\n\r\n关灯了。','2017-06-21 15:03:02','2017-06-21 15:03:02','one-thousand-a-night-the-fourth-night'),(84,3,3,'Windows7 CMD 下mklink命令创建符号链接','## 说明\r\n\r\n在 Laravel 中，使用 `php artisan storage:link` 命令将创建一个软连接，将 `public/storage` 指向 `storage/app/public`。\r\n\r\nWindows 图形界面没有提供创建软连接的接口。如果要在其中创建一个软连接，需要通过 CMD。\r\n \r\n## 创建软链接\r\n\r\n使用 `mklink` 命令。\r\n\r\n```\r\nE:\\wamp\\www\\discuss>mklink\r\n创建符号链接。\r\n\r\nMKLINK [[/D] | [/H] | [/J]] Link Target\r\n\r\n        /D      创建目录符号链接。默认为文件\r\n                符号链接。\r\n        /H      创建硬链接，而不是符号链接。\r\n        /J      创建目录联接。\r\n        Link    指定新的符号链接名称。\r\n        Target  指定新链接引用的路径\r\n                (相对或绝对)。\r\n```\r\n\r\n将 `public/uploads` 目录指向 `storage/app/uploads`。\r\n\r\n```\r\nE:\\wamp\\www\\discuss>mklink /D \"./public/uploads\" \"E:\\wamp\\www\\discuss\\storage\\app\\uploads\"\r\n为 ./public/uploads <<===>> E:\\wamp\\www\\discuss\\storage\\app\\uploads 创建的符号链接\r\n```','2017-06-21 18:10:41','2017-06-21 18:10:41','under-the-windows-cmd-mklink-command-to-create-a-symbolic-link'),(85,3,3,'Bootstrap 轮播图淡入淡出效果的写法','Bootstrap 轮播图的默认切换效果是左右滑动，这种体验并不好。下面的代码将轮播图的效果改为**淡入淡出**。\r\n\r\n## 添加 CSS 样式\r\n\r\n重写轮播图的 CSS 样式。\r\n\r\n```\r\n.carousel-fade .carousel-inner .item {\r\n	-webkit-transition-property: opacity;\r\n	transition-property: opacity;\r\n}\r\n.carousel-fade .carousel-inner .item,\r\n.carousel-fade .carousel-inner .active.left,\r\n.carousel-fade .carousel-inner .active.right {\r\n	opacity: 0;\r\n}\r\n.carousel-fade .carousel-inner .active,\r\n.carousel-fade .carousel-inner .next.left,\r\n.carousel-fade .carousel-inner .prev.right {\r\n	opacity: 1;\r\n}\r\n.carousel-fade .carousel-inner .next,\r\n.carousel-fade .carousel-inner .prev,\r\n.carousel-fade .carousel-inner .active.left,\r\n.carousel-fade .carousel-inner .active.right {\r\n  left: 0;\r\n	-webkit-transform: translate3d(0, 0, 0);\r\n	transform: translate3d(0, 0, 0);\r\n}\r\n.carousel-fade .carousel-control {\r\n	z-index: 2;\r\n}\r\n```\r\n\r\n## 加类名 `.carousel-fade`\r\n\r\n为轮播组件 `.carousel.slide` 加类名 `.carousel-fade`。\r\n\r\n## 看 Demo\r\n\r\nDemo看[这里](https://codepen.io/Rowno/pen/Afykb)。','2017-06-21 18:11:54','2017-06-21 18:15:19','the-bootstrap-shuffling-figure-fading-effect-writing'),(86,5,5,'Python：文件操作','## 文件操作\r\n读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。\r\n\r\n读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。\r\n\r\n## 打开文件\r\n我们要对文件进行操作必须先打开一个文件对象，使用Python内置的`open()`函数，传入文件名和标示符：\r\n```\r\nf = open(\'test\',\'r\')        \r\n\r\nf = open(\'/Users/chenys/PycharmProjects/untitled/通用序列/test\'，‘r\')     \r\n\r\n```\r\n标示符`r`表示只读模式（关于模式，具体查看内置函数文档内容，详细介绍`open()`函数的使用详情），这样我们就成功打开了一个文件。\r\n\r\n## 读取文件\r\n读取文件python中有3种方法分别是`read()`、`readline()`、`readlines()`\r\n\r\n### `read()`方法\r\nread() 方法用于从文件读取指定的字节数，如果未给定或为负则读取所有。\r\n\r\n#### 语法：\r\n```\r\nfileobject.read(size)\r\n#size -- 从文件中读取的字节数。\r\n```\r\n\r\n#### 返回值\r\n返回从字符串中读取的字节。\r\n\r\n#### 实例\r\n文件test内容如下：\r\n```\r\n123456789123\r\n在我地盘这你就得听我的\r\n把音乐收割用听觉找快乐\r\n开始在雕刻我个人的特色\r\n未来难预测坚持当下的选择\r\n```\r\n读取文件内容：\r\n```\r\nf =  open(\'test\',\'r\')\r\nprint(\'文件名为：\'，f.name)\r\n\r\nline = f.read(12)\r\nprint(\'读取前12个字节的文件内容为：％s‘ ％(line))\r\n\r\nline = f.read()\r\nprint(\'读取的文件内容为：%s\'%(line))\r\n\r\n```','2017-06-21 21:49:17','2017-06-22 00:44:42','python-file-operations'),(87,3,3,'开发知乎：使用 Repository 模式','Repository 模式是为了将 Controller 中与 Model 相关的查询操作独立出来，让结构和逻辑更加明晰、代码更好维护。\r\n\r\n## 创建 `QuestionRepository`\r\n\r\n在 `app` 新建文件夹 `Repositories`，再在该文件夹下创建类 `QuestionRepository`。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Repositories;\r\n\r\nuse App\\Topic;\r\nuse App\\Model\\Question;\r\n\r\nclass QuestionRepository\r\n{\r\n    /**\r\n     * @param $id\r\n     * @return \\Illuminate\\Database\\Eloquent\\Collection|\\Illuminate\\Database\\Eloquent\\Model\r\n     */\r\n    public function byIdWithTopics($id)\r\n    {\r\n        return Question::with(\'topics\')->findOrFail($id);\r\n    }\r\n\r\n    /**\r\n     * @param array $attributes\r\n     * @return mixed\r\n     */\r\n    public function create(array $attributes)\r\n    {\r\n        return Question::create($attributes);\r\n    }\r\n\r\n    /**\r\n     * @param array $topics\r\n     * @return array\r\n     */\r\n    public function normallizeTopic(array $topics)\r\n    {\r\n        return collect($topics)->map(function ($topic) {\r\n            if (is_numeric($topic))\r\n            {\r\n                Topic::find($topic)->increment(\'questions_count\');\r\n                return (int) $topic;\r\n            }\r\n\r\n            $newTopic = Topic::create([\'name\' => $topic, \'questions_count\' => 1]);\r\n            return $newTopic->id;\r\n        })->toArray();\r\n    }\r\n}\r\n```\r\n\r\n这是将原来 `QuestionController` 的代码放到这里来了。\r\n\r\n## 改写 `QuestionController`\r\n\r\n首先在构造方法里借助依赖注入取得 `QuestionRepository` 实例。\r\n\r\n```\r\nprotected $questionRepository;\r\n\r\nfunction __construct(QuestionRepository $questionRepository)\r\n{\r\n	$this->questionRepository = $questionRepository;\r\n}\r\n```\r\n\r\n此时，就可改下 `store` 和 `show` 方法的代码了。\r\n\r\n```\r\npublic function store(StoreQuestionRequest $request)\r\n{\r\n	$data = $request->only(\'title\', \'body\');\r\n	$data = array_merge($data, [\r\n		\'user_id\' => Auth::user()->id,\r\n	]);\r\n\r\n	$question = $this->questionRepository->create($data);  // 注意这里\r\n\r\n	$topics = $request->input(\'topics\');\r\n	if (! is_null($topics))\r\n	{\r\n		$topics = $this->questionRepository->normallizeTopic($topics); // 注意这里\r\n		$question->topics()->attach($topics);\r\n	}\r\n\r\n	return redirect()->route(\'questions.show\', [\'id\' => $question->id]);\r\n}\r\n\r\npublic function show($id)\r\n{\r\n	$question = $this->questionRepository->byIdWithTopics($id);  // 注意这里\r\n\r\n	return view(\'question.show\', compact(\'question\'));\r\n}\r\n```','2017-06-21 22:52:29','2017-06-21 22:52:29','development-on-zhihu-using-the-repository-pattern'),(88,3,3,'修改Boostrap菜单下拉框在hover时显示下拉列表','```\r\n$(\'.dropdown\').hover(function () {\r\n	$(this).addClass(\"open\");\r\n	$(this).find(\'.dropdown-toggle\').attr( \"aria-expanded\", true);\r\n}, function () {\r\n	$(this).removeClass(\"open\");\r\n	$(this).find(\'.dropdown-toggle\').attr( \"aria-expanded\", false);\r\n});\r\n```','2017-06-22 01:59:43','2017-06-22 01:59:43','modify-the-boostrap-menu-drop-down-box-when-hover-display-the-drop-down-list'),(89,3,3,'Google搜索baooab.com！','![baooab.com in google](http://www.baooab.com/storage/uploads/avatars/594bc3e6515fb.png)','2017-06-22 05:20:37','2017-06-22 05:20:37','google-search-baooabcom'),(90,3,3,'一千零一夜：第五夜','**（一）**\r\n\r\n有点窝火。一个是论文，一个是来自甘肃的一个项目。我感觉到自己的时间都用在这上面了。\r\n\r\n我不敢想如果这样的事情如果一直挤占着我的时间会怎样。也许我已经有不爱摊上事的毛病了，虽然平时花在Coding上的时间已经很长了。\r\n\r\n天上下着毛毛雨。预报说明天晚上至后天早上会有梅雨季节里最大一场暴雨。期待。我倒是不讨厌雨，甚至可以不打伞在雨里走都不碍事。\r\n\r\n这是现在的我：有点憔悴和胖，也没有装出很兴奋开心。即使一个人走路也不会担心寂寞无主。\r\n\r\n**（二）**\r\n\r\n我闻到了黄泥和河水的味道，此时在浙江路桥上。\r\n\r\n雨水打湿了围栏的木质扶手和走道。我没有继续往前走就准备回去了。','2017-06-22 06:24:55','2017-06-22 06:24:55','one-thousand-nights-the-fifth-night'),(91,3,3,'坚持不遗余力的表达','嘴笨是没有关系的，只要脑袋足够清醒。\r\n\r\n清醒对于动物来说，就是能够保持警惕，捕获到猎物，得以生存。对人来说，就是能够不受蛊惑，也就是思想的奴役，生存上的压抑。\r\n\r\n坚持不遗余力的表达，表达会让思想更巩固和结实，有自己的主心骨。避免心灵鸡汤似的温声细语和碎碎念。\r\n\r\n没有价值的话，就是你一直在听，他一直在讲，但最后你终究还是没明白他要说什么。','2017-06-22 06:44:30','2017-06-22 06:44:30','stick-to-spare-no-effort-to-express'),(92,3,3,'管理平台登陆后默认文字版首页不显示','在用户视图里设置**默认首页**：/Hom/HomepageRead','2017-06-22 18:08:50','2017-06-22 18:08:50','management-platform-after-landing-the-default-text-version-of-the-home-page-does-not-display'),(93,3,3,'开发知乎：实现编辑问题','## 页面\r\n\r\n```\r\n@extends(\'layouts.app\')\r\n\r\n@push(\'styles\')\r\n<style>\r\n    .selectize-dropdown.multi {\r\n        z-index: 1000;\r\n    }\r\n\r\n    .selectize-input input {\r\n        font-size: 14px;\r\n    }\r\n</style>\r\n@endpush\r\n\r\n@section(\'content\')\r\n    @include(\'vendor.ueditor.assets\')\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div class=\"col-md-8 col-md-offset-2\">\r\n                <div class=\"panel panel-default\">\r\n                    <div class=\"panel-heading\">更新问题</div>\r\n                    <div class=\"panel-body\">\r\n                        <form action=\"{{ route(\'questions.update\', [\'question\' => $question->id]) }}\" method=\"POST\">\r\n                            {{ method_field(\'PATCH\') }}\r\n                            {{ csrf_field() }}\r\n                            <div class=\"form-group{{ $errors->has(\'title\') ? \' has-error\' : \'\' }}\">\r\n                                <input type=\"text\" class=\"form-control\" name=\"title\" id=\"title\" placeholder=\"标题\"\r\n                                       value=\"{{ $question->title }}\">\r\n                                @if ($errors->has(\'title\'))\r\n                                    <span class=\"help-block\">\r\n                                        <strong>{{ $errors->first(\'title\') }}</strong>\r\n                                    </span>\r\n                                @endif\r\n                            </div>\r\n                            <div class=\"form-group{{ $errors->has(\'topics\') ? \' has-error\' : \'\' }}\">\r\n                                <label for=\"topics\">所属话题</label>\r\n                                <select id=\"topics\" name=\"topics[]\" multiple>\r\n                                    @forelse ($question->topics as $topic)\r\n                                        <option value=\"{{ $topic->id }}\" selected>{{ $topic->name }}</option>\r\n                                    @empty\r\n                                        <option value=\"\">搜索话题，最多添加5个</option>\r\n                                    @endforelse\r\n                                </select>\r\n                            </div>\r\n                            <div class=\"form-group{{ $errors->has(\'body\') ? \' has-error\' : \'\' }}\">\r\n                                <script id=\"container\" name=\"body\" type=\"text/plain\">\r\n                                    {!! $question->body !!}\r\n                                </script>\r\n                                @if ($errors->has(\'body\'))\r\n                                    <span class=\"help-block\">\r\n                                        <strong>{{ $errors->first(\'body\') }}</strong>\r\n                                    </span>\r\n                                @endif\r\n                            </div>\r\n                            <div class=\"form-group\">\r\n                                <input type=\"submit\" class=\"btn btn-primary btn-block\" value=\"提交\">\r\n                            </div>\r\n                        </form>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n@endsection\r\n\r\n@push(\'scripts\')\r\n<script type=\"text/javascript\">\r\n    // 问题内容使用 ueditor 编辑器\r\n    var ue = UE.getEditor(\'container\', {\r\n        toolbars: [\r\n            [\'bold\', \'italic\', \'underline\', \'strikethrough\', \'blockquote\', \'insertunorderedlist\', \'insertorderedlist\', \'justifyleft\',\'justifycenter\', \'justifyright\',  \'link\', \'insertimage\', \'fullscreen\']\r\n        ],\r\n        elementPathEnabled: false,\r\n        enableContextMenu: false,\r\n        autoClearEmptyNode:true,\r\n        wordCount:false,\r\n        imagePopup:false,\r\n        autotypeset:{ indent: true,imageBlockLine: \'center\' },\r\n        initialFrameHeight:200,\r\n        initialContent: \'{!!  old(\'body\') !!}\'\r\n    });\r\n    ue.ready(function() {\r\n        ue.execCommand(\'serverparam\', \'_token\', \'{{ csrf_token() }}\'); // 设置 CSRF token.\r\n    });\r\n\r\n    // 话题多选框\r\n\r\n    $(\'#topics\').selectize({\r\n        plugins: [\'remove_button\'],\r\n        valueField: \'id\',\r\n        labelField: \'name\',\r\n        searchField: \'name\',\r\n        options: [],\r\n        create: false,\r\n        render: {\r\n            option: function(item, escape) {\r\n                return \'<div>\' +\r\n                    \'<span class=\"name\">\' + escape(item.name) + \'</span>\' +\r\n                    \'</div>\';\r\n            }\r\n        },\r\n        load: function(query, callback) {\r\n            if (!query.length) return callback();\r\n            $.ajax({\r\n                url: \'{{ url(\'api/topics\') }}?query=\' + encodeURIComponent(query),\r\n                type: \'GET\',\r\n                error: function() {\r\n                    callback();\r\n                },\r\n                success: function(res) {\r\n                    callback(res);\r\n                }\r\n            });\r\n        },\r\n        maxItems: 5,\r\n        persist: false\r\n    });\r\n</script>\r\n@endpush\r\n```\r\n\r\n## `QuestionController`\r\n\r\n绑定多对多关系时使用 `attach()` 方法，同步关系时使用 `sync()` 方法。\r\n\r\n用户只能编辑自己的提问。\r\n\r\n```\r\npublic function edit($id)\r\n{\r\n	$question = $this->questionRepository->byId($id);\r\n\r\n	if (Auth::user()->owns($question))\r\n	{\r\n		return view(\'question.edit\', compact(\'question\'));\r\n	}\r\n\r\n	return back();\r\n}\r\n\r\npublic function update(StoreQuestionRequest $request, $id)\r\n{\r\n	$data = $request->only(\'title\', \'body\');\r\n	$data = array_merge($data, [\r\n		\'user_id\' => Auth::user()->id,\r\n	]);\r\n\r\n	$question = $this->questionRepository->byId($id);\r\n	$question->update($data);\r\n\r\n	$topics = $request->input(\'topics\');\r\n	if (! is_null($topics))\r\n	{\r\n		$question->topics()->sync($topics);\r\n	}\r\n\r\n	return redirect()->route(\'questions.show\', [\'id\' => $question->id]);\r\n}\r\n```\r\n\r\n## User Model\r\n\r\n```\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\npublic function owns(Model $model)\r\n{\r\n	return $this->id == $model->user_id;\r\n}\r\n```','2017-06-22 20:32:35','2017-06-22 20:32:35','development-on-zhihu-editing-problems'),(94,3,3,'Bootstrap Code 标签水平滚动','默认 `<code>` 标签如果超出容器的宽度时，会折行显示，这样看起来很不方便。下面的代码就是让它在水平宽度不够时，能够水平滚动查看。\r\n\r\n```\r\ncode {\r\n	overflow: auto;\r\n    word-wrap: normal;\r\n    white-space: pre;\r\n}\r\n```','2017-06-22 20:37:21','2017-06-22 20:37:21','the-bootstrap-code-label-horizontal-scrolling'),(95,3,3,'开发知乎：提问列表和删除问题功能的实现','这一节实现两个功能：提问列表和删除问题。\r\n\r\n## 提问列表\r\n\r\n我们会在 `QuestionRepository` 创建一个 `getQuestionsFeed` 方法，然后在 `QuestionController` 的 `index` 方法中使用它。\r\n\r\n```\r\n// QuestionRepository\r\npublic function getQuestionsFeed()\r\n{\r\n	return Question::published()->latest(\'updated_at\')->with(\'user\')->paginate(15);\r\n}\r\n\r\n// Question Model\r\npublic function user()\r\n{\r\n	return $this->belongsTo(User::class);\r\n}\r\n\r\npublic function scopePublished($query)\r\n{\r\n	return $query->where(\'is_hidden\', \'F\');\r\n}\r\n\r\n// QuestionController\r\npublic function index()\r\n{\r\n	$questions = $this->questionRepository->getQuestionsFeed();\r\n	return view(\'questions.index\',compact(\'questions\'));\r\n}\r\n```\r\n\r\n`resources/views/questions/index.blade.php`\r\n\r\n```\r\n@extends(\'layouts.app\')\r\n\r\n@section(\'content\')\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div class=\"col-md-8 col-md-offset-2\">\r\n                @foreach ($questions as $question)\r\n                    <div class=\"media\">\r\n                        <div class=\"media-left media-middle\">\r\n                            <a href=\"#\">\r\n                                <img src=\"{{ asset($question->user->avatar) }}\" alt=\"{{ $question->user->name }}的头像\"\r\n                                     style=\"width: 32px; height: 32px;\"\r\n                                >\r\n                            </a>\r\n                        </div>\r\n                        <div class=\"media-body\">\r\n                            <div class=\"media-heading\">\r\n                                <h4><a href=\"{{ route(\'questions.show\', [\'question\' => $question->id]) }}\">{{ $question->title }}</a></h4>\r\n                            </div>\r\n                        </div>\r\n                    </div>    \r\n                @endforeach\r\n            </div>\r\n            <div class=\"col-md-12\">\r\n                {{ $questions->links() }}\r\n            </div>\r\n        </div>\r\n    </div>\r\n@endsection\r\n```\r\n\r\n## 删除问题\r\n\r\n`resources/views/questions/show.blade.php` 添加编辑和删除提问的按钮。\r\n\r\n```\r\n@if (Auth::check() && Auth::user()->owns($question))\r\n	<div class=\"panel-footer\">\r\n		<a class=\"btn btn-default btn-xs\" href=\"{{ route(\'questions.edit\', [\'question\' => $question->id]) }}\">\r\n			编辑\r\n		</a>\r\n		<a class=\"btn btn-default btn-xs\" href=\"{{ route(\'questions.edit\', [\'question\' => $question->id]) }}\"\r\n			onclick=\"event.preventDefault();document.getElementById(\'question-destroy\').submit();\">\r\n			删除\r\n		</a>\r\n		<form id=\"question-destroy\" action=\"{{ route(\'questions.destroy\', [\'question\' => $question->id]) }}\" \r\n			method=\"POST\"\r\n			style=\"display: none;\">\r\n			{{ method_field(\'DELETE\') }}\r\n			{{ csrf_field() }}\r\n		</form>\r\n	</div>\r\n@endif\r\n```\r\n\r\n然后在 `QuestionController` 中添加 `edit` 和 `destroy` 方法。\r\n\r\n```\r\npublic function edit($id)\r\n{\r\n	$question = $this->questionRepository->byId($id);\r\n\r\n	if (Auth::user()->owns($question))\r\n	{\r\n		return view(\'questions.edit\', compact(\'question\'));\r\n	}\r\n\r\n	return back();\r\n}\r\n\r\npublic function destroy($id)\r\n{\r\n	$question = Question::findOrFail($id);\r\n\r\n	if (Auth::user()->owns($question))\r\n	{\r\n		$question->delete();\r\n		flash(\'提问删除成功！\');\r\n		return redirect()->route(\'questions.index\');\r\n	}\r\n\r\n	abort(\'403\', \'Forbidden\');\r\n}\r\n```\r\n\r\n结束！','2017-06-22 21:57:05','2017-06-22 21:57:05','development-on-zhihu-question-list-and-delete-the-realization-of-the-function-of-problem'),(96,3,3,'开发知乎：创建问题的答案','## Answer Migration\r\n\r\n```\r\n$ php artisan make:model Answer -m\r\n```\r\n\r\n`CreateAnswersTable`\r\n\r\n```\r\nSchema::create(\'answers\', function (Blueprint $table) {\r\n	$table->increments(\'id\');\r\n	$table->unsignedInteger(\'user_id\')->index();\r\n	$table->unsignedInteger(\'question_id\')->index();\r\n	$table->text(\'body\');\r\n	$table->unsignedInteger(\'votes_count\')->default(0)->comment(\'点赞数\');\r\n	$table->unsignedInteger(\'comments_count\')->default(0);\r\n	$table->string(\'is_hidden\', 8)->default(\'F\');\r\n	$table->string(\'close_comment\', 8)->default(\'F\');\r\n	$table->timestamps();\r\n\r\n	$table->foreign(\'user_id\')\r\n		->references(\'id\')->on(\'users\')\r\n		->onDelete(\'cascade\');\r\n	$table->foreign(\'question_id\')\r\n		->references(\'id\')->on(\'questions\')\r\n		->onDelete(\'cascade\');\r\n});\r\n```\r\n\r\n## Answer Model\r\n\r\n```\r\nclass Answer extends Model\r\n{\r\n    protected $fillable = [\r\n        \'user_id\', \'question_id\', \'body\',\r\n    ];\r\n\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(User::class);\r\n    }\r\n\r\n    public function question()\r\n    {\r\n        return $this->belongsTo(Question::class);\r\n    }\r\n}\r\n```\r\n\r\n## Question Model\r\n\r\n添加 `answers` 关系。\r\n\r\n```\r\npublic function answers()\r\n{\r\n	return $this->hasMany(Answer::class);\r\n}\r\n```','2017-06-22 22:19:17','2017-06-22 22:19:17','development-on-zhihu-create-the-answer-to-the-question'),(97,3,3,'ES6：新增的字符串函数','## 新增的4个方法\r\n \r\n1. `string.startsWith(\'1991\', 6)`：从第 `7` 个字符算起，是否是以 `1991` 这个字符串开始的。 \r\n2. `string.endsWith(\'X\')`：字符串是否以 `X` 结尾的。\r\n3. `string.includes(\'zhangb\')`：字符串中包含 `zhangb` 这个字符串吗？结果是 `true` 或者 `false`。\r\n4. `\'love\'.repeat(10000)`：重复打印 `love` 一万遍。\r\n\r\n## 应用\r\n\r\n下面使用 `repeat` 写出字符串右对齐函数 `padder`。\r\n\r\n```\r\nfunction padder(string, length=50) {\r\n	return `${ \' \'.repeat(Math.max(length - string.length, 0)) }${ string }`;\r\n}\r\n\r\nconsole.log(padder(\'zhangb\'));\r\nconsole.log(padder(\'zhangb\\\'s love not work at all\'));\r\n```','2017-06-23 00:48:58','2017-06-23 01:11:18','es6-new-string-functions'),(98,3,3,'ES6系列课程','#### 一、[var、let和const][1]\r\n\r\n#### 二、[ES6：let和const][2]\r\n\r\n#### 三、[let和const应用场景][3]\r\n\r\n#### 四、[暂时性死区][4]\r\n\r\n#### 五、[箭头函数][5]\r\n\r\n#### 六、[箭头函数中的this][6]\r\n\r\n#### 七、[函数默认值][7]\r\n\r\n#### 八、[不适合使用箭头函数的场景][8]\r\n\r\n#### 九、[模板字符串][9]\r\n\r\n#### 十、[新增的字符串函数][10]\r\n\r\n（待续）\r\n\r\n[1]: http://www.baooab.com/discussions/es6-var-let-and-const\r\n[2]: http://www.baooab.com/discussions/es6-let-and-const\r\n[3]: http://www.baooab.com/discussions/es6-let-and-const-applications\r\n[4]: http://www.baooab.com/discussions/es6-temporary-dead-zone\r\n[5]: http://www.baooab.com/discussions/es6-arrow-function\r\n[6]: http://www.baooab.com/discussions/es6-arrow-function-in-this\r\n[7]: http://www.baooab.com/discussions/the-default-value-es6-function\r\n[8]: http://www.baooab.com/discussions/es6-not-suitable-for-use-the-arrow-function\r\n[9]: http://www.baooab.com/discussions/es6-template-string\r\n[10]: http://www.baooab.com/discussions/es6-new-string-functions','2017-06-23 01:12:27','2017-06-23 01:12:27','es6-series'),(99,3,3,'鱼·鸟·雨（小诗）','烟雨蒙蒙\r\n\r\n我盯着水里没有淹死的鱼\r\n\r\n看着天上没有渴死的鸟\r\n\r\n然而 并没有鱼和鸟\r\n\r\n只有烟雨蒙蒙\r\n\r\n2017.6.23','2017-06-23 02:32:24','2017-10-10 04:43:58','fish-birds-and-the-rain'),(100,3,3,'一千零一夜：第六夜','**（一）**\r\n\r\n连续三天，下班后我在同一家餐车买晚饭――鸡蛋饼和炒面。天上烟雨蒙蒙，在路上还有排队的车子。我坐在那里吃饭，父子两人在玩超级玛丽，小孩说的话让我感觉比玩得游戏要精彩。\r\n\r\n我想到小孩子写作文一定很好写，伞下或者树下，阴晴风雨，这一方小地方。\r\n\r\n我突然想到我小学就学会作假了。作文里写一些不是自己情感的故事，或者根本就不是自己的事情。\r\n\r\n有一个作文，我写我吃辣椒，现在还记得老师充满善意的评语，是申妮娜老师，我感到羞愧（那时就有），因为是抄的一本作文书上的。那本作文书是在校园里的水泥道上跟一个贩子买的，忘记多少钱了，但我知道不贵。\r\n\r\n**（二）**\r\n\r\n刚才听了罗永浩的干货日记，不想说汉堡的事情了。\r\n\r\n你听罗永浩的东西，感觉他很真诚。锤子手机的官网做得很好，我感觉比苹果好，看它的折起导航栏的位置都特别――左边。\r\n\r\n足够个性化、独特，又能创造美。','2017-06-23 08:09:33','2017-06-23 08:09:33','one-thousand-nights-6-nights'),(101,3,3,'一千零一夜：第七夜','没有风，也没有雨，稍显得闷热。四川某地滑坡掩埋了一百多口人，我并不关心，关心的是还没有快递到的笔记本电脑。\r\n\r\n如果说现在最珍贵的东西时间，那显然我并没做好。我连书也没读。\r\n\r\n高楼上支起的牌子我觉得说得好。\r\n\r\n\r\n不是忙着生，就是忙着死。关照人类是一个很大的课题，我无能为力。世纪广场上坐着一些流浪汉打趣、讲话和沉默，让我感觉自己生活没有那么糟，他们和我并没有关系，就像现在还掩埋于土里的四川人。\r\n\r\n我现在只是在努力挣取生存资料的阶段而已。年轻总是这样，而讲到总是被辜负的年轻时，也大都源于此吧，我想。','2017-06-24 06:11:32','2017-06-24 06:11:32','one-thousand-nights-the-first-ring'),(102,3,3,'何为软件的Alpha、Beta、RC和GA发布版本？','## 简介\r\n\r\n一个软件或者一个功能在发布时，通常会有Beta版这么一说。我很熟悉，差不多知道是什么意思，但没去深究，感觉上就是一个可以用但不保证功能稳定的版本。\r\n\r\n直到昨天我看到了 [MariaDB 数据库发布标准][1]，才对 Alpha、Beta、RC 和 GA 这些概念明晰一些。可能这套标准并不适应于大部分领域，但我感觉对于一个初学者，可以大大增进对这些概念的理解。\r\n\r\n[1]: https://mariadb.com/kb/en/mariadb/release-criteria/\r\n\r\n## 软件发布标准\r\n\r\n### Alpha 版\r\n\r\n此阶段软件逐步添加新特性，一些老特性可能被删除。用户尝试使用时，不保证特性的稳定性。\r\n\r\n### Beta 版\r\n\r\n不再删除特性。此版本兼容 RC 和 GA 发布版本。\r\n\r\n### RC 版\r\n\r\n全称是“Release Candidate”，也称 Gamma 版，之后的发布版本可能还是 RC。此阶段软件不再添加特性，默认配置也不再改变，只接受 Bug 修复。\r\n\r\n### GA 版\r\n\r\n全称是“General Availability”，也称 Stable 版。该阶段软件已足够稳定，请放心使用。','2017-06-24 18:43:07','2017-06-25 15:59:09','what-is-a-software-of-alpha-beta-rc-and-ga-release'),(103,3,3,'Laravel 文档阅读：路由','## 基础路由\r\n\r\n在 Laravel 中要简单地定义一个路由非常方便，传递一个 URI 和闭包即可。\r\n\r\n	Route::get(\'foo\', function () {\r\n		return \'Hello World\';\r\n	})\r\n\r\n#### 默认路由文件\r\n\r\nLaravel 中所有的路由定义在 `routes` 目录下，这个目录下的内容会自动被框架加载。在 `routes/web.php` 文件中定义的是 Web 接口路由，这些路由默认都使用了 `web` 中间件组过滤，它提供了 Session 会话和 CSRF 保护功能。 `routes/api.php` 文件用来定义 API 接口路由，这些路由都是无状态的，默认使用了 `api` 中间件过滤。\r\n\r\n许多项目，基本上都是以 `routes/web.php` 为起点进行开发的，它能实现快速开发一个项目的需要。在 `routes/web.php` 中定义的路由在浏览器中是可以直接访问到的。例如，在浏览器中输入 `http://your-app.dev/user` 地址来访问下面的路由：\r\n\r\n	Route::get(\'/user\', \'UsersController@index\');\r\n\r\n定义在 `routes/api.php` 中的路由被嵌套在了一个路由组里，这是在 `RouteServiceProvider` 中设定的。这个组里的路由都使用了 `/api` 这个 URI 前缀，这样在你定义路由的时候，就不必再手动添加这个前缀了。如果你不想使用 `/api` 这个前缀的话，那么可以在 `RouteServiceProvider` 中修改。\r\n\r\n    /**\r\n     * Define the \"api\" routes for the application.\r\n     *\r\n     * These routes are typically stateless.\r\n     *\r\n     * @return void\r\n     */\r\n    protected function mapApiRoutes()\r\n    {\r\n        Route::prefix(\'api\')\r\n             ->middleware(\'api\')\r\n             ->namespace($this->namespace)\r\n             ->group(base_path(\'routes/api.php\'));\r\n    }\r\n\r\n\r\n#### 可用的路由方法\r\n\r\n每一个 HTTP 请求类型都有对应的路由方法可供使用：\r\n\r\n	Route::get($uri, $callback);\r\n	Route::post($uri, $callback);\r\n	Route::put($uri, $callback);\r\n	Route::patch($uri, $callback);\r\n	Route::delete($uri, $callback);\r\n	Route::options($uri, $callback);\r\n\r\n有时一个路由需要能够匹配多个请求类型，这时可以用 `match` 方法。\r\n\r\n	Route::match([\'get\', \'post\'], \'/\', function () {\r\n		//\r\n	});\r\n\r\n如果希望一个路由能够匹配所有请求类型的话，使用 `any` 方法：\r\n\r\n	Route::any(\'foo\', function () {\r\n		//\r\n	});\r\n\r\n#### CSRF 保护\r\n\r\n使用 `Route::post`、`Route::put`、`Route::patch` 和 `Route::delete` 定义的路由，要求访问它们的 HTML 表单都要传递一个 CSRF token，否则请求会被拒绝。你可以在 CSRF 文档里阅读更多这方面的内容。\r\n\r\n	<form method=\"POST\" action=\"/profile\">\r\n		{{ csrf_field() }}\r\n		...\r\n	</form>\r\n\r\n### 重定向路由\r\n\r\n如果你要将一个路由重定向到另一个路由，可以使用 `Route::redirect` 方法。这就节省定义一个完整路由或者控制器来操作简单的重定向带来的一些麻烦：\r\n\r\n	Route::redirect(\'/here\', \'/there\', 301);\r\n\r\n### 视图路由\r\n\r\n如果你只是要简单返回一个视图，可以使用 `Route::view` 方法，类似 `Route::redirect` 方法，也节省了一些麻烦。`view` 方法的第一个参数是 URI，第二个参数是视图名。另外，也可以使用可选的第三个数组类型参数向视图传递数据：\r\n\r\n	Route::view(\'/welcome\', \'welcome\');\r\n\r\n	Route::view(\'/welcome\', \'welcome\', [\'name\' => \'Taylor\']);\r\n\r\n## 路由参数\r\n\r\n### 必需参数\r\n\r\n有时需要捕获路由 URI 片段，得到我们要用的参数值。例如，我们从一个路由 URL 里捕获用户 ID，你可以这样定义路由参数：\r\n\r\n	Route::get(\'user/{id}\', function ($id) {\r\n		return \'User \'.$id;\r\n	});\r\n\r\n你可以按照需要在路由里定义多个路由参数。\r\n\r\n	Route::get(\'posts/{post}/comments/{comment}\', function ($postId, $commentId) {\r\n		//\r\n	});\r\n\r\n在花括号（`{}`）里的单词会被解析，这些单词由字符字母组成， 不能使用中划线（`-`），**可以使用使用下划线（`_`）**，路由参数是按照顺序注入到回调闭包或者控制器中的形参上的，与这些形参起什么名字没有关系。\r\n\r\n### 可选参数\r\n\r\n上面的路由参数，在 HTTP 请求中都是必须传递的，如果你需要路由参数是可选的路由参数，那么就要在参数名后头放上一个问好（`?`）标识，表示这是可选参数，不过这时要保证对应位置上的 **形参必须要有默认值**。\r\n\r\n	Route::get(\'user/{name?}\', function ($name = null) {\r\n		return $name;\r\n	});\r\n\r\n	Route::get(\'user/{name?}\', function ($name = \'John\') {\r\n		return $name;\r\n	});\r\n\r\n### 正则表达式约束\r\n\r\n可以对路由参数做格式限制的，这时要用到路由实例的 `where` 方法。`where` 方法的第一个参数是路由参数名，第二个参数就是一个正则表达式（规定参数格式）：\r\n\r\n	Route::get(\'user/{name}\', function ($name) {\r\n		//\r\n	})->where(\'name\', \'[A-Za-z]+\');\r\n\r\n	Route::get(\'user/{id}\', function ($id) {\r\n		//\r\n	})->where(\'id\', \'[0-9]+\');\r\n\r\n	Route::get(\'user/{id}/{name}\', function ($id, $name) {\r\n		//\r\n	})->where([\'id\' => \'[0-9]+\', \'name\' => \'[a-z]+\']);\r\n\r\n####  全局约束\r\n\r\n如果在项目里，一个路由参数名的规则都是一样的，这时就可以用 `pattern` 方法定义全局约束，具体是在 `RouteServiceProvider` 的 `boot` 里使用 `pattern` 方法定义规则。 \r\n\r\n	/**\r\n	 * Define your route model bindings, pattern filters, etc.\r\n	 *\r\n	 * @return void\r\n	 */\r\n	public function boot()\r\n	{\r\n		Route::pattern(\'id\', \'[0-9]+\');\r\n\r\n		parent::boot();\r\n	}\r\n\r\n全局约束规则定义好后，所有路由中匹配该参数名的路由参数值都受该规则限制。\r\n\r\n	Route::get(\'user/{id}\', function ($id) {\r\n		// Only executed if {id} is numeric...\r\n	});\r\n\r\n## 命名路由\r\n\r\n命名路由就是给路由起一个名字，有了名字后，我们就可以用这个名字来生成访问这个路由的 URL 地址了。在定义路由的时候，链式调用 `name` 方法，就给路由起了一个名字：\r\n\r\n	Route::get(\'user/profile\', function () {\r\n		//\r\n	})->name(\'profile\');\r\n\r\n也可以为基于控制器 action 的路由起名：\r\n\r\n	Route::get(\'user/profile\', \'UserController@showProfile\')->name(\'profile\');\r\n\r\n#### 生成命名路由的 URL\r\n\r\n访问命名路由，使用全局 `route` 辅助函数，这个函数会生成访问这个路由的 URL 地址。\r\n\r\n	// Generating URLs...\r\n	$url = route(\'profile\');\r\n\r\n	// Generating Redirects...\r\n	return redirect()->route(\'profile\');\r\n\r\n如果命名路由中包含参数，那么在调用 `route` 函数的时候，传递第二个参数来指定路由参数值。\r\n\r\n	Route::get(\'user/{id}/profile\', function ($id) {\r\n		//\r\n	})->name(\'profile\');\r\n\r\n	$url = route(\'profile\', [\'id\' => 1]);\r\n\r\n#### 检查当前路由\r\n\r\n如果你想知道，当前请求是否是发送到一个特定的命名路由上的，用 Route 实例的 `named` 方法就可以做到。例如，我们在一个路由中间件里定义了这个逻辑：\r\n\r\n	/**\r\n	 * Handle an incoming request.\r\n	 *\r\n	 * @param  \\Illuminate\\Http\\Request  $request\r\n	 * @param  \\Closure  $next\r\n	 * @return mixed\r\n	 */\r\n	public function handle($request, Closure $next)\r\n	{\r\n	   // 如果当前请求是发往名字是“profile”的路由的，就会执行 if 里面的逻辑 \r\n		if ($request->route()->named(\'profile\')) {\r\n			//\r\n		}\r\n\r\n		return $next($request);\r\n	}\r\n\r\n## 路由组\r\n\r\n当我们定义的路由很多的时候，就会发现有些路由是有一些共同特征的，比如用了同一个中间件、有相同的命名空间、有一样的 URI 前缀地址等等。这时为了方便，我们就不要给每个路由重复、单独地定义这些内容了，使用 `Route::group` 方法就可以轻松解决这个麻烦， `Route::group` 方法让具有共同特征的路由放在一个组里面，我们称这个组叫「路由组」。\r\n\r\n### 中间件\r\n\r\n给一个路由组应用中间件，是在 `group` 方法之前调用 `middleware` 方法，中间件会按照中间件在数组里的出现顺序以此执行：\r\n\r\n	Route::middleware([\'first\', \'second\'])->group(function () {\r\n		Route::get(\'/\', function () {\r\n			// Uses first & second Middleware\r\n		});\r\n\r\n		Route::get(\'user/profile\', function () {\r\n			// Uses first & second Middleware\r\n		});\r\n	});\r\n\r\n### 命名空间\r\n\r\n另一个路由组的常用用处是使用 `namespace` 方法为添加统一的命名空间：\r\n\r\n	Route::namespace(\'Admin\')->group(function () {\r\n		// Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace\r\n	});\r\n\r\n需要注意的是，在 `RouteServiceProvider` 中已经为 `routes/web.php` 和 `routes/api.php` 文件中定义的路由添加了 `App\\Http\\Controllers` 的命名空间前缀。所以在定义路由时，你只需要指定 `App\\Http\\Controllers` 命名空间的后面部分就行了。\r\n\r\n---\r\n\r\n### 子域路由\r\n\r\n路由组也可用于处理子域地址，在子域上也可以使用参数，路由能捕获子域地址里的参数值。在 `group` 方法前调用 `domain` 方法就可以使用这个功能了。\r\n\r\n	Route::domain(\'{account}.myapp.com\')->group(function () {\r\n		Route::get(\'user/{id}\', function ($account, $id) {\r\n			//\r\n		});\r\n	});\r\n\r\n### 路由前缀\r\n\r\n`prefix` 方法用来给路由组添加 URI 前缀。例如，我们给所有路由 URL 添加 `admin` 前缀：\r\n\r\n	Route::prefix(\'admin\')->group(function () {\r\n		Route::get(\'users\', function () {\r\n			// Matches The \"/admin/users\" URL\r\n		});\r\n	});\r\n\r\n## 路由模型绑定\r\n\r\n我们通常在路由或者控制器 action 中获得一个模型 ID 值，然后通过这个 ID 找到对应的模型实例。Laravel 路由模型绑定让这个过程更加简单，它会自动在你的路由中注入模型实例。例如，传递一个用户 ID ，得到对应的用户实例。\r\n\r\n### 隐形绑定\r\n\r\nLaravel 会自动解析路由或控制 action 中的形参变量，但前提是该变量名与路由参数名一样、且有类型（指 Eloquent Model）提示的。\r\n\r\n	Route::get(\'api/users/{user}\', function (App\\User $user) {\r\n		return $user->email;\r\n	});\r\n\r\n在这里，`$user` 变量的类型是 `App\\User` 这个 Eloquent Model，并且这个变量名跟 URL 路由参数 `{user}` 是一样的，所以 Laravel 会自动将拥有该 ID 的 `App\\User` 实例对象赋值给 `$user` 变量。如果实例对象在数据库中未找到，就会抛出一个 404 响应。\r\n\r\n#### 自定义模型在路由中主键名\r\n\r\n如果要让路由绑定从数据库中获得模型实例使用的默认字段不是 `id`，而是其他字段，这时候就要在 Eloquent Model 中重写 `getRouteKeyName` 方法：\r\n\r\n	/**\r\n	 * Get the route key for the model.\r\n	 *\r\n	 * @return string\r\n	 */\r\n	public function getRouteKeyName()\r\n	{\r\n		return \'slug\';\r\n	}\r\n\r\n### 精确绑定\r\n\r\n在 `RouteServiceProvider` 类的 `boot` 方法中，使用 `Route::model` 方法为特定的路由参数名绑定 Eloquent Model 类：\r\n\r\n	public function boot()\r\n	{\r\n		parent::boot();\r\n\r\n		Route::model(\'user\', App\\User::class);\r\n	}\r\n\r\n接下来，在路由中使用路由参数 `{user}`：\r\n\r\n	Route::get(\'profile/{user}\', function (App\\User $user) {\r\n		//\r\n	});\r\n\r\n我们把所有路由参数是 `{user}` 的都绑定给了 `App\\User` 模型，最后对应的 `User` 模型实例就会注入到路由中。例如，`profile/1` 的请求地址最终会从数据库中获得 ID 是 `1` 的那个用户数据。如果在数据库里没有找到匹配的用户，就会自动返回 404 响应。\r\n\r\n#### 自定义解析逻辑\r\n\r\n如果希望解析路由参数时，使用自己的一套更加个性化的逻辑，使用 `Route::bind` 方法就行了。\r\n\r\n	public function boot()\r\n	{\r\n		parent::boot();\r\n\r\n		Route::bind(\'user\', function ($value) {\r\n			return App\\User::where(\'name\', $value)->first();\r\n		});\r\n	}\r\n\r\n## 表单方法伪造\r\n\r\nHTML 表单不支持`PUT`、`PATCH` 和 `DELETE` 方式的 HTTP 请求。为了能与后台的 `PUT`、`PATCH` 和 `DELETE` 类型的路由匹配，就需要添加一个名为 `_method` 的隐藏表单域。 `_method` 这个隐藏表单域的值会被 Laravel 看做 HTTP 请求的标识：\r\n\r\n	<form action=\"/foo/bar\" method=\"POST\">\r\n		<input type=\"hidden\" name=\"_method\" value=\"PUT\">\r\n		<input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\">\r\n	</form>\r\n\r\n你也可以使用 `method_field` 辅助函数产生这个 `_method` 隐藏表单域：\r\n\r\n	{{ method_field(\'PUT\') }}\r\n\r\n## 访问当前路由\r\n\r\n使用 `Route` 门面的 `current`、`currentRouteName` 和 `currentRouteAction` 方法获得处理当前请求的路由信息：\r\n\r\n	$route = Route::current();\r\n\r\n	$name = Route::currentRouteName();\r\n\r\n	$action = Route::currentRouteAction();\r\n\r\n更多关于 [Route 门面的底层类][1] 和 [Route 实例][2] 的所有可用方法请参考 API 文档。\r\n\r\n[1]: https://laravel.com/api/5.5/Illuminate/Routing/Router.html\r\n[2]: https://laravel.com/api/5.5/Illuminate/Routing/Route.html','2017-06-25 03:39:26','2017-09-15 04:04:08','reading-laravel-documentation-routing'),(104,3,3,'阅读Laravel文档：中间件','## 注册中间件\r\n\r\n注册中间件修改的是 `app/Http/Kernel.php` 这个文件。\r\n\r\n###  全局中间件\r\n\r\n如果需要每个请求都要被你写的中间件过滤，那么就把中间件添加到 `$middleware` 这个数组里。\r\n\r\n### 路由中间件\r\n\r\n如果写的中间件是为了用在路由上的，那就把中间件添加到 `$routeMiddleware` 这个数组里。形式就是：\r\n\r\n```\r\n \'alias\' => SomeMiddlewareClass::class,\r\n```\r\n\r\n### 中间件组\r\n\r\n中间件组和中间件的使用是一样一样的。它的好处是一次可以同时指定多个路由。\r\n\r\n## 中间件参数\r\n\r\n中间件类里的 `handle` 方法还可以接受第三个参数，这个参数值是在调用中间件时冒号（`:`）后面的那个值。\r\n\r\n```\r\nRoute::put(\'post/{id}\', function ($id) {\r\n    //\r\n})->middleware(\'role:editor\');\r\n```\r\n\r\n```\r\npublic function handle($request, Closure $next, $role)\r\n{\r\n	if (! $request->user()->hasRole($role)) {\r\n		// Redirect...\r\n	}\r\n\r\n	return $next($request);\r\n}\r\n```\r\n\r\n这里 `$role` 的值就是 `\"editor\"`。','2017-06-25 04:36:46','2017-06-26 00:28:29','reading-laravel-documentation-middleware'),(105,3,3,'阅读Laravel文档：CSRF保护','## 简介\r\n\r\nCSRF 就是指跨站请求伪造。Laravel 中除 GET 请求外，其它类型请求都要经过 `VerifyCsrfToken` 中间件过滤（也就是 CSRF 验证），这是因为 `routes/web.php` 中的路由默认使用了 `web` 中间件组，而这个中间件组里就有`VerifyCsrfToken` 中间件。\r\n\r\n## CSRF Tokens & JavaScript\r\n\r\nLaravel 默认前端发送 Ajax 请求使用的库是 Axios，所有 Ajax 请求的 header 都要带上 `X-CSRF-TOKEN` ，在 `resources/assets/js/bootstrap.js` 中已经为我们处理好了。\r\n\r\n实现的方式是，默认布局文件 `layouts/app.blade.php` 里有这么一个记录 CSRF 令牌的 `meta` 标签。\r\n\r\n```\r\n<meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\r\n```\r\n\r\n如果非要用 jQuery 也没有关系，在使用前配置下就 OK 了。\r\n\r\n```\r\n$.ajaxSetup({\r\n    headers: {\r\n        \'X-CSRF-TOKEN\': $(\'meta[name=\"csrf-token\"]\').attr(\'content\')\r\n    }\r\n});\r\n```','2017-06-25 04:50:27','2017-06-25 05:01:34','reading-laravel-documentation-csrf-protection'),(106,3,3,'一千零一夜：第八夜','**（一）**\r\n\r\n我都没有发现那个用废旧拖把把支起的番薯株。早上，天上小雨淅沥沥。白天，高楼路上没有彩灯会感觉干净、朴素很多。\r\n\r\n看到宿舍走廊里打扫的阿姨和一楼切菜的阿姨，就感觉自己是蛀虫，行动上的。\r\n\r\n一次晚上行走，我写下了这些：\r\n\r\n> 我刚才在外面走路，当然是在洗澡之前。路上留意了几个场景，我记在这里：在牌桌旁躺着的狗；身体紧实、脸蛋圆圆的女子；凉爽的风；哗哗响的树叶；在静默中波动的苏州河/吴淞江。\r\n\r\n**（二）**\r\n\r\n宿舍里是乒乒乓乓的声音，游戏解说和电影。\r\n\r\n雨停了，说不定还要下。\r\n\r\n**（三）**\r\n\r\n不管了，睡下。','2017-06-25 06:53:30','2017-06-25 06:53:30','one-thousand-nights-the-eighth-night'),(107,3,3,'Bootstrap3.3.7的CDN链接','1. bootstrap.min.css\r\n\r\nhttps://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\r\n\r\n2. jquery-1.12.4.min.js\r\n\r\nhttp://lib.sinaapp.com/js/jquery/1.12.4/jquery-1.12.4.min.js\r\n\r\n3. bootstrap.min.js\r\n\r\nhttps://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js','2017-06-25 15:39:22','2017-06-25 15:39:22','bootstrap337-cdn-links'),(108,3,3,'Laravel项目的中文环境配置','修改 `config/app.php` 下的两个字段：时区和语言。\r\n\r\n```\r\n\'timezone\' => \'PRC\',\r\n\r\n\'locale\' => \'zh-CN\',\r\n```\r\n\r\n设定时区保证保存和显示的是中国时间；设定语言会应用在 HTML 页面并优先使用 `zh-CN` 下的语言模板。','2017-06-25 15:43:03','2017-06-25 15:43:03','laravel-chinese-environment-configuration-of-the-project'),(109,3,3,'Laravel上传、更新头像','## `storage:link`\r\n\r\nArtisan 命令\r\n\r\n```\r\nphp artisan storage:link\r\n```\r\n\r\n会创建一个软连接将 `public/storage` 目录指向 `storage/app/public`。\r\n\r\n## Blade 页面\r\n\r\n```\r\n<form method=\"POST\" action=\"http://www.baooab.com/user/avatar\" accept-charset=\"UTF-8\" enctype=\"multipart/form-data\">       \r\n	{{ csrf_field() }}\r\n    <div class=\"form-group\">\r\n        <input class=\"form-control\" name=\"avatar\" type=\"file\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <input class=\"btn btn-primary form-control\" type=\"submit\" value=\"修改\">\r\n    </div>\r\n</form>\r\n```\r\n\r\n## AvatarController \r\n\r\n```\r\npublic function change(Request $request)\r\n{\r\n    $avatar = $request->file(\'avatar\');\r\n\r\n    if ($avatar->isValid())\r\n    {\r\n        $user = Auth::user();\r\n\r\n        $originExt = $avatar->getClientOriginalExtension();\r\n        // 新文件名。例如：\'586f2d753dfbd.jpg\'\r\n        $newName = uniqid() . \'.\' . $originExt;\r\n        Storage::putFileAs(\'public/uploads/avatars\', $avatar, $newName);\r\n\r\n        $user->avatar = \'storage/uploads/avatars/\' . $newName;\r\n        $user->save();\r\n\r\n        return back();\r\n    }\r\n}\r\n```','2017-06-25 15:54:44','2017-06-25 15:54:54','laravel-upload-update-face'),(110,3,3,'Windows7系统使用xcopy命令复制文件夹','使用 `xcopy` 命令。它的参数有：\r\n\r\n`/f`：询问目标 `laravel-5-3` 是文件还是文件夹。\r\n\r\n`/s`：迭代复制子目录。\r\n\r\n比如有这样的需要——将项目 `template5.3` 复制到 `laravel-5-3`——可以这样使用命令：\r\n\r\n```\r\nxcopy template5.3 laravel-5-3 /f /s\r\n```','2017-06-25 15:58:26','2017-06-25 15:58:26','windows-7-system-use-xcopy-command-copy-folder'),(111,3,3,'Laravel验证表单字段','```\r\n$rules = [\r\n    \'title\' => \'required|min:6|max:255|unique:questions\',\r\n    \'body\' => \'required\',\r\n];\r\n\r\n$messages = [\r\n    \'title.required\' => \'标题必填\',\r\n    \'title.min\' => \'标题至少 :min 个字符\',\r\n    \'title.unique\' => \'已经有人提过这个问题了\',\r\n    \'body.required\' => \'内容必填\',\r\n];\r\n\r\n$this->validate($request, $rules, $messages);\r\n```','2017-06-25 16:08:23','2017-06-25 16:08:23','laravel-validation-of-form-fields'),(112,3,3,'Laraval开发包：laravelcollective/html','包地址：https://laravelcollective.com/docs/master/html\r\n\r\n下载方式：\r\n\r\n```\r\ncomposer require \"laravelcollective/html\":\"^5.4.0\"\r\n```','2017-06-25 16:14:38','2017-06-25 16:14:38','laraval-development-kit-laravelcollectivehtml'),(113,3,3,'Laravel Artisan Tinker 使用介绍','## 简介\r\n\r\n利用 Laravel artisan tinker 可以在以命令的形式为数据库表插入数据，对插入测试数据十分便利。\r\n\r\n下面以插入论坛帖子的形式对它的使用举例。\r\n\r\n## 使用\r\n\r\n### Model\r\n\r\n创建 Discussion Model\r\n\r\n```\r\n$ php artisan make:model discussion -m -c\r\nModel created successfully.\r\nCreated Migration: 2017_06_07_094146_create_discussions_table\r\nController created successfully.\r\n```\r\n\r\n### 迁移文件\r\n\r\n1. 填充迁移文件\r\n\r\n```\r\nSchema::create(\'discussions\', function (Blueprint $table) {\r\n	$table->increments(\'id\');\r\n	$table->unsignedInteger(\'user_id\');\r\n	$table->unsignedInteger(\'last_user_id\');\r\n	$table->string(\'title\');\r\n	$table->text(\'body\');\r\n	$table->timestamps();\r\n\r\n	$table->foreign(\'user_id\')\r\n		->references(\'id\')->on(\'users\')\r\n		->onDelete(\'cascade\');\r\n});\r\n```\r\n\r\n2. 执行迁移\r\n\r\n```\r\n$ php artisan migrate\r\n```\r\n\r\n### 测试数据\r\n\r\n添加为 Discussion Model 准备的工厂方法。 \r\n\r\n```\r\n$factory->define(App\\Discussion::class, function (Faker\\Generator $faker) {\r\n    $user = factory(App\\User::class)->create();\r\n\r\n    return [\r\n        \'title\' => $faker->sentence,\r\n        \'body\' => $faker->paragraph,\r\n        \'user_id\' => $user->id,\r\n        \'last_user_id\' => $user->id,\r\n    ];\r\n});\r\n```\r\n\r\n### 使用 tinker 插入测试数据\r\n\r\n```\r\n$ php artisan tinker\r\nPsy Shell v0.8.6 (PHP 7.0.10 cli) by Justin Hileman\r\n>>> namespace App;\r\n>>> factory(Discussion::class, 30)->create();\r\n```','2017-06-25 16:23:10','2017-11-24 06:32:24','laravel-artisan-tinker-used-is-introduced'),(114,3,3,'开发知乎：实现提交答案','## 简介\r\n\r\n用户提交答案的文本框也是用 Ueditor。回答的地方在提问详情页，需要添加一个路由，一个控制器 `AnswerController`。\r\n\r\n## 创建控制器\r\n\r\n### 创建 `AnswerController`。\r\n\r\n```\r\n$ php artisan make:controller AnswerController\r\n```\r\n\r\n添加保存保存答案的方法 `store`。\r\n\r\n```\r\nclass AnswerController extends Controller\r\n{\r\n    public $answerRepository;\r\n\r\n    function __construct(AnswerRepository $answerRepository)\r\n    {\r\n        $this->answerRepository = $answerRepository;\r\n        $this->middleware(\'auth\');\r\n    }\r\n    \r\n    public function store(StoreAnswerRequest $request, $question)\r\n    {\r\n        $data = $request->only(\'body\');\r\n        $data = array_merge($data, [\r\n            \'user_id\' => Auth::user()->id,\r\n            \'question_id\' => $question,\r\n        ]);\r\n\r\n        $answer = $this->answerRepository->create($data);\r\n        $answer->question()->increment(\'answers_count\');\r\n\r\n        return back();\r\n    }\r\n}\r\n```\r\n\r\n### 创建 `AnswerRepository` \r\n\r\n这里使用了 Repository 模式。再来创建 `AnswerRepository`（内容非常简单）。\r\n\r\n```\r\nclass AnswerRepository\r\n{\r\n    public function create(array $attributes)\r\n    {\r\n        return Answer::create($attributes);\r\n    }\r\n}\r\n```\r\n\r\n## 创建路由\r\n\r\n在 `routes/web.php` 添加一个路由。\r\n\r\n```\r\nRoute::post(\'questions/{question}/answer\', \'AnswerController@store\')->name(\'answers.store\');\r\n```\r\n\r\n## 创建页面\r\n\r\n```\r\n<div class=\"row\">\r\n	<div class=\"col-md-8 col-md-offset-2\">\r\n		<div class=\"panel panel-default\">\r\n			<div class=\"panel-heading\">{{ $question->answers_count }} 个回答</div>\r\n			<div class=\"panel-body\">\r\n\r\n				@foreach ($question->answers as $answer)\r\n					<div class=\"media\">\r\n						<div class=\"media-left media-middle\">\r\n							<a href=\"#\">\r\n								<img src=\"{{ asset($answer->user->avatar) }}\" alt=\"{{ $answer->user->name }}的头像\"\r\n									 style=\"width: 32px; height: 32px;\"\r\n								>\r\n							</a>\r\n						</div>\r\n						<div class=\"media-body\">\r\n							<h4 class=\"media-heading\">\r\n								<a href=\"/users/{{ $answer->user->id }}\">\r\n									{{ $answer->user->name }}\r\n								</a>\r\n								{!! $answer->body !!}\r\n							</h4>\r\n						</div>\r\n					</div>\r\n				@endforeach\r\n\r\n				<form action=\"{{ route(\'answers.store\', [\'question\' => $question->id]) }}\" method=\"POST\">\r\n					{{ csrf_field() }}\r\n					<div class=\"form-group{{ $errors->has(\'body\') ? \' has-error\' : \'\' }}\">\r\n						<script id=\"container\" name=\"body\" type=\"text/plain\">\r\n							{!!  old(\'body\') !!}\r\n						</script>\r\n						@if ($errors->has(\'body\'))\r\n							<span class=\"help-block\">\r\n								<strong>{{ $errors->first(\'body\') }}</strong>\r\n							</span>\r\n						@endif\r\n					</div>\r\n					<div class=\"form-group\">\r\n						<input type=\"submit\" class=\"btn btn-primary btn-block\" value=\"回答\">\r\n					</div>\r\n				</form>\r\n			</div>\r\n		</div>\r\n	</div>\r\n</div>\r\n```','2017-06-25 18:19:15','2017-06-25 18:19:15','development-on-zhihu-submit-the-answer'),(115,3,3,'开发知乎：用户关注问题','## 简介\r\n\r\n> 难点：用户和被关注的问题是多对多关系；关注、取消关注操作；根据不同关注状态，显示“关注”、“正在关注”按钮。\r\n\r\n实现关注问题的技术手段主要是利用多对多关系中的 `toggle` 方法。\r\n\r\n```\r\n// User Model\r\npublic function follows()\r\n{\r\n	return $this->belongsToMany(Question::class, \'user_question\')->withTimestamps();\r\n}\r\n\r\npublic function followThis($question)\r\n{\r\n	$this->follows()->toggle($question);\r\n}\r\n\r\n// QuestionController\r\nAuth::user()->followThis($question);\r\n```\r\n\r\n## 迁移文件\r\n\r\n创建创建文件。\r\n\r\n```\r\n$ php artisan make:migration create_user_question_table --create=user_question\r\n```\r\n\r\n补充迁移文件内容。\r\n\r\n```\r\nSchema::create(\'user_question\', function (Blueprint $table) {\r\n	$table->increments(\'id\');\r\n	$table->unsignedInteger(\'user_id\');\r\n	$table->unsignedInteger(\'question_id\');\r\n	$table->timestamps();\r\n\r\n	$table->foreign(\'user_id\')\r\n		->references(\'id\')->on(\'users\')\r\n		->onDelete(\'cascade\');\r\n	$table->foreign(\'question_id\')\r\n		->references(\'id\')->on(\'questions\')\r\n		->onDelete(\'cascade\');\r\n});\r\n```\r\n\r\n执行迁移。\r\n\r\n```\r\n$ php artisan migrate\r\n```\r\n\r\n## Follow Model\r\n\r\n中间表对应的 Model 使用 `Follow`。\r\n\r\n```\r\n$ php artisan make:model Follow\r\n```\r\n\r\n补充 Follow Model 内容。\r\n\r\n```\r\nclass Follow extends Model\r\n{\r\n    protected $table = \'user_question\';\r\n\r\n    protected $fillable = [\r\n        \'question_id\',\r\n        \'user_id\',\r\n    ];\r\n\r\n```\r\n\r\n## User Model\r\n\r\nUser Model 中添加如下方法：\r\n\r\n1. `follows`：关系方法。通过这个方法可以找到用户关注的所有问题。\r\n2. `followThis`：关注/取消关注操作，主要利用多对多关系中的 `toggle` 方法实现关系插入/删除。\r\n3. `followed`：用户是否关注了某个问题，返回 `true` 或 `false`，前台根据这个逻辑显示按钮样式和文字。\r\n\r\n```\r\npublic function follows()\r\n{\r\n	return $this->belongsToMany(Question::class, \'user_question\')->withTimestamps();\r\n}\r\n\r\npublic function followThis($question)\r\n{\r\n	$this->follows()->toggle($question);\r\n}\r\n\r\npublic function followed($question)\r\n{\r\n	return !! $this->follows()->where(\'question_id\', $question)->count();\r\n}\r\n```\r\n\r\n## Question Model\r\n\r\n暂时没被用到，但是先把通过问题、找到其所有关注者的关系建立好。\r\n\r\n```\r\npublic function followers()\r\n{\r\n	return $this->belongsToMany(User::class, \'user_question\')->withTimestamps();\r\n}\r\n```\r\n\r\n## 路由\r\n\r\n在 `routes/web.php` 中添加路由。 \r\n\r\n```\r\nRoute::get(\'questions/{question}/follow\', \'QuestionController@follow\')->name(\'questions.follow\');\r\n```\r\n\r\n## 页面\r\n\r\n在问题展示页面，添加关注问题的按钮。\r\n\r\n```\r\n<div class=\"col-md-8 col-md-offset-1\">\r\n	<!-- 问题展示部分 -->\r\n</div>\r\n<div class=\"col-md-3\">\r\n	<div class=\"panel panel-default\">\r\n		<div class=\"panel-heading\">\r\n			<h2>{{ $question->followers_count }}</h2>\r\n			<span>关注者</span>\r\n		</div>\r\n		<div class=\"panel-body\">\r\n			<a href=\"{{ route(\'questions.follow\', [\'question\' => $question->id]) }}\"\r\n			   class=\"btn {{ Auth::user() && Auth::user()->followed($question->id) ? \'btn-success\' : \'btn-info\' }}\">\r\n				{{ Auth::user() && Auth::user()->followed($question->id) ? \'正在关注\' : \'关注\' }}\r\n			</a>\r\n			<a href=\"#editor\" class=\"btn btn-primary\">撰写答案</a>\r\n		</div>\r\n	</div>\r\n</div>\r\n```','2017-06-25 21:02:32','2017-06-25 21:03:03','development-on-zhihu-user-concerns'),(116,5,5,'Python：高级特性','## 切片\r\n取一个list或tuple的部分元素是非常常见的操作，例如，一个list如下：\r\n```\r\nA =  [\'chenys\',1,\'sunl\',2,3,4]\r\n```\r\n取前3个元素，应该怎么做？\r\n\r\n笨办法：\r\n```\r\nprint(A[0],A[1],A[2])\r\n```\r\n这样取值，如果取前N个元素就没辙了。\r\n\r\n取前N个元素，也就是索引为0-(0-1)的元素，可以用循环:\r\n```\r\nr = []\r\nn = 3\r\nfor i in range(n):\r\n    r.append(A[i])\r\nprint(r)\r\n\r\n```\r\n\r\n对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。\r\n\r\n对应上面的问题，取前3个元素，用一行代码就可以完成切片：\r\n```\r\nprint(A[0:3])\r\n\r\n```\r\n\r\n`L[0:3]`表示，从索引`0`开始取，直到索引`3`为止，但不包括索引`3`。即索引`0，1，2`，正好是3个元素。\r\n\r\n如果第一个元素是`0`，还可以省略：\r\n```\r\nprint(A[:3])\r\n```\r\n\r\n也可以从索引1开始，取出2个元素出来：\r\n\r\n```\r\nprint(A[1:3])\r\n```','2017-06-25 21:22:10','2017-06-25 21:58:30','python-advanced-features'),(117,3,3,'开发知乎：使用 Vue.js 组件实现关注功能','> 下面的操作都是基于 Laravel 5.4 版本。前端发送 Ajax 请求使用 [axios.js][1]。\r\n\r\n[1]: https://github.com/mzabriskie/axios\r\n\r\n## 准备\r\n\r\n### 新建组件文件\r\n\r\n在 `resources/assets/js/components` 下新建组件文件 `QuestionFollowButton.vue`。\r\n\r\n### 注册组件文件\r\n\r\n在 `resources/assets/js/app.js` 中注册我们自定义组件。\r\n\r\n```\r\nVue.component(\'question-follow-button\', require(\'./components/QuestionFollowButton.vue\'));\r\n```\r\n\r\n### 使用组件\r\n\r\n在 `resources/views/questions/show.blade` 模板文件中使用。\r\n\r\n```\r\n<!-- 将 -->\r\n <a href=\"{{ route(\'questions.follow\', [\'question\' => $question->id]) }}\"\r\n   class=\"btn {{ Auth::user() && Auth::user()->followed($question->id) ? \'btn-success\' : \'btn-info\' }}\">\r\n	{{ Auth::user() && Auth::user()->followed($question->id) ? \'正在关注\' : \'关注\' }}\r\n</a>\r\n\r\n<!-- 替换为 -->\r\n<question-follow-button question=\"{{ $question->id }}\" user=\"{{ $question->user->id }}\"></question-follow-button>\r\n```\r\n\r\n## 写组件\r\n\r\n在 Blade 模板中使用时，我们向组件 `<question-follow-button>` 通过标签属性的形式，传递了数据 `question` 和 `user`，这需**要在 `QuestionFollowButton.vue` 里通过 `props` 显式接收**。\r\n\r\n使用 `props` 显式接收父组件传递过来的数据。\r\n\r\n```\r\n<template>\r\n    <button class=\"btn\"\r\n        v-bind:class=\"[followed ? \'btn-success\' : \'btn-info\']\"\r\n        v-text=\"text\"\r\n        v-on:click=\"follow\"\r\n    ></button>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        props:[\'question\', \'user\'],\r\n        mounted() {\r\n            axios.post(\'/api/question/follower\', {question: this.question, user: this.user})\r\n                .then((response) => {\r\n                    this.followed = response.data.followed;\r\n                })\r\n                .catch(function (error) {\r\n                    console.log(error);\r\n                });\r\n        },\r\n        data() {\r\n            return {\r\n                followed: false\r\n            }\r\n        },\r\n        computed: {\r\n            text() {\r\n                return this.followed ? \'正在关注\' : \'关注\'\r\n            }\r\n        },\r\n        methods: {\r\n            follow() {\r\n                axios.post(\'/api/question/follow\', {\'question\': this.question, \'user\': this.user})\r\n                    .then((response) => {\r\n                        this.followed = response.data.followed;\r\n                    })\r\n                    .catch(function (error) {\r\n                        console.log(error);\r\n                    });\r\n            }\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n事件方法定义在 `methods` 里。\r\n\r\n## 路由\r\n\r\n在 `routes/api.php` 添加路由。\r\n\r\n```\r\nRoute::post(\'/question/follower\', function (Request $request) {\r\n    $followed = !! \\App\\Follow::where(\'question_id\', $request->input(\'question\'))\r\n        ->where(\'user_id\', $request->input(\'user\'))\r\n        ->count();\r\n    if ($followed)\r\n    {\r\n        return response()->json([\'followed\' => true]);\r\n    }\r\n    return response()->json([\'followed\' => false]);\r\n})->middleware(\'api\');\r\n\r\nRoute::post(\'/question/follow\', function (Request $request) {\r\n    $followed = \\App\\Follow::where(\'question_id\', $request->input(\'question\'))\r\n        ->where(\'user_id\', $request->input(\'user\'))\r\n        ->first();\r\n    if (! is_null($followed))\r\n    {\r\n        $followed->delete();\r\n        return response()->json([\'followed\' => false]);\r\n    }\r\n\r\n    \\App\\Follow::create([\r\n        \'question_id\' => $request->input(\'question\'),\r\n        \'user_id\'=> $request->input(\'user\'),\r\n    ]);\r\n    return response()->json([\'followed\' => true]);\r\n})->middleware(\'api\');\r\n```','2017-06-26 00:09:24','2017-06-26 00:09:43','development-on-zhihu-using-the-vue-js-component-implementation-focuses-on-function'),(118,3,3,'开发知乎：API token 认证','## 简介\r\n\r\n之前的问题关注里，Vue 组件中的 Ajax 请求都不需要认证。但是如果这个 Ajax 请求对应的路由（`routes/api.php` 中的）使用了 `auth:api` 中间件过滤，那么就需要进行 token 认证。条件有两个：\r\n\r\n1. 用户表里有 `api_token` 字段。\r\n2. Ajax 请求头部添加认证（形式如：`Authorization:Bearer  qIagGb3nUuxDpzqZ0KqTbFjAAwp7Yqv0vZahYmWIGythrncR3y2GUycVc0Lj`，`Bearer ` 后面的值就是用户的 `api_token` 字段值）。\r\n\r\n## 修改 `users` 表\r\n\r\n```\r\n$ composer require doctrine/dbal\r\n```\r\n\r\n```\r\n$  php artisan make:migation add_api_token_to_users --table=users\r\n```\r\n\r\n```\r\nclass AddApiTokenToUsers extends Migration\r\n{\r\n    /**\r\n     * Run the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function up()\r\n    {\r\n        Schema::table(\'users\', function (Blueprint $table) {\r\n            $table->string(\'api_token\', 64)->unique();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reverse the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function down()\r\n    {\r\n        Schema::table(\'users\', function (Blueprint $table) {\r\n            $table->dropColumn(\'api_token\');\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n```\r\n$ php artisan migrate\r\n```\r\n\r\n## 修改注册功能\r\n\r\n因为添加了一个字段 `api_token`，所以注册功能和 User Model 都要有些许修改。\r\n\r\n### 注册\r\n\r\n`RegisterController` 中创建用户的部分需要修改。\r\n\r\n```\r\n$user = User::create([\r\n	...\r\n	\'api_token\' => str_random(60),\r\n]);\r\n```\r\n\r\n### User Model\r\n\r\n允许批量创建的字段里也要加上 `api_token`。\r\n\r\n```\r\nprotected $fillable = [\r\n	\'name\', \'email\', \'password\', \'avatar\', \'confirmation_token\', \'api_token\',\r\n];\r\n```\r\n\r\n## 添加 `ApiToken`\r\n\r\n在布局文件中设置 `ApiToken`，以供 `axios.js`（Laravel 5.4 前端默认用 axios.js 作为发送 Ajax 请求的库） 取用。\r\n\r\n```\r\n<script>\r\n	window.Laravel = {\r\n		ApiToken: \'{{ Auth::check() ? \'Bearer \' . Auth::User()->api_token : \'Bearer \' }}\'\r\n	};\r\n</script>\r\n```\r\n\r\n在前端配置文件里（`bootstrap.js`）中为 `axios.js` Ajax 请求设置全局的头部认证。\r\n\r\n```\r\nlet token = document.head.querySelector(\'meta[name=\"csrf-token\"]\');\r\nlet apiToken = Laravel.ApiToken;\r\n\r\nif (token) {\r\n    window.axios.defaults.headers.common[\'X-CSRF-TOKEN\'] = token.content;\r\n    window.axios.defaults.headers.common[\'Authorization\'] = apiToken;\r\n} else {\r\n    console.error(\'CSRF token not found: https://laravel.com/docs/csrf#csrf-x-csrf-token\');\r\n}\r\n```','2017-06-26 00:27:42','2017-06-26 01:49:46','development-on-zhihu-api-token-authentication'),(119,3,3,'一千零一夜：第九夜','**（一）**\r\n\r\n淅沥沥现在下起雨来，下午4点46分。\r\n\r\n下班了，天也黑了。雨还没停。\r\n\r\n**（二）**\r\n\r\n在我回去的路上，雨不大，我也硬走到地铁站了。我的电脑今天下午到了，现在摆在床上。\r\n\r\n我在饺子店吃黄焖鸡，老板在切韭菜，味道很盛。\r\n\r\n**（三）**\r\n\r\n今晚没有散步，干脆就不散步了罢！','2017-06-26 07:17:42','2017-06-26 07:17:42','one-thousand-nights-9-nights'),(120,3,3,'Sublime 包安装和快捷键参考','为 Sublime 下载插件需要一个工具——Package Control。在新安装完的 Sublime 的 Prefrences 菜单下没有，所以先安装它。\r\n\r\n## 安装 Package Control\r\n\r\nCtrl + ` ` `，唤起控制台，在控制台中输入如下的文本。\r\n\r\n```\r\nimport urllib2,os,hashlib; h = \'df21e130d211cfc94d9b0905775a7c0f\' + \'1e3d39e33b79698005270310898eea76\'; pf = \'Package Control.sublime-package\'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( \'http://packagecontrol.io/\' + pf.replace(\' \', \'%20\')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), \'wb\' ).write(by) if dh == h else None; print(\'Error validating download (got %s instead of %s), please try manual install\' % (dh, h) if dh != h else \'Please restart Sublime Text to finish installation\')\r\n```\r\n\r\n安装完毕后，Ctrl + Shift + P 调出搜索框，搜索“Install Package”，在搜索过程中会出现“Package Control: Install Package”选项，Enter 选择，就会进入包搜索界面。\r\n\r\n下面以安装 Markdown Preview 为例。输入“Markdown Preview”，选择它，然后 Enter 即可。打开一个 md 文件，Ctrl + B 即可在当前目录生成一个同名的 HTML 文件。\r\n\r\n### 常用包\r\n\r\n1. Emmet\r\n\r\n## 常用快捷键\r\n\r\n1. 整行复制\r\n\r\nCtrl + Shift + D\r\n\r\n2. 整行上下移动\r\n\r\nCtrl + Shift + ↑\r\n\r\nCtrl + Shift + ↓kai\r\n\r\n3. 打开命令面板\r\n\r\nCtrl + Shift + P\r\n\r\n4. 搜索项目文件\r\n\r\nCtrl + P\r\n\r\n5. 粘贴并格式化\r\n\r\nCtrl + Shift + V\r\n\r\n6. 选择行\r\n\r\nCtrl + L（重复增加选择下一行）\r\n\r\n7. 删除当前行\r\n\r\nCtrl + X\r\n\r\n8. 替换\r\n\r\nCtrl + H','2017-06-26 17:22:26','2017-06-26 23:26:58','sublime-does-package-installation-and-shortcuts'),(121,3,3,'在 Windows 10 系统中安装 WNMP 环境','WNMP 又称 WEMP，即 Windows 系统下的 Nginx、MariaDB 和 PHP 环境搭建。\r\n\r\n这份教程的最后，我们将 WNMP 环境统一搭建在了 `D:\\wnmp` 目录下，这份目录的清单是这样的。\r\n\r\n```\r\nwnmp/\r\n├── php/\r\n│   └── 7.1.6/\r\n|		├── php.ini\r\n|		├── php-cgi.exe\r\n|		└── php.exe\r\n├── nginx/\r\n│   └── 1.13.1/\r\n|   	└── conf/\r\n|			└── nginx.conf\r\n└── www/\r\n    └── index.html\r\n```\r\n\r\n## 原料\r\n\r\n1. PHP\r\n\r\n下载地址：[php.net][1]。\r\n\r\n[1]: http://windows.php.net/download\r\n\r\n要注意的是，Nginx 需使用 PHP 的 FastCGI Server 模块，下载的 PHP 版本是“Non Thread Safe”的。\r\n\r\n比如：我下载的 PHP 版本文件名为 `php-7.1.6-nts-Win32-VC14-x64.zip`。\r\n\r\n2. Nginx\r\n\r\n下载地址：[nginx.org][2]。\r\n\r\n[2]: http://nginx.org/en/download.html\r\n\r\n我下载的 Nginx 版本文件名为 `nginx-1.13.1.zip`。\r\n\r\n3. RunHiddenConsole\r\n\r\n这是一个 exe 文件，是为了保证之后编写的启动 Nginx 服务器的 `start_nginx.bat` 脚本和关闭 Nginx 服务器的 `stop_nginx.bat` 脚本执行后立即关闭，隐藏于后台。\r\n\r\n下载地址：[lighttpd.net][3]。\r\n\r\n[3]: http://redmine.lighttpd.net/attachments/660/RunHiddenConsole.zip\r\n\r\n文件名即为 `RunHiddenConsole.zip`。\r\n\r\n4. MariaDB\r\n\r\n下载地址：[mariadb.org][4]。\r\n\r\n[4]: https://downloads.mariadb.org/\r\n\r\n我下载的 MariaDB 版本文件名为 `mariadb-10.2.6-winx64.msi`。\r\n\r\n## 安装 PHP\r\n\r\n因为 PHP 版本是 7.1.6，将 `php-7.1.6-nts-Win32-VC14-x64.zip` 里的内容解压到 `D:\\wnmp\\php\\7.1.6` 目录下。\r\n\r\n### 修改配置\r\n\r\n将 `php.ini-development` 重命名为 `php.ini`。进入修改三处。 \r\n\r\n1. 指定 PHP 扩展目录\r\n\r\nPHP 扩展就放在 ext 文件夹下。指定扩展目录时，使用绝对路径。\r\n\r\n```\r\n; 去掉注释，指定扩展目录\r\n\r\n; On windows:\r\nextension_dir = \"D:/wnmp/php/7.1.6/ext\"\r\n```\r\n\r\n2. 启用扩展\r\n\r\n默认许多扩展并没有开启，比如 mysqli、 openSSL。所以需要手动去掉注释，启用一些扩展。\r\n\r\n为了方便日后使用，把下面的扩展去掉注释。\r\n\r\n```\r\n; 像下面这样去掉注释，指定启用的扩展目录\r\n\r\n; Windows Extensions\r\n; Note that ODBC support is built in, so no dll is needed for it.\r\n; Note that many DLL files are located in the extensions/ (PHP 4) ext/ (PHP 5+)\r\n; extension folders as well as the separate PECL DLL download (PHP 5+).\r\n; Be sure to appropriately set the extension_dir directive.\r\n;\r\nextension=php_bz2.dll\r\nextension=php_curl.dll\r\nextension=php_fileinfo.dll\r\n;extension=php_ftp.dll\r\nextension=php_gd2.dll\r\nextension=php_gettext.dll\r\nextension=php_gmp.dll\r\nextension=php_intl.dll\r\nextension=php_imap.dll\r\n;extension=php_interbase.dll\r\nextension=php_ldap.dll\r\nextension=php_mbstring.dll\r\nextension=php_exif.dll      ; Must be after mbstring as it depends on it\r\nextension=php_mysqli.dll\r\n;extension=php_oci8_12c.dll  ; Use with Oracle Database 12c Instant Client\r\nextension=php_openssl.dll\r\n;extension=php_pdo_firebird.dll\r\nextension=php_pdo_mysql.dll\r\n;extension=php_pdo_oci.dll\r\n;extension=php_pdo_odbc.dll\r\n;extension=php_pdo_pgsql.dll\r\nextension=php_pdo_sqlite.dll\r\n;extension=php_pgsql.dll\r\n;extension=php_shmop.dll\r\n\r\n; The MIBS data available in the PHP distribution must be installed.\r\n; See http://www.php.net/manual/en/snmp.installation.php\r\n;extension=php_snmp.dll\r\n\r\nextension=php_soap.dll\r\nextension=php_sockets.dll\r\nextension=php_sqlite3.dll\r\n;extension=php_tidy.dll\r\nextension=php_xmlrpc.dll\r\nextension=php_xsl.dll\r\n```\r\n\r\n3. 设置 cgi.fix_pathinfo。\r\n\r\n```\r\n; 去掉注释，将 cgi.fix_pathinfo 设置为 1\r\n\r\ncgi.fix_pathinfo=1\r\n```\r\n\r\n### 设置全局变量\r\n\r\n将路径 `D:\\wnmp\\php\\7.1.6` 设置到系统全局环境变量 `PATH` 里。\r\n\r\n进入命令界面，输入如下命令，如果正确输出版本号，说明设置成功。\r\n\r\n```\r\n$ php -v\r\nPHP 7.1.6 (cli) (built: Jun  8 2017 01:52:52) ( NTS MSVC14 (Visual C++ 2015) x64\r\n )\r\nCopyright (c) 1997-2017 The PHP Group\r\nZend Engine v3.1.0, Copyright (c) 1998-2017 Zend Technologies\r\n```\r\n\r\n## 安装 Nginx\r\n\r\n解压 `nginx-1.13.1.zip` 文件中内容到 `D:\\wnmp\\nginx\\1.13.1` 目录下。\r\n\r\n## 修改配置\r\n\r\n进入 `conf` 目录，编辑配置文件 `nginx.conf`。修改 80 端口的 Server 配置信息，具体如下。\r\n\r\n```\r\nlocation / {\r\n    root   html;\r\n    index  index.html index.htm;\r\n}\r\n\r\n# 改为\r\n\r\nlocation / {\r\n    root   D:/wnmp/www;\r\n    index  index.php index.html index.htm;\r\n}\r\n```\r\n\r\n```\r\n# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\r\n#\r\n#location ~ \\.php$ {\r\n#    root           html;\r\n#    fastcgi_pass   127.0.0.1:9000;\r\n#    fastcgi_index  index.php;\r\n#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\r\n#    include        fastcgi_params;\r\n#}\r\n\r\n# 改为\r\n\r\n# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\r\n#\r\nlocation ~ \\.php$ {\r\n    root           D:/wnmp/www;\r\n    fastcgi_pass   127.0.0.1:9000;\r\n    fastcgi_index  index.php;\r\n    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\r\n    include        fastcgi_params;\r\n}\r\n```\r\n\r\n要注意两点：\r\n\r\n1. 我们将网站根目录设置到了 `D:/wnmp/www` 目录中，所以**务必要创建 `D:/wnmp/www` 目录**！\r\n\r\n2. 最后一部分配置内容是将 `.php` 后缀的文件都交给 PHP 开在 9000 端口的 FastCGI Server 处理。\r\n\r\n## 开启 Nginx 服务器\r\n\r\n第一步，解压 `RunHiddenConsole.zip` 文件得到 `RunHiddenConsole.exe`，将它放在与 `php.exe` 同级的目录，就是本教程的 `D:\\wnmp\\php\\7.1.6` 目录。\r\n\r\n我们已经说过，`RunHiddenConsole.exe` 的作用为了保证启动 Nginx 服务器的 `start_nginx.bat` 脚本和关闭 Nginx 服务器的 `stop_nginx.bat` 脚本执行后立即关闭，隐藏于后台的。\r\n\r\n接下来，我们来编写启动和关闭 Nginx 服务器的脚本，它们放在与 `nginx.exe` 同级的目录中，就是本教程的 `D:\\wnmp\\nginx\\1.13.1` 目录。\r\n\r\n### 启动 Nginx 的脚本\r\n\r\n启动 Nginx 的脚本名为 `start_nginx.bat`。内容如下：\r\n\r\n```\r\n@echo off\r\n\r\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\r\nset PHP_FCGI_MAX_REQUESTS=1000\r\n\r\necho Starting PHP FastCGI...\r\nRunHiddenConsole php-cgi -b 127.0.0.1:9000 -c D:/wnmp/php/7.1.6/php.ini\r\n\r\necho Starting nginx...\r\nRunHiddenConsole ./nginx.exe -p D:/wnmp/nginx/1.13.1\r\n```\r\n\r\n### 关闭 Nginx 的脚本\r\n\r\n关闭 Nginx 的脚本名为 `stop_nginx.bat`。内容如下：\r\n\r\n```\r\n@echo off\r\necho Stopping nginx...  \r\ntaskkill /F /IM nginx.exe > nul\r\necho Stopping PHP FastCGI...\r\ntaskkill /F /IM php-cgi.exe > nul\r\nexit\r\n```\r\n\r\n### 浏览器访问\r\n\r\n在 `D:/wnmp/www` 中创建文件 `index.php`。\r\n\r\n```\r\n<?php\r\n	phpinfo();\r\n>\r\n```\r\n\r\n点击 `start_nginx.bat` 文件，浏览器输入 http://localhost/ ，如果出现 PHP 配置信息界面，表示服务器安装成功！\r\n\r\n## MariaDB \r\n\r\nMariaDB 数据库安装过程非常简单，这里不再赘述了。:-D','2017-06-26 22:54:22','2017-06-29 15:37:12','10-wnmp-installed-in-the-system-environment-on-windows'),(122,3,3,'在 Windows 10 系统中安装 Composer','## 简介\r\n\r\nComposer 是 PHP 的一个依赖包管理工具，它允许你在 `composer.json` 文件中声明项目所依赖的包，在你使用 `composer install` 后为你的项目安装它们。\r\n\r\n## 安装 Composer\r\n\r\n在安装 Composer 前请务必确保已经正确安装了 PHP――打开命令行窗口并执行 `php -v` 查看是否正确输出版本号。\r\n\r\n### 下载 Composer\r\n\r\n从 [getcomposer.org][1] 下载 `composer.phar`（我下载的是 1.4.2 版本的）。并将该文件放置在与 `php.exe` 同级的目录下（我的地址为 `D:\\wnmp\\php\\7.1.6`）。键入 `php composer.phar -V`，如果正确输出 composer 版本号，说明安装成功。\r\n\r\n```\r\n$ php composer.phar -V\r\nComposer version 1.4.2 2017-05-17 08:17:52\r\n```\r\n\r\n### 全局配置\r\n\r\n像上面那样这样操作，还是很麻烦，能全局直接使用 `composer` 命令是再好不过的了。接下来就实现。\r\n\r\n新建 `composer.bat` 文件，放置于与 `php.exe` 同级的目录下。内容如下：\r\n\r\n```\r\n@php \"%~dp0composer.phar\" %*\r\n```\r\n\r\n接下来打开命令行界面，输入 `composer` 指令。如果正确输出 composer 版本号，说明 Composer 全局配置成功！\r\n\r\n```\r\nC:\\Users\\zhangb>composer -V\r\nComposer version 1.4.2 2017-05-17 08:17:52\r\n```\r\n\r\n## 设置中国镜像\r\n\r\n因为一些不得而知的原因，国外镜像下载速度并不稳定。接下来，将依赖的包下载源更换成 [Composer 中国全量镜像][2] 提供的地址。\r\n\r\n```\r\n$ composer config -g repo.packagist composer https://packagist.phpcomposer.com\r\n```\r\n\r\n查阅是否更换成功。\r\n\r\n```\r\n$ composer config -gl\r\n```\r\n\r\n[1]: https://getcomposer.org/download/\r\n[2]: https://pkg.phpcomposer.com/','2017-06-26 23:24:40','2017-06-26 23:51:11','in-windows-10-composer-installed-in-the-system'),(123,3,3,'前端软件下载地址','1. Node.js \r\n\r\nhttps://nodejs.org/en/download/\r\nnode-v6.11.0-x64.msi\r\n\r\n2. MariaDB\r\n\r\nhttps://downloads.mariadb.org/\r\nmariadb-10.2.6-winx64.msi\r\n\r\n3. PHP\r\n\r\nhttp://windows.php.net/download\r\nphp-7.1.6-nts-Win32-VC14-x64.zip\r\n\r\n4. Nginx\r\n\r\nhttp://nginx.org/en/download.html\r\nnginx-1.13.1.zip\r\n\r\n5. Git\r\n\r\nhttps://git-scm.com/downloads\r\nGit-2.13.1.2-64-bit.exe\r\n\r\n6. sublime\r\n\r\nhttp://www.sublimetext.com/\r\nSublime Text Build 3126 x64 Setup.exe','2017-06-26 23:53:59','2017-06-26 23:53:59','the-front-end-software-download-address'),(124,3,3,'开发知乎： Vue.js 组件实现关注功能（改进版）','## 回顾\r\n\r\n在 [之前的课程][1] 中，我们用 Vue 组件开发 API 版的“问题关注”，现在回头来看，代码有不安全和不够优雅的缺点。\r\n\r\n[1]: http://www.baooab.com/discussions/development-on-zhihu-using-the-vue-js-component-implementation-focuses-on-function\r\n\r\n### 不够安全\r\n\r\n在之前的代码中，判断是否是否关注问题时，我们直接传递了用户ID。如下：\r\n\r\n```\r\n export default {\r\n        props:[\'question\', \'user\'],\r\n        mounted() {\r\n            axios.post(\'/api/question/follower\', {question: this.question, user: this.user})\r\n```\r\n\r\n这就存在一个漏洞——只要用户登录，那么它就可以直接模拟别的用户关注/不关注某个问题。\r\n\r\n### 不够优雅\r\n\r\n我们在 `routes/api.php` 中写的代码也非常冗余和丑陋。\r\n\r\n### 一个窍门\r\n\r\n有一个窍门就是可以使用 `Auth::guard(\'api\')->user()` 简化这两个难题。\r\n\r\n## 改进代码\r\n\r\n### `QuestionFollowButton.vue`\r\n\r\n把两个请求 `/api/question/follower` 和 `/api/question/follow` 请求的 `user` 参数去掉。\r\n\r\n```\r\nmounted() {\r\n            axios.post(\'/api/question/follower\', {question: this.question})\r\n	\r\n	...\r\n	\r\nmethods: {\r\n	follow() {\r\n		axios.post(\'/api/question/follow\', {\'question\': this.question})\r\n```\r\n\r\n### `api.php`\r\n\r\n1. 先要修改 User Model 一处：\r\n\r\n```\r\npublic function followThis($question)\r\n{\r\n    $this->follows()->toggle($question);\r\n}\r\n\r\n // 改为\r\n \r\npublic function followThis($question)\r\n{\r\n    return $this->follows()->toggle($question);\r\n}\r\n```\r\n\r\n`toggle` 方法返回的数据类型类似：\r\n\r\n```\r\narray:2 [\r\n  \"attached\" => array:1 [\r\n    0 => 15\r\n  ]\r\n  \"detached\" => []\r\n]\r\n```\r\n\r\n上面的数据显示，此时用户做的操作是*关注*，关注了 `id` 是 15 的提问。否则，`attached` 键对应的数组为空， `detached` 键对应的数组不为空（长度为1）。\r\n\r\n可以根据着这个返回的数据，判断用户的操作行为，从而给问题关注数 `加1` / `减1`。\r\n\r\n2. 修改路由\r\n\r\n```\r\nRoute::post(\'/question/follower\', function (Request $request) {\r\n    $user = Auth::guard(\'api\')->user();\r\n\r\n    $followed = $user->followed($request->input(\'question\'));\r\n    if ($followed)\r\n    {\r\n        return response()->json([\'followed\' => true]);\r\n    }\r\n\r\n    return response()->json([\'followed\' => false]);\r\n})->middleware(\'auth:api\');\r\n\r\nRoute::post(\'/question/follow\', function (Request $request) {\r\n    $user = Auth::guard(\'api\')->user();\r\n    $question = Question::findOrFail($request->input(\'question\'));\r\n\r\n    $followed = $user->followThis($request->input(\'question\'));\r\n    if (count($followed[\'detached\']) > 0)\r\n    {\r\n        $question->decrement(\'followers_count\');\r\n        return response()->json([\'followed\' => false]);\r\n    }\r\n\r\n    $question->increment(\'followers_count\');\r\n    return response()->json([\'followed\' => true]);\r\n})->middleware(\'auth:api\');\r\n```','2017-06-27 00:39:37','2017-06-27 00:58:12','development-on-zhihu-vue-js-component-implementation-focus-on-function-improved-version'),(125,3,3,'一千零一夜：第十夜','跑完步回来，还未洗澡。我想到一战全球二十亿人口，但现在七十多亿，据说以后能达一百亿。多出来这么多人等于原始冲动加组成人体蛋白质的元素。\r\n\r\n这么看，人和动物在本质上是没区别的。因为有思想，以人为本，所以一切以人的意志为衡量标准。\r\n\r\n有几辆公路车在我旁边骑过，回头看时，瘦瘦的轮胎上，细小的车座被大屁股塞着。\r\n\r\n浙江路桥边，有两个异乡人（像清真饭馆的人），拿着弹弓打苏州河里的饮料罐头，挺准的，罐头飘走之后，又开始打桥下掉着得空矿泉水瓶子。我看着，最后他们走了。\r\n\r\n我发现我现在的写的是给未来我的礼物。','2017-06-27 06:24:47','2017-06-27 06:24:47','one-thousand-nights-the-tenth-night'),(126,3,3,'安装 Laravel.io','## 安装 PHP 依赖\r\n\r\n`composer install`\r\n\r\n安装在 `package.json` 里声明的依赖。\r\n\r\n## 配置环境\r\n\r\n先创建数据库，然后再创建拥有该数据库权限的用户。\r\n\r\n### 创建数据库\r\n\r\n创建数据库 `laravelio`（`utf8mb4_general_ci` 编码）。\r\n\r\n```\r\nCREATE DATABASE `laravelio` /*!40100 COLLATE \'utf8mb4_general_ci\' */\r\n```\r\n\r\n### 创建用户\r\n\r\n创建用户 `zhangb`，并给予数据库 `laravelio` 的所有权限。\r\n\r\n```\r\nCREATE USER \'zhangb\'@\'localhost\' IDENTIFIED BY \'123456\';\r\nGRANT USAGE ON *.* TO \'zhangb\'@\'localhost\';\r\nGRANT SELECT, EXECUTE, SHOW VIEW, ALTER, ALTER ROUTINE, CREATE, CREATE ROUTINE, CREATE TEMPORARY TABLES, CREATE VIEW, DELETE, DROP, EVENT, INDEX, INSERT, REFERENCES, TRIGGER, UPDATE, LOCK TABLES  ON `laravelio`.* TO \'zhangb\'@\'localhost\' WITH GRANT OPTION;\r\nFLUSH PRIVILEGES;\r\nSHOW GRANTS FOR \'zhangb\'@\'localhost\';\r\n```\r\n\r\n### 配置环境文件\r\n\r\n`cp .env.example .env`\r\n\r\n## 新的 key\r\n\r\n`php artisan key:generate`\r\n\r\n## 迁移&插入伪数据\r\n\r\n`php artisan migrate --seed`\r\n\r\n## 安装 Webpack\r\n\r\n```\r\n$ npm install webpack -g \r\n```\r\n\r\n## 安装前端依赖\r\n\r\n`npm install`\r\n\r\n## 编译前端\r\n\r\n```\r\n$ npm run production\r\n```\r\n\r\n## 开启服务\r\n\r\n`php artisan serve`\r\n\r\n## 浏览器浏览\r\n\r\nlocalhost:8000','2017-06-27 17:54:15','2017-06-28 01:25:56','install-laravel-io'),(127,3,3,'一千零一夜：第11夜','这天晚上，也就是这时候，我刚洗完澡躺在床上。窗户关着，我旁边空调的风吹出来。\r\n\r\n我原本并没有心意写出什么，但日久天长，也不是难能写出点什么。日子这样过去，我在不久之前还在专心看一个项目的源代码。\r\n\r\n时间竟这样无声无息的过去，我没有感觉，但理智和身体告诉我，时间确实过去。不用刻意的留意，就像每年年底都会有总结风气。\r\n\r\n到底过得怎样，以未来的眼光看现在，并不一定公正。没有计划，没有规划，职业的。危机好像在我周围四伏着。\r\n\r\n我有三天是完全没有看书了，也不觉得后悔。我的注意力完全放在代码上了。唉。\r\n\r\n但现在，我还没有什么规划呢。竟然，想掩盖生命无意义的本质也变得困难起来。','2017-06-28 05:53:47','2017-06-28 05:58:02','one-thousand-night-night-11'),(128,3,3,'当你要说（小诗）','当你要说去那里 去\r\n\r\n当你要说来这里 来\r\n\r\n不说啥\r\n\r\n可能痛苦一场\r\n\r\n可能麻木无意\r\n\r\n就这样\r\n\r\n你要说明天不一起散步了\r\n\r\n不说话了\r\n\r\n不相见了\r\n\r\n悲而不伤\r\n\r\n凉儿\r\n\r\n2017.6','2017-06-28 06:55:26','2017-06-28 06:55:59','when-you-say-poem'),(129,3,3,'Laravel.io 社区源码阅读：序言','上个周末，我在 [Laravel News][1] 读到了 [Laravel.io 社区网站改版的消息][2]，新版网站基于 Laravel 5.4 编写，并且开源！\r\n\r\n就像文章里说：\r\n\r\n> The entire portal is open source and can be used as both a learning resource and as a project to contribute too.\r\n\r\n我觉得这是个学习的好机会，在昨天 [我 Fork 了源代码][3]，并开始阅读。接下里的时间里，我会把项目源码的一些实现过程和编码技巧总结下来，写出来。\r\n\r\n基本计划是写成一个系列文章。\r\n\r\n（完）\r\n\r\n[1]: https://laravel-news.com/\r\n[2]: https://laravel-news.com/laravel-io-launches-its-next-version\r\n[3]: https://github.com/baooab/laravelio','2017-06-28 17:34:35','2017-06-28 17:34:35','laravel-io-community-source-reading-preface'),(130,3,3,'Laravel.io 社区源码阅读：Github 登录','## 简介\r\n\r\nLaravel.io 社区网站支持 Github 账号登录，用户可直接用 Github 账号登录。\r\n\r\n### 好处\r\n\r\n1. 注册时， 不需要提供密码。\r\n2. 使用 Github 账号直接登录。\r\n\r\n### 原理\r\n\r\n这里用到的核心技术是 Github 提供的 OAuth 授权功能。OAuth 授权的方式如下：\r\n\r\n1. 客户端提供 `client_id` 和 `redirect_uri` 字段，向 OAuth 服务器（这里是指 Github 提供的服务）请求授权。\r\n2. OAuth 服务器给客户端返回一个 Code 码。\r\n3. 客户端使用 Code 码、`client_id` 、`client_secret` 和 `redirect_uri` 再次向 OAuth 服务器请求。\r\n4. OAuth 服务器给客户端返回 `access_token`。\r\n5. 客户端使用这个 `access_token` 就可以获取授权用户的数据了。\r\n\r\n在本项目中，使用了 Laravel Socialite 这个包用来处理客户端与 OAuth 服务的交互细节，并且只暴露统一的两个接口。\r\n\r\n项目中具体实现 Github OAuth 授权流程如下：\r\n\r\n1. 在 Github [创建一个 OAuth Application][1]，得到 `Client ID` 和 `Client Secret`。\r\n\r\n[1]: https://github.com/settings/applications/new\r\n\r\n2. 在 Laravel 项目中，下载 [Laravel Socialite][2] 依赖，并按照文档进行配置。：\r\n\r\n	* `redirectToProvider`：跳转至应用认证界面。\r\n	* `handleProviderCallback`：处理回调逻辑。\r\n	\r\n		在这个方法里，可以直接用 `Socialite::driver(\'github\')->user()` 得到社交网站上的用户数据。\r\n\r\n[2]: https://github.com/laravel/socialite\r\n\r\n## 实现\r\n\r\n### Laravel Socialite 的配置\r\n\r\nLaravel Socialite 包的配置文件是 `config/services.php`。Github OAuth Application 配置信息写在 `.env` 文件中。\r\n\r\n```\r\n// config/services.php\r\n\'github\' => [\r\n	\'client_id\' => env(\'GITHUB_ID\'),\r\n	\'client_secret\' => env(\'GITHUB_SECRET\'),\r\n	\'redirect\' => env(\'GITHUB_URL\'),\r\n],\r\n\r\n// .env\r\nGITHUB_ID=your-github-app-id\r\nGITHUB_SECRET=your-github-app-secret\r\nGITHUB_URL=http://lio.app/auth/github\r\n```\r\n\r\n注意这里的 `GITHUB_URL` 和在 Github 账号里 `Authorization callback URL` 的关系：**前者地址包含后者地址**，就是说在 Github 上，**将  `Authorization callback URL` 设置为 `http://lio.app` 是最棒**的，就是后期 `auth/github` 改为 `auth/v2/github` 也不影响使用。\r\n\r\n### 路由\r\n\r\n之前已经说过，Laravel Socialite 主要给我们暴露了两个处理方法，我们势必要对两个两个方法进行路由分配。\r\n\r\n```\r\n/routes/web.php\r\n\', [\'as\' => \'login.github\', \'uses\' => \'GithubController@redirectToProvider\']);\r\nRoute::get(\'auth/github\', \'GithubController@handleProviderCallback\');\r\n```\r\n\r\n`login/github` 用来跳转到 Github 授权界面，`auth/github` 用来处理回调逻辑（使用 Github 账号登录、注册的核心逻辑都在这里）。\r\n\r\nLaravel Socialite 核心处理方法是 `Socialite::driver(\'github\')`，授权界面跳转、授权用户信息获取都依靠它。\r\n\r\n下面来看，控制 Laravel.io 社区项目中 Github 账号登录的控制器 `GithubController`。\r\n\r\n### `GithubController`\r\n\r\n```\r\npublic function redirectToProvider()\r\n{\r\n	return Socialite::driver(\'github\')->redirect();\r\n}\r\n\r\npublic function handleProviderCallback()\r\n{\r\n	$socialiteUser = Socialite::driver(\'github\')->user();\r\n	try {\r\n		$user = User::findByGithubId($socialiteUser->getId());\r\n		return $this->userFound($user);\r\n	} catch (ModelNotFoundException $exception) {\r\n		return $this->userNotFound(new GithubUser($socialiteUser->user));\r\n	}\r\n}\r\n```\r\n\r\n`redirectToProvider` 跳转至 Github 授权界面。\r\n\r\n`handleProviderCallback` 处理授权用户的数据操作，分两种情况：\r\n\r\n1. 用户还未使用 Github 账号注册信息：此时使用 `userNotFound` 方法——将 Github 用户的数据存储近 Session，进入注册界面，确定昵称、邮箱和用户名。\r\n\r\n2. 用户已注册：此时直接获取 Github User Id，在数据库中找到用户，`Auth::login($user)` 登录、跳转即可。','2017-06-28 18:17:50','2017-06-28 21:16:22','laravel-io-community-source-reading-making-login'),(131,3,3,'Laravel 在 config/mail.php 中统一配置 Mailable 类的 from 方法','`config/mail.php` 中：\r\n\r\n```\r\n\'from\' => [\r\n	\'address\' => \'example@example.com\', \r\n	\'name\' => \'App Name\',\r\n],\r\n```\r\n\r\n这样就不用再每个 `Mailable` 类里傻乎乎的写 `from` 了。\r\n\r\n```\r\npublic function build()\r\n{\r\n    return $this->from(\'example@example.com\') // 傻乎乎的\r\n                ->view(\'emails.orders.shipped\')\r\n				->with([\r\n                        \'orderName\' => $this->order->name,\r\n                        \'orderPrice\' => $this->order->price,\r\n                    ]);\r\n}\r\n```','2017-06-28 21:40:31','2017-06-28 23:28:40','laravel-in-configmail-php-unified-configuration-mailable-the-from-of-a-class-method'),(132,3,3,'设置管理员密码','明文密码：20170629\r\n\r\nselect * from Sys_User where Name = \'LiLei\';\r\n\r\nupdate Sys_User set Password = \'68966BF6343CBBD956E5EC3DCCBD48A1\' where Name = \'sysadmin\';','2017-06-28 22:45:07','2017-06-28 22:45:07','set-the-administrator-password'),(133,3,3,'Laravel 的 make:auth Artisan 命令到底生成了哪些文件？','众所周知，在 Laravel 中执行\r\n\r\n```\r\n$ php artisan make:auth\r\n$ php artisan migrate\r\n```\r\n\r\n命令后，我们就能拥有一个完整的登录、注册认证系统，这为开发带来极大的便利。\r\n\r\n但 `make:auth` 命令执行，到底生成了哪些文件、做了哪些修改呢？\r\n\r\n在此之前，需要清楚的是，安装完一个 Laravel 项目后：\r\n\r\n1. 框架内部已存在认证所需的控制器。在 `App\\Http\\Controllers\\Auth` 命名空间下，包括 `LoginController`、`RegisterController`、`ForgotPasswordController` 和 `ResetPasswordController` 四个控制器。\r\n2. 框架内部已存在认证所需的迁移表文件。在 `database/migrations` 文件夹下，包括 `2014_10_12_000000_create_users_table.php` 和 `2014_10_12_100000_create_password_resets_table.php` 两个。\r\n\r\n当执行 `php artisan make:auth` 命令时，Laravel 做了什么 [官方文档有说][1]，具体是生成、修改了下面的文件：\r\n\r\n[1]: https://laravel.com/docs/5.4/authentication#authentication-quickstart\r\n\r\n**视图**\r\n\r\n创建了下面的 6 个 Blade 视图文件。\r\n\r\n1. `home.blade.php`。\r\n2. `layouts/app.blade.php`。\r\n3. `auth/login.blade.php`。\r\n4. `auth/register.blade.php`。\r\n5. `auth/passwords/email.blade.php`。\r\n6. `auth/passwords/reset.blade.php`。\r\n\r\n**控制器**\r\n\r\n创建了 1 个控制器 `HomeController`。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse Illuminate\\Http\\Request;\r\n\r\nclass HomeController extends Controller\r\n{\r\n    /**\r\n     * Create a new controller instance.\r\n     *\r\n     * @return void\r\n     */\r\n    public function __construct()\r\n    {\r\n        $this->middleware(\'auth\');\r\n    }\r\n\r\n    /**\r\n     * Show the application dashboard.\r\n     *\r\n     * @return \\Illuminate\\Http\\Response\r\n     */\r\n    public function index()\r\n    {\r\n        return view(\'home\');\r\n    }\r\n}\r\n```\r\n\r\n**路由**\r\n\r\n为 `routes/web.php` 中注册了认证系统使用的路由。\r\n\r\n```\r\nAuth::routes();\r\n\r\nRoute::get(\'/home\', \'HomeController@home\')->(\'name\');\r\n```\r\n\r\n（完）','2017-06-28 23:12:28','2017-07-11 20:44:20','laravel-make-auth-artisan-command-what-generates-the-file'),(134,3,3,'一千零一夜：第12夜','用 Windows 10 系统编程，对程序员还有有伤害的。\r\n\r\n我又是穷光蛋了。\r\n\r\n现在的作息也不对。编程时间太多，完全没做其它事情的时间了。','2017-06-29 14:47:06','2017-06-29 14:47:06','one-thousand-night-night-12'),(135,3,3,'WIndows 系统中 hosts 文件位置','```\r\nC:\\Windows\\System32\\drivers\\etc\r\n```','2017-06-29 15:42:46','2017-06-29 15:42:46','windows-hosts-file-location-in-the-system'),(136,3,3,'快速部署 Laravel 所需的 PHP 环境','1. `composer.bat`、`composer.phar`。\r\n\r\n前者内容：\r\n\r\n```\r\n@php \"%~dp0composer.phar\" %*\r\n```\r\n\r\n2. `RunHiddenConsole.exe`。\r\n\r\n3. `start_nginx.bat`、`stop_nginx.bat`。\r\n\r\n前者内容：\r\n\r\n```\r\n@echo off\r\n\r\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\r\nset PHP_FCGI_MAX_REQUESTS=1000\r\n\r\nRunHiddenConsole D:/wnmp/php/5.6.30/php-cgi.exe -b 127.0.0.1:9002 -c D:/wnmp/php/5.6.30/php.ini\r\n\r\necho Starting nginx...\r\nRunHiddenConsole D:/wnmp/nginx/1.13.1/nginx.exe -p D:/wnmp/nginx/1.13.1\r\n```\r\n\r\n后者内容：\r\n\r\n```\r\n@echo off\r\necho Stopping nginx...  \r\ntaskkill /F /IM nginx.exe > nul\r\necho Stopping PHP FastCGI...\r\ntaskkill /F /IM php-cgi.exe > nul\r\nexit\r\n```','2017-06-29 15:57:44','2017-06-29 15:57:44','required-for-rapid-deployment-laravel-php-environment'),(137,3,3,'如何以个人邮件的方式在 Laravel 发送账号激活邮件和密码设置邮件','## 邮件配置\r\n\r\n`.env`。\r\n\r\n```\r\nMAIL_DRIVER=smtp\r\nMAIL_HOST=smtp.qq.com\r\nMAIL_PORT=465\r\nMAIL_USERNAME=3183442656@qq.com\r\nMAIL_PASSWORD=lbdstjgtueefdhaf\r\nMAIL_ENCRYPTION=ssl\r\nMAIL_FROM_ADDRESS=3183442656@qq.com\r\nMAIL_FROM_NAME=乱炖社区\r\n```\r\n\r\n## 账号激活邮件\r\n\r\n`RegisterController` 的 `create` 方法：\r\n\r\n```\r\nuse App\\Jobs\\SendEmailConfirmation;\r\n\r\n$this->dispatchNow(new SendEmailConfirmation($user));\r\n```\r\n\r\n`SendEmailConfirmation`。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Jobs;\r\n\r\nuse App\\User;\r\nuse App\\Mail\\EmailConfirmation;\r\nuse Illuminate\\Contracts\\Mail\\Mailer;\r\nuse Illuminate\\Queue\\SerializesModels;\r\n\r\nclass SendEmailConfirmation\r\n{\r\n    use SerializesModels;\r\n\r\n    /**\r\n     * @var \\App\\User\r\n     */\r\n    private $user;\r\n\r\n    public function __construct(User $user)\r\n    {\r\n        $this->user = $user;\r\n    }\r\n\r\n    public function handle(Mailer $mailer)\r\n    {\r\n        $mailer->to($this->user->emailAddress())\r\n            ->send(new EmailConfirmation($this->user));\r\n    }\r\n}\r\n```\r\n\r\n`EmailConfirmation`。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Mail;\r\n\r\nuse App\\User;\r\nuse Illuminate\\Mail\\Mailable;\r\nuse Illuminate\\Queue\\SerializesModels;\r\n\r\nclass EmailConfirmation extends Mailable\r\n{\r\n    use SerializesModels;\r\n\r\n    /**\r\n     * @var \\App\\User\r\n     */\r\n    public $user;\r\n\r\n    public function __construct(User $user)\r\n    {\r\n        $this->user = $user;\r\n    }\r\n\r\n    /**\r\n     * Build the message.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        return $this->subject(\'Confirm your SalivaForum email address\')\r\n            ->markdown(\'emails.email_confirmation\');\r\n    }\r\n}\r\n```\r\n\r\n`email_confirmation.blade.php`。\r\n\r\n```\r\n@component(\'mail::message\')\r\n# Welcome to SalivaForum!\r\n\r\nThanks for joining up with the [SalivaForum](https://www.baooab.com) community!\r\n\r\nWe just need to confirm your email address so please click the button below to confirm it:\r\n\r\n@component(\'mail::button\', [\'url\' => route(\'email.confirm\', [$user->emailAddress(), $user->confirmationCode()])])\r\nConfirm Email Address\r\n@endcomponent\r\n\r\nWe hope to see you soon on the portal.\r\n\r\nRegards,<br>\r\n{{ config(\'app.name\') }}\r\n@endcomponent\r\n```\r\n\r\n`email.confirm` 路由。\r\n\r\n```\r\nRoute::group([\'namespace\' => \'Auth\'], function () {\r\n\r\n    Route::get(\'email-confirmation\', [\'as\' => \'email.send_confirmation\', \'uses\' => \'EmailConfirmationController@send\']);\r\n    Route::get(\'email-confirmation/{email_address}/{code}\', [\'as\' => \'email.confirm\', \'uses\' => \'EmailConfirmationController@confirm\']);\r\n\r\n});\r\n```\r\n\r\n`EmailConfirmationController`。\r\n\r\n```\r\npublic function confirm(User $user, string $code)\r\n{\r\n	if ($user->matchesConfirmationCode($code)) {\r\n		$user->confirm();\r\n		return redirect()->route(\'dashboard\')->with(\'status\', \'邮箱验证成功！\');\r\n	}\r\n\r\n	return  redirect(\'/\')->with(\'status\', \'邮箱验证失败！\');\r\n}\r\n```\r\n\r\nUser Model\r\n\r\n```\r\npublic function matchesConfirmationCode(string $code): bool\r\n{\r\n	return $this->confirmation_code === $code;\r\n}\r\n\r\npublic function confirm()\r\n{\r\n	$this->update([\'confirmed\' => true, \'confirmation_code\' => null]);\r\n}\r\n```\r\n\r\n## 密码重置邮件\r\n\r\nUser Model\r\n\r\n```\r\nuse Illuminate\\Support\\Facades\\Mail;\r\nuse App\\Mail\\ResetPasswordNotification;\r\n\r\npublic function sendPasswordResetNotification($token)\r\n{\r\n	Mail::to($this->email)->send(new ResetPasswordNotification($token));\r\n}\r\n```\r\n\r\n`ResetPasswordNotification`。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Mail;\r\n\r\nuse Illuminate\\Bus\\Queueable;\r\nuse Illuminate\\Mail\\Mailable;\r\nuse Illuminate\\Queue\\SerializesModels;\r\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\nclass ResetPasswordNotification extends Mailable\r\n{\r\n    use Queueable, SerializesModels;\r\n\r\n    protected $token;\r\n\r\n    /**\r\n     * Create a new message instance.\r\n     *\r\n     * @return void\r\n     */\r\n    public function __construct($token)\r\n    {\r\n        $this->token = $token;\r\n    }\r\n\r\n    /**\r\n     * Build the message.\r\n     *\r\n     * @return $this\r\n     */\r\n    public function build()\r\n    {\r\n        return $this->markdown(\'emails.reset_password_notification\')\r\n                    ->with(\'token\', $this->token);\r\n    }\r\n}\r\n```\r\n\r\n`reset_password_notification.blade.php`。\r\n\r\n```\r\n@component(\'mail::message\')\r\n# Reset Password\r\n\r\nYou are receiving this email because we received a password reset request for your account.\r\n\r\n@component(\'mail::button\', [\'url\' => url(config(\'app.url\').route(\'password.reset\', $token, false))])\r\nReset Password\r\n@endcomponent\r\n\r\nIf you did not request a password reset, no further action is required.\r\n\r\nThanks,<br>\r\n{{ config(\'app.name\') }}\r\n@endcomponent\r\n```\r\n\r\n涉及到的路由\r\n\r\n```\r\nRoute::get(\'password/reset\', [\'as\' => \'password.forgot\', \'uses\' => \'ForgotPasswordController@showLinkRequestForm\']);\r\nRoute::post(\'password/email\', [\'as\' => \'password.forgot.post\', \'uses\' => \'ForgotPasswordController@sendResetLinkEmail\']);\r\nRoute::get(\'password/reset/{token}\', [\'as\' => \'password.reset\', \'uses\' => \'ResetPasswordController@showResetForm\']);\r\nRoute::post(\'password/reset\', [\'as\' => \'password.reset.post\', \'uses\' => \'ResetPasswordController@reset\']);\r\n```','2017-06-29 16:20:34','2017-06-29 16:34:39','how-in-the-form-of-personal-email-in-laravel-email-account-activation-email-and-password'),(138,3,3,'修改迁移文件字段需下载依赖 doctrine/dbal','```\r\n$ composer require doctrine/dbal\r\n```\r\n\r\n现在就可以在迁移文件里使用 `change`、`renameCloumn` 和 `dropColumn` 方法了。\r\n\r\n```\r\nSchema::table(\'users\', function (Blueprint $table) {\r\n    $table->string(\'name\', 50)->change();\r\n});\r\n\r\nSchema::table(\'users\', function (Blueprint $table) {\r\n    $table->renameColumn(\'from\', \'to\');\r\n});\r\n\r\nSchema::table(\'users\', function (Blueprint $table) {\r\n    $table->dropColumn(\'votes\');\r\n});\r\n```','2017-06-29 17:19:55','2017-06-29 17:19:55','modify-the-migration-file-field-dependence-doctrinedbal-need-to-download'),(139,3,3,'Laravel 默认 Auth 认证系统路由概览','```\r\n$ php artisan route:list\r\n+--------+----------+------------------------+------------------+------------------------------------------------------------------------+--------------+\r\n| Domain | Method   | URI                    | Name             | Action                                                                 | Middleware   |\r\n+--------+----------+------------------------+------------------+------------------------------------------------------------------------+--------------+\r\n|        | GET|HEAD | /                      |                  | Closure                                                                | web          |\r\n|        | GET|HEAD | api/user               |                  | Closure                                                                | api,auth:api |\r\n|        | GET|HEAD | dashboard              | dashboard        | App\\Http\\Controllers\\DashboardController@show                          | web,auth     |\r\n|        | GET|HEAD | login                  | login            | App\\Http\\Controllers\\Auth\\LoginController@showLoginForm                | web,guest    |\r\n|        | POST     | login                  |                  | App\\Http\\Controllers\\Auth\\LoginController@login                        | web,guest    |\r\n|        | POST     | logout                 | logout           | App\\Http\\Controllers\\Auth\\LoginController@logout                       | web          |\r\n|        | POST     | password/email         | password.email   | App\\Http\\Controllers\\Auth\\ForgotPasswordController@sendResetLinkEmail  | web,guest    |\r\n|        | GET|HEAD | password/reset         | password.request | App\\Http\\Controllers\\Auth\\ForgotPasswordController@showLinkRequestForm | web,guest    |\r\n|        | POST     | password/reset         |                  | App\\Http\\Controllers\\Auth\\ResetPasswordController@reset                | web,guest    |\r\n|        | GET|HEAD | password/reset/{token} | password.reset   | App\\Http\\Controllers\\Auth\\ResetPasswordController@showResetForm        | web,guest    |\r\n|        | GET|HEAD | register               | register         | App\\Http\\Controllers\\Auth\\RegisterController@showRegistrationForm      | web,guest    |\r\n|        | POST     | register               |                  | App\\Http\\Controllers\\Auth\\RegisterController@register                  | web,guest    |\r\n+--------+----------+------------------------+------------------+------------------------------------------------------------------------+--------------+\r\n```','2017-06-29 17:36:37','2017-06-29 17:36:37','an-overview-of-the-routing-laravel-default-auth-certification-system'),(140,3,3,'如何为 Github 项目打标签 Tag','```\r\n$ git tag\r\n\r\n$ git tag -a v1.1 -m \'version 1.1\'\r\n\r\n$ git push origin v1.1\r\n\r\n$ git show v1.1\r\n```','2017-06-29 18:20:00','2017-06-29 18:23:03','how-to-play-tag-tag-for-making-project'),(141,3,3,'如何使用 Git 分支','```\r\n$ git branch 1.2\r\n\r\n$ git branch\r\n\r\n$ git checkout 1.2\r\n\r\n$ git push origin 1.2\r\n```\r\n\r\n删除远程分支 `1.0`，这样操作。\r\n\r\n```\r\n$ git push origin :1.0\r\n```','2017-06-29 18:32:31','2017-07-01 20:41:09','how-to-use-git-branch'),(142,3,3,'Laravel 中绝对坑爹的地方啊！','1. `welcome.blade.php`、`app.css`  和 `app.scss` 文件中的。\r\n\r\n```\r\n<!-- Fonts -->\r\n<link href=\"https://fonts.googleapis.com/css?family=Raleway:100,600\" rel=\"stylesheet\" type=\"text/css\">\r\n```\r\n\r\n2. `asssets/js/app.js` 中的。\r\n\r\n```\r\nconst app = new Vue({\r\n    el: \'#app\'\r\n});\r\n```','2017-06-29 23:32:11','2017-06-29 23:32:11','pit-dad-laravel-that-in-a-place'),(143,3,3,'一千零一夜：第13夜','**（一）**\r\n\r\n早上，一个坐在轮椅上的老汉就是睡在金银楼门口的那位，想到每天都有铺床铺叠床铺的习惯，还是挺好的。\r\n\r\n大爷大妈的早操一定是伴随着音乐的，并不好听。\r\n\r\n**（二）**\r\n\r\n我回去的路上，也正好是下雨的时间。我带了伞，后半路程打着，也渐渐没了雨。今天周五，我竟没有意识到。\r\n\r\n一直在编程，可事情总是不太圆满。我在想一个人怎么能喜欢它呢，却能坚持学它，我就是。原因可能是――不做这个――做什么呢？是为了钱没错，可究竟还是为了给自己一个证明罢了。\r\n\r\n**（三）**\r\n\r\n阮一峰有点中年焦虑了，有点不喜欢他了。就像韩寒一样，看了他的两部电影，第一部没看懂，第二部也没怎么样，有点无趣。','2017-06-30 05:32:41','2017-06-30 05:32:41','one-thousand-night-night-13'),(144,3,3,'为了工作需要','几乎每一个CSS框架都说自己是轻量级的，我越来越发现没有最好的，也不见得是更好。这东西只有过时，但过时的东西不见得不好。\r\n\r\n有人说年轻最重要的是时间，这是因为他根据自己的经验得来的，投身在外包项目上，让他觉得浪费了时间，还不如学更高超技术。\r\n\r\n我觉得这就是生活――你明明看见大多数人没有珍惜时间，没有做出珍惜、看重时间的行动，而你却恰恰提倡时间最重要。可能每个人想到这点时，都觉得时间重要，特别是在年轻的时候，也不能熬夜――但就是做了。总结下来，这更像是在对自己提醒。但，又有人说――年轻是拿来挥霍的。\r\n\r\n所以，聪明的你也一定知道，这世界里每一个脑袋、每一张嘴、每次发音和每个行动，都会有不同解释，并设法让你相信，来我这一边，是值得的。\r\n\r\n在这样的世界里，是再操蛋不过的了，却是最真实的，你得应付它。因为人类返璞归真是不可能的了，最好情况是偶尔质朴。\r\n\r\n其实，工作、成就、金钱是最重要的吗？对于现在穷逼的我，我会看钱一眼的，因为没有它，我也算是活不了了，但――我始终觉得――人的终究终极目标，就是――情感上的丰富。','2017-06-30 06:12:30','2017-06-30 06:12:30','in-order-to-work-need-to'),(145,3,3,'神奇的 Cache::remember','有时，你希望能从缓存里取数据，但是如果缓存里没有呢，就希望从数据库表里取，取完后还能缓存，继续用。\r\n\r\nLaravel 让这样的操作变得简单。且看下面的例子：\r\n\r\n```\r\n$value = Cache::remember(\'users\', $minutes, function () {\r\n    return DB::table(\'users\')->get();\r\n});\r\n```\r\n\r\n是的，使用 `Cache::remember` 就可以让上面的需求实现了。具体的解释如下：\r\n\r\n先从缓存里取所有用户数据，如果没有就从数据库 `users` 表里取得，并且缓存起来，有效期就是 `$minutes` 所表示的分钟数。','2017-06-30 06:39:11','2017-06-30 06:39:11','the-magic-of-the-cache-remember'),(146,3,3,'何为 Laravel 中的服务提供者（一）','Laravel 中有服务提供者（Service Provider）的概念，它其实就是 **控制反转**（IoC，Inverse of Control）。\r\n\r\n控制反转最常见的方式是**依赖注入**（DI，Dependence Injection）。在 Laravel 中最常见的依赖注入方式，是通过构造函数的依赖注入。\r\n\r\n```\r\nclass Bar {\r\n	public $foo;\r\n	\r\n	public function __constructor(Foo $foo) {\r\n		$this->foo = $foo;\r\n	}\r\n}\r\n\r\nRoute::get(\'/\', function (Bar $bar) {\r\n	dd($bar);\r\n})\r\n```\r\n\r\n上面就是典型的依赖注入：你能成功得到 Bar 类的实例变量 `$bar`，并且变量中还有同样靠依赖注入的 Foo 类实例变量 `$foo`。\r\n\r\n当然你也可以**自定义依赖注入的逻辑，会被优先使用**，作为最终的依赖注入逻辑。\r\n\r\n```\r\nclass Bar {\r\n	public $foo;\r\n	\r\n	public function __constructor(Foo $foo) {\r\n		$this->foo = $foo;\r\n	}\r\n}\r\n\r\nRoute::get(\'/\', function (Bar $bar) {\r\n	dd($bar);\r\n})\r\n\r\nApp:bind(\'Bar\', function () {\r\n	dd(\'run here！\');\r\n})\r\n```\r\n\r\n自定义绑定逻辑后，访问 `/` 路径，会打印 `run here` 的字样。','2017-07-01 00:42:24','2017-07-01 01:34:05','what-is-laravel-service-providers-in-the-a'),(147,3,3,'何为 Laravel 中的服务提供者（二）','以 FilesystemServicePrider 为例。每个服务提供者里都有一个 register 方法――用来在 app 实例里添加服务。\r\n\r\n```\r\n$this->app->singleton(\'files\', function () {\r\n	return new FileSystem();\r\n})\r\n```\r\n\r\n在 `routes` 文件里就可以这样获得 FileSystem 类实例：\r\n\r\n```\r\napp(\'files\')\r\n\r\napp()[\'files\'];\r\n\r\napp()->make(\'files\');\r\n```\r\n\r\n它们等于用\r\n\r\n```\r\nnew FileSystem()\r\n```\r\n\r\n但使用服务提供者有一个好处——处理依赖注入——**如果文件系统实例是需要好几个依赖类**，像下面这样。\r\n\r\n```\r\nnew FileSystem(Bar $bar, Foo $foo);\r\n```\r\n\r\n那么每次实例化都要这样写，很麻烦！如果在注入服务时设置好的话\r\n\r\n```\r\n$this->app->singleton(\'files\', function () {\r\n	return new FileSystem(Bar $bar, Foo $foo);\r\n})\r\n```\r\n\r\n是不是很方便，而且此处是单例模式，一个实例可在系统之中共享使用！\r\n\r\n而不在服务提供者中注册服务的方式――在服务提供者之外注册服务（绑定依赖）的方式是 `App::bind`。','2017-07-01 00:57:45','2017-07-01 01:11:53','what-is-a-service-providers-in-the-laravel-2'),(148,3,3,'何为 Laravel 中的服务提供者（三）','这一节将我们自己写的类使用服务提供者注入到 Laravel IoC 容器中。\r\n\r\n1. `Stripe` class\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Billing\\Stripe;\r\n\r\nclass Stripe {\r\n	public funtion charge() {\r\n		dd(\'charged\')；\r\n	}\r\n}\r\n```\r\n\r\n2. `BillingServiceProvider`\r\n\r\n```\r\n$ php artisan make:provider BillingServiceProvider \r\n```\r\n\r\n书写 `BillingServiceProvider` 的 `register` 方法，将生成 `Stripe` 类实例的逻辑设定好。\r\n\r\n```\r\n$this->app->bind(\'billing\', function () {\r\n	return new Stripe();\r\n})\r\n```\r\n\r\n3. 注册服务\r\n\r\n在 `app/config` 的 `$providers` 中注册服务提供者。\r\n\r\n```\r\n\\App\\Providers\\BillingServiceProvider::class，\r\n```\r\n\r\n4. 在 `routes/web.php` 中使用。\r\n\r\n```\r\nRoute::get(\'/\', function () {\r\n	app(\'billing\')->charge();\r\n})\r\n\r\n// 或者\r\nRoute::get(\'/\', function (Stripe $stripe) {\r\n	$stripe->charge();\r\n})\r\n```','2017-07-01 01:33:07','2017-07-01 01:33:07','what-is-a-service-providers-in-the-laravel-3'),(149,3,3,'一千零一夜：第14夜','我已经有困意了。刚才还起来喝了口水，做了平板支撑。\r\n\r\n看了鲁迅的小说《孔乙己》《药》，《药》没看完，但觉得写的好，开头写得很好。现在合上放在一边了。\r\n\r\n我要睡觉了。','2017-07-01 14:06:19','2017-07-01 14:06:19','one-thousand-nights-14th-night'),(150,3,3,'手动实现 Laravel 中的重置密码功能','Laravel 原生提供了重置密码功能，那么如果我们自己写呢？\r\n\r\n我们都知道，在注册时 Laravel 将我们的密码通过 `bcrypt` 函数加密的形式存入数据库。\r\n\r\n```\r\n$user = User::create([\r\n	\'name\' => $data[\'name\'],\r\n	\'email\' => $data[\'email\'],\r\n	\'password\' => bcrypt[\'password\'],\r\n	\'confirmation_code\' => str_random(60),\r\n]);\r\n```\r\n\r\n按照这种逻辑，手写密码重置功能时，验证旧密码的方式，应该是\r\n\r\n```\r\nbcrypt[\'oldPassword\'] === $user->password\r\n```\r\n\r\n然而不是！需写成如下这样的：\r\n\r\n```\r\nuse Illuminate\\Support\\Facades\\Hash;\r\n\r\nHash::check($oldPassword, Auth::user()->password);\r\n```','2017-07-01 18:23:01','2017-07-01 18:23:29','manual-laravel-to-realize-the-reset-password-function'),(151,3,3,'在 Laravel 显示错误信息的方式','```\r\npublic function login(LoginRequest $request)\r\n{\r\n	$data = $request->only([\'email\', \'password\']);\r\n\r\n	if (Auth::attempt([\r\n		\'email\' => $data[\'email\'],\r\n		\'password\' => $data[\'password\'],\r\n		\'is_confirmed\' => 1\r\n	]))\r\n	{\r\n		return redirect(\'/\')->with(\'status\', [\'type\' => \'success\', \'info\' => \'用户登录成功\']);\r\n	}\r\n\r\n	return back()->withInput()->with(\'status\', [\'type\' => \'danger\', \'info\' => \'用户登录失败\']);\r\n}\r\n\r\npublic function logout()\r\n{\r\n	Auth::logout();\r\n	return redirect(\'/\');\r\n}\r\n```\r\n\r\n```\r\n@if (session(\'status\'))\r\n	<div class=\"alert alert-{{ session(\'status\')[\'type\'] }}\">\r\n		{{ session(\'status\')[\'info\'] }}\r\n	</div>\r\n@endif\r\n```','2017-07-01 18:51:02','2017-07-01 18:51:02','in-laravel-display-error-message'),(152,3,3,'将用户就头像转移至 deleted 目录（代码段）','```\r\n public function changeAvatar(Request $request)\r\n {\r\n	$avatar = $request->file(\'avatar\');\r\n\r\n	if ($avatar->isValid())\r\n	{\r\n//            $AVATAR_DIR = \'avatars\';\r\n//            $AVATAR_DELETED_DIR = \'deleted\';\r\n\r\n		$user = Auth::user();\r\n\r\n//            if(Storage::disk(\'local\')->exists($user->avatar))\r\n//            {\r\n//                $contents = Storage::disk(\'local\')->get($user->avatar);\r\n//                $deletedAvatarName = \'user_\' . $user->id . \'_\' . date(\'Ymd_His\') . \'.jpg\';\r\n//                Storage::put($AVATAR_DIR . DIRECTORY_SEPARATOR . $AVATAR_DELETED_DIR . DIRECTORY_SEPARATOR . $deletedAvatarName, $contents);\r\n//            }\r\n\r\n		$originExt = $avatar->getClientOriginalExtension();\r\n		// 新文件名。例如：\'586f2d753dfbd.jpg\'\r\n		$newName = uniqid() . \'.\' . $originExt;\r\n		Storage::putFileAs(\'public/uploads/avatars\', $avatar, $newName);\r\n\r\n		$user->avatar = \'storage/uploads/avatars/\' . $newName;\r\n		$user->save();\r\n\r\n//            dd(Image::make(\'uploads/avatars/\' . $newName));\r\n\r\n//            Storage::prepend(\'uploads.log\',\r\n//                Carbon::now() . \' \' . $user->email . \'(\' . $user->id . \') 上传头像至 \' . DIRECTORY_SEPARATOR . $AVATAR_DIR . $newName\r\n//            );\r\n\r\n		return back();\r\n}\r\n```','2017-07-01 19:22:03','2017-07-01 19:22:03','to-transfer-user-will-head-to-does-directory-code'),(153,3,3,'使用 Laravel Mix 编译 JavaScript 和 CSS','Laravel Mix 是从 Laravel 5.4 起提供的 JavaScript 和 CSS 编译工具，之前是用 Laravel Elixir。区别是，前者是基于 Webpack，后者是基于 Gulp。\r\n\r\n在我们使用 `php artisan make:auth` 命令生成的 `app.blade.php` 文件中，可以看到\r\n\r\n```\r\n<link href=\"{{ asset(\'css/app.css\') }}\" rel=\"stylesheet\">\r\n<script src=\"{{ asset(\'js/app.js\') }}\"></script>\r\n```\r\n\r\n这是引用了 `public` 目录下的两个文件：`css/app.css` 和 `js/app.js`。它们*可以看做*就是用 Laravel Mix 编译后的输出文件。\r\n\r\nLaravel Mix 的编译规则在项目根目录下的 `webpack.mix.js` 文件中设定。\r\n\r\n```\r\nmix.js(\'resources/assets/js/app.js\', \'public/js\')\r\n   .sass(\'resources/assets/sass/app.scss\', \'public/css\');\r\n```\r\n\r\n很明显，Laravel Mix 最终将 `resources/assets/js/app.js` 文件处理到 `public/js` 文件夹下的 `app.js`（未指定输出文件名时，就保持和源文件名一样），将 `resources/assets/sass/app.scss` 文件处理成 `public/css` 文件夹下的 `app.css`（输出文件名和源文件名一样）。\r\n\r\n如果你修改或间接修改了 `resources/assets/js/app.js` 和 `resources/assets/sass/app.scss` 文件，并且想让改动最终在项目中生效，就需要重新用 Laravel Mix 编译了。命令如下：\r\n\r\n```\r\n$ npm run dev\r\n\r\n// 或者\r\n\r\n$ npm run production\r\n```\r\n\r\n`npm run dev` 适用于开发环境，最终输出的代码不会被压缩；`npm run production` 适用于生产环境，最终输出的代码会被压缩。\r\n\r\n那么压缩何不压缩到底有什么区别呢？\r\n\r\n刚才我用这两条命令分别试了一下，对象就是一个空的 Laravel 5.4 项目。结果如下：\r\n\r\n```\r\n// 使用 npm run dev\r\n/js/app.js   1.19 MB\r\n/css/app.css    681 kB\r\n\r\n// 使用 npm run production\r\n/js/app.js    291 kB            \r\n/css/app.css    114 kB  \r\n```','2017-07-02 02:21:23','2017-07-02 02:21:23','using-laravel-mix-compiled-javascript-and-css'),(154,3,3,'【问题处理】\'NODE_ENV\' 不是内部或外部命令，也不是可运行的程序或批处理文件','在 Laravel 项目中使用 `npm run dev` 编译前端文件时，报错\r\n\r\n```\r\n\'NODE_ENV\' 不是内部或外部命令，也不是可运行的程序或批处理文件。\r\n```\r\n\r\n在 Windows 系统中，只有一种可能……就是没有\r\n\r\n```\r\n$ npm install\r\n```\r\n\r\n:kissing_smiling_eyes:','2017-07-02 02:22:21','2017-07-02 02:22:21','problem-node-env-not-internal-or-external-command-nor-can-run-a-program-or-batch-file'),(155,3,3,'为 Laravel Mix 编译的 JavaScript 和 CSS 文件加版本号','## 什么意思？\r\n\r\n加版本号，什么意思？我们来看 Github 网页源码中是怎样引入 JavaScript 和 CSS 文件的。\r\n\r\n```\r\n<link crossorigin=\"anonymous\" href=\"https://assets-cdn.github.com/assets/frameworks-e04a23d39bf81b7db3c635177756ef51bc171feb440be9e174933c6eb56382da.css\" integrity=\"sha256-4Eoj05v4G32zxjUXd1bvUbwXH+tEC+nhdJM8brVjgto=\" media=\"all\" rel=\"stylesheet\" />\r\n\r\n<script crossorigin=\"anonymous\" integrity=\"sha256-nL0D6lZGHoSriVa/d5mpd9bMih+YTHG17LLt/bo9dz8=\" src=\"https://assets-cdn.github.com/assets/frameworks-9cbd03ea56461e84ab8956bf7799a977d6cc8a1f984c71b5ecb2edfdba3d773f.js\"></script>\r\n```\r\n\r\n本质上引入的文件是 `frameworks.css` 和 `frameworks.js`，`e04a23d39bf81b7db3c635177756ef51bc171feb440be9e174933c6eb56382da` 和 `9cbd03ea56461e84ab8956bf7799a977d6cc8a1f984c71b5ecb2edfdba3d773f` 就是指版本号。版本号可以是一个时间戳，也可以是一个唯一的令牌（token）。\r\n\r\n## 为什么要加？\r\n\r\n那么加版本号有什么好处呢？这个问题问得好 :wave:\r\n\r\n答案就是为了强制浏览器加载最新的编译文件，因为浏览器为了性能考虑，在一段时间内同一个资源如果本地存在，就不会从远方的服务器抓取。这就带来一个问题——修改的效果在用户的浏览器中可能不会立即生效，那么此时为每一个新编译的文件加一个唯一的版本号就变得有必要了，因为只要编译了文件，页面中引入的文件名总是不一样，所以浏览器总是会发出请求，使用最新的编译文件。\r\n\r\n## 在 Laravel 中用\r\n\r\n在 Laravel 中，为编译文件加版本号非常方便，只要在 `webpack.mix.js` 文件中，在设定 Laravel Mix 编译规则的地方使用 `version()` 方法就 OK 了 :+1:\r\n\r\n```\r\nmix.js(\'resources/assets/js/app.js\', \'public/js\')\r\n   .sass(\'resources/assets/sass/app.scss\', \'public/css\')\r\n	 .version();\r\n```\r\n\r\n下面执行 `npm run dev`，输出的文件为\r\n\r\n* `public/js/app.a92101167c611fee1b3a.js`\r\n* `public/css/app.5d9cb0105749a63e10d03d4e6ef535ab.css`\r\n \r\n在 `layouts/app.blade.php` 中的引入方式也要改变。\r\n\r\n```\r\n<link href=\"{{ asset(\'/css/app.css\') }}\" rel=\"stylesheet\">\r\n<script src=\"{{ asset(\'/js/app.js\') }}\"></script>\r\n\r\n<!-- 改为 -->\r\n\r\n<link href=\"{{ mix(\'/css/app.css\') }}\" rel=\"stylesheet\">\r\n<script src=\"{{ mix(\'/js/app.js\') }}\"></script>\r\n```\r\n\r\n这样，就可以正确引入编译后、带版本号的编译文件了。\r\n\r\n## `mix` 是怎么做到的\r\n\r\n有人可能会问了，我明明给的是 `\'/css/app.css` 和 `/js/app.js`，`mix()` 是怎样做到引入正确版本号的编译文件呢？这个问题问得好 :metal:\r\n\r\n其实每次执行 `npm run dev` 和 `npm run production` 的时候，还会在 `public` 目录下生成一个 `mix-manifest.json` 文件，内容类似下面这样：\r\n\r\n```\r\n{\r\n  \"/js/app.js\": \"/js/app.a92101167c611fee1b3a.js\",\r\n  \"/css/app.css\": \"/css/app.5d9cb0105749a63e10d03d4e6ef535ab.css\"\r\n}\r\n```\r\n\r\n你可能就明白了——**传递给 `min()` 方法的参数其实是一个 Key** ，而不是一个文件名。`min()` 方法就是从 `mix-manifest.json` 文件中找到 Key 对应的 Value 的 :clap:','2017-07-02 02:22:54','2017-07-02 02:22:54','the-compiler-to-laravel-mix-javascript-and-css-files-and-version-number'),(156,3,3,'PHP中的反斜线和正斜线的区别','反斜线就是 `\\`，正斜线就是 `/`。在使用 Laravel 的过程中，就会看到。\r\n\r\n```\r\nclass Article extends Model\r\n{\r\n    public function hasManyComments(){\r\n        return $this->hasMany(\'App\\Comment\',\'article_id\',\'id\');\r\n    }\r\n}\r\n```\r\n\r\n```\r\nclass ArticleController extends Controller\r\n{\r\n    public function show($id){\r\n        return view(\'article/show\')->withArticle(Article::with(\'hasManyComments\')->find($id));\r\n    }\r\n}\r\n```\r\n\r\n是这样的――类名用反斜线是 PHP 命名空间的规则，斜线是表示路径的分隔符。\r\n\r\n在 Unix 操作系统中，`/` 才表示目录，而 `\\` 表示转义字符。在 Windows 的环境下，`/` 和 `\\` 都是有效的路径分隔符。\r\n\r\n总结一下：在路径中总是使用 `/` 作为分隔符，`\\` 用来做命名空间分隔符。','2017-07-02 03:59:09','2017-07-02 04:01:11','the-difference-between-backslash-and-slash-in-php'),(157,3,3,'一千零一夜：第15夜','**（一）**\r\n\r\n下雨了，我在雨中。说来奇怪，我并不觉得雨讨厌，在雨中淋着也没事，只要不大。\r\n\r\n我在露台上吃黄焖鸡，阿姨给我送来一小碗青豆，我非常感激――是咸水煮的青豆，虽然没什么味道，但是也是一份心意，我吃完了。\r\n\r\n我在听《甜甜的》和《马德里不思议》，曲风明快，听起来非常自在。当然还有miwa的《ミラクル》！\r\n\r\n**（二）**\r\n\r\n跑步回来，还没洗澡。也没想什么，路上唱歌，嗓子有点不行了，高潮飙不上去啊。待会休息再看看鲁迅吧。','2017-07-02 05:50:24','2017-07-02 05:50:24','one-thousand-nights-15th-night'),(158,3,3,'在 Windows 10 系统中安装 Laravel Installer','## 好处和坏处\r\n\r\n### 好处\r\n\r\n可以通过 Laravel Installer 安装 Laravel。它比用 Composer Create-Project 的好处是：\r\n\r\n1. 命令简单\r\n\r\n```\r\n$ laravel new blog\r\n\r\n# VS\r\n\r\n$ composer create-project --prefer-dist laravel/laravel blog\r\n```\r\n\r\n2. 来源不同\r\n\r\n使用 Laravel Installer 有两种安装项目的命令：\r\n\r\n* `laravel new blog`\r\n* `laravel new blog --dev`\r\n\r\n它们对应的下载地址是：\r\n\r\n* http://cabinet.laravel.com/latest.zip\r\n* http://cabinet.laravel.com/latest-develop.zip\r\n\r\n就是说用 **Laravel Installer 安装包是从官网提供的地址下载的、不是从 Composer 库里取的**。\r\n\r\n### 坏处 \r\n\r\nLaravel Installer 不能指定下载的版本号。这个时候就要用 Composer Create-Project 了。\r\n\r\n```\r\n$ composer create-project --prefer-dist laravel/laravel blog \"5.3.*\" \r\n```\r\n\r\n## 安装\r\n\r\n执行命令 `composer global require \"laravel/installer\"`，全局安装 Laravel Installer。在 Windows 10 系统中，Composer 安装的全局软件放在 `C:/Users/zhangb/AppData/Roaming/Composer` 文件夹下。\r\n\r\n```\r\nC:\\Users\\zhangb>composer global require \"laravel/installer\"\r\nChanged current directory to C:/Users/zhangb/AppData/Roaming/Composer\r\nUsing version ^1.3 for laravel/installer\r\n./composer.json has been created\r\nLoading composer repositories with package information\r\nUpdating dependencies (including require-dev)\r\nPackage operations: 10 installs, 0 updates, 0 removals\r\n  - Installing symfony/process (v3.3.2): Loading from cache\r\n  - Installing psr/log (1.0.2): Loading from cache\r\n  - Installing symfony/debug (v3.3.2): Loading from cache\r\n  - Installing symfony/polyfill-mbstring (v1.4.0): Loading from cache\r\n  - Installing symfony/console (v3.3.2): Loading from cache\r\n  - Installing guzzlehttp/promises (v1.3.1): Downloading (100%)\r\n  - Installing psr/http-message (1.0.1): Downloading (100%)\r\n  - Installing guzzlehttp/psr7 (1.4.2): Downloading (100%)\r\n  - Installing guzzlehttp/guzzle (6.3.0): Downloading (100%)\r\n  - Installing laravel/installer (v1.3.6): Downloading (100%)\r\nsymfony/console suggests installing symfony/event-dispatcher ()\r\nsymfony/console suggests installing symfony/filesystem ()\r\nWriting lock file\r\nGenerating autoload files\r\n```\r\n\r\n将路径 `C:\\Users\\zhangb\\AppData\\Roaming\\Composer\\vendor\\bin` 添加到全局变量中。下面打开命令行界面，就可以使用 `laravel` 命令了。\r\n\r\n## 源码\r\n\r\n刚才有说，「Laravel Installer 安装包是从官网提供的地址下载的、不是从 Composer 库里取」。依据何在——从源码里看到的。源码在 `C:/Users/zhangb/AppData/Roaming/Composer/vendor/laravel/installer/src/NewCommand.php` 中。有一个 `download` 方法。\r\n\r\n```\r\n/**\r\n * Download the temporary Zip to the given file.\r\n *\r\n * @param  string  $zipFile\r\n * @param  string  $version\r\n * @return $this\r\n */\r\nprotected function download($zipFile, $version = \'master\')\r\n{\r\n	switch ($version) {\r\n		case \'develop\':\r\n			$filename = \'latest-develop.zip\';\r\n			break;\r\n		case \'master\':\r\n			$filename = \'latest.zip\';\r\n			break;\r\n	}\r\n\r\n	$response = (new Client)->get(\'http://cabinet.laravel.com/\'.$filename);\r\n\r\n	file_put_contents($zipFile, $response->getBody());\r\n\r\n	return $this;\r\n}\r\n```','2017-07-02 17:02:13','2017-07-02 17:06:35','10-laravel-installed-in-the-system-in-windows-installer'),(159,3,3,'如何设置 Model 让 Eloquent 处理不是 int 类型且自增的主键','Eloquent 默认认为表格主键名叫 `id`，而且是自增的 `int` 类型。如果你的主键不是自增的，也不是 `int` 类型的，将公开属性 `$incrementing` 设置为 `false` 即可。\r\n\r\n```\r\npublic $incrementing = false;\r\n```','2017-07-02 17:48:45','2017-07-02 17:48:45','how-to-set-up-the-model-to-deal-with-the-eloquent-not-int-type-and-the-increase-of-the-primary-key'),(160,3,3,'如何设置 Model 让 Eloquent 不维护 updated_at 和 created_at 字段','默认 Eloquent 会自动维护表格的 updated_at 和 created_at 字段，如果不想如此，将 `$timestamps` 属性设置为 `false` 即可。\r\n\r\n```\r\n/**\r\n * Indicates if the model should be timestamped.\r\n *\r\n * @var bool\r\n */\r\npublic $timestamps = false;\r\n```','2017-07-02 17:55:18','2017-07-02 17:55:18','how-to-set-up-the-model-for-eloquent-do-not-maintain-updated-at-and-created-at-field'),(161,3,3,'如何设置 Model 让 Eloquent 自动维护自定义的表格的创建、更新字段名','如果表格的创建字段名不是 `created_at`，更新字段名不是 `updated_at`，此刻就要在 Model 中设定、覆盖两个常量 `CREATED_AT` 和 `UPDATED_AT`。\r\n\r\n```\r\n<?php\r\n\r\nclass Flight extends Model\r\n{\r\n    const CREATED_AT = \'creation_date\';\r\n    const UPDATED_AT = \'last_update\';\r\n}\r\n```\r\n\r\n需要注意的是，迁移文件里的 `$table->timestamps();` 的作用是添加可为空（nullable）的 `created_at` 和 `updated_at` 的 `timestamp` 类型字段。','2017-07-02 17:59:53','2017-07-02 18:05:07','how-to-set-up-the-model-for-eloquent-automatic-maintenance-custom-form-creation-update-the-field-name'),(162,3,3,'Collection 类实例的 filter 和 reject 方法','在 Laravel 中，我们可以使用 `collect` 辅助函数产生 `Illuminate\\Support\\Collection` 实例。\r\n\r\n```\r\n$collection = collect([\'taylor\', \'abigail\', null])->map(function ($name) {\r\n    return strtoupper($name);\r\n})\r\n->reject(function ($name) {\r\n    return empty($name);\r\n});\r\n```\r\n\r\n`Collection` 类提供 [许多有用][1] 的方法。其中就有 `filter` 和 `reject`，它们是互斥的方法。\r\n\r\n[1]: https://laravel.com/docs/5.4/eloquent-collections#available-methods\r\n\r\n1.  `filter`：过滤出符合条件的元素。\r\n2.  `reject`：过滤掉符合条件的元素。\r\n\r\n## `filter`\r\n\r\n```\r\n$collection = collect([1, 2, 3, 4]);\r\n\r\n$filtered = $collection->filter(function ($value, $key) {\r\n    return $value > 2;\r\n});\r\n\r\n$filtered->all();\r\n\r\n// [3, 4]\r\n```\r\n\r\n上面的例子是「找出所有 **大于2** 的元素」。\r\n\r\n## `reject`\r\n\r\n```\r\n$flights = App\\Flight::all();\r\n\r\n$flights = $flights->reject(function ($flight) {\r\n    return $flight->cancelled;\r\n});\r\n```\r\n\r\n上面的例子是「找出所有 **未取消** 的航班」。','2017-07-02 18:35:33','2017-07-02 18:35:33','the-filter-and-reject-method-of-collection-class-instance'),(163,3,3,'解决 Larvel 5.4 「Specified key was too long」 问题','Laravel 5.4 把默认数据库字符集更改成 `utf8mb4`，作为对存储 emojis 表情的支持。当你运行低于 MySQL v5.7.7 版本（MariaDB 10.2 以下），在尝试运行迁移时遇到下面的错误：\r\n\r\n```\r\n[Illuminate\\Database\\QueryException]\r\n SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes (SQL: alter table users add unique users_email_unique (email))\r\n\r\n[PDOException]\r\n SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes\r\n```\r\n\r\n解决方式是在 `AppServiceProvider` 的 `boot` 方法内添加\r\n\r\n```\r\nuse Illuminate\\Support\\Facades\\Schema;\r\n\r\npublic function boot()\r\n{\r\n    Schema::defaultStringLength(191);\r\n}\r\n```\r\n\r\n即可。','2017-07-02 18:45:08','2017-07-02 18:45:08','solve-larvel-54-specified-key-was-too-long'),(164,3,3,'Laravel 中 Eloquent 关系映射：一对一','一个 `User` 有一部 `Phone`。\r\n\r\n## 正向\r\n\r\n`hasOne` 方法。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse App\\Models\\Phone;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass User extends Model\r\n{\r\n    /**\r\n     * Get the phone record associated with the user.\r\n     */\r\n    public function phone()\r\n    {\r\n        return $this->hasOne(Phone::class, \'foreign_key\', \'local_key\');\r\n    }\r\n}\r\n```\r\n\r\n「foreign_key」默认是 `phones` 表中名为 `user_id` 的字段；如果 `users` 表的主键名是 `uuid`（通过 `$primaryKey` 属性设定），那么「foreign_key」对应的就是 `phones` 表中名为 `user_uuid` 的字段。「local_key」默认是 `users` 表的 `id` 字段（其实就是 `$primaryKey` 的值）。\r\n\r\n```\r\nprotected $primaryKey = \'uuid\';\r\n```\r\n\r\n其实，可以发现，「foreign_key」和「local_key」中的 「key」用的都是 Model `$primaryKey` 属性所表示的值。在任何一个 Model 中，主键名都是用 `$primaryKey` 这个属性所表示的值。\r\n\r\n\r\n## 反向\r\n	\r\n`belongsTo` 方法。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Phone extends Model\r\n{\r\n    /**\r\n     * Get the user that owns the phone.\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(\'App\\User\', \'foreign_key\', \'other_key\');\r\n    }\r\n}\r\n```\r\n\r\n「foreign_key」默认是 `phones` 表名为 `user_id` 的字段，是这样得来的：取关系方法 `user()` 中的 `user` + `_id` 得来的。在一个约定足够好的项目中，会省去不少工作。\r\n\r\n「other_key」默认是 `users` 表中的 `id` 字段，如果实际比较的是 `uuid`，那么就需要写明了。\r\n\r\n## 总结\r\n\r\n**正向和反向规则都是单独定义的**，只不过在 Laravel 中默认的约定足够好，让我们感觉浑然天成。所以约定很重要。','2017-07-02 21:19:49','2017-07-02 23:09:25','laravel-eloquent-in-relational-mapping-one-to-one'),(165,3,3,'使用 chunk 方法，分批次从数据库取数据','如果数据库中的数据量很大，一次性 `all()` 取数据的话，对服务器内存「压力山大」。这是可以考虑使用 Eloquent Chunk 方法分批从数据库取数据。\r\n\r\n举一个不太恰当的例子，如果数据库里有 1000 条用户数据，采用 `all` 方式一次性就会取到全部 1000 条数据；如果使用 `chunk` 的方式，一次取 200，那么就要取 5 次（发 5 条 SQL）。\r\n\r\n```\r\nRoute::middleware(\'api\')->get(\'/user\', function (Request $request) {\r\n	return User::all();\r\n});\r\n\r\nRoute::middleware(\'api\')->get(\'/user\', function (Request $request) {\r\n	$users = collect([]);\r\n\r\n    User::chunk(200, function ($chunk) use ($users) {\r\n   		foreach ($chunk as $user) {\r\n        	$users->push($user);\r\n    	}\r\n	});\r\n\r\n	return $users;\r\n});\r\n```','2017-07-02 22:15:03','2017-07-02 22:15:20','using-the-chunk-method-partial-time-to-fetch-the-data-from-the-database'),(166,3,3,'belongsTo 关联的 withDefault 方法','在 Laravel 5.4 中，新增了一个方法 [`withDefault`][1]，它是结合 `belongsTo` 一起使用的。所以先要知道，什么是 `belongsTo` 关联？\r\n\r\n[1]: https://laravel.com/docs/5.4/eloquent-relationships#one-to-one\r\n\r\n## 什么是 `belongsTo` 关联？\r\n\r\n`belongsTo` 关联是一对一、一对多关系中，在定义反向关联关系（Inverse Of The Relationship）的 Model 中使用的。比如：\r\n\r\n1. 一对一关系：一个 `User` 对应一部 `Phone`，在 Phone Model 中定义的关联就是「一对一关系的反向关联」。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse App\\User;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Phone extends Model\r\n{\r\n    /**\r\n     * Get the user that owns the phone.\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(User::class);\r\n    }\r\n}\r\n```\r\n\r\n2. 一对多关系：一个 `User` 对应多篇 `Article`，在 Article Model 中定义的关联就是「一对多关系的反向关联」。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse App\\User;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Article extends Model\r\n{\r\n    /**\r\n     * Get the author that owns the article.\r\n     */\r\n    public function user()\r\n    {\r\n        return $this->belongsTo(User::class);\r\n    }\r\n}\r\n```\r\n\r\n## `withDefault ` 为什么要有？\r\n\r\n这个问题问得好:clap:\r\n\r\n在实际使用中，可能会出现这样的情况：一个用户删除了，但是与这个用户对应的 Phone 和 Article 记录没有删除。当我们通过 Phone Model 和 Article Model 查询用户时，就有可能返回一个 `null` 值。\r\n\r\n有些时候这个 `null`  值会引发一些问题。为了解决这个问题， `withDefault` 应运而生。\r\n\r\n```\r\n/**\r\n * Get the author that owns the article.\r\n */\r\npublic function user()\r\n{\r\n    return $this->belongsTo(User::class)->withDefault();\r\n}\r\n```\r\n\r\n这种情况下，`withDefault` 会返回一个 User Model 实例，从而避免了 `null` 引发的问题。当然，你还可以这个实例填充数据：使用数组或者闭包。\r\n\r\n```\r\n/**\r\n * Get the author of the article.\r\n */\r\npublic function user()\r\n{\r\n    return $this->belongsTo(User::class)->withDefault([\r\n        \'name\' => \'佚名\',\r\n    ]);\r\n}\r\n\r\n/**\r\n * Get the author of the article.\r\n */\r\npublic function user()\r\n{\r\n    return $this->belongsTo(User::class)->withDefault(function ($user) {\r\n        $user->name = \'佚名\';\r\n    });\r\n}\r\n```','2017-07-02 22:51:43','2017-07-02 22:51:43','withdefault-method-belongsto-associations'),(167,5,5,'Python:训练','## 如何为元组中的每个元素命名，提高程序可阅读性\r\n\r\n实际案例：\r\n学生信息系统中数据为固定形式（名字，年龄，性别，邮箱等。。）\r\n\r\n学生数量很大为了减小存储开销，对每个学生信息用元组表示\r\n（‘chenys’,15,\'male\',\'chenys@163.com\')\r\n（‘sunl’,18,\'male\',\'sunl@163.com\')\r\n（‘lilei’,30,\'male\',\'lilei@163.com\')\r\n（‘hanmeimei’,29,\'female\',\'chenys@163.com\')\r\n \r\n访问时，为毛使用索引（index）访问，大量的索引降低程序可读性，如何解决这个问题？\r\n\r\n```\r\nstudent = (‘chenys’,15,\'male\',\'chenys@163.com\')\r\n\r\n#name\r\nprint student[0]\r\n\r\n#age\r\nprint(student[1])\r\n... 依次类推\r\n```\r\n\r\n但是这样我们阅读程序时，没发直观的看到`student[0]`,`student[1]`等代表什么含义。\r\n所以，我们可以通过修改程序\r\n\r\n```\r\nNAME,AGE,SEX,MAIL = range(4)\r\n\r\nstudent = (‘chenys’,15,\'male\',\'chenys@163.com\')\r\n\r\nprint(student[NAME])\r\n\r\nprint(student[AGE])\r\n```\r\n之前的索引`0`,`1`等修改为`MANE`,`AGE`等，更直观的知道含义\r\n\r\n\r\n还可以使用标准库中的`collections,namedtuple`替换内置`tuple`\r\n\r\n```\r\nfrom collections import namedtuple\r\n\r\nStudent = namedtuple(\'Student\',[\'name\',\'age\',\'sex\',\'email\'])\r\n\r\ns = Student(\'chenys\',\'16\',\'male\',\'chenys@163.com\')\r\n\r\nprint(s)\r\n```\r\n\r\n\r\n\r\n## 如何统计序列中元素的出现频度\r\n\r\n实际案例\r\n1. 某随机序列［12，5，6，6，4，5，5，5，4，7，...］，找到出线次数最高的3个元素，他们的出现次数时多少？\r\n2. 对某英文文章的单词，进行词频统计，找到出现次数最高的10个单词，它们出现次数时多少？\r\n\r\n我们使用标准库中的`collections`, `counter` 方法\r\n```\r\nfrom random import randint       ##导入随机数模块\r\n\r\ndata = [randint(0,20) for _ in range(30)]     ##在0～20中生成随机数，共30个\r\n\r\nfrom collections import Counter\r\n\r\nc = Counter(data)\r\n\r\nprint(c)\r\n\r\nprint(c.most_common(3))           ##统计出现频率最高的3个\r\n```\r\n\r\n\r\n## 如何根据字典中的值的大小，对字典中的项排序\r\n\r\n实际案例\r\n\r\n某班英语成绩以字典的形式存储为：`{\'chenys\':100,\'sunl\':93,\'zhangb\':80,.....}`根据成绩高低，计算学生排名。\r\n\r\n```\r\nfrom random import  randint\r\n\r\nd = { x: randint(60,100) for x in \'xyzabc\'}\r\n\r\nprint(d)\r\n\r\nprint(sorted(zip(d.values(),d.keys())))\r\n\r\n```\r\n\r\n`zip`函数可以把2个列表拼接起来，合成一个\r\n\r\n\r\n传递sorted key的值得出结果\r\n```\r\nfrom random import  randint\r\n\r\nd = { x: randint(60,100) for x in \'xyzabc\'}\r\n\r\nprint(sorted(d.items(),key = lambda x:x[1]))\r\n\r\n```','2017-07-02 23:10:40','2017-07-03 01:20:03','python-training'),(168,3,3,'Laravel 中 Eloquent 关系映射：一对多','## 场景\r\n\r\n一篇 `Post` 对应多条 `Comment`。\r\n\r\n## 正向关联\r\n\r\n使用 `hasMany` 方法。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse App\\Models\\Comment;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Post extends Model\r\n{\r\n    /**\r\n     * Get the comments for the blog post.\r\n     */\r\n    public function comments()\r\n    {\r\n        return $this->hasMany(Comment::class);\r\n    }\r\n}\r\n```\r\n\r\n`hasMany` 方法的完整写法是这样的（当然，后面两个参数可以省略，使用默认值也行）：\r\n\r\n```\r\nreturn $this->hasMany(Comment::class, \'foreign_key\', \'local_key\');\r\n```\r\n\r\n「foreign_key」默认取值 `post_id`，指 `comments` 表的 `post_id` 字段。需要注意的是，Laravel 中字段名称采用的都是「snake_name」形式，那这个  `post_id` 怎么来的呢？\r\n\r\n这个问题问得好 :clap:\r\n\r\n是这样的：这个外键肯定不是指 `posts` 表里的外键，而是指 `comments` 里的外键，通过这个外键可以找到这个 `Comment` 评论的 `Post`。\r\n\r\n`hasMany` 是在 Post Model 中定义的，自然 `post_id` 中的「post」、「id」来源都是有依据的——「post」其实就是 Post Model 中「Post」首字母小写的形式；「id」就是取 Post Model 中 `$primatyKey` 的值（默认就是 `id`），也就是说如果 Post Model 中 `$primatyKey` 的值改成 `uuid` 了，那么 「foreign_key」就是 `post_uuid` 了！\r\n\r\n「local_key」默认取值 `id`，指本表（`posts` 表）的 `id` 字段，它其实也是 `$primatyKey` 的值（默认就是 `id`） 。如果  `$primatyKey` 的值改成 `uuid` 了，那么 「foreign_key」自然就是 `uuid` 了。\r\n\r\n## 反向关联\r\n\r\n使用 `belongsTo` 方法。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse App\\Models\\Post;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Comment extends Model\r\n{\r\n    /**\r\n     * Get the post that owns the comment.\r\n     */\r\n    public function post()\r\n    {\r\n        return $this->belongsTo(Post::class);\r\n    }\r\n}\r\n```\r\n\r\n`hasMany` 方法的完整写法是这样的：\r\n\r\n```\r\n/**\r\n * Get the post that owns the comment.\r\n */\r\npublic function post()\r\n{\r\n    return $this->belongsTo(Post::class, \'foreign_key\', \'other_key\');\r\n}\r\n```\r\n\r\n「foreign_key」自然是指本表（`comments` 表）的外键，根据这个外键找 `Post`。那么问题来了，找 `Post` 的本表外键值有了，那和 `posts` 表里哪个字段对比呢？答案就是第三个参数 「other_key」。\r\n\r\n「other_key」默认取 `id`，它在 Comment Model 中找不到可以依据的字段。\r\n\r\n## 总结\r\n\r\n在一对多关系中，在「一」的一方使用 `hasMany` 方法。对于 Post Model 来说，它控制不了 「foreign_key」的值，能控制的了 「other_key」的值（`$primaryKey` 的值）。\r\n\r\n在一对多关系中，在「多」的一方使用 `belongsTo` 方法。对于 Comment Model 来说，它能控制的了 「foreign_key」的值，却控制不了 「other_key」的值（因为这是由 Post Model 中的 `$primaryKey` 决定的）。','2017-07-02 23:35:35','2017-07-03 00:31:41','in-laravel-eloquent-relationship-mapping-a-couple-more'),(169,3,3,'Laravel 中 Eloquent 关系映射：多对多','## 场景\r\n\r\n用户（`User`） 和角色（`Role`）。一个用户可以有多个角色，一个角色可以对应多个用户。\r\n\r\n这时默认就得有三张表：`users`、`roles` 和 `role_user`。**`role_user` 就是多对多关系里会用到的关系表**，这个表名起得也有讲究，是「snake\\_name」形式，单词是按字母表顺序排列、以 `_` 为连接符组成的。\r\n\r\n`role_user`  表中的数据类似下面这样：\r\n\r\n| user_id | role_id  |\r\n| -------- | -------- |\r\n| 1     | 1     |\r\n| 1     | 2     |\r\n| 2     | 1     |\r\n| 2     | 2     |\r\n\r\n## 正向关联\r\n\r\n使用 `belongsToMany ` 方法。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse App\\Models\\Role;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass User extends Model\r\n{\r\n    /**\r\n     * The roles that belong to the user.\r\n     */\r\n    public function roles()\r\n    {\r\n        return $this->belongsToMany(Role::class);\r\n    }\r\n}\r\n```\r\n\r\n从方法名中解释：User 有许多（Many） Role 在（belongsTo）中间表中。\r\n\r\n当然，你也可以指定中间表名，比如 `user_role`。\r\n\r\n```\r\nreturn $this->belongsToMany(Role::class, \'user_role\');\r\n```\r\n\r\n`belongsToMany` 还有第三、第四个参数\r\n\r\n```\r\nreturn $this->belongsToMany(Role::class, \'user_role\', \'local_foreign_key\', \'other_foreign_key\');\r\n```\r\n\r\n「local_foreign_key」指本表（`users`）在关系表里对应的字段，默认是 `user_id`，「other_foreign_key」是它表（`roles`）在关系表里对应的字段，默认是 `role_id`。\r\n\r\n\r\n## 反向关联\r\n\r\n你可能已经想到，还是使用 `belongsToMany` 方法。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse App\\Models\\User;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Role extends Model\r\n{\r\n    /**\r\n     * The users that belong to the role.\r\n     */\r\n    public function users()\r\n    {\r\n        return $this->belongsToMany(User::class);\r\n    }\r\n}\r\n```\r\n\r\n`belongsToMany` 的完整写法是 `belongsToMany(User::class, \'user_role\', \'local_foreign_key\', \'other_foreign_key\');`\r\n\r\n「local_foreign_key」指本表（`roles`）在关系表里对应的字段，默认是 `role_id`，「other_foreign_key」是它表（`users`）在关系表里对应的字段，默认是 `user_id`。\r\n\r\n## 关系表\r\n\r\n### `pivot` 对象\r\n\r\n有时，需要访问关系表里的数据，那么就要用 Model 实例的 `pivot` 对象。\r\n\r\n```\r\n$user = App\\User::find(1);\r\n\r\nforeach ($user->roles as $role) {\r\n    echo $role->pivot->created_at;\r\n}\r\n```\r\n\r\n### `withPivot` 方法\r\n\r\n默认 `pivot` 对象只会取 model keys —— `user_id` 和 `role_id` 字段数据。如果像上面这样取 `created_at` 字段，就要在定义关联时带上。\r\n\r\n```\r\nreturn $this->belongsToMany(Role::class)->withPivot(\'created_at\', \'updated_at\');\r\n```\r\n\r\n### `withTimestamps` 方法\r\n\r\n如果关系表里有 `created_at` 和 `updated_at` 字段需要维护，可以在定义关联时，加上 `withTimestamps` 方法。\r\n\r\n```\r\nreturn $this->belongsToMany(Role::class)->withTimestamps();\r\n```','2017-07-03 01:05:03','2017-07-03 23:23:45','laravel-eloquent-in-relational-mapping-many-to-many'),(170,3,3,'一千零一夜：第16夜','今天忽而差点忘记了。在看 Laravel 文档，路还长。\r\n\r\n写点什么呢？写得什么吧。我心里比较平静的，这样说肯定是废话了，此刻我在宿舍，空调吹着，自然不闷热。\r\n\r\n我想到在家里在开空调的屋子里的时候，空气感觉格外干燥。可能这边水多，空气湿度高，就不觉得空气干燥了。看我分析得多透彻（真臭屁）。\r\n\r\n我今天在路上走，树上的偶尔有知了叫着，此时耳朵里好像也有隐隐的知了叫声。上海的知了叫得跟我们家里不一样，这边是一直长哨，家里是有节奏的长哨，叫的时候，屁股是一撅一撅的。\r\n\r\n昨天跑步时，还看到有人拿手电在树上照着，本来就不多。未来夏天可能只有闷热了，知了也没喽。\r\n\r\n没有什么可惜，只是单一了。遥想从前、当年，总颇多感慨。殊不知，从前和当年也是跟现在一样过去的，那是过去的现在。\r\n\r\n现在不感觉到什么，以后回忆里只有空白和凄凉，如此空白的过去，想想都淡，都淡出个鸟来了。','2017-07-03 06:32:25','2017-07-03 06:32:25','one-thousand-nights-the-night-of-the-16th'),(171,7,7,'CentOS 6.5下利用Rsyslog+LogAnalyzer+MySQL部署日志服务器','## 安装开发包\r\n\r\n```\r\nyum -y install wget gcc-c++ ncurses ncurses-devel cmake make perl bison openssl openssl-devel gcc* libxml2 libxml2-devel curl-devel libjpeg* libpng* freetype*\r\n```\r\n\r\n\r\n## 安装mysql，php，apach，rsyslog 连接MySQL数据库的模块\r\n\r\n```\r\nyum -y install rsyslog-mysql mysql-server php httpd php-mysql php-gd\r\n```\r\n\r\n## 启动服务并加入开机启动\r\n\r\n1. 启动Apache\r\n\r\n```\r\n/etc/init.d/httpd start\r\nchkconfig httpd on\r\n```\r\n\r\n2. 启动数据库\r\n\r\n```\r\n/etc/init.d/mysqld start\r\nchkconfig mysqld on\r\n```\r\n\r\n3. 设置MySQL root 密码\r\n\r\n```\r\nmysqladmin -uroot password \'abc123\r\n```\r\n\r\n4.  测试php运行环境\r\n\r\n```\r\ncd /var/www/html/\r\n```\r\n\r\n```\r\n[root@TS html]# cat > index.php <<EOF \r\n> <?php \r\n> phpinfo(); \r\n> ?> \r\n> EOF\r\n```\r\n\r\n打开浏览器访问：http://127.0.0.1/index.php\r\n\r\n## 安装配置RSYSLOG\r\n\r\n1.  检查是否安装了rsyslog软件\r\n\r\n```\r\nrpm -qa|grep rsyslog    //默认系统都安装了该软件\r\n```\r\n\r\n2.  导入rsyslog-mysql 数据库文件\r\n\r\n```\r\ncd /usr/share/doc/rsyslog-mysql-5.8.10/\r\nmysql -uroot -pabc123 < createDB.sql\r\nmysql -uroot –p\r\nmysql> show databases;\r\nmysql> show tables;\r\n```\r\n\r\n导入数据库操作创建了Syslog 库并在该库中创建了两张空表SystemEvents 和SystemEventsProperties。\r\n\r\n3.  创建rsyslog 用户在mysql下的相关权限\r\n\r\n```\r\nmysql -uroot –p\r\nmysql> grant all on Syslog.* to rsyslog@localhost identified by \'123456\';\r\nmysql> flush privileges;\r\nmysql> exit\r\n```\r\n\r\n4. 配置服务端支持rsyslog-mysql 模块，并开启UDP服务端口获取网内其他LINUX系统日志\r\n\r\n```\r\nvi /etc/rsyslog.conf \r\n$ModLoad ommysql \r\n*.* :ommysql:localhost,Syslog,rsyslog,123456\r\n```\r\n在 #### MODULES #### 下添加上面两行。\r\n说明：localhost 表示本地主机，Syslog 为数据库名，rsyslog 为数据库的用户，123456为该用户密码。\r\n5. 开启相关日志模块\r\n```\r\nvi /etc/rsyslog.conf \r\n$ModLoad immark    #immark是模块名，支持日志标记\r\n$ModLoad imudp    #imupd是模块名，支持udp协议\r\n$UDPServerRun 514    #允许514端口接收使用UDP和TCP协议转发过来的日志\r\n```\r\n\r\n6. 重启rsyslog 服务\r\n`/etc/init.d/rsyslog restart`\r\n\r\n## 安装LogAnglyzer\r\n1. 安装LogAnglyzer\r\n```\r\nwget http://download.adiscon.com/loganalyzer/loganalyzer-3.6.5.tar.gz\r\ntar zxf loganalyzer-3.6.5.tar.gz\r\ncd loganalyzer-3.6.5\r\nmkdir -p /var/www/html/loganalyzer\r\nrsync -a src/* /var/www/html/loganalyzer/\r\n```\r\n\r\n2. 在游览其中配置LogAnglyzer\r\n打开浏览器访问：http://127.0.0.1/loganalyzer/\r\n\r\n提示没有配置文件，点击 here 利用向导生成。\r\n3. 第一步，测试系统环境\r\n\r\n点击 “Next”，进入第二步\r\n\r\n提示错误：缺少config.php 文件，并且权限要设置为666，可以使用contrib目录下的configure.sh 脚本生成。\r\n查看configure.sh 文件内容\r\n\r\n需要在/var/www/html/loganalyzer/ 下创建config.php 文件，并设置其权限为666。\r\n```\r\ntouch /var/www/html/loganalyzer/config.php\r\nchmod 666 /var/www/html/loganalyzer/config.php \r\n```\r\n\r\n做完上面的操作之后，执行 ReCheck 操作，config.php 文件可写，点击 Next 进入下一步。\r\n\r\n第三步，基础配置\r\n\r\n在User Database Options 中，填入上面设置的参数，然后点击 Next.\r\n第四步，创建表\r\n\r\n点击 Next 开始创建表。\r\n第五步，检查SQL结果\r\n\r\n\r\n第六步，创建管理用户\r\n\r\n第七步，创建第一个系统日志source.\r\n\r\n第八步，完成\r\n\r\n\r\n关闭防火墙\r\nService iptable stop','2017-07-03 16:40:29','2017-07-03 16:49:22','centos-65-use-rsyslog-loganalyzer-mysql-deployment-log-server'),(172,3,3,'Laravel 文档阅读：事件','Laravel 的事件类放在 `app/Events` 目录下，事件侦听器放在 `app/Listeners` 目录下。\r\n\r\n## 注册事件&事件侦听器\r\n\r\n在 `EventServiceProvider ` 的 `listen ` 属性中注册事件和对应的事件侦听器。以 `OrderShipped ` 事件为例：\r\n\r\n```\r\n/**\r\n * The event listener mappings for the application.\r\n *\r\n * @var array\r\n */\r\nprotected $listen = [\r\n    \'App\\Events\\OrderShipped\' => [\r\n        \'App\\Listeners\\SendShipmentNotification\',\r\n    ],\r\n];\r\n```\r\n\r\n### 生成事件&事件监听器\r\n\r\n使用 Artisan 命令 `php artisan event:generate`，即可生成在 `EventServiceProvider ` 的 `listen ` 属性中注册事件和对应的事件侦听器。\r\n\r\n当然，已经存在的事件或事件侦听器不受影响。\r\n\r\n### 手工注册事件\r\n\r\n除了在 `EventServiceProvider ` 的 `listen ` 属性中注册事件外，还有一种注册事件的方式：**在 `EventServiceProvider ` 的 `boot` 方法里注册基于闭包的事件**，这称为「手工注册事件」。\r\n\r\n```\r\n/**\r\n * Register any other events for your application.\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    parent::boot();\r\n\r\n    Event::listen(\'event.name\', function ($foo, $bar) {\r\n        //\r\n    });\r\n}\r\n```\r\n\r\n也可以使用通配符，匹配多个事件。\r\n\r\n```\r\nEvent::listen(\'event.*\', function ($eventName, array $data) {\r\n    //\r\n});\r\n```\r\n\r\n## 定义事件\r\n\r\n事件类可以看成一个数据容器。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Events;\r\n\r\nuse App\\Order;\r\nuse Illuminate\\Queue\\SerializesModels;\r\n\r\nclass OrderShipped\r\n{\r\n    use SerializesModels;\r\n\r\n    public $order;\r\n\r\n    /**\r\n     * Create a new event instance.\r\n     *\r\n     * @param  Order  $order\r\n     * @return void\r\n     */\r\n    public function __construct(Order $order)\r\n    {\r\n        $this->order = $order;\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 定义侦听器\r\n\r\n侦听器里有个 `handle` 方法，处理事件逻辑。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Listeners;\r\n\r\nuse App\\Events\\OrderShipped;\r\n\r\nclass SendShipmentNotification\r\n{\r\n    /**\r\n     * Create the event listener.\r\n     *\r\n     * @return void\r\n     */\r\n    public function __construct()\r\n    {\r\n        //\r\n    }\r\n\r\n    /**\r\n     * Handle the event.\r\n     *\r\n     * @param  OrderShipped  $event\r\n     * @return void\r\n     */\r\n    public function handle(OrderShipped $event)\r\n    {\r\n        // Access the order using $event->order...\r\n    }\r\n}\r\n```\r\n\r\n在 `handle` 方法最后 `return false` 可阻止事件传播至其他侦听器。\r\n\r\n## 事件分派\r\n\r\n有个全局方法 `event ` 用来分派事件。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Order;\r\nuse App\\Events\\OrderShipped;\r\nuse App\\Http\\Controllers\\Controller;\r\n\r\nclass OrderController extends Controller\r\n{\r\n    /**\r\n     * Ship the given order.\r\n     *\r\n     * @param  int  $orderId\r\n     * @return Response\r\n     */\r\n    public function ship($orderId)\r\n    {\r\n        $order = Order::findOrFail($orderId);\r\n\r\n        // Order shipment logic...\r\n\r\n        event(new OrderShipped($order));\r\n    }\r\n}\r\n```\r\n\r\n## 事件注册者\r\n\r\n### 写事件注册者\r\n\r\n事件注册者（Subscribers）本质上是事件侦听器，但与事件侦听器不同的是，它**更像是几个事件侦听器**。事件注册者中可包含「多个事件」及对应「事件的处理逻辑」。\r\n\r\n每个事件注册者中都有一个 `subscribe` 方法，在这个方法里**设定指定事件的处理逻辑**。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Listeners;\r\n\r\nclass UserEventSubscriber\r\n{\r\n    /**\r\n     * Handle user login events.\r\n     */\r\n    public function onUserLogin($event) {}\r\n\r\n    /**\r\n     * Handle user logout events.\r\n     */\r\n    public function onUserLogout($event) {}\r\n\r\n    /**\r\n     * Register the listeners for the subscriber.\r\n     *\r\n     * @param  Illuminate\\Events\\Dispatcher  $events\r\n     */\r\n    public function subscribe($events)\r\n    {\r\n        $events->listen(\r\n            \'Illuminate\\Auth\\Events\\Login\',\r\n            \'App\\Listeners\\UserEventSubscriber@onUserLogin\'\r\n        );\r\n\r\n        $events->listen(\r\n            \'Illuminate\\Auth\\Events\\Logout\',\r\n            \'App\\Listeners\\UserEventSubscriber@onUserLogout\'\r\n        );\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 注册事件注册者\r\n\r\n事件注册者在 `EventServiceProvider ` 中注册，不过不是在 `$listen` 属性中，而是在 `$subscribe` 属性中。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Providers;\r\n\r\nuse Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\r\n\r\nclass EventServiceProvider extends ServiceProvider\r\n{\r\n    /**\r\n     * The event listener mappings for the application.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $listen = [\r\n        //\r\n    ];\r\n\r\n    /**\r\n     * The subscriber classes to register.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $subscribe = [\r\n        \'App\\Listeners\\UserEventSubscriber\',\r\n    ];\r\n}\r\n```','2017-07-03 17:42:43','2017-07-03 17:42:43','laravel-document-reading-events'),(173,3,3,'QQ 邮箱第三方客户端登录授权码申请流程','设置 > 账户 > POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务\r\n\r\n开启「POP3/SMTP服务」> 生成「授权码」（注意，请妥善保存授权码）。\r\n\r\nLaravel 中使用 `.env` 的配置：\r\n\r\n```\r\nMAIL_DRIVER=smtp\r\nMAIL_HOST=smtp.qq.com\r\nMAIL_PORT=465\r\nMAIL_USERNAME=xxxxxxxxxx@qq.com\r\nMAIL_PASSWORD=xxxxxxxxxxxxxxxx\r\nMAIL_ENCRYPTION=ssl\r\nMAIL_FROM_ADDRESS=xxxxxxxxxx@qq.com\r\nMAIL_FROM_NAME=Laravel\r\n```\r\n\r\n`smtp.qq.com` 是 QQ 发送邮件服务器的地址，使用 SSL，端口号 465 或 587；`xxxxxxxxxxxxxxxx` 是在 QQ 得到的授权码。','2017-07-03 18:34:27','2017-07-03 18:34:27','qq-mailbox-third-party-client-login-authorization-code-application-process'),(174,3,3,'使用数据库存取 Laravel 队列任务','队列（Queues）是为耗时操作准备的。下面使用数据库存取 Laravel 队列任务。\r\n\r\n\r\n## 创建队列任务表\r\n\r\n分两个：`jobs` 和 `failed_jobs`，前者是存放待执行任务的，后者是存放失败任务的。\r\n\r\n```\r\n$ php artisan queue:table\r\n$ php artisan queue:failed-table\r\n\r\n$ php artisan migrate\r\n```\r\n\r\n`queue:table` 命令会生成一个迁移文件 `2017_07_04_035056_create_jobs_table.php`。\r\n\r\n`queue:failed-table` 命令会生成一个迁移文件 `2017_07_04_131543_create_failed_jobs_table.php`。\r\n\r\n## 创建用户伪数据\r\n\r\n```\r\n$ php artisan tinker\r\nPsy Shell v0.8.8 (PHP 7.0.20 cli) by Justin Hileman\r\n>>> namespace App;\r\n>>> factory(User::class, 30)->create();\r\n```','2017-07-03 20:30:08','2017-07-03 23:14:27','using-the-database-access-laravel-queue-tasks'),(175,3,3,'测点速率超上限没预警','```\r\nselect * from Scf_SiteDatabase where DatabaseName like \'%潜山%\';\r\n\r\nselect * from Scf_SiteBasic where SiteName like \'%潜山%\';\r\n```\r\n\r\n```\r\nselect * from Svy_SurveyPoint where SurveyPointName like \'%AWA2-1%\';\r\n\r\nselect * from Svy_SurveyItem where Svy_SurveyItemID in (\'37F288BD-1478-4D48-ABC9-1C77CB8A9391\', \'37FB1B71-3092-4ACD-BB47-627FA91B690C\');\r\n```\r\n\r\n```\r\nselect * from Std_SurveyItem where Std_SurveyItemID = \'376A2A15-BB5D-4ADD-99FF-37D876B01DB0\';\r\n```','2017-07-04 00:45:25','2017-07-04 00:47:59','measuring-point-velocity-ultra-limit-warning'),(176,3,3,'快捷打印 Laravel 中的数据库查询（SQL）语句','闲话少叙，直接入题。首先，为什么要打印 Laravel 中 Query Builder 构建的 SQL 语句？\r\n\r\n答案很简单，就是我要知道到底执行了什么 SQL 语句，这样我就能合适地写 Query Builder、在适合用『热加载』的场景不会误用『懒加载』。\r\n\r\n## 热加载\r\n\r\n```\r\n$user = User::where(\'name\', \'Eric\')->with(\'articles\')->first();\r\n```\r\n\r\n上面就是热加载的例子――获取第一个名为『Eric』的用户信息同时，把他的文章也全都取到。\r\n\r\n这样的使用场景下，Query Builder 只使用了类似下面的两条 SQL 语句。\r\n\r\n1. `select * from users where name = \'Eric\' limit 1;`\r\n2. `select * from articles where user_id in (22);`\r\n\r\n就是说当你用 `$user->articles` 遍历用户文章时，不会再请求数据库了。\r\n\r\n## 懒加载\r\n\r\n懒加载和热加载是相对的。下面就是懒加载的例子。\r\n\r\n```\r\n$user = User::where(\'name\', \'Eric\')->first();\r\n\r\n// 在 blade 模版里遍历打印出用户文章\r\n@foreach ($user->posts as $post)\r\n```\r\n\r\n这种用法能达到效果，但是效率会变低――每次遍历、处理的一篇文章信息，都是向数据库执行一次 SQL 得到的。\r\n\r\n如果用户有 N 篇文章，就要执行 N 次 SQL 查询，再加上之前请求用户信息的 1 次 SQL，这就是所谓的『N+1』问题。\r\n\r\n明明能 2 次完成的事，就不要再花 N+1 次了。\r\n\r\n## 打印 SQL\r\n\r\n像上面的状况，如果我们知道底层是怎样执行 SQL 语句的，也许就不会发生了。这就为我们找出了一个有必要打印 SQL 语句来看的理由。\r\n\r\n既然文章题目是『快捷打印 SQL』，自然配置起来也很简单。配置到最后的结果的是：\r\n\r\n当你的 `APP_ENV` 设置为 `local`、请求 URL 后面紧跟 `?sql-debug=1` 时，就会打印出请求处理逻辑中涉及到的所有数据库查询语句。\r\n\r\n## 配置\r\n\r\nAppServiceProvider 的 boot 方法内写入\r\n\r\n```\r\nif ( env(\'APP_ENV\') === \'local\' ) {\r\n    DB::connection()->enableQueryLog();\r\n}\r\n\r\nif ( env(\'APP_ENV\') === \'local\' ) {\r\n    DB::connection()->enableQueryLog();\r\n		Event::listen(\'kernel.handled\', function ( $request, $response ) {\r\n        if ( $request->has(\'sql-debug\') ) {\r\n            $queries = DB::getQueryLog()；\r\n			if (!empty($queries)) {\r\n				foreach ($queries as &$query) {\r\n					$query[\'full_query\'] = vsprintf(str_replace(\'?\', \'%s\', $query[\'query\']), $query[\'bindings\']);\r\n				}\r\n			}\r\n            dd($queries);\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n注意：路由有两种形式——基于闭包（Closure）和基于控制器动作（Controller Action）的。**上面的配置只对基于控制器动作的路由有效**。\r\n\r\n## 参考链接\r\n\r\nhttps://www.reddit.com/r/laravel/comments/5f7y9f/debugging_the_amount_of_database_queries_per/','2017-07-04 04:54:47','2017-07-04 21:33:27','quick-print-database-query-sql-statements-in-the-laravel'),(177,7,7,'elasticsearch基本操作','## 创建索引\r\n```\r\nPut lagou\r\n{\r\n  \"settings\":{\r\n      \"index\":{\r\n           \"number_of_stards\":5,\r\n	\"number_of_replicas\":1\r\n        }\r\n  }\r\n}\r\n```\r\n\r\n## 获取信息\r\n```\r\nGet lagou/_settins（获取拉钩settings信息）\r\nGet _all/settings(获取所有索引信息）\r\nGet .kibana,lagou/_settings(获取kibana，lagou索性信息）\r\nGet _settings\r\n```\r\n\r\n## 修改settings\r\n```\r\nPut lagou/_settings\r\n{\r\n   \"number_of_shards\":3\r\n}\r\n```\r\n\r\n## 获取索引信息\r\n```\r\nGet _all\r\nGet lagou\r\n```\r\n\r\n## 保存文档\r\n```\r\nPut /lagou/job/1\r\n{\r\n	\"title\":\"python分布式爬虫开发\",\r\n	\"salary_min\":15000,\r\n	\"city\":\"北京\",\r\n	\"compant\":{\r\n		\"name\":\"百度\"，\r\n		\"company_addr\":\"北京软件园\"\r\n	\r\n	},\r\n	\"publish_date\":\"2017-4-16\",\r\n	\"comments\":15\r\n}\r\n\r\nPost/lagou/job/\r\n{\r\n	\"title\":\"python django 开发\",\r\n	\"salary_min\":30000,\r\n	\"city\":\"上海\",\r\n	\"compant\":{\r\n		\"name\":\"百度\"，\r\n		\"company_addr\":\"北京软件园\"\r\n	\r\n	},\r\n	\"publish_date\":\"2017-4-16\",\r\n	\"comments\":20\r\n}\r\n```\r\n\r\n## 查询\r\n```\r\nGet lagou/job/1\r\nGet lagou/job/1?_source=title\r\nGet lagou/job/1?_source=title,city\r\nGet lagou/job/1?_sourc\r\n```\r\n\r\n# 修改文章\r\n## 覆盖\r\n```\r\nPut /lagou/job/1\r\n{\r\n	\"title\":\"python分布式爬虫开发\",\r\n	\"salary_min\":15000,\r\n	\"city\":\"北京\",\r\n	\"compant\":{\r\n		\"name\":\"百度\"，\r\n		\"company_addr\":\"北京软件园\"\r\n	\r\n	},\r\n	\"publish_date\":\"2017-4-16\",\r\n	\"comments\":15\r\n}\r\n```\r\n\r\n## 修改\r\n```\r\nPost lagou/jog/1/_update\r\n{\r\n  \"doc\":{\r\n	\"comments\":20\r\n	}\r\n}\r\n```\r\n\r\n## 删除\r\n```\r\nDelete lagou/job/1\r\nDelete lagou\r\n```','2017-07-04 06:03:10','2017-07-04 06:26:35','elasticsearch-basic-operation'),(178,7,7,'elasticsearch-查询','## 查询分类\r\n基本查询：使用elasticsearch内置查询条件查询\r\n组合查询：把多个查询组合在一起进行复合查询\r\n过滤：查询同时，通过filter条件在不影响打分的情况下删选数据\r\n\r\n## Match查询（类似like模糊查询）\r\n```\r\nGet lagou/_search\r\n{\r\n	\"query\":{\r\n		\"match\":{\r\n			\"title\":\"python\"\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## term查询（精确查询）\r\n```\r\nGet lagou/_search\r\n{\r\n	\"query\":{\r\n		\"term\":{\r\n			\"company_name\":\"阿里巴巴科技有限公司\"\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## terms查询（工程师，django，系统任何一个满足返回结果）\r\n```\r\nGet lagou/_search\r\n{\r\n	\"query\":{\r\n		\"term\":{\r\n			\"title\":[\"工程师\",\"django\",\"系统\"]\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## 控制查询的返回数量\r\n```\r\nGet lagou/_search\r\n{\r\n	\"query\":{\r\n		\"term\":{\r\n			\"title\":\"python\"\r\n		}\r\n	},\r\n	\"from\":1\r\n	\"size\":2\r\n}\r\n```\r\n\r\n## Match all 查询\r\n```\r\nGet lagou/_search\r\n{\r\n	\"query\":{\r\n		\"match_all\":{}\r\n	}\r\n}\r\n```\r\n\r\n## Match_phrase查询-短语查询\r\n```\r\nGet lagou/_search\r\n{\r\n	\"query\":{\r\n		\"match_phrasel\":{\r\n			\"title\":{\r\n				\"query\":\"python系统\",\r\n				\"slop\":6    #python和系统之间的距离\r\n			}\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## Multi_match查询-比如可以指定多个字段,比如查询title和desc这两个字段里的包含python的关系词文档\r\n```\r\nGet lagou/_search\r\n{\r\n	\"query\":{\r\n		\"multi_matchl\":{\r\n			\"query\":\"python\",\r\n			\"flelds\":[\"title\",\"desc\"]\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## 指定返回字段(返回title，company_name字段)\r\n```\r\nGet lagou/_search\r\n{\r\n	\"stored_fields\":[\"title\",\"company_name\"],\r\n	\"query\":{\r\n		\"match\":{\r\n			\"title\":\"python\"\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## 通过sort把结果排序\r\n```\r\nGet lagou/_search\r\n{\r\n	\"query\":{\r\n		\"match_all\":{}\r\n	},\r\n	\"sort\":[{\r\n		\"comments\":{\r\n			\"other\":\"desc\"\r\n		}\r\n	}\r\n	]\r\n}\r\n```\r\n\r\n# 查询范围\r\n## range查询\r\n```\r\nGet lagou/_search /查询comments大于等于10小于等于20\r\n{\r\n	\"query\":{\r\n		\"range\":{\r\n			\"comments\":{\r\n				\"gte\":10, /大于等于\r\n				\"let\":20, /小于等于\r\n				\"boost\":2.0 /权重\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nGet lagou/_search /\r\n{\r\n	\"query\":{\r\n		\"range\":{\r\n			\"add_time\":{\r\n				\"gte\":\"2017-04-01\",\r\n				\"let\":\"now\"\r\n			}\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## Wildcard 查询 /模糊查询\r\n```\r\n{\r\n	\"query\":{\r\n		\"wildcard\":\r\n		{\"title\":{\"value\":\"pyth*n,\"boost\":2.0}}\r\n	}\r\n}\r\n```','2017-07-04 06:32:07','2017-07-04 06:32:07','elasticsearch-query'),(179,7,7,'elasticsearch-组合查询','## bool查询\r\n老版本的filtered已经被bool替换\r\n用bool包括 must should must_not filter来完成，格式如下：\r\n```\r\nBool:{\r\n	\"filter\":[],\r\n	\"must\":[],\r\n	\"should\":[],\r\n	\"must_not\":[]\r\n	}\r\n```\r\n\r\n# 简单过滤查询\r\n## 最简单的filter查询\r\nselect * from testjob where salary=20\r\n薪资为20K的工作\r\n```\r\nGet lagou/testjob/_search\r\n{\r\n	\"query\":{\r\n		\"bool\":{\r\n			\"must\":{\r\n				\"match_all\":{}\r\n			},\r\n			\"filter\":{\r\n				\"term\":{\r\n					\"salary\":20\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## 指定多个值\r\n薪资为20K的工作\r\n```\r\nGet lagou/testjob/_search\r\n{\r\n	\"query\":{\r\n		\"bool\":{\r\n			\"must\":{\r\n				\"match_all\":{}\r\n			},\r\n			\"filter\":{\r\n				\"term\":{\r\n					\"salary\":[10,20]\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n## 查看分析器解析的结果\r\n```\r\nGet _analyze\r\n{\r\n	\"analyzer\":\"ik_max_word\"\r\n	\"text\":\"Python网络开发工程师\"\r\n}\r\n```\r\n\r\n## bool过滤查询，可以做组合过滤查询\r\nselect * from testjob where(salary=20 or title=python) and (salary!=30）\r\n```\r\nGet lagou/testjob/_search\r\n{\r\n	\"query\":{\r\n		\"bool\":{\r\n			\"should\":[\r\n				{\"term\":{\"salary\":20}},\r\n				{\"term\":{\"title\":\"python\"}}\r\n				],\r\n				\"must_not\":{\r\n					\"term\":{\"salary\":30}\r\n				}\r\n			}\r\n		}\r\n	}\r\n```\r\n\r\n## 嵌套查询\r\nselect * from testjob where title=\"python\" or (title=\"elasticsearch\" and salary=30)\r\n···\r\nGet lagou/testjob/_search\r\n{\r\n	\"query\":{\r\n		\"bool\":{\r\n			\"should\":[\r\n				{\"term\":{\"title\":python},\r\n				{\"bool\":{\r\n					\"must\"[\r\n						{\"term\":{\"title\":\"elasticsearch\"}},\r\n						{\"term\":{\"salary\":30}}\r\n						]\r\n					}\r\n					}\r\n				]\r\n			}\r\n		}\r\n···\r\n\r\n## 过滤空和非空\r\n处理null控制的方法\r\nSelect tags from testjob2 where tags is not null\r\n\r\n```\r\nGet lagou/testjob2/_search\r\n{\r\n	\"query\":{\r\n		\"bool\":{\r\n			\"filter\":{\r\n				\"exists\":{\r\n					\"field\":\"tags\"\r\n					}\r\n				}\r\n			}\r\n		}\r\n	}\r\n```\r\n\r\n```\r\nGet lagou/testjob2/_search\r\n{\r\n	\"query\":{\r\n		\"bool\":{\r\n			\"must_not\":{\r\n				\"exists\":{\r\n					\"field\":\"tags\"\r\n					}\r\n				}\r\n			}\r\n		}\r\n	}\r\n```','2017-07-04 06:36:03','2017-08-14 04:15:41','elasticsearch-combination-query'),(180,7,7,'SQL SERVER基础篇','# 一.数据库语句\r\n## 1.查询\r\n```\r\nSELECT 列名称 FROM 表名称 where 条件\r\nSELECT * FROM 表名称 查询全部\r\n```\r\n## 2.插入\r\n```\r\nINSERT INTO 表名称 VALUES (值1, 值2,....)\r\nINSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)\r\n```\r\n## 3.更新\r\n```\r\nUPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值\r\nUPDATE Person SET FirstName = \'Fred\' WHERE LastName = \'Wilson\' \r\n```\r\n## 4.删除\r\n```\r\nDELETE FROM 表名称 WHERE 列名称 = 值\r\nDELETE FROM Person WHERE LastName = \'Wilson\' \r\n```\r\n## 5.去重\r\n```SELECT DISTINCT 列名称 FROM 表名称```\r\n\r\n## 6.排序\r\n```\r\norder by\r\nORDER BY 语句用于根据指定的列对结果集进行排序。\r\nORDER BY 语句默认按照升序对记录进行排序。\r\n如果您希望按照降序对记录进行排序，可以使用 DESC 关键字\r\nSELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC\r\n```','2017-07-04 06:44:24','2017-08-09 08:53:29','sql-server-based'),(181,7,7,'elasticsearch-mapping','## 映射:创建索引的时候，可以预先定义字段的类型以及相关信息\r\n## 类型:静态映射和动态映射\r\n## 内置类型\r\n## string类型：text，keyword（string在es5已经废弃）\r\n## 数字类型：long，interger，short，byte，doule，float\r\n## 日期类型：date\r\n## bool类型：boolean\r\n## binary类型：binary\r\n## 复杂类型：object，nested\r\n## geo类型：geo-point，geo-shape（地理位置）\r\n## 专业类型：ip，competion','2017-07-04 06:49:37','2017-07-04 06:50:03','elasticsearch-mapping'),(182,3,3,'一千零一夜：第17夜','我为家人身体都康健而开心。忽而想到往昔看过的电影《触不到的恋人》，听了简单的纯音乐。\r\n\r\n放多了就自然没有感觉，但轻微地听一下，心情平静，是往昔的平静。并不是倒退，因为我给自己的时间比较多，除了阅读文档，就是写这些，想这些了。\r\n\r\n《被嫌弃的松子的一生》这部电影就像犯神经，看的过程没有愉悦感，现在回想、看剧照也是一样的想法，没有变。我同情松子，却没有更深的想法，因为我觉得里面的人都是有神经病的。\r\n\r\n平庸，平庸如土，放纵，放纵如泥，热切，热切如火，灰心，灰心如灰。一种极致的情感表达，会有扭曲的感觉。','2017-07-04 07:03:31','2017-07-04 07:04:17','one-thousand-nights-the-night-of-the-17th'),(183,3,3,'一千零一夜：第18夜','因为待会要练平板支撑和搞懂 VM Vitrualbox，所以，我先把之前想到的记录下来。\r\n\r\n现在还在下雨，但空气也并不十分凉爽，有些闷热。今天的雨来得突然，也非常滂沱，你想不到中午还是艳阳高照、让人浑身无力的空气。\r\n\r\n我感觉自己手因为总摸手机变成鸡爪了。我感觉现在学习情绪有些芜杂。太繁多了，我跟进不过来。也不甚懂，却也没找到满意的解释，我感觉能像阮一峰那样把复杂的东西讲清楚是不容易的，需要条例清晰，也要用通俗易懂的语言。\r\n\r\n就写到这里。','2017-07-05 06:19:55','2017-07-05 06:19:55','one-thousand-night-night-18'),(184,3,3,'何为 VirtualBox？','VirtualBox 是一款跨平台的虚拟化软件。跨平台可以简单理解成这款软件可以在 Windows、Linux 和 Mac 系统上安装；虚拟化可以简单理解为能创建虚拟电脑。\r\n\r\n## 几个术语\r\n\r\n理解下面几个术语，会对理解虚拟化有很大帮助。\r\n\r\n1. 宿主系统（Host Operating System）。如果你是在 Windows 10 系统里安装 VirtualBox 的，那么宿主系统就是 Windows 10。\r\n2. 子操作系统（Guest Operating System）。运行在虚拟电脑里的操作系统就是子操作系统。\r\n3. 虚拟电脑（Virtual Machine，简称 VM）。前面有两处提到它――由 VirtualBox 创建，子操作系统运行其中。\r\n\r\n对 VirtualBox 来说，虚拟电脑就是一些参数设定――分配多少内存、分配多大硬盘、现在开机呢还是关机等。\r\n\r\n对宿主系统而言，虚拟电脑展现形式就是桌面上的一个窗口，能开启全屏模式，里面运行一台子操作系统。\r\n\r\n## 好处\r\n\r\n使用 VirtualBox 的好处如下：\r\n1. 不同于「双系统」模式，需要重启电脑才能切换系统。使用 VirtualBox，可在宿主系统里同时运行多个虚拟电脑，相当于运行多个操作系统。\r\n2. VirtualBox 创建的虚拟电脑相当于一个“容器”，你可以拷贝它到别的安装 VirtualBox 的电脑里使用。\r\n\r\n## 参考链接\r\n\r\nhttps://www.virtualbox.org/manual/ch01.html','2017-07-05 15:34:50','2017-07-05 19:03:22','what-is-a-virtualbox'),(185,3,3,'何为 Vagrant？','Vagrant 是用来管理虚拟电脑的。它依赖用来创建虚拟电脑的软件，比如：VM VitualBox 和 VMWare。所以，要先安装 VM VitualBox，再安装 Vagrant。\r\n\r\n## 两个概念\r\n\r\n关于 Vagrant，还有两个重要的概念需要理解——供应商（Providers）和盒子（Boxes）。\r\n\r\n### 供应商\r\n\r\nVagrant 是用来管理虚拟电脑的，而提供虚拟电脑的就是「供应商」。Vagrant 默认「供应商」是 VM VitualBox ，就是说 Vagrant 天生支持管理由 VM VitualBox 创建的虚拟电脑。\r\n\r\n所以要先安装供应商，再安装 Vagrant。\r\n\r\n### 盒子\r\n\r\n「盒子」是 Vagrant 可以识别的包，使用 `vagrant box` 命令管理。简单说它是一个操作系统+预制软件的发布包。\r\n\r\n盒子安装好后就是一个子操作系统，但与用系统镜像在虚拟电脑里直接安装的操作系统不同的是——用 Vagrant 管理。\r\n\r\n盒子支持发布版本号，还支持复制，转移到其它安装了 Vagrant 的电脑。\r\n\r\n对于一个开发团队来说，团队里的每个人的开发环境最好都是一样的（以避免因开发环境的差异导致引起的开发、发布的问题），而盒子就可以解决这个问题——全团队每个人都使用同一个版本号的盒子，即使后期开发环境改变（安装了一些依赖），那么直接升级盒子的版本号就可以了。\r\n\r\n这里有一些打包好的 [盒子清单供下载使用][1]。\r\n\r\n[1]: https://app.vagrantup.com/boxes/search\r\n\r\n## 安装\r\n\r\n下面创建一个 Ubuntu 12.04 LTS 64位\r\n\r\n```\r\n$ vagrant init hashicorp/precise64\r\n```\r\n\r\n执行后，在当前目录生成一个配置文件 `Vagrantfile`。然后，启动虚拟\r\n\r\n```\r\n$ vagrant up\r\nBringing machine \'default\' up with \'virtualbox\' provider...\r\n==> default: Box \'hashicorp/precise64\' could not be found. Attempting to find and install...\r\n    default: Box Provider: virtualbox\r\n    default: Box Version: >= 0\r\n==> default: Loading metadata for box \'hashicorp/precise64\'\r\n    default: URL: https://vagrantcloud.com/hashicorp/precise64\r\n==> default: Adding box \'hashicorp/precise64\' (v1.1.0) for provider: virtualbox\r\n    default: Downloading: https://vagrantcloud.com/hashicorp/boxes/precise64/versions/1.1.0/providers/virtualbox.box\r\n    default:\r\n==> default: Successfully added box \'hashicorp/precise64\' (v1.1.0) for \'virtualbox\'!\r\n==> default: Importing base box \'hashicorp/precise64\'...\r\n==> default: Matching MAC address for NAT networking...\r\n==> default: Checking if box \'hashicorp/precise64\' is up to date...\r\n==> default: Setting the name of the VM: OS_default_1499302083371_43550\r\n==> default: Clearing any previously set network interfaces...\r\n==> default: Preparing network interfaces based on configuration...\r\n    default: Adapter 1: nat\r\n==> default: Forwarding ports...\r\n    default: 22 (guest) => 2222 (host) (adapter 1)\r\n==> default: Booting VM...\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 参考链接\r\n\r\n1. https://www.vagrantup.com/docs/providers/\r\n2. https://app.vagrantup.com/boxes/search','2017-07-05 15:54:13','2017-07-05 17:18:30','what-is-a-vagrant'),(186,3,3,'何为 Homestead？','Homestead 是一个 Vagrant 盒子（Vagrant Box），由 Laravel 官方提供，使用 `vagrant box add laravel/homestead` 安装到本地，启动后是一个 Ubuntu 系统，预装了很多软件。 \r\n\r\n## Homestead Vagrant Box\r\n\r\nHomestead 包含的软件清单如下：\r\n\r\n* Ubuntu 16.04\r\n* Git\r\n* PHP 7.1\r\n* Nginx\r\n* MySQL\r\n* MariaDB\r\n* Sqlite3\r\n* Postgres\r\n* Composer\r\n* Node (With Yarn, Bower, Grunt, and Gulp)\r\n* Redis\r\n* Memcached\r\n* Beanstalkd\r\n* Mailhog\r\n* ngrok\r\n\r\n它的目的是为了提供开发 Laravel 项目的一个完整环境包（甚至是操作系统！），帮助开发人员统一开发环境。\r\n\r\n因为 Homestead 本身是一个 Vagrant 盒子，所以在任何安装了 Vagrant 的系统里安装、更新都很容易；又有官方的提供的环境包支持，所以开发人员再也没必要担心配置环境不一致、出错啦等问题！\r\n\r\n## 本质\r\n\r\nHomestead 所做的工作：连接本地系统和虚拟电脑中的 Ubuntu 系统。\r\n\r\n具体是：\r\n\r\n1. 本地端口到 Ubuntu 系统端口的映射（默认设定如下）\r\n\r\n```\r\nSSH: 2222 → 指向 22\r\nHTTP: 8000 → 指向 80\r\nHTTPS: 44300 → 指向 443\r\nMySQL: 33060 → 指向 3306\r\nPostgres: 54320 → 指向 5432\r\nMailhog: 8025 → 指向 8025\r\n```\r\n\r\n2. 本地 Laravel 项目同步到 Ubuntu 系统中（`Homestead.yaml` 文件中设定）。\r\n\r\n```\r\nip: \"192.168.10.10\"\r\n\r\nfolders:\r\n    - map: C:/Code\r\n      to: /home/vagrant/Code\r\n      \r\nsites:\r\n    - map: homestead.app\r\n      to: /home/vagrant/Code/Laravel/public\r\n```\r\n\r\n`C:\\Windows\\System32\\drivers\\etc\\hosts` 文件\r\n\r\n```\r\n192.168.10.10  homestead.app\r\n```\r\n\r\n上面讲本地 ` C:/Code` 目录映射到 `/home/vagrant/Code` 目录。本地访问 `homestead.app` 就是访问 `/home/vagrant/Code/Laravel/public` 项目。\r\n\r\n效果是，在本地浏览器中实时查看 Ubuntu 系统中的 Laravel 项目。之所以说是「实时」的，是因为在本地修改的代码会同步到 Ubuntu 系统中的目录中。','2017-07-05 23:23:42','2017-07-05 23:23:42','what-is-a-favored'),(187,3,3,'一千零一夜：第19夜','困、睡。','2017-07-06 07:06:55','2017-07-06 07:07:47','one-thousand-nights-19-night'),(188,3,3,'Vue.js 实例、与 HTML 绑定、data 对象 和数据双向绑定','1. 引入了 vue.js，就可以使用 `Vue` 构造函数创建 vue 实例了。  \r\n\r\n```\r\nnew Vue({})\r\n```\r\n\r\n2. 与 HTML 的绑定\r\n\r\n一个 vue 实例就是一个应用，`el` 指定应用起作用的区域。\r\n\r\n```\r\n<div id=\"app\"></div>\r\n\r\nnew Vue({\r\n	el: \'#app\'	\r\n})\r\n```\r\n\r\n在上面的例子中，vue 实例起作用的区域就在 `<div id=\"app\">` 内。\r\n\r\n这样，就实现了 vue 实例与 HTML 的绑定。\r\n\r\n2. `data` 对象\r\n\r\n创建一个 vue 实例时，还可以指定一个 `data` 对象。你可以在与之绑定的 HTML 中使用 `{{}}` 符号取 `data` 对象中的数据。\r\n\r\n```\r\n<div id=\"app\">{{ message }}</div>\r\n\r\nnew Vue({\r\n	el: \'#app\',\r\n	data: {\r\n		message: \'我是消息。\'\r\n	}	\r\n})\r\n```\r\n\r\n3. 数据双向绑定\r\n\r\n使用 `v-model` 绑定 `data` 对象。\r\n\r\n```\r\n<div id=\"app\">\r\n	<input type=\"text\" v-model=\"message\">\r\n	{{ message }}\r\n</div>\r\n\r\nnew Vue({\r\n	el: \'#app\',\r\n	data: {\r\n		message: \'我是消息。\'\r\n	}	\r\n})\r\n```\r\n\r\n`v-model` 是 vue.js 为 HTML 标签扩展的特性，用于给 [表单][1] 绑定 Vue 实例的 data 对象。\r\n\r\n[1]: https://cn.vuejs.org/v2/guide/forms.html\r\n\r\n在上面的例子中，在输入框中输入内容时，`{{ message }}` 部分也会立即显示你输入的值。这是为什么的呢？\r\n\r\n因为 input 输入框的内容绑定了 Vue 实例的 data 对象中的 `message`，所以输入框的内容就是 `message`，当它改变时，因为 `{{ message }}` 中解析的是 `message`，自然也改变了——这就是数据双向绑定。','2017-07-06 16:19:52','2017-07-06 22:12:44','vue-js-instance-binding-with-html-two-way-data-objects-and-data-binding'),(189,3,3,'JavaScript Array 对象合并数组的 concat () 方法介绍','> 百度翻译了下单词 `concat`，发现就是 **合并数组** 的意思，惊叹啊，短小精悍堪比文言文。\r\n\r\n`concat()` 方法可用于连接两个或多个数组。语法如下：\r\n\r\n```\r\narrayObject.concat(bla,bla,......,bla)\r\n```\r\n\r\n注意哦，`bla` 可以是可以是数组对象，也可以是一个简单值，比如数值、字符串啦。总之，好用的不要不要的。铁证如下：\r\n\r\n```\r\n[1,2,3].concat(4, [5, 6], [\'YY\']); \r\n//  [1, 2, 3, 4, 5, 6, \"YY\"]\r\n\r\n[\'George\', \'John\', \'Thomas\'].concat([\'James\', \'Adrew\', \'Martin\']);\r\n// [\"George\", \"John\", \"Thomas\", \"James\", \"Adrew\", \"Martin\"]\r\n\r\n[0].concat(1, [[2]])\r\n// [0, 1, [[2]]]\r\n```','2017-07-07 00:40:32','2017-07-07 00:40:32','javascript-array-object-merge-array-concat-method-is-introduced'),(190,3,3,'JavaScript Array 对象剪接数组的 splice () 方法介绍','> **splice** *[splaɪs]* 在电影界术语是「剪辑」，在 JavaScript 数组世界里，也是剪辑能手。\r\n\r\n`splice` 既能删数组元素，又能添数组元素，是个多面手。而且它是**直接对数组修改**，然后以数组形式返回删除的元素。\r\n\r\n语法如下：\r\n\r\n```\r\narrayObject.splice(index,howmany,item1,.....,itemX)\r\n```\r\n\r\n1. `index`：指定添加/删除元素的索引位置。\r\n2. `howmany`：要删几个元素啊？\r\n3. `item1, ..., itemX`：要添加的元素。可选。\r\n\r\n举例子：\r\n\r\n```\r\narr = [\'George\', \'John\', \'Thomas\']\r\narr.splice(1, 1);\r\n// [ \'John\']\r\narr\r\n// [\'George\', \'Thomas\']\r\n\r\narr = [\'George\', \'John\', \'Thomas\'];\r\narr.splice(1, 2, \'James\', \'Adrew\', \'Martin\');\r\n// [\"John\", \"Thomas\"]\r\narr\r\n// [\"George\", \"James\", \"Adrew\", \"Martin\"]\r\n```','2017-07-07 00:41:20','2017-07-07 00:41:20','javascript-array-object-splicing-array-splice-method-is-introduced'),(191,3,3,'学习 Vue.js：写一个简单的 Todo 小样','这是学习 Vue.js 的一个小样，最后的结果在 [codepen.io][1] 上能看到。需要引入 Bootstrap 样式文件和 Vue.js 库。\r\n\r\n1. https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\r\n2. https://unpkg.com/vue@2.3.4/dist/vue.js\r\n\r\n[1]: https://codepen.io/zhangbao/full/LLJNxJ/\r\n\r\n再稍微加点自定义样式。\r\n\r\n```\r\nbody {\r\n	margin-top: 20px;\r\n}\r\n\r\n.btn-xs+.btn-xs {\r\n	margin-right: .5rem;\r\n}\r\n\r\na.list-group-item.completed {\r\n	background-color: #f5f5f5;\r\n	text-decoration: line-through;\r\n}\r\n```\r\n\r\n## 架构\r\n\r\nHTML\r\n\r\n```\r\n<div id=\"todoApp\" class=\"container\">\r\n	<div class=\"panel panel-default\">\r\n		<div class=\"panel-heading text-center\">\r\n			计划要做的事情，共 0 件\r\n		</div>\r\n		<div class=\"panel-body\">\r\n			<div class=\"list-groups\">\r\n				<a class=\"list-group-item\">\r\n					;)\r\n				</a>\r\n			</div>\r\n		</div>\r\n		<div class=\"panel-footer\">\r\n			<form>\r\n				<div class=\"form-group\">\r\n					<input type=\"text\" class=\"form-control text-center\">\r\n				</div>\r\n				<button class=\"btn btn-default btn-block\" type=\"submit\">添加</button>\r\n			</form>\r\n		</div>\r\n	</div>\r\n</div>\r\n```\r\n\r\nJavaScript\r\n\r\n```\r\nnew Vue({\r\n	el: \'#todoApp\',\r\n	data: {\r\n		todos: [\r\n			{title: \'吃早饭\', completed: false},\r\n			{title: \'吃午饭\', completed: false},\r\n			{title: \'吃晚饭\', completed: false}\r\n		],\r\n		newTodo: {title: \'\', completed: false},\r\n	},\r\n	methods: {}\r\n});\r\n```\r\n\r\n## 循环打印 todos 列表\r\n\r\n```\r\n<div class=\"panel-heading text-center\">\r\n	计划要做的事情，共 {{ todos.length }} 件\r\n</div>\r\n\r\n<a class=\"list-group-item\" v-for=\"(todo, index) in todos\">\r\n	{{ todo.title }}\r\n</a>\r\n```\r\n\r\n## 添加 Todo\r\n\r\n```\r\n<form v-on:submit.prevent=\"add\">\r\n	<div class=\"form-group\">\r\n		<input type=\"text\" class=\"form-control text-center\" v-model=\"newTodo.title\">\r\n	</div>\r\n	<button class=\"btn btn-default btn-block\" type=\"submit\">添加</button>\r\n</form>\r\n```\r\n\r\n`input` 输入框绑定了 `newTodo.title` 的值。表单提交时，执行 `add` 方法。\r\n\r\n```\r\nmethods: {\r\n	add() {\r\n		if (! this.newTodo.title.trim()) { return ; }\r\n		this.todos.push({\r\n			title: this.newTodo.title,\r\n			completed: this.newTodo.completed\r\n		});\r\n		this.newTodo.title = \'\';\r\n	}\r\n}\r\n```\r\n\r\n## 删除 Todo\r\n\r\n```\r\n<a class=\"list-group-item\"  v-for=\"(todo, index) in todos\">\r\n	{{ todo.title }}\r\n	<button class=\"btn btn-xs btn-danger pull-right\" v-on:click=\'destroy(index)\' title=\"删除\">✘</button>\r\n</a>\r\n```\r\n\r\n点击删除按钮，执行 `destroy` 方法。\r\n\r\n```\r\ndestroy(index) {\r\n	this.todos.splice(index, 1);\r\n}\r\n```\r\n\r\n## 标记 Todo 完成/未完成\r\n\r\n```\r\n<a class=\"list-group-item\" v-bind:class=\"{ \'completed\': todo.completed }\" v-for=\"(todo, index) in todos\">\r\n	{{ todo.title }}\r\n	<button class=\"btn btn-xs btn-danger pull-right\" v-on:click=\'destroy(index)\' title=\"删除\">✘</button>\r\n	<button class=\"btn btn-xs pull-right\" v-on:click=\'toggleDone(index)\' v-bind:class=\"[todo.completed ? \'btn-success\': \'\']\" v-bind:title=\"[todo.completed ? \'点击，标记为未完成\': \'点击，标记为已完成\']\">✔</button>\r\n</a>\r\n```\r\n\r\n标记 Todo 使用 `toggleDone` 方法。\r\n\r\n```\r\ntoggleDone(index) {\r\n	this.todos[index].completed = !this.todos[index].completed;\r\n}\r\n```\r\n\r\n## 上移、下移 Todo\r\n\r\n```\r\n<button class=\"btn btn-xs btn-info pull-right\" v-on:click=\'down(index)\' title=\"下移\">↓</button>\r\n<button class=\"btn btn-xs btn-info pull-right\" v-on:click=\'up(index)\' title=\"上移\">↑</button>\r\n```\r\n\r\n### 上移\r\n\r\n执行 `up` 方法。\r\n\r\n```\r\nup(index) { \r\n	if (index - 1 < 0) { return ; }\r\n	var temp = this.todos[index];\r\n	this.todos[index] = this.todos[index-1];\r\n	this.todos[index-1] = temp;\r\n	this.todos = [].concat(this.todos);\r\n}\r\n```\r\n\r\n### 下移\r\n\r\n执行 `down` 方法。\r\n\r\n```\r\ndown(index) {\r\n	if (index + 1 >= this.todos.length) { return ; }\r\n	var temp = this.todos[index];\r\n	this.todos[index] = this.todos[index+1];\r\n	this.todos[index+1] = temp;\r\n	this.todos = [].concat(this.todos);\r\n}\r\n```\r\n\r\n需要注意的是，上移和下移方法中，最后都生成新的 `todos`，否则数组中元素位置的调整，不会引页面重绘。\r\n\r\n```\r\nthis.todos = [].concat(this.todos);\r\n```','2017-07-07 00:41:58','2017-07-07 00:41:58','learning-vue-js-write-a-simple-todo-samples'),(192,3,3,'学习 Vue.js： Todo 小样组件版','在 [上一篇][1] 中写了一个 Todo 小样，但 Vue.js 提供的便利不只有这些，还有组件化。下面将之前的 Todo 小样重写成可重复利用的组件，结果在 [codepen.io][2] 上可看到。\r\n\r\n[1]: https://laravel-china.org/articles/5205/learn-vuejs-write-a-simple-todo-sample\r\n[2]: https://codepen.io/zhangbao/full/QgVKvP\r\n\r\n## 注册组件\r\n\r\nVue.js 使用 `Vue.component` 注册全局组件，下面注册组件 `todo-items`。\r\n\r\n```\r\nVue.component(\'todo-items\', {\r\n	template: \'#todo-items-template\',\r\n	props: [\'initialTodos\'],\r\n	data() {\r\n		return {\r\n			todos: this.initialTodos ? [].concat(this.initialTodos) : [],\r\n			newTodo: { title: \'\', completed: false }\r\n		}\r\n	},\r\n	methods: {\r\n		add() {\r\n			if (! this.newTodo.title.trim()) { return ; }\r\n			this.todos.push({\r\n				title: this.newTodo.title,\r\n				completed: this.newTodo.completed\r\n			});\r\n			this.newTodo.title = \'\';\r\n		},\r\n		destroy(index) {\r\n			this.todos.splice(index, 1);\r\n		},\r\n		toggleDone(index) {\r\n			this.todos[index].completed = !this.todos[index].completed;\r\n		},\r\n		up(index) { \r\n			if (index - 1 < 0) { return ; }\r\n			var temp = this.todos[index];\r\n			this.todos[index] = this.todos[index-1];\r\n			this.todos[index-1] = temp;\r\n			this.todos = [].concat(this.todos);\r\n		},\r\n		down(index) {\r\n			if (index + 1 >= this.todos.length) { return ; }\r\n			var temp = this.todos[index];\r\n			this.todos[index] = this.todos[index+1];\r\n			this.todos[index+1] = temp;\r\n			this.todos = [].concat(this.todos);\r\n		}\r\n	}\r\n});\r\n```\r\n\r\n组件中 `data` 数据是使用函数形式返回的对象，是为了每个组件实例都有独一无二 data 对象。\r\n\r\n## 写模板代码\r\n\r\n组件 `todo-items` 使用的 `#todo-items-template` 处的模板代码，就是之前的 Todos 的 HTML 代码，用 `type=\"text/x-template` 的 script 标签包围。\r\n\r\n```\r\n<script type=\"text/x-template\" id=\"todo-items-template\">\r\n	<div class=\"panel panel-default\">\r\n		<div class=\"panel-heading text-center\">\r\n			计划要做的事情，共 {{ todos.length }} 件\r\n		</div>\r\n		<div class=\"panel-body\">\r\n			<div class=\"list-groups\">\r\n				<a class=\"list-group-item\" v-bind:class=\"{ \'completed\': todo.completed }\" v-for=\"(todo, index) in todos\">\r\n					{{ todo.title }}\r\n					<button class=\"btn btn-xs btn-danger pull-right\" v-on:click=\'destroy(index)\'title=\"删除\">✘</button>\r\n					<button class=\"btn btn-xs btn-info pull-right\" v-on:click=\'down(index)\'title=\"下移\">↓</button>\r\n					<button class=\"btn btn-xs btn-info pull-right\" v-on:click=\'up(index)\'title=\"上移\">↑</button>\r\n					<button class=\"btn btn-xs pull-right\" v-on:click=\'toggleDone(index)\' v-bind:class=\"[todo.completed ? \'btn-success\': \'\']\" v-bind:title=\"[todo.completed ? \'点击，标记为未完成\': \'点击，标记为已完成\']\">✔</button>\r\n				</a>\r\n			</div>\r\n		</div>\r\n		<div class=\"panel-footer\">\r\n			<form v-on:submit.prevent=\"add\">\r\n				<div class=\"form-group\">\r\n					<input type=\"text\" class=\"form-control text-center\" v-model=\"newTodo.title\">\r\n				</div>\r\n				<button class=\"btn btn-default btn-block\" type=\"submit\">添加</button>\r\n			</form>\r\n		</div>\r\n	</div>\r\n</script>\r\n```\r\n\r\n## 使用组件\r\n\r\n```\r\n<div id=\"app\" class=\"container\">\r\n	<div class=\"row\">\r\n		<div class=\"col-md-6\">\r\n			<todo-items v-bind:initial-todos=\"initialTodos\"></todo-items>\r\n		</div>\r\n		<div class=\"col-md-6\">\r\n			<todo-items v-bind:initial-todos=\"initialTodos\"></todo-items>\r\n		</div>\r\n	</div>\r\n</div>\r\n```\r\n\r\n```\r\nnew Vue({\r\n	el: \'#app\',\r\n	data: {\r\n		initialTodos: [\r\n			{title: \'吃早饭\', completed: false},\r\n			{title: \'吃午饭\', completed: false},\r\n			{title: \'吃晚饭\', completed: false}\r\n		]\r\n	}\r\n});\r\n```\r\n\r\n注意到，两个组件实例，都赋予了同一个 `initialTodos` 对象。为了保证每个组件里的 `todos` 对象是独一无二的，所以组件内部 `todos` 数据都使用了 ` [].concat(this.initialTodos)` 返回的新数组；否则同一个 Vue 实例下的组件的 `todos` 数据，会因为引用了同一个对象，行为变一样了。','2017-07-07 00:42:28','2017-07-07 00:42:28','learning-vue-js-todo-sample-components'),(193,3,3,'使用 Vue 脚手架工具改写 Todos 小样','##  下载 `vue-cli`\r\n\r\n下载脚手架工具 `vue-cli`。\r\n\r\n```\r\n$ npm install -g vue-cli\r\n```\r\n\r\n## 下载 Webpack 模板项目\r\n\r\n下载 Vue 的 Webpack 模板，项目名叫 `vuejs-2-test`。\r\n\r\n```\r\n$ vue init webpack vuejs-2-test\r\n```\r\n\r\n## 添加组件 `Todos.vue`\r\n\r\n在 `src/components` 下添加文件 `Todos.vue`。\r\n\r\n```\r\n<template>\r\n  <div class=\"panel panel-default\">\r\n    <div class=\"panel-heading text-center\">\r\n      计划要做的事情，共 {{ todos.length }} 件\r\n    </div>\r\n    <div class=\"panel-body\">\r\n      <div class=\"list-groups\">\r\n        <a class=\"list-group-item\" v-bind:class=\"{ \'completed\': todo.completed }\" v-for=\"(todo, index) in todos\">\r\n          {{ todo.title }}\r\n          <button class=\"btn btn-xs btn-danger pull-right\" v-on:click=\'destroy(index)\'title=\"删除\">✘</button>\r\n          <button class=\"btn btn-xs btn-info pull-right\" v-on:click=\'down(index)\'title=\"下移\">↓</button>\r\n          <button class=\"btn btn-xs btn-info pull-right\" v-on:click=\'up(index)\'title=\"上移\">↑</button>\r\n          <button class=\"btn btn-xs pull-right\" v-on:click=\'toggleDone(index)\' v-bind:class=\"[todo.completed ? \'btn-success\': \'\']\" v-bind:title=\"[todo.completed ? \'点击，标记为未完成\': \'点击，标记为已完成\']\">✔</button>\r\n        </a>\r\n      </div>\r\n    </div>\r\n    <div class=\"panel-footer\">\r\n      <form v-on:submit.prevent=\"add\">\r\n        <div class=\"form-group\">\r\n          <input type=\"text\" class=\"form-control text-center\" v-model=\"newTodo.title\">\r\n        </div>\r\n        <button class=\"btn btn-default btn-block\" type=\"submit\">添加</button>\r\n      </form>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n\r\nexport default {\r\n  props: [\'initialTodos\'],\r\n  data() {\r\n    return {\r\n      todos: this.initialTodos ? [].concat(this.initialTodos) : [],\r\n      newTodo: { title: \'\', completed: false }\r\n    }\r\n  },\r\n  methods: {\r\n    add() {\r\n      if (! this.newTodo.title.trim()) { return ; }\r\n      this.todos.push({\r\n        title: this.newTodo.title,\r\n        completed: this.newTodo.completed\r\n      });\r\n      this.newTodo.title = \'\';\r\n    },\r\n    destroy(index) {\r\n      this.todos.splice(index, 1);\r\n    },\r\n    toggleDone(index) {\r\n      this.todos[index].completed = !this.todos[index].completed;\r\n    },\r\n    up(index) { \r\n      if (index - 1 < 0) { return ; }\r\n      var temp = this.todos[index];\r\n      this.todos[index] = this.todos[index-1];\r\n      this.todos[index-1] = temp;\r\n      this.todos = [].concat(this.todos);\r\n    },\r\n    down(index) {\r\n      if (index + 1 >= this.todos.length) { return ; }\r\n      var temp = this.todos[index];\r\n      this.todos[index] = this.todos[index+1];\r\n      this.todos[index+1] = temp;\r\n      this.todos = [].concat(this.todos);\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n.btn-xs+.btn-xs {\r\n  margin-right: .5rem;\r\n}\r\n\r\na.list-group-item.completed {\r\n  background-color: #f5f5f5;\r\n  text-decoration: line-through;\r\n}\r\n</style>\r\n```\r\n\r\n组件有 3 部分组成：`<template>`、`<script>` 和 `<style>`，会分别由 3 个 loader 加载处理。\r\n\r\n## 引入 `Todos.vue` 组件\r\n\r\n在 **`src/App.vue` 文件中引入组件 `Todos.vue`**。\r\n\r\n```\r\n<template>\r\n  <div id=\"app\">\r\n    <!-- <img src=\"./assets/logo.png\"> -->\r\n    <!-- <hello></hello> -->\r\n    <div class=\"container\">\r\n      <div class=\"row\">\r\n        <div class=\"col-md-6\">\r\n          <todos v-bind:initial-todos=\"initialTodos\"></todos> \r\n        </div>\r\n        <div class=\"col-md-6\">\r\n          <todos v-bind:initial-todos=\"initialTodos\"></todos> \r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport Hello from \'./components/Hello\'\r\nimport Todos from \'./components/Todos\'\r\n\r\nexport default {\r\n  name: \'app\',\r\n  components: {\r\n	Todos\r\n  },\r\n  data() {\r\n    return {\r\n      initialTodos: [\r\n        {title: \'吃早饭\', completed: false},\r\n        {title: \'吃午饭\', completed: false},\r\n        {title: \'吃晚饭\', completed: false}\r\n      ]\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n#app {\r\n  font-family: \'Avenir\', Helvetica, Arial, sans-serif;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n  /*text-align: center;*/\r\n  color: #2c3e50;\r\n  margin-top: 60px;\r\n}\r\n</style>\r\n```\r\n\r\n使用 ES6 语法 `import` 引入 `Todos` 组件。\r\n\r\n```\r\nimport Todos from \'./components/Todos\'\r\n```\r\n\r\n并且在当前 `App` 组件中，声明使用 `Todos` 组件。\r\n\r\n```\r\ncomponents: {\r\n	Todos\r\n},\r\n```\r\n\r\n然后在 `<template>` 中以 `<todos>` 标签的形式插入组件，并绑定组件初始值。\r\n\r\n这里需要注意的是：\r\n\r\n1. 初始化 `initialTodos` 的时候，是以 **`data()` 函数的形式返回包含 `initialTodos` 的变量**的。\r\n2. 给 `Todos` 组件绑定 `initialTodos` 变量的时候，使用的特性是 `initial-todos`——因为 **HTML 特性是不区分大小写**，Vue.js 会自动将「property-name」形式名称处理成「首字母小写的驼峰」形式的名称！\r\n\r\n## `App.vue` 是怎样起作用的？\r\n\r\n`npm run dev` 之后，看到的页面其实是处理后的 `index.html` 页面，在页面 `</body>` 前插入了一个 `app.js` 文件。\r\n\r\n`app.js` 插入 `index.html` 的逻辑是在 `src/main.js` 中定义的，我们来看下。\r\n\r\n```\r\nimport Vue from \'vue\'\r\nimport App from \'./App\'\r\n\r\nVue.config.productionTip = false\r\n\r\n/* eslint-disable no-new */\r\nnew Vue({\r\n  el: \'#app\',\r\n  template: \'<App/>\',\r\n  components: { App }\r\n})\r\n```\r\n\r\n内容不多，它的作用就是将引入的 `App.vue` 组件插入到 `index.html` 中的 `#app` 的容器内。','2017-07-07 01:30:35','2017-07-07 17:57:24','using-the-vue-scaffolding-tools-todos-small-kind'),(194,3,3,'ES6：解构赋值','## 例子一\r\n\r\n解构赋值：解开构成对象的属性，赋值给包围在 `{}` 里的变量。\r\n\r\n```\r\nconst Tom = { name: \'zhangb\', age: 25 };\r\n\r\nconst { name, age } = Tom;\r\n\r\nconsole.log(name); // zhangb\r\nconsole.log(age); // 25\r\n```\r\n\r\n过程：先声明变量 `name` 和 `age`，然后在变量 `Tom` 中找同名属性，再把值赋给 `name` 和 `age`（找不到对应的同名属性的变量就自然是 `undefined` 了）。\r\n\r\n## 例子二\r\n\r\n对象解构中的变量重命名。\r\n\r\n```\r\nconst Tom = { \r\n	name: \'zhangb\', \r\n	age: 25, \r\n	family: {\r\n		mom: \'Lily\',\r\n		dad: \'Fare\',\r\n		bro: \'Youy\'\r\n	}\r\n};\r\n\r\nconst { mom : m, dad: d, bro: b } = Tom.family;\r\n\r\nconsole.log(m);\r\nconsole.log(d);\r\nconsole.log(b);\r\n```\r\n\r\n## 例子三\r\n\r\n赋值时默认值——当对象属性值为 `undefined` 时，采用默认值。\r\n\r\n```\r\nfunction Vue(options) {\r\n	const { el = \'#app\', data = {}, method = {}} = options;\r\n}\r\n\r\nVue({\r\n	el: \'#todos\',\r\n	data: {\r\n		message: \'你好\'\r\n	}\r\n});\r\n```','2017-07-07 05:47:04','2017-07-07 05:48:01','es6-deconstruction-assignment'),(195,3,3,'一千零一夜：第20夜','**（一）**\r\n\r\n六月过去了。走在路上，知了叫得密集了，草里也有虫叫，但不知道名字。\r\n\r\n昨天还显得繁杂、混浊的河里，今天看过去干净、清爽。还记得三条嘴撅在水面上张着的大鱼，惊奇，不知是吃树叶还是呼吸氧气，看着它游下去不见了。\r\n\r\n**（二）**\r\n\r\n姚俊杰回来了，所以游戏的声音又大起来，他回来后，我才发觉我并不希望他来。\r\n\r\n虽然下午回来时，扇着风扇很热，可是现在不热了。我发现，即使是这样，也丝毫没有让生活更好些，反而是更放纵了。\r\n\r\n人变得懦弱和懒。其实技术并不一定让世界变得更加美好了，只是确实改变了世界的行为方式。人开始变得不那么依赖体力了，也不那么思考艰苦了，没有对比就无分好坏。','2017-07-07 07:04:53','2017-07-07 07:05:12','one-thousand-nights-20-nights'),(196,3,3,'Vue Todos 与 Laravel 前后端分离（一）','之前的 `initialTodos` 都是前台写死的，现在从 Laravel 后台获取。需要注意的是：\r\n\r\n1. 对于 Vue.js 项目，为了能发送 Ajax 请求，要安装一个依赖 [`vue-axios`][1]。\r\n2. 对于提供 API 的 Laravel 项目，为了能允许跨域访问（CORS），需要安装依赖 [`Laravel-cors`][2]。\r\n\r\n[1]: https://github.com/imcvampire/vue-axios\r\n[2]: https://github.com/barryvdh/laravel-cors\r\n\r\n## 后端提供的 API\r\n\r\n```\r\nRoute::get(\'/todos\', function (Request $request) {\r\n    return [\r\n    	[ \'title\' => \'吃早饭\', \'completed\' => false ],\r\n        [ \'title\' => \'吃午饭\', \'completed\' => false ],\r\n        [ \'title\' => \'吃晚饭\', \'completed\' => false ],\r\n    ];\r\n});	\r\n```\r\n\r\n地址： http://homestead.app/api/todos\r\n\r\n数据：\r\n\r\n```\r\n[\r\n    {\r\n        \"title\": \"吃早饭\",\r\n        \"completed\": false\r\n    },\r\n    {\r\n        \"title\": \"吃午饭\",\r\n        \"completed\": false\r\n    },\r\n    {\r\n        \"title\": \"吃晚饭\",\r\n        \"completed\": false\r\n    }\r\n]\r\n```\r\n\r\n## 前端请求\r\n\r\n1. 在 `App.vue` 中使用 axios 请求接口数据,再将接收到数据歘递给 `Todos.vue` 组件。\r\n\r\n```\r\n<template>\r\n  <div id=\"app\">\r\n    <div class=\"container\">\r\n      <div class=\"row\">\r\n        <div class=\"col-md-6\">\r\n          <todos v-bind:todos=\"todayTodos\"></todos> \r\n        </div>\r\n        <div class=\"col-md-6\">\r\n          <todos v-bind:todos=\"tomorrowTodos\"></todos> \r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport Hello from \'./components/Hello\'\r\nimport Todos from \'./components/Todos\'\r\n\r\nexport default {\r\n  name: \'app\',\r\n  components: {\r\n    Todos\r\n  },\r\n  data() {\r\n    return {\r\n      todayTodos: [],\r\n      tomorrowTodos: [],\r\n    }\r\n  },\r\n  mounted() {\r\n    this.axios.get(\'http://homestead.app/api/todos\').then((response) => {\r\n      console.log(response.data)  \r\n      this.todayTodos = response.data\r\n      this.tomorrowTodos = [].concat(response.data)\r\n    })\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n2.  在 `Todos.vue` 组件接收数据。\r\n\r\n```\r\n<script>\r\n\r\nexport default {\r\n  props: [\'todos\'],\r\n  data() {\r\n    return {\r\n      newTodo: { title: \'\', completed: false }\r\n    }\r\n  },\r\n  methods: {\r\n  \r\n  ...\r\n```','2017-07-07 18:34:01','2017-07-07 21:49:49','vue-todos-separated-from-laravel-front-and-rear-end-a'),(197,3,3,'怎样安装和破解Photoshop CS6？','## 下载 Photoshop CS6\r\n\r\nhttps://www.baidu.com/s?wd=PS6\r\n\r\n## 破解教程\r\n\r\nhttp://jingyan.baidu.com/article/335530da4c5f4719cb41c3c3.html\r\n\r\n## 附件\r\n\r\n破解补丁：http://www.jb51.net/softs/135369.html','2017-07-08 01:35:52','2017-07-08 01:36:02','how-to-install-and-crack-photoshop-cs6'),(198,3,3,'PhotoShop/PS 简单使用','1. 视图 > 清除参考线\r\n\r\n2. 窗口 > （点击）信息\r\n\r\n## 移动工具\r\n\r\n![](https://raw.githubusercontent.com/baooab/blog/master/tutorials/images/Using-PS6/v.png)\r\n\r\n选中「移动工具」，✔ 上「自动选择」，选择「图层」。\r\n\r\n`CTRL + 1` 图片 100% 显示，`CTRL + 0` 显示图片全貌。\r\n\r\n`CTRL + +` 放大，`CTRL + -` 缩小。\r\n\r\n\r\n## 切片\r\n\r\n显示和隐藏切片：执行“视图——显示——切片”，可以隐藏或显示切片。\r\n\r\n删除切片：单击鼠标右键：删除切片。\r\n\r\n清除切片：执行“视图——清除切片”。\r\n\r\n## 图层组\r\n\r\n合并几个图层到一个组：选中图层，Ctrl + g。\r\n\r\n## 放大\r\n\r\n等比例放大：Ctrl + 点击选中图层，Ctrl + T 截取图层，按下 Shift 键拖拽即可。','2017-07-08 07:09:42','2017-12-26 06:12:23','the-use-of-photoshop-simple-introduction'),(199,3,3,'一千零一夜：第21夜','**（一）**\r\n\r\n我今天主要学了 PS 简易切图。\r\n\r\n点击图片看图层；CTRL + 点击图层图标显示图层区域；选择图层，CTRL + T 也可显示图层区域；存储为 web 图片；\r\n\r\n**（二）**\r\n\r\n杨绛翻译书《唐吉可德》到手了。看译者序言和钱钟书翻译的前言，都是厚厚的几页。\r\n\r\n我想到他们是这样的钻研文学，虽然杨绛的书《我们仨》没看除写得有多好，但我感觉看这本书应该不会失望，看杨绛写的译者序言猜出的。\r\n\r\n想到钱钟书这样的人，晚年的样子，觉得人总是要老的，即使是这样聪明、钻研的人。想到现在每天像复制一样的度过年轻，实在可惜。可我又不会因此熬夜的，不值得。\r\n\r\n**（三）**\r\n\r\n虽然懒，可有些时候没有女孩们的欢声了。总会觉得少什么，即使什么也不会发生。\r\n\r\n睡觉！','2017-07-08 07:27:18','2017-07-08 07:27:18','one-thousand-nights-the-21st-night'),(200,3,3,'CSS：margin 使用上的问题','1. 子元素传递上下 margin 给父元素\r\n\r\nmargin 传递形式：只有上下传递，左右不传递。\r\n\r\n```\r\n.box {\r\n	line-height: 30px;\r\n	font: 14px/30px \"宋体\";	\r\n	background: gainsboro;\r\n}\r\n\r\n.box-1 {\r\n	background: pink;\r\n	margin: 100px;\r\n}\r\n\r\n.box-2 {\r\n	background: paleturquoise;\r\n}\r\n\r\n<div class=\"box\">\r\n	<div class=\"box box-1\">\r\n		box1\r\n	</div>\r\n	<div class=\"box box-2\">\r\n		box2\r\n	</div>\r\n</div>\r\n```\r\n\r\n子元素会把自己的 margin 的 `top` 和 `bottom` 传递给父元素。\r\n\r\n解决办法：给父元素加上一个边框。\r\n\r\n这就是为什么父子元素之间的距离用 `padding` 的原因。\r\n\r\n2. 同级元素的上下 margin 会合并\r\n\r\n 同级元素的上下 margin 会合并，合并的结果时较大的那个 margin 距离。\r\n \r\n 解决方法：只给一个元素设定 margin bottom / margin top。','2017-07-08 23:29:45','2017-07-08 23:33:00','css-margin-use-problems'),(201,3,3,'什么是 HTML、CSS 和 JavaScript？','## 什么是 HTML\r\n\r\n1. HTML：超文本标记语言（HyperText Markup Language）。\r\n\r\n标记就是「标签」。\r\n\r\n超文本就是不只能显示文本。\r\n\r\n2. HTML 不区分大小写。\r\n\r\n## 什么是 CSS\r\n\r\n写网页就是「画方块」，经常用做画方块的标签是 `div`，用 CSS 将方块显示出来。\r\n\r\n边框是一个非矩形。\r\n\r\n下箭头写法：\r\n\r\n```\r\nborder: 10px solid transparent;\r\nborder-top-color: red;\r\n```\r\n\r\n一行文字垂直居中的方式是：行高值和容器高度相等。\r\n\r\n```\r\n.box {\r\n    border: 1px solid #000000;\r\n    height: 30px;\r\n    line-height: 30px;\r\n}\r\n```\r\n\r\n当行高是奇数时，上部比下部小 1px。\r\n\r\n字体：\r\n\r\n```\r\nfont: fontWeight fontStyle fontSize/line-height font-family\r\n```\r\n\r\n一个字体大小就是「1em」。\r\n\r\n`letter-spacing`：能分开单个英文字母和单个汉字。\r\n\r\n`word-spacing`：单词间距，单词是用「空格」分隔的，所以对汉字无效。\r\n\r\n`word-break`：词内换行——让单词换行\r\n\r\n`word-break: break-word`：词内换行\r\n\r\n`word-break: break-word`：词内换行，所有长单词都不另起一行显示。\r\n\r\n在宋体下，一个空格是一个字体的一半。从上到下量字体大小。\r\n\r\n## 什么是 JavaScript\r\n\r\n1. `onclick`：当「点击的时候」。\r\n\r\n2. `onclick=\"this.style.width=\'800px\'; this.style.height=\'500px\';\"`：当点击的时候，这个 `div` 的宽度变 `800px`，高度变 `500px`。','2017-07-08 23:52:18','2017-07-08 23:52:18','what-is-html-css-and-javascript'),(202,3,3,'HTML 常用标签','* `div` 块级元素\r\n* `a` 超链接\r\n* `span` 区分样式\r\n* `h1`-`h6` 标题\r\n* `p` 段落\r\n* `strong` 强调（粗体）\r\n* `em` 强调（斜体）\r\n* `ul` 无序\r\n* `ol` 有序\r\n* `li` 列表项\r\n* `dl` 自定义列表\r\n* `dt` 自定义列表标题\r\n* `dd` 自定义列表项\r\n* `mark` 标记\r\n* `img` 图片\r\n* `header` 头部\r\n* `nav` 导航\r\n* `footer` 底部\r\n* `section` 板块\r\n* `article` 内容\r\n* `aside` 附属信息\r\n* `time` 时间\r\n\r\n完整列表参见 [W3school.com.cn](http://www.w3school.com.cn/tags/)。','2017-07-09 00:04:04','2017-07-09 00:04:04','commonly-used-html-tags'),(203,3,3,'一千零一夜：第22夜','**（一）**\r\n\r\n南京东路上都有知了在叫了。我洗衣服，太浪费洗衣粉了。\r\n\r\n我看见在洗衣粉水里的一粒西瓜籽，如果它没被烧死，未来可能就是一株像样的西瓜秧了，但是如果死了，那么就是一场微观世界里的搏杀过程，但也有可能被冲入下水道，再无生长的机会。\r\n\r\n小盆里的那株番茄秧，长得快而且壮，结了几个番茄蛋，但叶子枯萎了。在有限的土地里生长着。\r\n\r\n**（二）**\r\n\r\n下午有风。\r\n\r\n**（三）**\r\n\r\n晚上有听到知了叫，今天感觉那么明显。好像是从今天开始的。两天周末，我都花在宿舍里了，没有去外面。\r\n\r\n炎热夏季，漫漫长日，炽白日光，无聊悠长。','2017-07-09 05:51:58','2017-07-09 05:51:58','one-thousand-nights-22-night'),(204,3,3,'导出监测数据','```\r\nselect SurveyItemName, PointName, AValue, SValue, SurveyTime from Dat_SurveyData where SurveyItemName in (\'钢支撑轴力(第一方)\', \'测斜(第一方)\', \'砼支撑轴力(\r\n\r\n第一方)\', \'地表沉降(第一方)\') order by SurveyTime desc;\r\n\r\nselect COUNT(*) from Dat_SurveyData where SurveyItemName in (\'钢支撑轴力(第一方)\', \'测斜(第一方)\', \'砼支撑轴力(第一方)\', \'地表沉降(第一方)\');\r\n\r\nselect COUNT(*) from Dat_SurveyData;\r\n```','2017-07-09 17:39:19','2017-07-09 17:39:19','export-monitoring-data'),(205,3,3,'Windows 系统下 npm 全局软件安装的位置','```\r\nC:\\Users\\zhangb\\AppData\\Roaming\\npm\r\n```','2017-07-09 17:49:51','2017-07-09 17:49:51','the-location-of-the-windows-system-under-npm-global-software-installation'),(206,5,3,'Linux：每天一个命令 ls命令','## ls命令\r\n 通过ls 命令不仅可以查看linux文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多!\r\n \r\n 命令格式：\r\n ```\r\n ls  [选项]  [目录名]\r\n ```\r\n \r\n 命令功能：`列出目标目录中所有的子目录和文件`\r\n \r\n 常用参数：\r\n\r\n```\r\n-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件\r\n\r\n-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。\r\n\r\n-c  配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序\r\n\r\n-C 每栏由上至下列出项目\r\n\r\n–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是\'never\'、\'always\'或\'auto\'其中之一\r\n\r\n-d, –directory 将目录象文件一样显示，而不是显示其下的文件。\r\n\r\n-D, –dired 产生适合 Emacs 的 dired 模式使用的结果\r\n\r\n-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效\r\n\r\n-g 类似 -l,但不列出所有者\r\n\r\n-G, –no-group 不列出任何有关组的信息\r\n\r\n-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)\r\n\r\n–si 类似 -h,但文件大小取 1000 的次方而不是 1024\r\n\r\n-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地\r\n\r\n–indicator-style=方式 指定在每个项目名称后加上指示符号<方式>：none (默认)，classify (-F)，file-type (-p)\r\n\r\n-i, –inode 印出每个文件的 inode 号\r\n\r\n-I, –ignore=样式 不印出任何符合 shell 万用字符<样式>的项目\r\n\r\n-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。\r\n\r\n-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。\r\n\r\n-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息\r\n\r\n-m 所有项目以逗号分隔，并填满整行行宽\r\n\r\n-o 类似 -l,显示文件的除组信息外的详细信息。   \r\n\r\n-r, –reverse 依相反次序排列\r\n\r\n-R, –recursive 同时列出所有子目录层\r\n\r\n-s, –size 以块大小为单位列出所有文件的大小\r\n\r\n-S 根据文件大小排序\r\n\r\n–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：\r\nextension -X status -c\r\nnone -U time -t\r\nsize -S atime -u\r\ntime -t access -u\r\nversion -v use -u\r\n-t 以文件修改时间排序\r\n-u 配合 -lt:显示访问时间而且依访问时间排序\r\n配合 -l:显示访问时间但根据名称排序\r\n否则：根据访问时间排序\r\n-U 不进行排序;依文件系统原有的次序列出项目\r\n-v 根据版本进行排序\r\n-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值\r\n-x 逐行列出项目而不是逐栏列出\r\n-X 根据扩展名排序\r\n-1 每行只列出一个文件\r\n\r\n–help 显示此帮助信息并离开\r\n\r\n–version 显示版本信息并离开\r\n```\r\n\r\n常用范例：\r\n\r\n范例一：列出/home/chen 目录下的所有文件和详细信息\r\n```\r\n[root@web01 chen]# ls -lR /home/chen/\r\n/home/chen/:\r\ntotal 0\r\n-rw-r--r-- 1 root root 0 Jul 10 09:58 test.log\r\n\r\n```\r\n\r\n范例二：列出/home/chen 目录下以“t”开头的文件\r\n\r\n```\r\n[root@web01 chen]# ls -l t* /home/chen/\r\n-rw-r--r-- 1 root root    0 Jul 10 09:58 test.log\r\n-rw-r--r-- 1 root root    0 Jul 10 10:19 tt12312ttt.log\r\n-rw-r--r-- 1 root root    0 Jul 10 10:19 tt341111tt.log\r\n-rw-r--r-- 1 root root    0 Jul 10 10:18 ttttt.log\r\n\r\n```\r\n\r\n范例三：计算/home/chen 目录下文件个数\r\n\r\n```\r\nls -l /home/chen/ |wc -l\r\n\r\n```','2017-07-09 18:06:31','2017-07-09 19:56:42','linux-every-day-a-command-the-ls-command'),(207,5,5,'Linux：每天一个命令 cd命令','## cd 命令\r\ncd 命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。\r\n\r\n命令格式：\r\n\r\n```\r\ncd [目录名] \r\n```\r\n\r\n命令功能：`切换当前目录至其他目录`\r\n\r\n\r\n常用范例：\r\n\r\n范例一： 进入系统根目录\r\n```\r\ncd /\r\n```\r\n\r\n范例二： 退出当前目录\r\n\r\n```\r\ncd ..                      ##可以一直使用这个命令，最终退出到根目录\r\n```\r\n\r\n范例三： 进入指定目录\r\n\r\n```\r\ncd /home/chen\r\n```\r\n\r\n范例四：返回进入此目录之前的目录\r\n\r\n```\r\ncd -\r\n```','2017-07-09 18:24:58','2017-07-09 18:36:53','linux-every-day-a-command-the-cd-command'),(208,5,5,'Linux：每天一个命令 pwd命令','## pwd命令\r\nLinux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。\r\n\r\n命令格式：\r\n\r\n```\r\npwd [选项]\r\n```\r\n\r\n命令功能：`查看”当前工作目录“的完整路径`\r\n\r\n常用实例：\r\n\r\n范例一：用pwd命令查看当前文件目录全路径\r\n\r\n```\r\n[root@web01 chen]# pwd\r\n/home/chen\r\n\r\n```','2017-07-09 18:38:26','2017-07-09 18:41:05','linux-every-day-a-command-pwd-command'),(209,5,5,'Linux：每天一个命令 mkdir命令','## mkdir命令\r\nlinux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。\r\n\r\n命令格式：\r\n\r\n```\r\nmkdir [选项] 目录 ...\r\n```\r\n\r\n命令功能：`通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。 `\r\n\r\n命令参数：\r\n\r\n```\r\n  -m, --mode=模式，设定权限<模式> (类似 chmod)，而不是 rwxrwxrwx 减 umask\r\n  -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; （递归目录创建）\r\n  -v, --verbose  每次创建新目录都显示信息\r\n      --help   显示此帮助信息并退出\r\n      --version  输出版本信息并退出\r\n```\r\n\r\n命令实例：\r\n\r\n范例一：创建一个空目录\r\n\r\n```\r\n[root@web01 chen]# mkdir ceshi1\r\n[root@web01 chen]# ll\r\ndrwxr-xr-x 2 root root 4096 Jul 10 10:44 ceshi1\r\n```\r\n\r\n范例二： 创建递归目录\r\n\r\n```\r\n[root@web01 chen]# mkdir ceshi1/ceshi2 -p\r\n[root@web01 chen]# tree ceshi1/\r\nceshi1/\r\n└── ceshi2\r\n\r\n\r\n说明：\r\ntree 命令：把文件目录以树型结果呈现出来，如果没有该命令可以通过 yum tree 安装\r\n```\r\n\r\n范例三：创建权限为777的目录\r\n\r\n```\r\n[root@web01 ceshi2]# mkdir -m 777 ceshi1/ceshi2/ceshi3  -p\r\n[root@web01 ceshi2]# ll\r\ndrwxrwxrwx 2 root root 4096 Jul 10 10:48 ceshi3\r\n\r\n说明：\r\nceshi3 的权限为rwxrwxrwx\r\n```\r\n\r\n范例四： 一个命令创建项目的目录结构\r\n\r\n```\r\n[root@web01 chen]# mkdir -vp /home/chen/soft/{lib/,bin/,doc/{info,product},logs/{log1,log2},service/deploy/product}\r\nmkdir: created directory `/home/chen/soft\'\r\nmkdir: created directory `/home/chen/soft/lib/\'\r\nmkdir: created directory `/home/chen/soft/bin/\'\r\nmkdir: created directory `/home/chen/soft/doc\'\r\nmkdir: created directory `/home/chen/soft/doc/info\'\r\nmkdir: created directory `/home/chen/soft/doc/product\'\r\nmkdir: created directory `/home/chen/soft/logs\'\r\nmkdir: created directory `/home/chen/soft/logs/log1\'\r\nmkdir: created directory `/home/chen/soft/logs/log2\'\r\nmkdir: created directory `/home/chen/soft/service\'\r\nmkdir: created directory `/home/chen/soft/service/deploy\'\r\nmkdir: created directory `/home/chen/soft/service/deploy/product\'\r\n\r\n\r\n\r\n[root@web01 chen]# tree soft/\r\nsoft/\r\n├── bin\r\n├── doc\r\n│   ├── info\r\n│   └── product\r\n├── lib\r\n├── logs\r\n│   ├── log1\r\n│   └── log2\r\n└── service\r\n    └── deploy\r\n        └── product\r\n\r\n```','2017-07-09 18:55:55','2017-07-09 18:55:55','linux-every-day-a-command-the-mkdir-command'),(210,5,5,'Linux：每天一个命令 rm命令','## rm命令\r\n\r\n创建文件和目录的命令mkdir ，今天学习一下linux中删除文件和目录的命令： rm命令。rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。\r\nrm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。\r\n\r\n1.命令格式：\r\n\r\n```\r\nrm [选项]  文件 ...\r\n```\r\n\r\n2.命令功能：`删除一个目录中的一个或者多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。`\r\n\r\n3.命令参数：\r\n```\r\n    -f, --force    忽略不存在的文件，从不给出提示。\r\n    -i, --interactive 进行交互式删除\r\n    -r, -R, --recursive   指示rm将参数中列出的全部目录和子目录均递归地删除。\r\n    -v, --verbose    详细显示进行的步骤\r\n      	--help     显示此帮助信息并退出\r\n      	--version  输出版本信息并退出\r\n```\r\n\r\n4.命令实例：\r\n\r\n范例一：删除文件`test.log`,系统会先询问是否删除\r\n\r\n```\r\n[root@web01 chen]# rm test.log \r\nrm: remove regular empty file `test.log\'?  y\r\n\r\n说明 ：\r\n输出y后就会删除文件，不想删除就输入n\r\n```\r\n\r\n范例二：强行删除文件`ttttt.logi`，系统不会提示\r\n\r\n```\r\n[root@web01 chen]# rm -rf ttttt.log \r\n\r\n```\r\n\r\n范例三：删除当前目录下的所有.log文件；删除前逐一询问确认\r\n\r\n```\r\n[root@web01 chen]# rm -i *.log\r\nrm: remove regular empty file `tt12312ttt.log\'? y\r\nrm: remove regular empty file `tt341111tt.log\'? y\r\n\r\n```\r\n\r\n范例四：删除test目录及目录下的所有文件，删除之前逐一询问\r\n\r\n```\r\n[root@web01 chen]# rm -r test/\r\nrm: descend into directory `test\'? y\r\nrm: remove regular empty file `test/1112222.txt\'? y\r\nrm: remove regular empty file `test/111.txt\'? y\r\nrm: remove regular empty file `test/111223333322.txt\'? y\r\nrm: remove directory `test\'? y\r\n\r\n```\r\n\r\n范例五：删除test目录及目录下的所有文件，删除后不会询问直接删除\r\n\r\n```\r\n[root@web01 chen]# rm -rf test/\r\n\r\n```','2017-07-09 19:10:21','2017-07-09 20:52:58','linux-a-command-rm-command-every-day'),(211,5,5,'Linux：每天一个命令 mv命令','## mv命令\r\n\r\nmv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录\r\n\r\n命令格式：\r\n\r\n```\r\nmv [选项] 源文件或目录 目标文件或目录\r\n```\r\n\r\n命令功能：`mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。`\r\n\r\n\r\n命令参数：\r\n\r\n```\r\n-b ：若需覆盖文件，则覆盖前先行备份。 \r\n-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；\r\n-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！\r\n-u ：若目标文件已经存在，且 source 比较新，才会更新(update)\r\n-t  ： --target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。\r\n```\r\n\r\n命令实例：\r\n\r\n范例一：文件改名 把`abc.txt`改名为`cba.txt`\r\n\r\n```\r\n[root@web01 chen]# mv abc.txt cba.txt\r\n[root@web01 chen]# ll\r\n-rw-r--r-- 1 root root    0 Jul 10 13:02 cba.txt\r\n```\r\n\r\n范例二：移动文件\r\n\r\n```\r\n[root@web01 chen]# mv cba.txt /home/chen/ceshi1/\r\n[root@web01 chen]# ll /home/chen/ceshi1/\r\n-rw-r--r-- 1 root root    0 Jul 10 13:02 cba.txt\r\n\r\n```\r\n\r\n范例三：文件被覆盖钱做简单的备份 `-b` 参数\r\n\r\n```\r\n[root@web01 ceshi2]# mv aaa.txt -b cba.txt \r\nmv: overwrite `cba.txt\'? y\r\n[root@web01 ceshi2]# ll\r\n-rw-r--r-- 1 root root    9 Jul 10 13:06 cba.txt\r\n-rw-r--r-- 1 root root    0 Jul 10 13:02 cba.txt~\r\n[root@web01 ceshi2]# cat cba.txt\r\nasdasdas\r\n[root@web01 ceshi2]# cat cba.txt~\r\n\r\n```\r\n\r\n范例四：把当前目录里的所有文件移动到另一个目录中\r\n\r\n```\r\n[root@web01 ceshi2]# mv /home/chen/ceshi1/ceshi2/cba.* /home/chen/ceshi1/\r\n[root@web01 ceshi1]# ll\r\n-rw-r--r-- 1 root root    9 Jul 10 13:06 cba.txt\r\n-rw-r--r-- 1 root root    0 Jul 10 13:02 cba.txt~\r\n\r\n```\r\n\r\n范例五： 移动到上级目录\r\n\r\n```\r\n[root@web01 ceshi1]# mv cba.* ..\r\n[root@web01 chen]# ll\r\n-rw-r--r-- 1 root root    9 Jul 10 13:06 cba.txt\r\n-rw-r--r-- 1 root root    0 Jul 10 13:02 cba.txt~\r\n\r\n```\r\n\r\n范例六： 将文件改名，即时文件2存在，也直接覆盖\r\n\r\n```\r\n[root@web01 chen]# cat asd.txt \r\n123\r\n[root@web01 chen]# cat cba.txt\r\nasdasdas\r\n[root@web01 chen]# mv -f asd.txt cba.txt\r\n[root@web01 chen]# cat cba.txt\r\n123\r\n\r\nasd.txt的内容直接覆盖了cba.txt内容，-f 这是个危险的选项，使用的时候一定要保持头脑清晰，一般情况下最好不用加上它。\r\n```','2017-07-09 21:17:20','2017-07-09 21:17:20','linux-a-command-mv-command-every-day'),(212,5,5,'Linux：每天一个命令 cp命令','## cp命令\r\n\r\ncp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 \r\n\r\n命令格式：\r\n\r\n```\r\ncp [选项]... [-T] 源 目的\r\n或：cp [选项]... 源... 目录\r\n或：cp [选项]... -t 目录 源...\r\n```\r\n\r\n命令功能：`将源文件复制至目标文件，或将多个源文件复制至目标目录。`\r\n\r\n命令参数：\r\n\r\n```\r\n-a, --archive           等于-dR --preserve=all\r\n    --backup=CONTROL    为每个已存在的目标文件创建备份\r\n-b                      类似--backup 但不接受参数\r\n   --copy-contents      在递归处理是复制特殊文件内容\r\n-d                      等于--no-dereference --preserve=links\r\n-f, --force         如果目标文件无法打开则将其移除并重试(当 -n 选项\r\n                    存在时则不需再选此项)\r\n-i, --interactive        覆盖前询问(使前面的 -n 选项失效)\r\n-H                跟随源文件中的命令行符号链接\r\n-l, --link            链接文件而不复制\r\n-L, --dereference   总是跟随符号链接\r\n-n, --no-clobber   不要覆盖已存在的文件(使前面的 -i 选项失效)\r\n-P, --no-dereference   不跟随源文件中的符号链接\r\n-p                等于--preserve=模式,所有权,时间戳\r\n    --preserve[=属性列表   保持指定的属性(默认：模式,所有权,时间戳)，如果\r\n               可能保持附加属性：环境、链接、xattr 等\r\n-R, -r, --recursive  复制目录及目录内的所有项目\r\n```\r\n\r\n命令实例：\r\n\r\n范例一： 复制单个文件到目标目录，文件在目标目录中不存在\r\n\r\n```\r\n[root@web01 chen]# cp /home/chen/cba.txt /home/chen/ceshi1/\r\n[root@web01 chen]# cd ceshi1/\r\n[root@web01 ceshi1]# ll\r\n-rw-r--r-- 1 root root    4 Jul 10 13:33 cba.txt\r\n\r\n说明：\r\n在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。  \r\n```\r\n\r\n范例二：目标文件存在时，会询问是否覆盖\r\n\r\n```\r\n[root@web01 chen]# cp /home/chen/cba.txt /home/chen/ceshi1/\r\ncp: overwrite `/home/chen/ceshi1/cba.txt\'? y\r\n\r\n```\r\n\r\n范例三：复制整个目录\r\n\r\n```\r\n[root@web01 chen]# cp -a test1/ test2\r\n[root@web01 chen]# ll test2\r\ndrwxr-xr-x 2 root root 4096 Jul 10 13:52 test1\r\n[root@web01 chen]# tree test2\r\ntest2\r\n└── test1\r\n    └── aaaa\r\n\r\n```','2017-07-09 21:53:44','2017-07-09 21:53:44','linux-a-command-cp-command-every-day'),(213,5,5,'Linux：每天一个命令 touch命令','## touch命令\r\n\r\nlinux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。\r\n\r\n命令格式：\r\n\r\n```\r\ntouch [选项]... 文件...\r\n```\r\n\r\n命令参数：\r\n\r\n```\r\n-a   或--time=atime或--time=access或--time=use 　只更改存取时间。\r\n-c   或--no-create 　不建立任何文档。\r\n-d 　使用指定的日期时间，而非现在的时间。\r\n-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。\r\n-m   或--time=mtime或--time=modify 　只更改变动时间。\r\n-r 　把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。\r\n-t 　使用指定的日期时间，而非现在的时间。\r\n```\r\n\r\n命令功能：`touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。`\r\n\r\n\r\n命令实例：\r\n\r\n范例一： 创建不存在的文件\r\n\r\n```\r\n[root@web01 chen]# touch abc.txt\r\n[root@web01 chen]# ll\r\n-rw-r--r-- 1 root root    0 Jul 10 13:58 abc.txt\r\n\r\n```\r\n\r\n范例二： 更新`cba.txt`的时间戳与`abc.txt`相同\r\n\r\n```\r\n[root@web01 chen]# touch -r cba.txt  abc.txt \r\n[root@web01 chen]# ll\r\ntotal 20\r\n-rw-r--r-- 1 root root    0 Jul 10 13:16 abc.txt\r\n-rw-r--r-- 1 root root    4 Jul 10 13:16 cba.txt\r\n\r\n```','2017-07-09 22:00:58','2017-07-09 22:00:58','linux-a-command-touch-every-day'),(214,5,5,'Linux：每天一个命令 cat命令','## cat命令\r\n\r\ncat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 \r\n\r\n命令格式：\r\n\r\n```\r\ncat [选项] [文件]...\r\n```\r\n\r\n命令功能：\r\n\r\n```\r\ncat主要有三大功能：\r\n1.一次显示整个文件:cat filename\r\n2.从键盘创建一个文件:cat > filename 只能创建新文件,不能编辑已有文件.\r\n3.将几个文件合并为一个文件:cat file1 file2 > file\r\n```\r\n\r\n命令参数：\r\n\r\n```\r\n-A, --show-all           等价于 -vET\r\n-b, --number-nonblank    对非空输出行编号\r\n-e                       等价于 -vE\r\n-E, --show-ends          在每行结束处显示 $\r\n-n, --number             对输出的所有行编号,由1开始对所有输出的行数编号\r\n-s, --squeeze-blank      有连续两行以上的空白行，就代换为一行的空白行 \r\n-t                       与 -vT 等价\r\n-T, --show-tabs          将跳格字符显示为 ^I\r\n-u                       (被忽略)\r\n-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外\r\n```\r\n\r\n使用实例：\r\n\r\n范例一：按照文件内容顺序添加行号，打印到当前屏幕上\r\n\r\n```\r\n[root@web01 chen]# cat -n abc.txt  abc123.txt \r\n     1	123\r\n     2	456\r\n     3	\r\n     4	567\r\n     5	abc\r\n     6	cnm\r\n     7	\r\n     8	rnm\r\n\r\n```\r\n\r\n范例一：按照文件内容顺序添加行号（不添加空白行），打印到当前屏幕上\r\n\r\n```\r\n[root@web01 chen]# cat -b abc.txt  abc123.txt \r\n     1	123\r\n     2	456\r\n\r\n     3	567\r\n     4	abc\r\n     5	cnm\r\n\r\n     6	rnm\r\n\r\n```\r\n\r\n范例三：把`abc.txt` 内容追加到`abc123.txt` 中\r\n\r\n```\r\n[root@web01 chen]# cat -n abc.txt  >>abc123.txt \r\n[root@web01 chen]# cat abc123.txt \r\nabc\r\ncnm\r\n\r\nrnm\r\n     1	123\r\n     2	456\r\n     3	\r\n     4	567\r\n\r\n```','2017-07-09 22:08:47','2017-07-09 22:08:47','linux-every-day-a-command-the-cat-command'),(215,3,3,'学习 Vue.js：与 Laravel 结合持久化 Todo 数据（准备篇）','前面用 vue.js 写了一个 [Todo 小样][1]，但没有做持久化，下面完成。完成的具体方式是：Laravel 作为 API Server，数据存入 MySQL，前台采用 [Vue Webpack Template][2]。\r\n\r\n[1]: https://laravel-china.org/articles/5205/learn-vuejs-write-a-simple-todo-sample\r\n[2]: https://github.com/vuejs/vue-cli\r\n\r\n## 准备工作\r\n\r\n### Laravel\r\n\r\n1. 创建项目\r\n\r\n```\r\n$ laravel new ApiServer\r\n```\r\n\r\n2. 下载 `barryvdh/laravel-cors`\r\n\r\nLaravel API 默认会阻止跨域请求（Cross-Origin Resource Sharing），这个包能开放跨域请求。\r\n\r\n```\r\n$ composer require barryvdh/laravel-cors\r\n```\r\n\r\n配置过程参看 [文档][3]。\r\n\r\n[3]: https://github.com/barryvdh/laravel-cors\r\n\r\n3. 迁移 `todos` 表\r\n\r\n创建 `todos` 表的迁移文件。\r\n\r\n```\r\n$ php artisan make:migration create_todos_table --create=todos\r\n```\r\n\r\n设定表格字段。\r\n\r\n```\r\nSchema::create(\'todos\', function (Blueprint $table) {\r\n	$table->increments(\'id\');\r\n	$table->string(\'title\')->unique();\r\n	$table->boolean(\'completed\')->default(false);\r\n	$table->timestamps();\r\n});\r\n```\r\n\r\n执行迁移。\r\n\r\n```\r\n$ php artisan migrate\r\n```\r\n\r\n4. 创建 Todo Model\r\n\r\n```\r\n$ php artisan make:model Models\\Todo\r\n```\r\n\r\n修改\r\n\r\n```\r\nprotected $fillable = [\r\n	\'title\'\r\n];\r\n```\r\n\r\n5. 写 API。\r\n\r\n前台页面有对 Todo 的增、删、改（完成状态）和查的操作，总共 5 个 API，在 `routes/api.php` 中写。\r\n\r\n```\r\nRoute::get(\'/todos\', function (Request $request) {\r\n	$todos = Todo::all();\r\n	\r\n	return $todos;\r\n});\r\n\r\nRoute::get(\'/todo/{id}\', function (Request $request, $id) {\r\n	$todo = Todo::find($id);\r\n\r\n	if (is_null($todo)) {\r\n		return [\'id\' => -1, \'title\' => \'哎呀\', \'desc\' => \'请求有误\'];\r\n	}\r\n\r\n	return $todo;\r\n});\r\n\r\nRoute::patch(\'/todo/{id}/toggleComplete\', function (Request $request, $id) {\r\n	$todo = Todo::findOrFail($id);\r\n\r\n	$todo->completed = ! $todo->completed;\r\n	$todo->save();\r\n\r\n	return $todo;\r\n});\r\n\r\nRoute::post(\'/todos/create\', function (Request $request) {\r\n	$data = $request->only(\'title\');\r\n\r\n	$todo = Todo::create($data);\r\n\r\n	return $todo;\r\n});\r\n\r\nRoute::delete(\'/todo/{id}/delete\', function (Request $request, $id) {\r\n	return Todo::destroy($id);\r\n});\r\n```\r\n\r\n### Vue Webpack Template\r\n\r\n写基于 Vue 的前端项目，有脚手架模板可以用，就像写 PHP 项目时用 Laravel，会带来开发上的极大便利。\r\n\r\n创建 Laravel 项目使用 `laravel` 命令，创建  Vue 前端项目使用 `vue` 命令，为了能用 `vue` 命令，我们要安装 [vue-cli][4]。\r\n\r\n[4]: https://github.com/vuejs/vue-cli\r\n\r\n```\r\n$ npm install -g vue-cli\r\n```\r\n\r\nVue Webpack Template 就是使用 Webpack 作为前端构建工具的脚手架模板，没有意外都是从这个模板开始开发项目的。下面创建项目 `todos`。\r\n\r\n```\r\n$ vue init webpack todos\r\n```\r\n\r\n安装过程中  Project name、Project description、Author 和 Vue build 走默认即可。\r\n\r\n在提示「Install vue-router?（Y/n）」的地方，输入 `Y`。[`vue-router`][5] 与 vue 结合，给单页应用提供路由功能。\r\n\r\n[5]: https://router.vuejs.org/zh-cn/essentials/getting-started.html\r\n\r\nESLint、Karma + Mocha 和 Nightwatch 都不需要安装。\r\n\r\n```\r\n$ cd todos\r\n$ npm install\r\n$ npm run dev\r\n```\r\n\r\n浏览器看到 `http://localhost:8080/#/` 地址被打开，显示欢迎页，表示 vue 项目安装成功。地址里的 `#/` 说明成功安装了 `vue-router`，以后的操作都是在一个页面里的。\r\n\r\n下一节将介绍在 vue 项目中怎样与 Laravel 后台 API 交互，并且完成项目功能。','2017-07-10 00:06:51','2017-07-10 06:37:06','learning-vue-js-combine-with-laravel-persistence-todo-data-prepare'),(216,3,3,'HTML 行内元素的特点','行内元素：\r\n\r\n1. 内容撑开宽高，宽高都是 auto。\r\n\r\n2. 不支持设定宽高。\r\n\r\n3. 不支持上下的 margin 和 padding。（上下 margin 没有，上面 padding 没有，下面的 padding 确实有但是不占空间）。\r\n\r\n4. 所有行内元素显示在一行。\r\n\r\n5. 代码换行被解析为一个空格（0.5em）。','2017-07-10 05:30:25','2017-07-10 05:30:25','the-characteristics-of-the-html-inline-elements'),(217,3,3,'常用块级元素与行内元素','块级元素：div、h1-h6、p、ul、li、ol、dl、dt、dd、header、nav、section、article、footer 和 aside。\r\n\r\n行内元素：a、span、strong、em、mark、img 和 time。','2017-07-10 06:26:16','2017-09-12 01:09:52','commonly-used-block-level-elements-and-inline-elements'),(218,3,3,'一千零一夜：第23夜','我大学里让我印象深刻的一件事情，就是教学区的上课铃声，来自《东京爱情故事》，由歌手小田和正演唱的《突如其来的爱情》（ラブストーりーは突然に）。\r\n\r\n继而又想到高中学校中午休息时放的曲子，那是陈淑桦的《滚滚红尘》。\r\n\r\n瞬间尘土铺面。','2017-07-10 06:35:30','2017-07-10 06:35:30','one-thousand-nights-23-night'),(219,5,5,'Linux：每天一个命令 nl命令','## nl命令\r\nnl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。  \r\n\r\n命令格式：\r\n\r\n```\r\nnl [选项]... [文件]...\r\n```\r\n\r\n命令功能：`nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。`\r\n\r\n\r\n\r\n命令参数：\r\n\r\n```\r\n-b  ：指定行号指定的方式，主要有两种：\r\n-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；\r\n-b t ：如果有空行，空的那一行不要列出行号(默认值)；\r\n-n  ：列出行号表示的方法，主要有三种：\r\n-n ln ：行号在萤幕的最左方显示；\r\n-n rn ：行号在自己栏位的最右方显示，且不加 0 ；\r\n-n rz ：行号在自己栏位的最右方显示，且加 0 ；\r\n-w  ：行号栏位的占用的位数。\r\n-p 在逻辑定界符处不重新开始计算。 \r\n```\r\n\r\n\r\n命令实例：\r\n\r\n范例一：用`nl`列出abc.txt 内容\r\n\r\n```\r\n[root@web01 chen]# nl abc.txt \r\n     1	123\r\n     2	456\r\n       \r\n     3	567\r\n\r\n说明：\r\n文件空白行，nl不会加上行号\r\n```\r\n\r\n\r\n范例二：用`nl`列出abc.txt内容，空白行也加上行号\r\n\r\n```\r\n[root@web01 chen]# nl -ba abc.txt \r\n     1	123\r\n     2	456\r\n     3	\r\n     4	567\r\n\r\n```\r\n\r\n范例三：让行号签名自动补上0，统一输出格式\r\n\r\n```\r\n[root@web01 chen]# nl -ba -n rz abc.txt \r\n000001	123\r\n000002	456\r\n000003	\r\n000004	567\r\n\r\n```','2017-07-10 17:12:40','2017-07-10 17:12:40','linux-a-command-the-nl-command-every-day'),(220,5,5,'Linux：每天一个命令 more命令','## more命令\r\nmore命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。\r\n\r\n命令格式：\r\n\r\n```\r\nmore [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] \r\n```\r\n\r\n命令功能：`more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。`\r\n\r\n\r\n命令参数：\r\n\r\n```\r\n+n      从笫n行开始显示\r\n-n       定义屏幕大小为n行\r\n+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示  \r\n-c       从顶部清屏，然后显示\r\n-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能\r\n-l        忽略Ctrl+l（换页）字符\r\n-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似\r\n-s       把连续的多个空行显示为一行\r\n-u       把文件内容中的下画线去掉\r\n```','2017-07-10 17:14:55','2017-07-10 17:14:55','linux-a-command-more-every-day'),(221,5,5,'Linux：每天一个命令 less命令','## less命令\r\n\r\nless 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。\r\n\r\n命令格式：\r\n\r\n```\r\nless [参数]  文件 \r\n```\r\n\r\n命令功能：`less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。`\r\n\r\n命令参数：\r\n\r\n```\r\n-b <缓冲区大小> 设置缓冲区的大小\r\n-e  当文件显示结束后，自动离开\r\n-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件\r\n-g  只标志最后搜索的关键词\r\n-i  忽略搜索时的大小写\r\n-m  显示类似more命令的百分比\r\n-N  显示每行的行号\r\n-o <文件名> 将less 输出的内容在指定文件中保存起来\r\n-Q  不使用警告音\r\n-s  显示连续空行为一行\r\n-S  行过长时间将超出部分舍弃\r\n-x <数字> 将“tab”键显示为规定的数字空格\r\n/字符串：向下搜索“字符串”的功能\r\n?字符串：向上搜索“字符串”的功能\r\nn：重复前一个搜索（与 / 或 ? 有关）\r\nN：反向重复前一个搜索（与 / 或 ? 有关）\r\nb  向后翻一页\r\nd  向后翻半页\r\nh  显示帮助界面\r\nQ  退出less 命令\r\nu  向前滚动半页\r\ny  向前滚动一行\r\n空格键 滚动一行\r\n回车键 滚动一页\r\n[pagedown]： 向下翻动一页\r\n[pageup]：   向上翻动一页\r\n```','2017-07-10 17:17:23','2017-07-10 17:17:23','linux-a-command-less-every-day'),(222,5,5,'Linux：每天一个命令 head命令','## head命令\r\n\r\nhead 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾\r\n\r\n命令格式：\r\n\r\n```\r\nhead [参数]... [文件]...  \r\n```\r\n\r\n命令功能：`head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 \r\n`\r\n\r\n命令参数：\r\n\r\n```\r\n-q 隐藏文件名\r\n-v 显示文件名\r\n-c<字节> 显示字节数\r\n-n<行数> 显示的行数\r\n```','2017-07-10 17:19:51','2017-07-10 17:19:51','linux-a-command-head-every-day'),(223,5,5,'Linux：每天一个命令 tail命令','## tail命令\r\n\r\ntail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. \r\n\r\n命令格式：\r\n\r\n```\r\ntail[必要参数][选择参数][文件] \r\n```\r\n\r\n命令功能：`用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。`\r\n\r\n命令参数：\r\n\r\n```\r\n-f 循环读取\r\n-q 不显示处理信息\r\n-v 显示详细的处理信息\r\n-c<数目> 显示的字节数\r\n-n<行数> 显示行数\r\n--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. \r\n-q, --quiet, --silent 从不输出给出文件名的首部 \r\n-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 \r\n```','2017-07-10 17:21:39','2017-07-10 17:21:39','linux-a-command-tail-every-day'),(224,3,3,'学习 Vue.js：与 Laravel 结合持久化 Todo 数据（实现篇）','[上一节](https://laravel-china.org/articles/5228/learning-vuejs-combine-laravel-to-persist-todo-data) 做了一些准备工作，这一节来完成 Todo 项目。\r\n\r\n## 引入 `bootstrap.css`\r\n\r\n项目中用到了 Bootstrap 的样式文件，在 `index.html` 文件中引入之。\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <title>lara-vue</title>\r\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\r\n  </head>\r\n  <body>\r\n    <div id=\"app\"></div>\r\n    <!-- built files will be auto injected -->\r\n  </body>\r\n</html>\r\n```\r\n\r\n## 使用 `axios.js`\r\n\r\n本项目中前端发送 Ajax 请求使用 [`axios.js`][1]，为了能在 vue 项目中更好的集成它，也使用 [`vue-axios`][2]。\r\n\r\n[1]: https://github.com/mzabriskie/axios\r\n[2]: https://github.com/imcvampire/vue-axios\r\n\r\n```\r\n$ npm install --save axios vue-axios\r\n```\r\n\r\n修改项目入口文件 `src/main.js`，引入 `axios` 和 `VueAxios`。\r\n\r\n```\r\nimport Vue from \'vue\'\r\nimport axios from \'axios\'\r\nimport VueAxios from \'vue-axios\'\r\nimport App from \'./App\'\r\nimport router from \'./router\'\r\n\r\nVue.use(VueAxios, axios)\r\n\r\nVue.config.productionTip = false\r\n\r\n/* eslint-disable no-new */\r\nnew Vue({\r\n  el: \'#app\',\r\n  router,\r\n  template: \'<App/>\',\r\n  components: { App }\r\n})\r\n```\r\n\r\n## 创建组件\r\n\r\n在 `src/components` 文件夹中新建两个组件 `Todos.vue` 和 `Todo.vue`，前者是为了显示 Todo 列表，后者是为了显示 Todo 详情。本项目中，详情页只是为了说明 `vue-router` 的使用，没有提供比在首页中更多的信息。\r\n\r\n对 `vue-router` 来说，这两个组件就是两个页面。\r\n\r\n### 设定路由\r\n\r\n在 `src/router/index.js` 中设定路由。\r\n\r\n```\r\nimport Vue from \'vue\'\r\nimport Router from \'vue-router\'\r\nimport Todos from \'@/components/Todos\'\r\nimport Todo from \'@/components/Todo\'\r\n\r\nVue.use(Router)\r\n\r\nexport default new Router({\r\n  routes: [\r\n    {\r\n      path: \'/\',\r\n      name: \'Todos\',\r\n      component: Todos\r\n    },\r\n    {\r\n      path: \'/todo/:id\',\r\n      name: \'Todo\',\r\n      component: Todo\r\n    }\r\n  ]\r\n})\r\n```\r\n\r\n这里设定了两个路由 `/` 和 `/todo/xx`，对应两个组件，所以说在 vue 中，组件就是页面。\r\n\r\n`name` 是路由的名字， 给 `<router-link>` 标签使用，用于链接到指定路由。\r\n\r\n## 写组件\r\n\r\n接下来写 `Todos.vue` 和 `Todo.vue` 组件的内容，\r\n\r\n### `Todo.vue`\r\n\r\n```\r\n<template>\r\n  <div class=\"todo\">\r\n    <div v-if=\"loading\" class=\"loading\">\r\n      Loading...\r\n    </div>\r\n\r\n    <div v-if=\"error\" class=\"error\">\r\n      {{ error }}\r\n    </div>\r\n\r\n    <div v-if=\"todo\" class=\"content\">\r\n      <nav>\r\n        <router-link :to=\"{ name: \'Todos\'}\">←返回</router-link>\r\n      </nav>\r\n      <h2>{{ todo.title }}</h2>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data () {\r\n      return {\r\n        loading: false,\r\n        todo: null,\r\n        error: null\r\n      }\r\n    },\r\n    created () {\r\n      // 组件创建完后获取数据，\r\n      // 此时 data 已经被 observed 了\r\n      this.fetchData()\r\n    },\r\n    watch: {\r\n      // 如果路由有变化，会再次执行该方法\r\n      \'$route\': \'fetchData\'\r\n    },\r\n    methods: {\r\n      fetchData () {\r\n        this.error = this.todo = null\r\n        this.loading = true\r\n\r\n        this.axios.get(\'http://localhost:8000/api/todo/\' + this.$route.params.id)\r\n          .then((response) => {\r\n            this.loading = false\r\n            this.todo = response.data\r\n          })\r\n          .catch((error) => {\r\n            this.error = error.toString()\r\n          });\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n<style scoped>\r\n  .todo {\r\n    text-align: center;\r\n  }\r\n</style\r\n```\r\n\r\n举个例子：当地址栏请求 `http://localhost:8080/#/todo/4` 地址时，触发 `fetchData` 方法， axios 发出 get 请求，`this.$route.params.id`（对应路由定义中的 `:id`） 拿到 `4`，取得数据后显示。\r\n\r\n```\r\n<div v-if=\"todo\" class=\"content\">\r\n	<nav>\r\n		<router-link :to=\"{ name: \'Todos\'}\">←返回</router-link>\r\n	</nav>\r\n	<h2>{{ todo.title }}</h2>\r\n</div>\r\n```\r\n\r\n`<router-link>` 标签本质是一个超链接，链接到名叫 `Todos` 的路由，我们已经知道，这是 Todo 列表页。\r\n\r\n### `Todos.vue`\r\n\r\n```\r\n<template>\r\n  <div class=\"container\">\r\n    <div class=\"row\">\r\n      <div class=\"col-md-6 col-md-offset-3\">\r\n        <div class=\"panel panel-default\">\r\n          <div class=\"panel-heading text-center\">\r\n              计划要做的事情，共 {{ todos.length }} 件\r\n          </div>\r\n          <div class=\"panel-body\">\r\n            <div class=\"list-groups\">\r\n              <a class=\"list-group-item\" v-bind:class=\"{ \'completed\': todo.completed }\" v-for=\"(todo, index) in todos\">\r\n                <router-link :to=\"{ name: \'Todo\', params: { id: todo.id }}\">{{ todo.title }}</router-link>\r\n                <button class=\"btn btn-xs btn-danger pull-right\" v-on:click=\'destroy(index, todo)\'title=\"删除\">✘</button>\r\n                <button class=\"btn btn-xs pull-right\" v-on:click=\'toggleDone(index, todo)\' v-bind:class=\"[todo.completed ? \'btn-success\': \'\']\" v-bind:title=\"[todo.completed ? \'点击，标记为未完成\': \'点击，标记为已完成\']\">✔</button>\r\n              </a>\r\n            </div>\r\n          </div>\r\n          <div class=\"panel-footer\">\r\n            <form v-on:submit.prevent=\"add\">\r\n              <div class=\"form-group\">\r\n                <input type=\"text\" class=\"form-control text-center\" v-model=\"newTodo.title\">\r\n              </div>\r\n              <button class=\"btn btn-default btn-block\" type=\"submit\">添加</button>\r\n            </form>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \'todos\',\r\n  props: [\'todos\'],\r\n  data () {\r\n    return {\r\n      newTodo: { title: \'\'}\r\n    }\r\n  },\r\n  methods: {\r\n    add() {\r\n      if (! this.newTodo.title.trim()) { return ; }\r\n      this.axios.post(\'http://localhost:8000/api/todos/create\', { \'title\': this.newTodo.title })\r\n          .then((response) => {\r\n              this.todos.push(response.data)\r\n							this.newTodo.title = \'\'\r\n          });\r\n    },\r\n    destroy(index, todo) {\r\n      this.axios.delete(\'http://localhost:8000/api/todo/\' + todo.id + \'/delete\')\r\n          .then((response) => {\r\n              this.todos.splice(index, 1)\r\n          });\r\n    },\r\n    toggleDone(index, todo) {\r\n      this.axios.patch(\'http://localhost:8000/api/todo/\' + todo.id + \'/toggleComplete\')\r\n          .then((response) => {\r\n              this.todos[index].completed = !this.todos[index].completed\r\n          });\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.btn-xs+.btn-xs {\r\n  margin-right: .5rem;\r\n}\r\n\r\na.list-group-item.completed {\r\n  background-color: #f5f5f5;\r\n  text-decoration: line-through;\r\n}\r\n</style>\r\n```','2017-07-10 22:22:50','2017-07-10 22:22:50','learning-vue-js-combine-with-laravel-persistence-todo-data-implementation'),(225,3,3,'表单验证规则：required、present 、filled 和 nullable','## 三个概念\r\n\r\n在解释这四个验证规则前，需要明晰三个概念——空值（empty）、输入数据（input data）和验证字段（filed under validation）。\r\n\r\n### 空值\r\n\r\n在 Laravel 中，一个字段值满足下面任一条件都被视为空值。\r\n\r\n* `null`\r\n* 空字符串（`\'\'`）\r\n* 空数组（`[]`）或空 `Countable` 对象\r\n* 无路径的上传文件\r\n\r\n###  输入数据&验证字段\r\n\r\n以注册功能为例。\r\n\r\n```\r\nuse Illuminate\\Http\\Request;\r\nuse Illuminate\\Support\\Facades\\Validator;\r\n\r\npublic function register(Request $request)\r\n{\r\n	$this->validator($request->all())->validate();\r\n\r\n	...\r\n}\r\n\r\nprotected function validator(array $data)\r\n{\r\n	return Validator::make($data, [\r\n		\'name\' => \'required|string|max:255\',\r\n		\'email\' => \'required|string|email|max:255|unique:users\',\r\n		\'password\' => \'required|string|min:6|confirmed\',\r\n	]);\r\n}\r\n```\r\n\r\n`$request->all()` 就是「输入数据」，`Validator::make` 里的 `name`、`email` 和 `password` 就是「验证字段」。\r\n\r\n## 验证规则\r\n\r\n### required\r\n\r\n验证字段必须出现在输入数据中、不能为空。\r\n\r\n### present\r\n\r\n验证字段必须出现在输入数据中、能为空。\r\n\r\n### filled\r\n\r\n验证字段可不在输入数据中。\r\n\r\n当验证字段出现在输入数据中时，不能为空。\r\n\r\n### nullable\r\n\r\n验证字段的值可以是 `null`。','2017-07-11 00:03:22','2017-07-11 00:36:12','form-validation-rules-required-the-present-filled-and-nullable'),(226,3,3,'学习 Vue.js：用 Vuex 重构 Todo 项目','在 [上一篇][1] 中，vue.js 与 Laravel 结合实现了 Todo 项目的数据持久化，下面用 Vuex 重构。\r\n\r\n[1]: https://laravel-china.org/articles/5229/learning-vuejs-combine-laravel-to-persist-todo-data-implementation\r\n\r\n## 安装 Vuex\r\n\r\n```\r\n$ npm install vuex --save\r\n```\r\n\r\n修改 `main.js`，引入 Vuex。\r\n\r\n```\r\nimport Vue from \'vue\'\r\nimport axios from \'axios\'\r\nimport VueAxios from \'vue-axios\'\r\nimport Vuex from \'vuex\'\r\nimport App from \'./App\'\r\nimport router from \'./router\'\r\n\r\nVue.use(VueAxios, axios)\r\nVue.use(Vuex)\r\n\r\nVue.config.productionTip = false\r\n\r\nconst store = new Vuex.Store({\r\n  state: {\r\n    todos: [],\r\n    newTodo: { id: null, title: \'\', completed: false }\r\n  },\r\n  mutations: {\r\n    // ...\r\n  },\r\n  actions: {\r\n    // ...\r\n  }\r\n})\r\n\r\n/* eslint-disable no-new */\r\nnew Vue({\r\n  el: \'#app\',\r\n  router,\r\n  store,\r\n  template: \'<App/>\',\r\n  components: { App }\r\n})\r\n```\r\n\r\nVuex 仅以一个全局对象（`store`）的形式呈现，就可以管理整个项目里所有的组件状态。`state` 对象里的 `todos` 和 `newTodo` 可简单理解为全局变量，这两个变量之所以对项目中所有组件可见，是因为在 `new Vue` 的时候注册入项目里了。\r\n\r\n```\r\nnew Vue({\r\n  ...\r\n  store,\r\n  ...\r\n})\r\n```\r\n\r\n## `App.vue`\r\n\r\n```\r\n<template>\r\n  <div id=\"app\">\r\n    <router-view></router-view>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \'app\',\r\n  mounted() {\r\n    this.$store.dispatch(\'getTodos\')\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n在组件里使用 `this.$store` 取得注入的 `store` 对象。我们把获得 Todo 列表的工作 dispatch 给了 `store` 对象的 getTodos action。\r\n\r\n```\r\n// main.js\r\nconst store = new Vuex.Store({\r\n  state: {\r\n    todos: [],\r\n    newTodo: { id: null, title: \'\', completed: false }\r\n  },\r\n  mutations: {\r\n    get_todos (state, todos) {\r\n      state.todos = todos\r\n    }\r\n  },\r\n  actions: {\r\n	getTodos (store) {\r\n      Vue.axios.get(\'http://localhost:8000/api/todos\').then((response) => {\r\n        store.commit(\'get_todos\', response.data)\r\n      })\r\n    }\r\n  }\r\n}\r\n```\r\n\r\ngetTodos action 取得 Todo 列表，把结果 `response.data` commit 给了 get_todos mutation； get_todos mutation 接收的第二个参数就是传递过去的 Todo 列表，然后赋值给了 `state.todos`。接下来在 `Todos.vue` 可直接使用 `todos` 变量了。\r\n\r\n## `Todos.vue`\r\n\r\n```\r\n// Todos.vue\r\n<script>\r\nexport default {\r\n  name: \'todos\',\r\n  computed: {\r\n    todos () {\r\n      return this.$store.state.todos\r\n    },\r\n    newTodo () {\r\n      return this.$store.state.newTodo\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n通过 `this.$store.state` 就能取得 `todos` 和 `newTodo`，然后就可以在组件 `<template>` 中直接使用了。\r\n\r\n## 增删改查\r\n\r\n与 Todo 项目增删改查的操作，与实现显示 Todo 列表的流程相似，这里直接贴出代码。共涉及三个文件 `main.js`、`Todos.vue` 和 `App.vue`。\r\n\r\n### `main.js`\r\n\r\n```\r\nimport Vue from \'vue\'\r\nimport axios from \'axios\'\r\nimport VueAxios from \'vue-axios\'\r\nimport Vuex from \'vuex\'\r\nimport App from \'./App\'\r\nimport router from \'./router\'\r\n\r\nVue.use(VueAxios, axios)\r\nVue.use(Vuex)\r\n\r\nVue.config.productionTip = false\r\n\r\nconst store = new Vuex.Store({\r\n  state: {\r\n    todos: [],\r\n    newTodo: { id: null, title: \'\', completed: false }\r\n  },\r\n  mutations: {\r\n    get_todos (state, todos) {\r\n      state.todos = todos\r\n    },\r\n    add_todo (state, todo) {\r\n      state.todos.push(todo)\r\n      state.newTodo.title = \'\'\r\n    },\r\n    delete_todo (state, index) {\r\n      state.todos.splice(index, 1)\r\n    },\r\n    toggle_done (state, todo) {\r\n      todo.completed = !todo.completed\r\n    }\r\n  },\r\n  actions: {\r\n    getTodos (store) {\r\n      Vue.axios.get(\'http://localhost:8000/api/todos\').then((response) => {\r\n        store.commit(\'get_todos\', response.data)\r\n      })\r\n    },\r\n    addTodo (store) {\r\n      if (! store.state.newTodo.title.trim()) { return ; }\r\n      Vue.axios.post(\'http://localhost:8000/api/todos/create\', { \'title\': store.state.newTodo.title })\r\n        .then((response) => {\r\n          store.commit(\'add_todo\', response.data)\r\n        });\r\n    },\r\n    deleteTodo (store, payload) {\r\n      Vue.axios.delete(\'http://localhost:8000/api/todo/\' + payload.todo.id + \'/delete\')\r\n        .then((response) => {\r\n          store.commit(\'delete_todo\', payload.index)\r\n        });\r\n    },\r\n    toggleDone (store, todo) {\r\n      Vue.axios.patch(\'http://localhost:8000/api/todo/\' + todo.id + \'/toggleComplete\')\r\n        .then((response) => {\r\n            store.commit(\'toggle_done\', todo)\r\n        });\r\n    }\r\n  }\r\n})\r\n\r\n/* eslint-disable no-new */\r\nnew Vue({\r\n  el: \'#app\',\r\n  router,\r\n  store,\r\n  template: \'<App/>\',\r\n  components: { App }\r\n})\r\n```\r\n\r\n### `App.vue`\r\n\r\n```\r\n<template>\r\n  <div id=\"app\">\r\n    <router-view></router-view>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \'app\',\r\n  mounted() {\r\n    this.$store.dispatch(\'getTodos\')\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n### `Todos.vue`\r\n\r\n```\r\n<template>\r\n  <div class=\"container\">\r\n    <div class=\"row\">\r\n      <div class=\"col-md-6 col-md-offset-3\">\r\n        <div class=\"panel panel-default\">\r\n          <div class=\"panel-heading text-center\">\r\n              计划要做的事情，共 {{ todos.length }} 件\r\n          </div>\r\n          <div class=\"panel-body\">\r\n            <div class=\"list-groups\">\r\n              <a class=\"list-group-item\" v-bind:class=\"{ \'completed\': todo.completed }\" v-for=\"(todo, index) in todos\">\r\n\r\n                <router-link :to=\"{ name: \'Todo\', params: { id: todo.id }}\">{{ todo.title }}</router-link>\r\n\r\n                <button class=\"btn btn-xs btn-danger pull-right\" v-on:click=\'destroy(todo, index)\'title=\"删除\">✘</button>\r\n                <button class=\"btn btn-xs pull-right\" v-on:click=\'toggleDone(todo)\' v-bind:class=\"[todo.completed ? \'btn-success\': \'\']\" v-bind:title=\"[todo.completed ? \'点击，标记为未完成\': \'点击，标记为已完成\']\">✔</button>\r\n              </a>\r\n            </div>\r\n          </div>\r\n          <div class=\"panel-footer\">\r\n            <form v-on:submit.prevent=\"add\">\r\n              <div class=\"form-group\">\r\n                <input type=\"text\" class=\"form-control text-center\" v-model=\"newTodo.title\">\r\n              </div>\r\n              <button class=\"btn btn-default btn-block\" type=\"submit\">添加</button>\r\n            </form>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \'todos\',\r\n  computed: {\r\n    todos () {\r\n      return this.$store.state.todos\r\n    },\r\n    newTodo () {\r\n      return this.$store.state.newTodo\r\n    }\r\n  },\r\n  methods: {\r\n    add() {\r\n      this.$store.dispatch(\'addTodo\')\r\n    },\r\n    destroy(todo, index) {\r\n      this.$store.dispatch(\'deleteTodo\', { todo, index })\r\n    },\r\n    toggleDone(todo) {\r\n      this.$store.dispatch(\'toggleDone\', todo)\r\n    }\r\n  }\r\n}\r\n</script>\r\n```','2017-07-11 00:38:14','2017-07-11 00:38:14','learning-vue-js-todo-with-vuex-reconstruction-project'),(227,3,3,'ES6：数组解构','在对应位置上赋值：\r\n\r\n```\r\nconst numbers = [\'two\', \'one\', \'three\', \'four\'];\r\n\r\nconst [one, two] = numbers;\r\n\r\nconsole.log(one, two); // two one\r\n```\r\n\r\n```\r\nconst numbers = [\'two\', \'one\', \'three\', \'four\'];\r\n\r\nconst [one, ,two] = numbers;\r\n\r\nconsole.log(one, two); // two three\r\n```\r\n\r\nRest 参数\r\n\r\n```\r\nconst numbers = [\'two\', \'one\', \'three\', \'four\'];\r\n\r\nconst [one, ...others] = numbers;\r\n\r\nconsole.log(one, others); // two [\"one\", \"three\", \"four\"]\r\n```\r\n\r\n默认值\r\n\r\n交换数值\r\n\r\n```\r\nlet a = 10;\r\nlet b = 5;\r\n\r\n[a, b] = [b, a]\r\n\r\nconsole.log(a, b); // 5 10\r\n```','2017-07-11 01:14:43','2017-07-11 01:14:43','es6-an-array-of-deconstruction'),(228,3,3,'ES6：For of 循环','forEach 循环（不能中途结束）\r\n\r\n```\r\nconst numbers = [\'two\', \'one\', \'three\', \'four\'];\r\n\r\nnumbers.forEach(number => {\r\n    console.log(number)\r\n})\r\n\r\n// two one three four\r\n```\r\n\r\nfor in 循环（会遍历数组上的非数字属性）\r\n\r\n```\r\nconst numbers = [\'two\', \'one\', \'three\', \'four\'];\r\n\r\nfor (let index in numbers) {\r\n    console.log(numbers[index])\r\n}\r\n\r\n// two one three four\r\n```\r\n\r\nfor of 循环\r\n\r\n```\r\nconst numbers = [\'two\', \'one\', \'three\', \'four\'];\r\n\r\nfor (let number of numbers) {\r\n   if (number === \'three\') {\r\n       break\r\n   }\r\n    console.log(number)\r\n}\r\n\r\n// two one\r\n```','2017-07-11 01:23:54','2017-07-11 01:23:54','es6-for-of-circulation'),(229,3,3,'一千零一夜：第24夜','我刚才拿起手机想要写，但终究被买水的空想打发了，现在又重新拾起。\r\n\r\n窗户外空调水滴在水里，身在屋里，感觉水是凉的，但不是，外面天气闷热。明天就入伏了。高温会是常态，但也会一直有空调在。我想到阿爸阿妈那里是没有的，我的环境这样好，如果不足够努力就不应该了。\r\n\r\n早晚有一天会有代价的，莫偷闲。\r\n\r\n――\r\n\r\n在凌晨的这时候，停电了，阿姨去处理了。嗯，插座上没有电。这是局部停电，阿姨控制不了。\r\n\r\n我在外面走，顺便买水和看，没看见人修，然而来电了。\r\n\r\n工业时代的一大悲剧可能就是停电了。然而我似乎没有感觉大家的悲哀，都有手头的事情做。','2017-07-11 06:54:11','2017-07-11 08:48:04','one-thousand-nights-24-nights'),(230,3,3,'深入 Eloquent Model find() 源码解读','## 准备\r\n\r\n生成迁移文件\r\n\r\n```\r\n$ php artisan make:model Models/Thread -m\r\n```\r\n\r\n补充迁移表的字段\r\n\r\n```\r\nSchema::create(\'threads\', function (Blueprint $table) {\r\n    $table->increments(\'id\');\r\n    $table->string(\'subject\');\r\n    $table->string(\'slug\')->index();\r\n    $table->text(\'body\');\r\n    $table->unsignedInteger(\'author_id\')->index();\r\n    $table->timestamps();\r\n\r\n    $table->foreign(\'author_id\')\r\n      ->references(\'id\')->on(\'users\')\r\n      ->onDelete(\'cascade\');\r\n});\r\n```\r\n\r\n定义 ThreadFactory.php\r\n\r\n```\r\n<?php\r\n\r\nuse App\\User;\r\nuse App\\Models\\Thread;\r\n\r\n$factory->define(Thread::class, function (Faker\\Generator $faker) {\r\n    return [\r\n        \'subject\' => $faker->text(20),\r\n        \'body\' => $faker->text,\r\n        \'slug\' => $faker->slug,\r\n        \'author_id\' => factory(User::class)->create()->id,\r\n    ];\r\n});\r\n```\r\n\r\n执行迁移\r\n\r\n```\r\n$ php artisan migrate\r\n```\r\n\r\n生成伪数据\r\n\r\n```\r\n$ php artisan tinker\r\n\r\n>>> namespace App;\r\n>>> factory(Models\\Thread::class, 30)->create();\r\n```\r\n\r\n## `Model::find()`\r\n\r\n所有的 Model 都继承自 `Illuminate\\Database\\Eloquent\\Model`。使用 `Thread::find(1)` 能找到 Thread 实例，但 `Model` 中并没有 `find` 方法。\r\n\r\n在 `Model` 中，如果调用了不存在的静态方法，就会调用 `__callStatic($method, $parameters)` 这个魔术方法。\r\n\r\n```\r\npublic static function __callStatic($method, $parameters)\r\n{\r\n	return (new static)->$method(...$parameters);\r\n}\r\n```\r\n\r\n`new static` 相当于 `new Thread`，实例化了一个 `Thread` 对象，在这个实例对象中调用 `find` 方法，但这个实例中并没有 `find` 方法，这时就调用 `__call` 方法了。\r\n\r\n`__call` 方法相当于 `__callStatic` 方法的非静态形式——实例化一个类，直接通过箭头（`->`）的方式调用方法，如果不存在，就会调用这个 `__call` 方法。\r\n\r\n```\r\npublic function __call($method, $parameters)\r\n{\r\n	if (in_array($method, [\'increment\', \'decrement\'])) {\r\n		return $this->$method(...$parameters);\r\n	}\r\n\r\n	return $this->newQuery()->$method(...$parameters);\r\n}\r\n```\r\n\r\n先判断调用的是否是 `increment` 和 `decrement` 其一，如果是，就调用 `Model` 这个父类中的 `increment` 和 `decrement` 方法；如果否，就在一个**新的 Query Builder **上调用方法。\r\n\r\nQuery Builder 创建的过程在 `newQuery` 方法上定义，`newQuery` 方法调用 `newQueryWithoutScopes` 方法，`newQueryWithoutScopes` 方法调用 `newEloquentBuilder` 方法，在 `newEloquentBuilder` 方法内部，创建、返回了 `\\Illuminate\\Database\\Eloquent\\Builder` 实例。\r\n\r\n```\r\npublic function newQuery()\r\n{\r\n	$builder = $this->newQueryWithoutScopes();\r\n\r\n	// 为 Query builder 注册全局的 Scope 方法\r\n	foreach ($this->getGlobalScopes() as $identifier => $scope) {\r\n		$builder->withGlobalScope($identifier, $scope);\r\n	}\r\n\r\n	return $builder;    \r\n}\r\n\r\npublic function newQueryWithoutScopes()\r\n{\r\n	$builder = $this->newEloquentBuilder($this->newBaseQueryBuilder());\r\n\r\n	return $builder->setModel($this)\r\n				->with($this->with)\r\n				->withCount($this->withCount);\r\n}\r\n\r\n/**\r\n * Create a new Eloquent query builder for the model.\r\n *\r\n * @param  \\Illuminate\\Database\\Query\\Builder  $query\r\n * @return \\Illuminate\\Database\\Eloquent\\Builder|static\r\n */\r\npublic function newEloquentBuilder($query)\r\n{\r\n	return new Builder($query);\r\n}\r\n```\r\n\r\n最后相当于在 `\\Illuminate\\Database\\Eloquent\\Builder` 上调用了 `find` 方法。\r\n\r\n```\r\n/**\r\n * Find a model by its primary key.\r\n *\r\n * @param  mixed  $id\r\n * @param  array  $columns\r\n * @return \\Illuminate\\Database\\Eloquent\\Model|\\Illuminate\\Database\\Eloquent\\Collection|static[]|static|null\r\n */\r\npublic function find($id, $columns = [\'*\'])\r\n{\r\n	if (is_array($id) || $id instanceof Arrayable) {\r\n		return $this->findMany($id, $columns);\r\n	}\r\n\r\n	return $this->whereKey($id)->first($columns);\r\n}\r\n\r\npublic function findMany($ids, $columns = [\'*\'])\r\n{\r\n	if (empty($ids)) {\r\n		return $this->model->newCollection();\r\n	}\r\n\r\n	return $this->whereKey($ids)->get($columns);\r\n}\r\n```\r\n\r\n当查询的单个 id，就会直接 `whereKey` 找到、返回第一个结果；否则调用 `findMany` 方法。两个方法最后都是调用了 `whereKey` 方法。\r\n\r\n```\r\npublic function whereKey($id)\r\n{\r\n	if (is_array($id) || $id instanceof Arrayable) {\r\n		$this->query->whereIn($this->model->getQualifiedKeyName(), $id);\r\n\r\n		return $this;\r\n	}\r\n\r\n	return $this->where($this->model->getQualifiedKeyName(), \'=\', $id);\r\n}\r\n```\r\n\r\n`Model` 的 `getQualifiedKeyName` 用来获得主键名，是 `tableName.primatyKey` 的形式。\r\n\r\n```\r\npublic function getQualifiedKeyName()\r\n{\r\n	return $this->getTable().\'.\'.$this->getKeyName();\r\n}\r\n\r\npublic function getTable()\r\n{\r\n	if (! isset($this->table)) {\r\n		return str_replace(\'\\\\\', \'\', Str::snake(Str::plural(class_basename($this))));\r\n	}\r\n\r\n	return $this->table;\r\n}\r\n\r\npublic function getKeyName()\r\n{\r\n	return $this->primaryKey;\r\n}\r\n```','2017-07-11 17:19:02','2017-07-11 18:19:58','further-eloquent-model-the-find-source'),(231,3,3,'Eloquent Builder with 热加载方法源码解读','```\r\nUser::with(\'threads\')->all();\r\n```\r\n\r\n`Illuminate\\Database\\Eloquent\\Builder` 的 `with` 方法：\r\n\r\n```\r\n/**\r\n * Set the relationships that should be eager loaded.\r\n *\r\n * @param  mixed  $relations\r\n * @return $this\r\n */\r\npublic function with($relations)\r\n{\r\n	$eagerLoad = $this->parseWithRelations(is_string($relations) ? func_get_args() : $relations);\r\n\r\n	$this->eagerLoad = array_merge($this->eagerLoad, $eagerLoad);\r\n\r\n	return $this;\r\n}\r\n```\r\n\r\n这里 `$relations` 就是 `\'threads\'`。调用 `parseWithRelations` 方法\r\n\r\n```\r\nprotected function parseWithRelations(array $relations)\r\n{\r\n	$results = [];\r\n\r\n	foreach ($relations as $name => $constraints) {\r\n		// If the \"relation\" value is actually a numeric key, we can assume that no\r\n		// constraints have been specified for the eager load and we\'ll just put\r\n		// an empty Closure with the loader so that we can treat all the same.\r\n		if (is_numeric($name)) {\r\n			$name = $constraints;\r\n\r\n			list($name, $constraints) = Str::contains($name, \':\')\r\n						? $this->createSelectWithConstraint($name)\r\n						: [$name, function () {\r\n							//\r\n						}];\r\n		}\r\n\r\n		// We need to separate out any nested includes. Which allows the developers\r\n		// to load deep relationships using \"dots\" without stating each level of\r\n		// the relationship with its own key in the array of eager load names.\r\n		$results = $this->addNestedWiths($name, $results);\r\n\r\n		$results[$name] = $constraints;\r\n	}\r\n\r\n	return $results;\r\n}\r\n```\r\n\r\n`$results[$name] = $constraints;` 中就有 \r\n\r\n```\r\n$results[\'threads\'] = function () {\r\n\r\n}\r\n```\r\n\r\n返回一个 Query Builder 之后，就开始 `get` 了——组合、查询 `select` 语句。\r\n\r\n```\r\n/**\r\n * Execute the query as a \"select\" statement.\r\n *\r\n * @param  array  $columns\r\n * @return \\Illuminate\\Database\\Eloquent\\Collection|static[]\r\n */\r\npublic function get($columns = [\'*\'])\r\n{\r\n	$builder = $this->applyScopes();\r\n\r\n	// If we actually found models we will also eager load any relationships that\r\n	// have been specified as needing to be eager loaded, which will solve the\r\n	// n+1 query issue for the developers to avoid running a lot of queries.\r\n	if (count($models = $builder->getModels($columns)) > 0) {\r\n		$models = $builder->eagerLoadRelations($models);\r\n	}\r\n\r\n	return $builder->getModel()->newCollection($models);\r\n}\r\n\r\n/**\r\n * Get the hydrated models without eager loading.\r\n *\r\n * @param  array  $columns\r\n * @return \\Illuminate\\Database\\Eloquent\\Model[]\r\n */\r\npublic function getModels($columns = [\'*\'])\r\n{\r\n	return $this->model->hydrate(\r\n		$this->query->get($columns)->all()\r\n	)->all();\r\n}\r\n```\r\n\r\n这里 `getModels` 就是指先找到 User Models，过程如下：`$this->query->get($columns)->all()` 得到是一个纯字段数组，`hydrate` 就把这些纯数组里的每个元素都转换成 User Model 实例。\r\n\r\n取得 User Model 实例后，且 count 大于 0，就使用 `eagerLoadRelations` 方法处理 conatrinct closure 了，直接忽略用 `.`  的热加载，加载当前的 `threads`。\r\n\r\n```\r\npublic function eagerLoadRelations(array $models)\r\n{\r\n	foreach ($this->eagerLoad as $name => $constraints) {\r\n		// For nested eager loads we\'ll skip loading them here and they will be set as an\r\n		// eager load on the query to retrieve the relation so that they will be eager\r\n		// loaded on that query, because that is where they get hydrated as models.\r\n		if (strpos($name, \'.\') === false) {\r\n			$models = $this->eagerLoadRelation($models, $name, $constraints);\r\n		}\r\n	}\r\n\r\n	return $models;\r\n}\r\n\r\n protected function eagerLoadRelation(array $models, $name, Closure $constraints)\r\n{\r\n	// First we will \"back up\" the existing where conditions on the query so we can\r\n	// add our eager constraints. Then we will merge the wheres that were on the\r\n	// query back to it in order that any where conditions might be specified.\r\n	$relation = $this->getRelation($name);\r\n\r\n	$relation->addEagerConstraints($models);\r\n\r\n	$constraints($relation);\r\n\r\n	// Once we have the results, we just match those back up to their parent models\r\n	// using the relationship instance. Then we just return the finished arrays\r\n	// of models which have been eagerly hydrated and are readied for return.\r\n	return $relation->match(\r\n		$relation->initRelation($models, $name),\r\n		$relation->getEager(), $name\r\n	);\r\n}\r\n```\r\n\r\n`eagerLoadRelation` 方法里把 User Models 和 Threads 进行匹配了。','2017-07-11 19:28:51','2017-07-11 19:39:36','eloquent-builder-with-heat-load-method-source-code'),(232,3,3,'如何在 make:auth 之后将登录方式改为用户名登录？','非常简单，修改两处就可以了。\r\n\r\n## 第一处\r\n\r\n在 `LoginController` 中添加\r\n\r\n```\r\npublic function username()\r\n{\r\n	return \'name\';\r\n}\r\n```\r\n\r\n`\'name\'` 对应 `users` 表的 `name` 字段，默认是 `\'email\'`。\r\n\r\n## 第二处\r\n\r\n修改 `auth/login.blade.php`\r\n\r\n```\r\n<div class=\"form-group{{ $errors->has(\'email\') ? \' has-error\' : \'\' }}\">\r\n	<label for=\"email\" class=\"col-md-4 control-label\">E-Mail Address</label>\r\n\r\n	<div class=\"col-md-6\">\r\n		<input id=\"email\" type=\"email\" class=\"form-control\" name=\"email\" value=\"{{ old(\'email\') }}\" required autofocus>\r\n\r\n		@if ($errors->has(\'email\'))\r\n			<span class=\"help-block\">\r\n				<strong>{{ $errors->first(\'email\') }}</strong>\r\n			</span>\r\n		@endif\r\n	</div>\r\n</div>\r\n```\r\n\r\n改为\r\n\r\n```\r\n<div class=\"form-group{{ $errors->has(\'name\') ? \' has-error\' : \'\' }}\">\r\n	<label for=\"name\" class=\"col-md-4 control-label\">Name</label>\r\n\r\n	<div class=\"col-md-6\">\r\n		<input id=\"name\" type=\"text\" class=\"form-control\" name=\"name\" value=\"{{ old(\'name\') }}\" required autofocus>\r\n\r\n		@if ($errors->has(\'name\'))\r\n			<span class=\"help-block\">\r\n				<strong>{{ $errors->first(\'name\') }}</strong>\r\n			</span>\r\n		@endif\r\n	</div>\r\n</div>\r\n```\r\n\r\n即可。','2017-07-11 20:54:59','2017-07-11 21:02:42','how-to-make-change-the-way-of-login-to-the-user-name-login-after-auth'),(233,3,3,'去掉 Laravel 项目中引入的 Raleway 字体','Laravel 项目中引入 Raleway 字体的地方有两处：\r\n\r\n1. `public/css/app.css`\r\n\r\n```\r\n@import url(https://fonts.googleapis.com/css?family=Raleway:300,400,600);@charset \"UTF-8\"; ...\r\n```\r\n\r\n2. `resources/assets/sass/app.scss`\r\n\r\n```\r\n// Fonts\r\n@import url(\"https://fonts.googleapis.com/css?family=Raleway:300,400,600\");\r\n\r\n// Variables\r\n@import \"variables\";\r\n\r\n// Bootstrap\r\n@import \"node_modules/bootstrap-sass/assets/stylesheets/bootstrap\";\r\n```\r\n\r\n把这两处中引入 Raleway 的地方删掉即可。\r\n\r\n你可能要问，为什么要删？\r\n\r\n答案是因为一个众所周知的原因，google 字体的加载可能非常缓慢，导致页面长时间处于空白、无响应状态。','2017-07-11 21:11:02','2017-07-11 21:11:02','remove-laravel-project-introduced-in-raleway-fonts'),(234,3,3,'模仿百度搜索的分页样式','## 使用\r\n\r\n[这里](https://codepen.io/zhangbao/full/awPqGp/) 有最终的分页效果。\r\n\r\n### HTML\r\n\r\n```\r\n<div class=\"page\">\r\n	<a href=\"#\" class=\"prev\">上一页</a>\r\n	<a href=\"#\">1</a>\r\n	<a href=\"#\">2</a>\r\n	<a href=\"#\" class=\"active\">3</a>\r\n	<a href=\"#\">4</a>\r\n	<a href=\"#\">5</a>\r\n	<a href=\"#\">6</a>\r\n	<a href=\"#\">7</a>\r\n	<a href=\"#\">8</a>\r\n	<a href=\"#\">9</a>\r\n	<a href=\"#\">10</a>\r\n	<a href=\"#\" class=\"next\">下一页</a>\r\n</div>\r\n```\r\n\r\n### CSS\r\n\r\n```\r\n.page {\r\n	width: 635px;\r\n	height: 36px;\r\n	font-size: 0;\r\n}\r\n\r\n.page > a {\r\n	display: inline-block;\r\n	font: 12px/34px \"microsoft yahei\";\r\n	width: 34px;\r\n	height: 34px;\r\n	border: 1px solid #e1e2e3;\r\n	text-align: center;\r\n	text-decoration: none;\r\n}\r\n\r\n.page > .prev, .page > .next {\r\n	width: 86px;\r\n}\r\n\r\n.page > a:not(:first-child) {\r\n	margin-left: 9px;\r\n}\r\n\r\n.page > a:hover, .page > a.active {\r\n	border-color: #3388ff;\r\n	background-color: #f2f8ff;\r\n}\r\n```\r\n\r\n## 实现过程\r\n\r\n1. 一共有 12 个项目，长宽分别是 `635px` 和 `36px`。\r\n\r\n```\r\n.page {\r\n	width: 635px;\r\n	height: 36px;\r\n}\r\n```\r\n\r\n2. 每个项目都有 1 像素的灰色边框。\r\n\r\n```\r\n.page > a {\r\n	border: 1px solid #e1e2e3;\r\n}\r\n```\r\n\r\n3. 「上一页」文字 size 是 `12px`，行高设置为边框内的高度 `34px`，字体「微软雅黑」。\r\n\r\n```\r\n.page > a {\r\n	font: 12px/34px \"microsoft yahei\";\r\n	border: 1px solid #e1e2e3;\r\n}\r\n```\r\n\r\n4. 设置页码文字垂直居中显示（`height` 的 `line-height` 一样大）。\r\n\r\n```\r\n.page > a {\r\n	display: inline-block;\r\n	width: 34px;\r\n	height: 34px;\r\n	font: 12px/34px \"microsoft yahei\";\r\n	border: 1px solid #e1e2e3;\r\n}\r\n```\r\n\r\n5. 文字居中、且无下划线。\r\n\r\n```\r\n.page > a {\r\n	display: inline-block;\r\n	width: 34px;\r\n	height: 34px;\r\n	font: 12px/34px \"microsoft yahei\";\r\n	border: 1px solid #e1e2e3;\r\n	text-align: center;\r\n	text-decoration: none;\r\n}\r\n```\r\n\r\n6. 「上一页」和「下一页」的宽度是 `86px`。\r\n\r\n```\r\n.page > .prev, .page > .next {\r\n	width: 86px;\r\n}\r\n```\r\n\r\n7. 每个项目之间有 `9px` 的空白（这里需要将父元素 `font-size` 先设置为 `0`，因为折行的行内元素之间默认会有 `0.5em` 的宽度间隔）。\r\n\r\n```\r\n.page {\r\n	width: 635px;\r\n	height: 36px;\r\n	font-size: 0;\r\n}\r\n\r\n.page > a:not(:first-child) {\r\n	margin-left: 9px;\r\n}\r\n```\r\n\r\n8. 项目在 hover、激活状态下（`.active`）有样式\r\n\r\n```\r\n.page > a:hover, .page > a.active {\r\n	border-color: #3388ff;\r\n	background-color: #f2f8ff;\r\n}\r\n```','2017-07-12 00:44:54','2017-07-12 00:44:54','imitation-baidu-search-page-style'),(235,3,3,'一千零一夜：第27夜','下午下了挺大的雨，下班后出来发现跟没下雨似的。\r\n\r\n---\r\n\r\n我想到，大师级人物之所以有这样的成就，是因为有自我，足够的自我，这才能表现他们的特异，与众不同的地方，也可以理解是偏执一种。\r\n\r\n我变得的非常讨厌游戏，它太容易让人入迷，入迷成本太低。当大家都在讨论游戏、玩游戏的时候，生活是如此单一和没有热望，如此一样，没有特异、哪怕个性的一点。\r\n\r\n熬夜变得普遍，然而也并没有增添更多的意义，只有远远的空洞和无聊。也许追求意义这件事本身都是没有丝毫意义的一件事情，它只源于人类空想，是人哄骗自己能活下去的理由。\r\n\r\n生活本身就是无意义的，你去问那流浪猫、那棵草，问它们哪怕生存的意义，它们也不会说的。有什么说得呢？\r\n\r\n生存而已。老鼠跳海是本能，是为了种群发展，如果这样看，人类并不大义凌然，否则就没有七十亿，多出来的蛋白质，来源自地球矿物质和元素。也许真的是这样，道德、教义和一切概念性的东西都是枷锁，是负重，我们懵懂无知，盲目前行。\r\n\r\n采集时代的力气兑换为思想的巨人，行动的矮子。','2017-07-14 07:29:19','2017-07-14 07:29:19','one-thousand-nights-the-night-of-the-27th'),(236,3,3,'ES6：Array.from 和 Array.of','## `Array.from()` \r\n\r\n将类数组对象转换为数组。\r\n\r\n```\r\n// NodeList -> 数组\r\nlet lis = document.querySelectorAll(\'li\');\r\n\r\nArray.from(lis, li => {\r\n	console.log(li.textContent);\r\n}); // 1 2 3\r\n\r\n// arguments -> 数组\r\nfunction sum() {\r\n	return Array.from(arguments).reduce((prev, next) => prev + next, 0);\r\n}	\r\n\r\nlet ret = sum(1, 2, 3, 4, 5, 6, 7);\r\nconsole.log(ret); // 28\r\n\r\n// 字符串 -> 数组\r\nlet str = \'Hello World!\';\r\nlet strArr = Array.from(str);\r\nconsole.log(strArr); // [\"H\", \"e\", \"l\", \"l\", \"o\", \" \", \"W\", \"o\", \"r\", \"l\", \"d\", \"!\"]\r\n```\r\n\r\n## `Array.of()`\r\n\r\n返回由参数组成的数组，为了弥补 `Array` 构造函数行为的不一致。\r\n\r\n```\r\nlet ret = Array.of(1, 2, 3, 3, [23, 4, \'sd\']);\r\nconsole.log(ret); // [1, 2, 3, 3, Array(3)]\r\n```','2017-07-14 23:48:09','2017-07-14 23:48:09','es6-array-the-from-and-array-of'),(237,3,3,'永远年轻，永远热泪盈眶','「永远年轻，永远热泪盈眶」这句话出自《The Dharm Bums》这本书，中文译名《达摩流浪者》，作者是美国作家Jack Kerouac，美国垮掉一代的代表人物，以下摘自原文：\r\n\r\n\"Japhy,\" I said out loud, I don\'t know when we\'ll meet again or what\'ll happen in the future, but Desolation, Desolation, I owe so much to Desolation. Thank you for guiding me to the place I learned all. Now comes the sadness of coming back to cities and I\'ve grown two months older and there\'s all that humanity of bars and burlesque shows and gritty love, all upsidedown in the void God bless them, but Japhy you and me forever know, **O ever youthful, O ever weeping**.\"','2017-07-15 01:55:51','2017-11-08 06:49:11','forever-young-forever-hot-tears'),(465,3,3,'对《诗经》里诗歌的个性理解','1. [摽有梅][1]\r\n\r\n愉快不是因为劳动，而是因为劳动中的调情。\r\n\r\n2. [殷其雷][2]\r\n\r\n走吧、走吧，人生难免经历苦痛挣扎。 - 《爱的代价》\r\n\r\n[1]: http://www.baooab.com/wp/2017/11/%e5%9b%bd%e9%a3%8e%c2%b7%e5%8f%ac%e5%8d%97%c2%b7%e6%91%bd%e6%9c%89%e6%a2%85/\r\n[2]: http://www.baooab.com/wp/2017/11/%e5%9b%bd%e9%a3%8e%c2%b7%e5%8f%ac%e5%8d%97%c2%b7%e6%ae%b7%e5%85%b6%e9%9b%b7/','2017-11-09 01:47:57','2017-11-09 01:50:24','to-understand-poetry-character-in-the-book-of-songs'),(238,7,7,'Python-mysql-pymysql','```\r\n#!/usr/bin/python3\r\nimport  pymysql\r\n\r\n# 打开数据库连接\r\ndb = pymysql.connect(\"192.168.159.128\",\"root\",\"Abcdef1234\",\"news\" )\r\n\r\n# 使用 cursor() 方法创建一个游标对象 cursor\r\ncursor = db.cursor()\r\n\r\n# SQL 查询语句\r\nsql = \"SELECT * FROM news;\"\r\n\r\n# 使用 execute()  方法执行 SQL 查询\r\ncursor.execute(sql)\r\n\r\n# 执行sql语句\r\ndb.commit()\r\n\r\n# 使用 fetchone() 方法获取单条数据.\r\ndata = cursor.fetchall()\r\n\r\nprint ( data)\r\n\r\n# 关闭数据库连接\r\ndb.close()\r\n```','2017-07-16 18:52:01','2017-08-09 08:44:25','python-mysql-pymysql'),(239,3,3,'删菜单','```\r\nALTER TABLE [dbo].[Sys_Menu] nocheck constraint FK_Menu_Menu\r\nGO\r\n\r\ndelete from [dbo].[Sys_Menu] where MenuID in (\r\nN\'9d373f54-988f-4678-8190-ec07f2c33f77\', \r\nN\'c01163e2-bf82-4418-90b6-047c4c19d866\',\r\nN\'d8ef3c59-cfbd-432c-8dd1-5a1bc0af963f\',\r\nN\'992f8654-2aff-4f9b-9a00-1de764eeb7fe\', \r\nN\'a4beb607-2984-4896-b693-6707c47e0aa4\',\r\nN\'9d547932-a75a-4ec3-8953-3f179797f384\',\r\nN\'bb346c67-da09-49a8-8d9c-2d1a28a486c9\', \r\nN\'ac1eff0d-ff17-4153-bd45-5b995be6aa00\',\r\nN\'b7bcd055-c748-4ece-9840-61d855366cde\',\r\nN\'38840e30-1aa8-4841-9db1-d09fb6887708\', \r\nN\'f229c189-4147-4139-aaf3-feef4c89caac\',\r\nN\'fe8f58a1-c4ea-4cb0-a196-98a2fad94623\',\r\nN\'c514dde7-da5e-434b-8a29-c33a2e77a85b\', \r\nN\'32188259-9bf7-494c-a273-d4c11e1f975c\',\r\nN\'c0b52327-902d-4829-b8d3-6c4d8c8390ca\',\r\nN\'4b2ae544-bf09-4c91-beda-a82c74233a32\', \r\nN\'ed75923b-1586-42f7-b0e4-99e6bbcf2c98\',\r\nN\'4257dbe6-2afb-462d-aa1d-496f09454ae5\',\r\nN\'46ff6b2e-6ba6-470f-9bb1-73e8e7501ed1\', \r\nN\'3743b79c-de61-4548-9ac7-f1a989cb9c6d\',\r\nN\'8da139ba-eb91-43d2-af64-3cb642c4d78c\',\r\nN\'53eb0b35-0748-435c-8eb8-bfb2b444c394\',\r\nN\'ff05aec7-114b-4c55-9cad-54605d9ba4f7\');\r\n\r\n\r\nALTER TABLE [dbo].[Sys_Menu] check constraint FK_Menu_Menu\r\ngo \r\n```','2017-07-19 00:58:55','2017-07-19 00:58:55','delete-menu'),(240,3,3,'这一夜','这一夜又停电了，如果不是因为停电，我也不会写这些。我是应该庆幸吗？狗日的。\r\n\r\n上海是个不夜城，南京东路地上有水，并没有下雨――总是有些事情在你不知道的地方发生。要睡觉的人多少会有点不明白这么晚，还走在路上的人。\r\n\r\n知了也没叫了，可能是累了，要歇歇。我的表达理论上应该被废弃了的，我感觉我总像是没有思想的劳碌鬼。','2017-07-22 07:56:39','2017-07-22 07:56:39','this-night'),(241,8,8,'翻转字符串','# 翻转字符串\r\n### 题目描述： \r\n\r\n#### 先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串。\r\n\r\n\r\n-----\r\n\r\n    function reverseString(str) {\r\n\r\n    return str.split(\'\').reverse().join(\'\');\r\n    }\r\n\r\n    reverseString(\"hello\");\r\n	\r\n\r\n-----\r\n\r\n\r\n### 思路： \r\n**实现该函数还是很容易的，只需要我们按照题目的要求逐步进行即可达到。 **\r\n1. split() 方法是将一个String对象分割成字符串数组，使用指定的分隔符将一个字符串分割成一个字符串数组。 \r\n2. reverse() 方法颠倒数组中元素的位置。第一个元素会成为最后一个，最后一个会成为第一个。 \r\n3. join() 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中，该方法并不会改变原来的数组。\r\n \r\n>      简单的来实现就是用str.split(’ ‘)按空格分割字符串，arr.reverse()来翻转数组，最后用arr.join(’ ‘)连接成字符串。','2017-07-24 22:17:03','2017-07-24 22:17:03','flip-the-string'),(242,3,3,'修改 Apache 最大文件上传大小，解决超过了站点的最大上传限制问题','我使用 Ubuntu 16.04 的系统。安装了 PHP7.0 和 Apache 架设网站。\r\n\r\n使用 HTTP 上传媒体图片时，报错说「xxx超过了站点的最大上传限制」，这是因为默认 Apache 上传文件大小限制在 2M。\r\n\r\n问题找到后，就可以修改了。\r\n\r\n编辑文件 `/etc/php/7.0/apache2/php.ini`。\r\n\r\n```\r\n; Temporary directory for HTTP uploaded files (will use system default if not\r\n; specified).\r\n; http://php.net/upload-tmp-dir\r\n;upload_tmp_dir =\r\n\r\n; Maximum allowed size for uploaded files.\r\n; http://php.net/upload-max-filesize\r\nupload_max_filesize = 2M\r\n\r\n; 修改为\r\nupload_max_filesize = 6M\r\n```\r\n\r\n然后重启服务器\r\n\r\n```\r\n# /etc/init.d/apache2 restart\r\n```\r\n\r\n即可。','2017-08-08 06:00:06','2017-08-08 06:07:55','modify-the-apache-maximum-file-upload-size-solve-the-problem-of-the-maximum-upload-restrictions-over-site'),(243,3,3,'当 Window 10 遇到了 Laravel Homestead，storage:link 命令出现问题','今天，我在 `C:\\Code\\SalivaForum` 中执行了 `storage:link ` Artisan 命令，使用 `salivaforum.app` 地址浏览时，发现虚拟机里 `public/storage` 里的图片访问不到，原来从我的宿主 Window 10 系统里同步过去的软连接是无效的。\r\n\r\n这是 `storage:link ` Artisan 命令的一个 BUG。\r\n\r\n我在网上找到了一个[解决办法][1]：在项目根目录（也就是 `C:\\Code\\SalivaForum`）下打开 Git Bash。执行\r\n\r\n```\r\n$ ln -sr storage/app/public public/storage\r\n```\r\n\r\n手动创建软连接即可。\r\n\r\n这条命令表示在 `public` 目录下创建一个软连接 `storage`，它指向目录 `storage/app/public`。\r\n\r\n[1]: https://laracasts.com/discuss/channels/servers/creating-symbolic-link-on-homestead','2017-08-08 06:25:28','2017-08-08 06:26:26','when-the-window-10-met-laravel-favored-storage-the-link-command'),(244,3,3,'在 Ubuntu 16.04 系统中为 Laravel 准备 PHP 环境。','安装 PHP 时，除了像 [这里][1] 说的\r\n\r\n```\r\n$ sudo apt-get install php libapache2-mod-php php-mcrypt php-mysql\r\n```\r\n\r\n此外，又因为 Laravel 5.4 依赖 Mbstring 扩展和 XML 扩展，还要再安装。\r\n\r\n```\r\n$ sudo apt-get install php-mbstring php-xml\r\n```\r\n\r\n而 OpenSSL、PDO 、Tokenizer 扩展似乎在 `php7.0-common` 已经包含了，不需要安装了。\r\n\r\n[1]: https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-16-04#step-3-install-php','2017-08-08 06:35:40','2017-08-08 06:37:19','in-ubuntu-1604-system-for-laravel-php-environment'),(245,3,3,'在 Windows 10 中使用 WinSCP 与 Ubuntu 系统交互，上传、下载文件','[WinSCP][1] 使用 SFTP 文件协议连接服务器。就不需要在服务器端安装什么 [SecureCRT][2] `rz`、`sz` 了。\r\n\r\n[1]: http://cn.bing.com/search?q=winscp\r\n[2]: http://www.baooab.com/forum/discussion/used-in-linux-securecrt-upload-and-download-file-command-sz-and-rz-usage-examples','2017-08-08 06:49:20','2017-08-08 06:49:20','used-in-windows-10-winscp-interact-with-ubuntu-upload-and-download-files'),(246,3,3,'在域名子目录中安装 Laravel 项目，要注意隐藏 .env 文件','## 一、为什么\r\n\r\n如果你把 Laravel 项目放在一个域名子目录中，你可能就要这样访问了。\r\n\r\n```\r\nsite.com/subfolder/public/\r\n```\r\n\r\n因为项目的入口文件是 `public` 下的 `index.php`。但这有一个问题，设想有人访问了下面的路径：\r\n\r\n```\r\nsite.com/subfolder/.env\r\n```\r\n\r\n你可能就懵逼了，你暴露了大量的敏感数据。所以如果是作为域名子目录存在的 Laravel 项目，务必要隐藏好 `.env` 文件。\r\n\r\n## 二、怎么隐\r\n\r\n**原料**：我有一台 Ubuntu 16.04 服务器，安装了 Apache 服务器，网站根目录位于 `/var/www/html`；一个 Laravel 项目；一个域名 `site.com`。\r\n\r\n**预期**：我用地址 `site.com/forum` 访问到我的项目，而且不暴露 `.env` 文件。\r\n\r\n### 第一步\r\n\r\n将 Laravel 项目放在 `/var/www/SalivaForum` 目录下。\r\n\r\n```\r\nwww\r\n  |\r\n  |-- SalivaForum\r\n	 |-- app 	<DIR> \r\n	 |-- bootstrap  <DIR>\r\n	 |-- config 	<DIR>   \r\n	 |-- database 	<DIR>          \r\n	 |-- **public** 	<DIR>          \r\n	 |-- resources 	<DIR>          \r\n	 |-- routes 	<DIR>          \r\n	 |-- storage 	<DIR>           \r\n	 |-- tests 	<DIR>          \r\n	 |-- vendor 	<DIR>          \r\n	 |-- .env\r\n	 |-- .env.example\r\n	 |-- .gitattributes\r\n	 |-- .gitignore\r\n	 |-- artisan\r\n	 |-- composer.json\r\n	 |-- composer.lock\r\n	 |-- gulpfile.js\r\n	 |-- package.json\r\n	 |-- phpunit.xml\r\n	 |-- readme.md\r\n	 |-- server.php\r\n```\r\n\r\n### 第二步\r\n\r\n将 `public` 重命名为 `forum`，移动到 `/var/www/html/forum`。\r\n\r\n```\r\n# mv /var/www/SalivaForum/public/ /var/www/SalivaForum/forum/\r\n# mv /var/www/SalivaForum/forum/ /var/www/html/\r\n```\r\n\r\n### 第三步\r\n\r\n这时，为了能正常启动 Laravel 应用，要修改 `/var/www/html/forum/index.php` 文件中的两处。\r\n\r\n```\r\nrequire __DIR__.\'/../bootstrap/autoload.php\';\r\n$app = require_once __DIR__.\'/../bootstrap/app.php\';\r\n\r\n// 修改为\r\nrequire __DIR__.\'/../../SalivaForum/bootstrap/autoload.php\';\r\n$app = require_once __DIR__.\'/../../SalivaForum/bootstrap/app.php\';\r\n```\r\n\r\n### 第四步\r\n\r\n为了让网站上传的图片能顺利访问到，还要手动创建一个软连接。\r\n\r\n```\r\n#  ln -sr /var/www/SalivaForum/storage/app/public/ /var/www/html/forum/storage \r\n```\r\n\r\n这条命令表示在 `forum` 目录下创建一个软连接 `storage`，它指向目录 `storage/app/public`。\r\n\r\n结束。\r\n\r\n这时，你的项目既可以正常访问，也可以很好的隐藏 `.env` 文件里的敏感数据。\r\n\r\n## 参考链接\r\n\r\n1. https://laravel-news.com/subfolder-install\r\n2. http://www.opentechguides.com/how-to/article/php/116/laravel-remove-public.html','2017-08-08 08:08:10','2017-08-08 08:14:44','in-the-domain-name-subdirectories-laravel-project-installation-pay-attention-to-the-hidden-env-file'),(247,3,3,'在 Ubuntu 16.04 系统中安装 LAMP 环境','## 安装 MySQL\r\n\r\n```\r\n# apt-get install mysql-server-5.7\r\n```\r\n\r\n## 安装 Apache\r\n\r\n1. 安装软件\r\n\r\n```\r\n# apt-get install apache2\r\n```\r\n\r\n2. 编辑配置文件\r\n\r\n编辑 apache2 的 `apache2.conf` 文件。\r\n\r\n```\r\n# vim /etc/apache2/apache2.conf\r\n```\r\n\r\n允许 `.htaccess` 文件重写。\r\n\r\n```\r\n<Directory /var/www/>\r\n	Options Indexes FollowSymLinks\r\n	AllowOverride All\r\n	Require all granted\r\n</Directory>\r\n```\r\n\r\n在文件最后添加服务器域名或 IP。\r\n\r\n```\r\nServerName server_domain_or_IP\r\n```\r\n\r\n3. 检查配置文件是否有拼写错误\r\n\r\n```\r\n# apache2ctl configtest\r\nSyntax OK\r\n```\r\n\r\n4. 重启 Apache\r\n\r\n```\r\n# /etc/init.d/apache2 restart\r\n```\r\n\r\n5. 在阿里云安全组开启 80 端口。\r\n\r\n## 安装 PHP\r\n\r\n```\r\n# apt-get install php libapache2-mod-php php-mcrypt php-mysql php-mbstring php-xml\r\n```\r\n\r\n重启 Apache 服务。\r\n\r\n```\r\n# /etc/init.d/apache2 restart\r\n```','2017-08-08 08:28:33','2017-08-08 08:28:33','in-ubuntu-1604-lamp-installed-in-the-system-environment'),(248,3,3,'CSS 中的伪元素和伪类','## 伪元素\r\n\r\n伪元素用于处理元素的子部分，用双冒号（`::`）修饰。常见的有：\r\n\r\n* `::after`\r\n* `::before`\r\n* `::first-letter`\r\n* `::first-line`\r\n* `::selection`\r\n\r\n## 伪类\r\n\r\n伪类是元素名、元素属性或元素内容以外的特征，作用在元素身上，用单冒号（`:`）修饰。常见的有：\r\n\r\n* `:link`\r\n* `:visited`\r\n* `:hover`\r\n* `:active`\r\n* `:nth-child`\r\n* `:first-child`\r\n* `:last-child`\r\n* `:nth-of-type`\r\n* `:nth-first-of-type`\r\n* `:nth-last-of-type`\r\n\r\n伪类通常是动态的，这意味着用户在与文档交互的时候元素可以获取或丢失伪类。','2017-08-09 05:24:12','2017-08-09 05:48:52','the-css-pseudo-element-and-the-pseudo-class'),(249,7,7,'Pyhton-redis','## String\r\n    set  -- 设置值\r\n    get -- 获取值\r\n    mset  -- 设置多个键值对\r\n    mget  -- 获取多个键值对\r\n    append -- 添加字符串\r\n    del -- 删除\r\n    incr/decr   -- 增加/减少 1\r\n\r\n```\r\nimport redis\r\nclass TestString(object):\r\n	def __init__(self):\r\n        self.r = redis.StrictRedis(host=\'localhost\', port=6379, db=0)\r\n	def test_set(self):\r\n		 \'\'\' set  -- 设置值 \'\'\'\r\n        rest = self.r.set(\'user2\', \'Amy\')\r\n        print(rest)\r\n        return rest\r\n	    def test_get(self):\r\n        \'\'\' get -- 获取值 \'\'\'\r\n        rest = self.r.get(\'user3\')\r\n        print(rest)\r\n        return rest\r\n\r\n    def test_mset(self):\r\n        \'\'\'  mset  -- 设置多个键值对 \'\'\'\r\n        d = {\r\n            \'user3\': \'Bob\',\r\n            \'user4\': \'Bobx\'\r\n        }\r\n        rest = self.r.mset(d)\r\n        print(rest)\r\n        return rest\r\n\r\n    def test_mget(self):\r\n        \'\'\' mget  -- 获取多个键值对 \'\'\'\r\n        l = [\'user3\', \'user4\']\r\n        rest = self.r.mget(l)\r\n        print(rest)\r\n        return rest\r\n\r\n    def test_del(self):\r\n        \'\'\' del --删除数据\'\'\'\r\n        rest = self.r.delete(\'user3\')\r\n        print(rest)\r\n```\r\n\r\n## List\r\n    lpush/rpush  -- 从左/右插入数据\r\n    lrange -- 获取指定长度的数据\r\n    ltrim -- 截取一定长度的数据\r\n    lpop/rpop --移除最左/右的元素并返回\r\n    lpushx/rpushx -- key存在的时候才插入数据，不存在时不做任何处理\r\n	\r\n```\r\nimport redis\r\nclass TestList(object):\r\n    def __init__(self):\r\n        self.r = redis.Redis(host=\'localhost\', port=6379, db=0)\r\n\r\n    def test_push(self):\r\n        \'\'\' lpush/rpush  -- 从左/右插入数据 \'\'\'\r\n        t = [\'Amy\', \'Jhon\']\r\n        rest = self.r.lpush(\'l_eat3\', *t)\r\n        print(rest)\r\n        rest = self.r.lrange(\'l_eat3\', 0, -1)\r\n        print(rest)\r\n\r\n    def test_pop(self):\r\n        \'\'\' lpop/rpop --移除最左/右的元素并返回 \'\'\'\r\n        rest = self.r.lpop(\'l_eat3\')\r\n        print(rest)\r\n        rest = self.r.lrange(\'l_eat3\', 0, -1)\r\n        print(rest)\r\n```\r\n\r\n## Set\r\n	sadd/srem -- 添加/删除元素\r\n    sismember --判断是否为set的一个元素\r\n    smembers --返回该集合的所有成员\r\n    sdiff -- 返回一个集合与其它集合的差异\r\n    sinter  -- 返回几个集合的交集\r\n    sunion -- 返回几个集合的并集\r\n	\r\n```\r\nimport redis\r\n	class TestSet(Base):\r\n		 def test_sadd(self):\r\n        \'\'\' sadd -- 添加元素 \'\'\'\r\n        l = [\'Cat\', \'Dog\']\r\n        rest = self.r.sadd(\'zoo3\', *l)\r\n        print(rest)\r\n        rest = self.r.smembers(\'zoo3\')\r\n        print(rest)\r\n\r\n\r\n    def test_srem(self):\r\n        \'\'\' srem -- 删除元素 \'\'\'\r\n        rest = self.r.srem(\'zoo2\', \'Dog\')\r\n        print(rest)\r\n        rest = self.r.smembers(\'zoo2\')\r\n        print(rest)\r\n\r\n    def test_sinter(self):\r\n        \'\'\'sinter  -- 返回几个集合的交集  \'\'\'\r\n        rest = self.r.sunion(\'zoo2\', \'zoo3\')\r\n        print(rest)\r\n```\r\n\r\n## Hash\r\n	 hset/hget --设置/获取散列值\r\n    hmset/hmget -- 设置/获取多对散列值\r\n    hsetnx -- 如果散列已经存在，则不设置\r\n    hkeys/hvals -- 返回所有Keys/Values\r\n    hlen -- 返回散列包含域（field）的数量\r\n    hdel -- 删除散列指定的域（field）\r\n    hexists -- 判断是否存在\r\n	\r\n```\r\nimport redis\r\n	class TestHash(Base):\r\n		def test_set(self):\r\n        \'\'\' hset/hget --设置/获取散列值 \'\'\'\r\n        rest = self.r.hset(\'stu:xxx02\', \'name\', \'Jhon\')\r\n        print(rest)\r\n        rest = self.r.hexists(\'stu:xxx02\', \'name\')\r\n        print(rest)\r\n        rest = self.r.hget(\'stu:xxx02\', \'name\')\r\n        print(rest)\r\n\r\n    def test_mset(self):\r\n        \'\'\' hmset/hmget -- 设置/获取多对散列值 \'\'\'\r\n        m = {\r\n            \'name\': \'Bob\',\r\n            \'age\': 21,\r\n            \'grade\': 98\r\n        }\r\n        rest = self.r.hmset(\'stu:xxx03\', m)\r\n        print(rest)\r\n        rest = self.r.hkeys(\'stu:xxx03\')\r\n        print(rest)\r\n```','2017-08-09 07:53:39','2017-08-09 07:53:39','pyhton-redis'),(250,7,7,'Pyhton-link mysql','```\r\nimport MySQLdb\r\n\r\ncon = MySQLdb.connect(\r\n	host=\'127.0.0.1\',\r\n	user=\'root\',\r\n	passwd=\'\',\r\n	port=3308,\r\n	db=\'news\',\r\n	charset=\'utf8\'\r\n	)\r\n\r\ncursor = con.cursor()\r\ncursor.execute(\'SELECT * FROM `news`\')\r\nrest = cursor.fetchone()\r\nprint(rest)\r\n```','2017-08-09 07:57:57','2017-08-09 08:08:11','pyhton-link-mysql'),(251,7,7,'Pyhton-link sql server','```\r\nimport pymssql\r\n\r\nclass MSSQL:\r\n    def __init__(self,host,user,pwd,db):\r\n        self.host = host\r\n        self.user = user\r\n        self.pwd = pwd\r\n        self.db = db\r\n\r\n    def __GetConnect(self):\r\n        if not self.db:\r\n            raise(NameError,\"没有设置数据库信息\")\r\n        self.conn = pymssql.connect(host=self.host,user=self.user,password=self.pwd,database=self.db,charset=\"utf8\")\r\n        cur = self.conn.cursor()\r\n        if not cur:\r\n            raise(NameError,\"连接数据库失败\")\r\n        else:\r\n            return cur\r\n\r\n    def ExecQuery(self,sql):\r\n        cur = self.__GetConnect()\r\n        cur.execute(sql)\r\n        resList = cur.fetchall()\r\n\r\n        #查询完毕后必须关闭连接\r\n        self.conn.close()\r\n        return resList\r\n\r\n    def ExecNonQuery(self,sql):\r\n        cur = self.__GetConnect()\r\n        cur.execute(sql)\r\n        self.conn.commit()\r\n        self.conn.close()\r\n\r\nms = MSSQL(host=\"192.168.80.13\",user=\"sunl\",pwd=\"abc123...\",db=\"test\")\r\nreslist = ms.ExecQuery(\"SELECT  count(*) as Deadlocks FROM sys.dm_os_performance_counters where counter_name like \'Number of Deadlocksc%\' \")\r\nfor i in reslist:\r\n    print (i)\r\n```','2017-08-09 07:58:55','2017-08-09 07:58:55','pyhton-link-sql-server'),(252,7,7,'Python-send mail','```\r\nimport smtplib\r\nfrom email.mime.text import MIMEText\r\nfrom email.header import Header\r\n\r\n#第三方 SMTP 服务\r\nfrom_addr = \"xxxx@163.com\"\r\npassword = \"xxxxx\"\r\nm = \'165019474@qq.com\'  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱\r\n\r\nmeg = MIMEText(\'Python 邮件发送测试...\', \'plain\', \'utf-8\')\r\nmeg[\'From\'] = from_addr\r\nmeg[\'To\'] = m\r\nmeg[\'Subject\'] = \'Python SMTP 邮件测试\'\r\n\r\nsmtpObj = smtplib.SMTP(\"smtp.163.com\",25)\r\nsmtpObj.login(from_addr,password)\r\nsmtpObj.sendmail(from_addr, m, meg.as_string())\r\nsmtpObj.close()\r\nprint (\"邮件发送成功\")\r\n```','2017-08-09 08:00:13','2017-08-09 08:00:44','python-send'),(253,7,7,'Python-urllib','```\r\nfrom urllib import request\r\nimport http.cookiejar\r\n\r\nurl = \'http://www.baidu.com\'\r\nprint(\'第一种方法:\')\r\nresponse1 = request.urlopen(url)\r\na=response1.getcode()\r\nprint(a)\r\nprint(len(response1.read()))\r\n\r\nprint(\'第二种方法\')\r\nreq = request.Request(url)\r\nreq.add_header(\'user-agent\', \'Mozilla/5.0\')\r\nresponse2 = request.urlopen(req)\r\nprint(response2.getcode())\r\nprint(len(response2.read()))\r\n\r\nprint(\'第三种方法\')\r\ncj = http.cookiejar.CookieJar()\r\nopener = request.build_opener(request.HTTPCookieProcessor(cj))\r\nrequest.install_opener(opener)\r\nresponse3 = request.urlopen(url)\r\nprint(response3.getcode())\r\nprint(cj)\r\nprint(response3.read().decode(\"utf-8\"))\r\n```','2017-08-09 08:03:02','2017-08-09 08:03:02','python-urllib'),(254,7,7,'Python-web_monitor','```\r\nimport pycurl\r\nimport os,sys\r\nimport time\r\n\r\nurl=\"http://qd-metro.telsafe.com.cn\"\r\nc=pycurl.Curl()\r\nc.setopt(pycurl.URL,url)\r\nc.setopt(pycurl.CONNECTTIMEOUT,5)\r\nc.setopt(pycurl.TIMEOUT,5)\r\nc.setopt(pycurl.NOPROGRESS,1)\r\nc.setopt(pycurl.FORBID_REUSE,1)\r\nc.setopt(pycurl.MAXREDIRS,1)\r\nc.setopt(pycurl.DNS_CACHE_TIMEOUT,30)\r\n\r\n#创建一个文件对象，以WB方式打开，用来存储返回的http头部及页面内容\r\nindexfile=open(os.path.dirname(os.path.realpath(__file__))+\"/content.txt\",\"wb\")\r\nc.setopt(pycurl.WRITEHEADER,indexfile)\r\nc.setopt(pycurl.WRITEDATA,indexfile)\r\ntry:\r\n    c.perform()     #提交请求\r\nexcept Exception:\r\n    print(\"connection error:\")\r\n    indexfile.close()\r\n    c.close()\r\n    sys.exit()\r\n\r\nNAMELOOOKUP_TIME=c.getinfo(pycurl.NAMELOOKUP_TIME)\r\nCONNECT_TIME=c.getinfo(pycurl.CONNECT_TIME)\r\nPRETRANSFER_TIME=c.getinfo(pycurl.PRETRANSFER_TIME)\r\nSTARTTRANSFER_TIME=c.getinfo(pycurl.STARTTRANSFER_TIME)\r\nTOTAL_TIME=c.getinfo(pycurl.TOTAL_TIME)\r\nHTTP_CODE=c.getinfo(pycurl.HTTP_CODE)\r\nSIZE_DOWNLOAD=c.getinfo(pycurl.SIZE_DOWNLOAD)\r\nHEADER_SIZE=c.getinfo(pycurl.HEADER_SIZE)\r\nSPEED_DOWNLOAD=c.getinfo(pycurl.SPEED_DOWNLOAD)\r\n#打印相关数据\r\nprint(\"HTTP状态码: %d\"%HTTP_CODE)\r\nprint(\"DNS解析时间: %d ms\"%(NAMELOOOKUP_TIME*1000))\r\nprint(\"建立连接时间: %d ms\"%(CONNECT_TIME*1000))\r\nprint(\"准备传输时间: %d ms\"%(PRETRANSFER_TIME*1000))\r\nprint(\"传输结束总时间: %d ms\"%(TOTAL_TIME*1000))\r\nprint(\"下载数据包大小: %d bytes/s\"%SIZE_DOWNLOAD)\r\nprint(\"HTTP头部大小: %d byte\"%HEADER_SIZE)\r\nprint(\"平均下载速度: %d bytes/s\"%SPEED_DOWNLOAD)\r\n#关闭文件及Curl对象\r\nindexfile.close()\r\nc.close()\r\n```','2017-08-09 08:04:31','2017-08-09 09:22:31','python-web-monitor'),(255,7,7,'Python-read text','```\r\nf=open(\'D:/BugReport.txt\',\'r+\')\r\nline=f.readline()\r\nprint(line)\r\nf.close()\r\n```','2017-08-09 08:05:32','2017-08-10 06:14:32','python-read'),(256,7,7,'Python-Post message','```\r\nimport requests\r\n\r\n\r\n\r\n#提交信息\r\nparams = {\'firstname\': \'Ryan\', \'lastname\': \'Mitchell\'}\r\nr = requests.post(\"http://pythonscraping.com/files/processing.php\", data=params)\r\nprint(r.text)\r\n\r\n#提交文件和图片\r\nfiles = {\'uploadFile\': open(\'../files/Python-logo.png\', \'rb\')}\r\nr = requests.post(\"http://pythonscraping.com/pages/processing2.php\",\r\nfiles=files)\r\nprint(r.text)\r\n\r\n#cookie（一）\r\nparams = {\'username\': \'Ryan\', \'password\': \'password\'}\r\nr = requests.post(\"http://pythonscraping.com/pages/cookies/welcome.php\", params)\r\nprint(\"Cookie is set to:\")\r\nprint(r.cookies.get_dict())\r\nprint(\"-----------\")\r\nprint(\"Going to profile page...\")\r\nr = requests.get(\"http://pythonscraping.com/pages/cookies/profile.php\",\r\ncookies=r.cookies)\r\nprint(r.text)\r\n\r\n#cookie（二）\r\nsession = requests.Session()\r\nparams = {\'username\': \'username\', \'password\': \'password\'}\r\ns = session.post(\"http://pythonscraping.com/pages/cookies/welcome.php\", params)\r\nprint(\"Cookie is set to:\")\r\nprint(s.cookies.get_dict())\r\nprint(\"-----------\")\r\nprint(\"Going to profile page...\")\r\ns = session.get(\"http://pythonscraping.com/pages/cookies/profile.php\")\r\nprint(s.text)\r\n\r\n#HTTP基本接入认证\r\nfrom requests.auth import AuthBase\r\nfrom requests.auth import HTTPBasicAuth\r\nauth = HTTPBasicAuth(\'ryan\', \'password\')\r\nr = requests.post(url=\"http://pythonscraping.com/pages/auth/login.php\", auth=\r\nauth)\r\nprint(r.text)\r\n```','2017-08-09 08:06:20','2017-08-09 08:06:20','python-post'),(257,7,7,'Python-search mysql','```\r\nimport MySQLdb\r\n\r\nclass MysqlSearch(object):\r\n\r\n    def __init__(self):\r\n        self.get_conn()\r\n\r\n    def get_conn(self):\r\n        try:\r\n            self.conn = MySQLdb.connect(\r\n                host=\'127.0.0.1\',\r\n                user=\'root\',\r\n                passwd=\'\',\r\n                db=\'news\',\r\n                port=3308,\r\n                charset=\'utf8\'\r\n            )\r\n        except MySQLdb.Error as e:\r\n            print(\'Error: %s\' % e)\r\n\r\n    def close_conn(self):\r\n        try:\r\n            if self.conn:\r\n                # 关闭链接\r\n                self.conn.close()\r\n        except MySQLdb.Error as e:\r\n            print(\'Error: %s\' % e)\r\n\r\n    def get_one(self):\r\n        # 准备SQL\r\n        sql = \'SELECT * FROM `news` WHERE `types` = %s ORDER BY `created_at` DESC;\'\r\n        # 找到cursor\r\n        cursor = self.conn.cursor()\r\n        # 执行SQL\r\n        cursor.execute(sql, (\'百家\', ))\r\n        # print(dir(cursor))\r\n        # 拿到结果\r\n        rest = dict(zip([k[0] for k in cursor.description], cursor.fetchone()))\r\n        # 处理数据\r\n        # 关闭cursor/链接\r\n        cursor.close()\r\n        self.close_conn()\r\n        return rest\r\n\r\n    def get_more(self):\r\n        # 准备SQL\r\n        sql = \'SELECT * FROM `news` WHERE `types` = %s ORDER BY `created_at` DESC;\'\r\n        # 找到cursor\r\n        cursor = self.conn.cursor()\r\n        # 执行SQL\r\n        cursor.execute(sql, (\'百家\', ))\r\n        # print(dir(cursor))\r\n        # 拿到结果\r\n        rest = [dict(zip([k[0] for k in cursor.description], row))\r\n            for row in cursor.fetchall()]\r\n        # 处理数据\r\n        # 关闭cursor/链接\r\n        cursor.close()\r\n        self.close_conn()\r\n        return rest\r\n\r\n    def get_more_by_page(self, page, page_size):\r\n        \'\'\' 分页查询数据 \'\'\'\r\n        offset = (page - 1) * page_size\r\n        # 准备SQL\r\n        sql = \'SELECT * FROM `news` WHERE `types` = %s ORDER BY `created_at` DESC LIMIT %s, %s;\'\r\n        # 找到cursor\r\n        cursor = self.conn.cursor()\r\n        # 执行SQL\r\n        cursor.execute(sql, (\'百家\', offset, page_size))\r\n        # print(dir(cursor))\r\n        # 拿到结果\r\n        rest = [dict(zip([k[0] for k in cursor.description], row)) \r\n            for row in cursor.fetchall()]\r\n        # 处理数据\r\n        # 关闭cursor/链接\r\n        cursor.close()\r\n        self.close_conn()\r\n        return rest\r\n\r\n    def add_one(self):\r\n        \'\'\' 插入数据 \'\'\'\r\n        # 受影响的行数\r\n        row_count = 0\r\n        try:\r\n            # 准备SQL\r\n            sql = (\r\n                \"INSERT INTO `news`(`title`,`image`, `content`, `types`, `is_valid`) VALUE\"\r\n                \"(%s, %s, %s, %s, %s);\"\r\n            )\r\n            # 获取链接和cursor\r\n            cursor = self.conn.cursor()\r\n            # 执行sql\r\n            # 提交数据到数据库\r\n            cursor.execute(sql, (\'标题11\', \'/static/img/news/01.png\', \'新闻内容5\', \'推荐\', 1))\r\n            # cursor.execute(sql, (\'标题12\', \'/static/img/news/01.png\', \'新闻内容6\', \'推荐\', 1))\r\n            # 提交事务\r\n            self.conn.commit()\r\n        except :\r\n            print(\'error\')\r\n            # 回滚事务\r\n            self.conn.rollback()\r\n        # 执行最后一条SQL影响的行数\r\n        row_count = cursor.rowcount\r\n        # 关闭cursor和链接\r\n        cursor.close()\r\n        self.close_conn()\r\n        # row_count > 0 表示成功\r\n        return row_count > 0\r\n\r\n\r\n\r\ndef main():\r\n    obj = MysqlSearch()\r\n    # rest = obj.get_one()\r\n    # print(rest[\'title\'])\r\n\r\n    # rest = obj.get_more()\r\n    # for item in rest:\r\n    #     print(item)\r\n    #     print(\'------\')\r\n\r\n    # rest = obj.get_more_by_page(2, 3)\r\n    # for item in rest:\r\n    #     print(item)\r\n    #     print(\'------\')\r\n\r\n    rest = obj.add_one()\r\n    print(rest)\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\r\n```','2017-08-09 08:10:34','2017-08-09 08:10:34','python-search-mysql'),(258,7,7,'Python-mysql-orm','```\r\n#!/usr/bin/python\r\n#coding=utf-8\r\n\r\nfrom sqlalchemy import create_engine\r\nfrom sqlalchemy.ext.declarative import declarative_base\r\nfrom sqlalchemy.orm import sessionmaker\r\nfrom sqlalchemy import Column, Integer, String, DateTime, Boolean\r\n\r\nengine = create_engine(\"mysql://root:@127.0.0.1:3308/news?charset=utf8\")\r\n\r\nSession = sessionmaker(bind=engine)\r\n\r\nBase = declarative_base()\r\n\r\n\r\nclass News(Base):\r\n    \'\'\' 新闻类型 \'\'\'\r\n    __tablename__ = \'news\'\r\n    id = Column(Integer, primary_key=True)\r\n    title = Column(String(200), nullable=False)\r\n    content = Column(String(2000), nullable=False)\r\n    types = Column(String(10), nullable=False)\r\n    image = Column(String(300))\r\n    author = Column(String(20))\r\n    view_count = Column(Integer)\r\n    created_at = Column(DateTime)\r\n    is_valid = Column(Boolean)\r\n\r\n\r\nclass MysqlOrmTest(object):\r\n\r\n    def __init__(self):\r\n        self.session = Session()\r\n\r\n    def add_one(self):\r\n        \'\'\' 添加数据 \'\'\'\r\n        new_obj = News(\r\n            title=\'ORM标题\',\r\n            content=\'content\',\r\n            types=\"百家\"\r\n        )\r\n        self.session.add(new_obj)\r\n        self.session.commit()\r\n        return new_obj\r\n\r\n    def get_one(self):\r\n        \'\'\' 获取一条数据 \'\'\'\r\n        return self.session.query(News).get(1)\r\n\r\n    def get_more(self):\r\n        \'\'\' 获取多条数据 \'\'\'\r\n        return self.session.query(News).filter_by(is_valid=1)\r\n\r\n    def update_data(self):\r\n        \'\'\' 修改数据 \'\'\'\r\n        obj = self.session.query(News).get(38)\r\n        obj.is_valid = 0\r\n        self.session.add(obj)\r\n        self.session.commit()\r\n        return obj\r\n\r\n    def delete_data(self):\r\n        \'\'\' 删除数据 \'\'\'\r\n        # 获取要删除的数据\r\n        data = self.session.query(News).get(39)\r\n        self.session.delete(data)\r\n        self.session.commit()\r\n\r\n\r\ndef main():\r\n    obj = MysqlOrmTest()\r\n    # rest = obj.add_one()\r\n    # print(dir(rest))\r\n    # print(obj.get_one().title)\r\n\r\n    # print(obj.get_more().count())\r\n    # for row in obj.get_more():\r\n    #     print(row.title)\r\n\r\n    # print(obj.update_data())\r\n\r\n    obj.delete_data()\r\n\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\r\n```','2017-08-09 08:14:23','2017-08-09 08:14:23','python-mysql-orm'),(259,7,7,'Python-mongo','```\r\nfrom datetime import datetime\r\nfrom pymongo import MongoClient\r\nfrom bson.objectid import ObjectId\r\n\r\n\r\nclass TestMongo(object):\r\n\r\n    def __init__(self):\r\n        self.client = MongoClient()\r\n        self.db = self.client[\'blog\']\r\n\r\n    def add_one(self):\r\n        \'\'\' 新增数据 \'\'\'\r\n        post = {\r\n            \'title\': \'新的标题\',\r\n            \'content\': \'博客内容，....\',\r\n            \'created_at\': datetime.now()\r\n        }\r\n        return self.db.blog.posts.insert_one(post)\r\n\r\n    def get_one(self):\r\n        \'\'\' 查询一条数据 \'\'\'\r\n        return self.db.blog.posts.find_one()\r\n\r\n    def get_more(self):\r\n        \'\'\' 查询多条数据 \'\'\'\r\n        return self.db.blog.posts.find({\'x\': 2})\r\n\r\n    def get_one_from_oid(self, oid):\r\n        \'\'\' 查询指定ID的数据 \'\'\'\r\n        obj = ObjectId(oid)\r\n        return self.db.blog.posts.find_one({\'_id\': obj})\r\n\r\n    def update(self):\r\n        \'\'\' 修改数据 \'\'\'\r\n        # 修改一条数据\r\n        # rest = self.db.blog.posts.update_one({\'x\': 11}, {\'$inc\': {\'x\': 10}})\r\n        # return rest\r\n        # 修改多条数据\r\n        return self.db.blog.posts.update_many({}, {\'$inc\': {\'x\': 10}})\r\n\r\n    def delete(self):\r\n        \'\'\' 删除数据 \'\'\'\r\n        # 删除一条数据\r\n        # return self.db.blog.posts.delete_one({\'x\': 10})\r\n        # 删除多条数据\r\n        return self.db.blog.posts.delete_many({\'x\': 12})\r\n\r\ndef main():\r\n    obj = TestMongo()\r\n    # rest = obj.add_one()\r\n    # print(rest.inserted_id)\r\n\r\n    # rest = obj.get_one()\r\n    # print(rest[\"_id\"])\r\n\r\n    # rest = obj.get_more()\r\n    # for item in rest:\r\n    #     print(item[\"_id\"])\r\n\r\n    # rest = obj.get_one_from_oid(\'5933d259fa3ebd1bdc12ce38\')\r\n    # print(rest)\r\n\r\n    # rest = obj.update()\r\n    # print(rest.matched_count)\r\n    # print(rest.modified_count)\r\n\r\n    rest = obj.delete()\r\n    print(rest.deleted_count)\r\n\r\nif __name__ == \'__main__\':\r\n    main()\r\n```','2017-08-09 08:15:30','2017-08-09 08:15:30','python-mongo'),(260,7,7,'Pyhton-mongoengine','```\r\nfrom datetime import datetime\r\nfrom pymongo import MongoClient\r\nfrom bson.objectid import ObjectId\r\nfrom mongoengine import connect, Document, EmbeddedDocument, \\\r\n    StringField, IntField, FloatField, DateTimeField, ListField, \\\r\n    EmbeddedDocumentField\r\n\r\n\r\n# connect(\'students\')\r\n# connect(\'students\', host=\'192.168.1.35\', port=27017)\r\nconnect(\'students\', host=\'mongodb://localhost/students\')\r\n\r\nclass Grade(EmbeddedDocument):\r\n    \'\'\' 学生的成绩 \'\'\'\r\n    name = StringField(required=True)\r\n    score = FloatField(required=True)\r\n\r\n\r\nSEX_CHOICES = (\r\n        (\'female\', \'女\'),\r\n        (\'male\', \'男\')\r\n    )\r\n\r\nclass Student(Document):\r\n    \'\'\' 学生模型 \'\'\'\r\n    name = StringField(required=True, max_lenght=32)\r\n    age = IntField(required=True)\r\n    sex = StringField(required=True, choices=SEX_CHOICES)\r\n    grade = FloatField()\r\n    created_at = DateTimeField(default=datetime.now())\r\n    grades = ListField(EmbeddedDocumentField(Grade))\r\n    address = StringField()\r\n    school = StringField()\r\n\r\n    meta = {\r\n        \'collection\': \'students\'\r\n    }\r\n\r\n\r\nclass TestMongoEngine(object):\r\n\r\n    def add_one(self):\r\n        \'\'\' 新增数据 \'\'\'\r\n        yuwen = Grade(\r\n            name=\'语文\',\r\n            score=95\r\n            )\r\n        english = Grade(\r\n            name=\'英语\',\r\n            score=89)\r\n        stu_obj = Student(\r\n            name=\'张三\',\r\n            age=21,\r\n            sex=\'male\',\r\n            grades=[yuwen, english]\r\n        )\r\n        # stu_obj.test = \'OK\'\r\n        stu_obj.save()\r\n        return stu_obj\r\n\r\n    def get_one(self):\r\n        \'\'\' 查询一条数据 \'\'\'\r\n        return Student.objects.first()\r\n\r\n    def get_more(self):\r\n        \'\'\' 查询多条数据 \'\'\'\r\n        # return Student.objects\r\n        return Student.objects.all()\r\n\r\n    def get_one_from_oid(self, oid):\r\n        \'\'\' 查询指定ID的数据 \'\'\'\r\n        return Student.objects.filter(id=oid).first()\r\n\r\n    def update(self):\r\n        \'\'\' 修改数据 \'\'\'\r\n        # 修改一条数据\r\n        # rest = Student.objects.filter(sex=\'male\').update_one(inc__age=1)\r\n        # return rest\r\n        # 修改多条数据\r\n        rest = Student.objects.filter(sex=\'male\').update(inc__age=1)\r\n        return rest\r\n\r\n    def delete(self):\r\n        \'\'\' 删除数据 \'\'\'\r\n        # 删除一条数据\r\n        rest = Student.objects.filter(sex=\'male\').first().delete()\r\n        # 删除多条数据\r\n        rest = Student.objects.filter(sex=\'male\').delete()\r\n        return rest\r\n\r\ndef main():\r\n    obj = TestMongoEngine()\r\n    # rest = obj.add_one()\r\n    # print(rest.id)\r\n\r\n    # rest = obj.get_one()\r\n    # print(rest.id)\r\n\r\n    rest = obj.get_more()\r\n    print(type(rest))\r\n    for item in rest:\r\n        print(item.id)\r\n\r\n    # rest = obj.get_one_from_oid(\'593bb8e7fa3ebd091078d40e\')\r\n    # print(rest.name)\r\n\r\n    # rest = obj.update()\r\n    # print(rest)\r\n\r\n    # rest = obj.delete()\r\n    # print(rest)\r\n\r\nif __name__ == \'__main__\':\r\n    main()\r\n```','2017-08-09 08:16:29','2017-08-09 08:16:29','pyhton-mongoengine'),(261,7,7,'SQL Server-每秒死锁数量','```\r\nSELECT  *\r\nFROM    sys.dm_os_performance_counters\r\nWHERE   counter_name LIKE \'Number of Deadlocksc%\';\r\n\r\n--查询当前阻塞\r\n\r\nWITH    CTE_SID ( BSID, SID, sql_handle )\r\n          AS ( SELECT   blocking_session_id ,\r\n                        session_id ,\r\n                        sql_handle\r\n               FROM     sys.dm_exec_requests\r\n               WHERE    blocking_session_id <> 0\r\n               UNION ALL\r\n               SELECT   A.blocking_session_id ,\r\n                        A.session_id ,\r\n                        A.sql_handle\r\n               FROM     sys.dm_exec_requests A\r\n                        JOIN CTE_SID B ON A.SESSION_ID = B.BSID\r\n             )\r\n    SELECT  C.BSID ,\r\n            C.SID ,\r\n            S.login_name ,\r\n            S.host_name ,\r\n            S.status ,\r\n            S.cpu_time ,\r\n            S.memory_usage ,\r\n            S.last_request_start_time ,\r\n            S.last_request_end_time ,\r\n            S.logical_reads ,\r\n            S.row_count ,\r\n            q.text\r\n    FROM    CTE_SID C \r\n            JOIN sys.dm_exec_sessions S ON C.sid = s.session_id\r\n            CROSS APPLY sys.dm_exec_sql_text(C.sql_handle) Q\r\n    ORDER BY sid\r\n```','2017-08-09 08:38:34','2017-08-09 08:38:34','sql-server-a-deadlock-number-per-second'),(262,7,7,'SQL Server-数据I/0','```\r\nSELECT DB_NAME(database_id) AS [Database Name] , file_id , io_stall_read_ms , num_of_reads , CAST(io_stall_read_ms / ( 1.0 + num_of_reads ) AS NUMERIC(10, 1)) AS [avg_read_stall_ms] , io_stall_write_ms , num_of_writes ,\r\nCAST(io_stall_write_ms / ( 1.0 + num_of_writes ) AS NUMERIC(10, 1)) AS [avg_write_stall_ms] , io_stall_read_ms + io_stall_write_ms AS [io_stalls] , num_of_reads + num_of_writes AS [total_io] , CAST(( io_stall_read_ms + io_stall_write_ms ) / ( 1.0 + num_of_reads\r\n+ num_of_writes) AS NUMERIC(10,1)) AS [avg_io_stall_ms]FROM sys.dm_io_virtual_file_stats(NULL, NULL)ORDER BY avg_io_stall_ms DESC\r\n```','2017-08-09 08:39:23','2017-08-09 08:39:23','sql-server-i-0-data'),(263,7,7,'SQL Server-批量处理数据收缩日志(SQL Server 2000 之后版本用）','```\r\nuse tempdb\r\ngo\r\n\r\n-- 创建临时表#dbs\r\ncreate table #dbs\r\n(\r\n    dbName varchar(128),--数据库名称\r\n    dbSize nvarchar(13),--数据库文件大小\r\n    owner varchar(128),--数据库owner角色名\r\n    dbid smallint,--数据库id\r\n    created nvarchar(11),--数据库创建日期\r\n    status nvarchar(600),--数据库状况\r\n    compatibility_level tinyint --为数据库设置特定兼容性级别。\r\n);\r\nGO\r\n\r\n-- 插入所有数据库信息至表中\r\ninsert into #dbs exec sp_helpdb;\r\nGO\r\n\r\n-- 替换数据库文件大小单位，方便进行数值比较\r\nupdate  #dbs set dbsize=replace(dbsize,\'MB\',\'\')\r\nGO\r\n\r\n-- 修改类型\r\nalter table #dbs alter column dbsize float\r\nGO\r\n\r\n-- 删除系统库和dbsize<300的记录\r\ndelete from #dbs where dbName in (\'master\',\'model\',\'msdb\',\'tempdb\') or dbsize<=300\r\n\r\n-- 修改数据库恢复模式为简单\r\nselect \'alter database [\' + dbname + \'] set recovery  SIMPLE\' as sqlText\r\ninto #ChangeToSimpleModeSqlCode\r\nfrom #dbs\r\nGO\r\n\r\n--逐行修改数据库恢复模式为简单\r\ndeclare @sqltext1 nvarchar(4000)\r\ndeclare c cursor for select sqlText from #ChangeToSimpleModeSqlCode\r\nopen c\r\nfetch next from c\r\ninto @sqltext1\r\nwhile @@fetch_status=0\r\nbegin\r\n    exec(@sqltext1)\r\n    fetch next from c into @sqltext1\r\nend\r\nclose c\r\ndeallocate c\r\n\r\n-- 数据库日志文件压缩\r\nselect \'use [\'+dbname+\'];declare @log_fname nvarchar(50);set @log_fname=file_name(2);dbcc shrinkfile(@log_fname,300)\' as sqlText\r\ninto ##sql_code\r\nfrom #dbs\r\nGO\r\n\r\n--逐行执行日志压缩脚本\r\ndeclare @sqltext2 nvarchar(4000)\r\ndeclare c cursor for select sqlText from ##sql_code\r\nopen c\r\nfetch next from c\r\ninto @sqltext2\r\nwhile @@fetch_status=0\r\nbegin\r\n    exec(@sqltext2)\r\n    fetch next from c into @sqltext2\r\nend\r\nclose c\r\ndeallocate c\r\n\r\n-- 还原数据库恢复模式\r\nselect \'alter database [\' + dbname + \'] set recovery  FULL\' as sqlText\r\ninto #ChangeToFullModeSqlCode\r\nfrom #dbs\r\n\r\n--逐行修改数据库恢复模式为完整\r\ndeclare @sqltext3 nvarchar(4000)\r\ndeclare c cursor for select sqlText from #ChangeToFullModeSqlCode\r\nopen c\r\nfetch next from c\r\ninto @sqltext3\r\nwhile @@fetch_status=0\r\nbegin\r\n    exec(@sqltext3)\r\n    fetch next from c into @sqltext3\r\nend\r\nclose c\r\ndeallocate c\r\n```','2017-08-09 08:41:42','2017-08-09 08:41:42','sql-server-batch-processing-log-data-contraction-sql-server-2000-version'),(264,7,7,'Docker-上传镜像','## 登入\r\ndocker login （镜像仓库地址）\r\n输入账号密码\r\n## 镜像打标\r\ndocker tag (image id) 119.23.21.44/user/nginx(仓库路径）:[镜像编号]\r\n## 上传\r\ndocker push 119.23.21.44/user/nginx:[镜像编号]','2017-08-10 02:53:24','2017-08-10 02:53:24','docker-upload-images'),(265,7,7,'Docker-进入容器','docker exec -it 559（容器号） /bin/bash','2017-08-10 02:56:43','2017-08-10 02:56:43','docker-into-the-container'),(266,3,3,'Laravel 文档阅读：文件存储（待续）','## 简介\r\n\r\nLaravel 文件存储系统底层使用的是 [Flysystem][1] PHP 包，为本地和远程操作文件带来很大的便利。\r\n\r\n## 配置\r\n\r\n文件存储系统的配置文件位于 `config/filesystems.php`。在这里指定「硬盘」（Disks），每个硬盘对应一个驱动（Driver）和存储位置。\r\n\r\n多个「硬盘」可以使用同一个驱动，比如默认配置里 `local` 和 `public` 硬盘都使用了 `local` 驱动。\r\n\r\n### Public 硬盘\r\n\r\n`public` 硬盘存储可公共访问的文件资源，它默认使用 `local` 驱动，存储位置在 `storage/app/public`。为了让文件能通过 Web 访问到，要创建一个从 `public/storage` 指向 `storage/app/public` 的软连接。\r\n\r\n你可以直接用 `storage:link` Artisan 命令做到：\r\n\r\n```\r\nphp artisan storage:link\r\n```\r\n\r\n假定我们已经存储了一个文件 `default-avatar.png`（完整路径是 `storage/app/public/default-avatar.png`），并且用 `storage:link` Artisan 命令成功创建了访问文件所需要的软连接。接下来就可以用 `asset` 辅助函数生成 URL 地址（以 `http://homestead.app/` 域名为例）。\r\n\r\n```\r\necho asset(\'storage/default-avatar.png\'); // http://homestead.app/storage/default-avatar.png\r\n```\r\n\r\n### Local 驱动\r\n\r\n当使用 `local` 驱动时，所有文件操作都是相对于配置文件里 `root` 对应的目录进行的，默认是 `storage/app ` 这个目录，所以下面的文件存储在 `storage/app/file.txt`。\r\n\r\n```\r\nStorage::disk(\'local\')->put(\'files/file.txt\', \'测试文本\');\r\n```\r\n\r\n## 获得硬盘实例\r\n\r\n`Storage` 门面用来与硬盘交互。你能用 `Storage` 门面的 `put` 方法把用户头像存储在默认硬盘（`local` 硬盘），这是在你没用 `disk` 方法指定硬盘的时候。\r\n\r\n```\r\nuse Illuminate\\Support\\Facades\\Storage;\r\n\r\nStorage::put(\'avatars/1\', $fileContents);\r\n```\r\n\r\n当然，你也可以用 `Storage` 门面的 `disk` 方法指定存储文件使用的硬盘。\r\n\r\n```\r\nStorage::disk(\'s3\')->put(\'avatars/1\', $fileContents);\r\n```\r\n\r\n## 获得文件\r\n\r\n`get` 方法用来获得文件内容，值是字符串。记住，方法里的文件路径是相对于 `root` 目录算的，默认 `local` 硬盘的 `root` 目录是 `storage/app`。\r\n\r\n```\r\n$contents = Storage::get(\'files/text.txt\');\r\n```\r\n\r\n`exists` 方法用来判断文件是否在硬盘中存在。\r\n\r\n```\r\n$exists = Storage::disk(\'s3\')->exists(\'files/text.txt\');\r\n```\r\n\r\n### 文件 URL\r\n\r\n如果是使用 `local` 或 `s3` 驱动，可以用 `url` 方法获得指定文件的 URL 地址。如果用 `local` 驱动，返回结果通常只是在给定文件路径前加上 `/storage` URL 字符串。\r\n\r\n\r\n```\r\nuse Illuminate\\Support\\Facades\\Storage;\r\n\r\n$url = Storage::url(\'file1.jpg\');\r\n```\r\n\r\n需要注意的是，这里的 `file1.jpg` 对应项目文件路径是 `public/storage/file1.jpg`，就是说 URL 地址都是公共资源的 URL 地址，是通过 `Storage::disk(\'public\')` 上传的文件，或者是使用 `local` 驱动上传到 `storage/app/public` 目录下的文件。务必要创建从 `public/storage` 指向 `storage/app/public` 目录的软连接。\r\n\r\n\r\n### 文件属性\r\n\r\n大小。\r\n\r\n```\r\nreturn Storage::size(\'public/default-avatar.png\')/1024;\r\n```\r\n\r\n最近修改时间。\r\n\r\n```\r\n$date = new DateTime();\r\n\r\n$date->setTimestamp(Storage::lastModified(\'public/default-avatar.png\'));\r\n\r\nreturn $date->format(\'U = Y-m-d H:i:s\') ;\r\n```\r\n\r\n`size` 和 `lastModified` 方法都是相对于 root 目录操作的。\r\n\r\n## 保存文件\r\n\r\nhttps://laravel.com/docs/5.4/filesystem#storing-files\r\n\r\n[1]: https://github.com/thephpleague/flysystem','2017-08-10 04:54:02','2017-08-10 06:05:37','laravel-document-reading-file-storage-to-be-continued'),(267,3,3,'从做一个作业中，理解了浮动和相对定位','### 理解了 3 点\r\n\r\n今天，重写了一个前端课程的作业。作业内容里使用了浮动和定位。作业最终效果如下。\r\n\r\n![图片](http://www.baooab.com/wp/wp-content/uploads/2017/08/zuoye2_css_chapter4_5.png)\r\n\r\n做了这个作业，让我理解了 3 点：\r\n\r\n1. 行内元素设置 `float: left;` / `float: right;` 属性后，具有块元素特征。\r\n2. 行内元素设置 `position: relative` 属性后，**不具有**块元素特征。\r\n3. 行内元素设置 `position: absolute` 属性后，**具有**块元素特征。\r\n\r\n### 代码结构\r\n\r\n#### 轮播容器\r\n\r\n下面讨论最终代码的结构，咱抛去 H3 标签不说。看下面轮播容器的代码布局。\r\n\r\n```\r\n<div class=\"slides-wrap clearfix\">\r\n	<a class=\"prev\" href=\"#\" title=\"上一期\">上一期</a>\r\n	<a class=\"next\" href=\"#\" title=\"下一期\">下一期</a>\r\n	<div class=\"content\">\r\n		<ul class=\"slides clearfix\">\r\n			 ...\r\n		</ul>\r\n	</div>\r\n</div>			\r\n```\r\n\r\n1. `.slides-wrap` 与 H3 标签同级，存在的唯一作用是清除（内部）浮动。\r\n2. `.prev`、`.next` 和 `.content` 是同级的，`.prev` 和 `.content` 是左浮动，`.next` 是右浮动。\r\n3. 之所以没有直接暴露 `ul`、在其外面嵌套一个 div `.content`，是为了用 JS 实现滚动——`.conetnt` 相对定位，`.slides` 绝对定位，那么当点击「上一期」「下一期」的时候，就可以通过调整 `.slides` 的 left position 或 right position 实现切换效果。\r\n\r\n#### 轮播图片\r\n\r\n再看轮播图片部分的代码：\r\n\r\n```\r\n<ul class=\"slides clearfix\">\r\n	<li>\r\n		<a href=\"#\">\r\n			<img src=\"./images/holder@230x170.png\" alt=\"img\">\r\n			<strong>第1211期</strong>\r\n			<span>冬天的静电会损害生理功能吗？</span>\r\n		</a>\r\n	</li>\r\n	<li>\r\n		<a href=\"#\">\r\n			<img src=\"./images/holder@230x170.png\" alt=\"img\">\r\n			<strong>第1211期</strong>\r\n			<span>晚睡拖延行为背后的心理学机制</span>\r\n		</a>\r\n	</li>\r\n	<li>\r\n		<a href=\"#\">\r\n			<img src=\"./images/holder@230x170.png\" alt=\"img\">\r\n			<strong>第1212期</strong>\r\n			<span>为什么每一颗大蒜，都有变成“黑蒜”的超级英雄梦？</span>\r\n		</a>\r\n	</li>\r\n	<li>\r\n		<a href=\"#\">\r\n			<img src=\"./images/holder@230x170.png\" alt=\"img\">\r\n			<strong>第1213期</strong>\r\n			<span>为什么聊天时不能始终盯着对方的眼睛？</span>\r\n		</a>\r\n	</li>\r\n</ul>\r\n```\r\n\r\n每个 li 都是浮动的，所以 ul 使用 `clearfix` 辅助类清除浮动。`a` 是相对定位的，它有 `width`、`height` 属性（要设定 `display:block`，否则无效），撑开了 li。`strong` 和 `span` 是绝对定位的。\r\n\r\n### 完整代码\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>作业2 - 基础第4~5章练习</title>\r\n    <style>\r\n        body, h3 {\r\n            margin: 0;\r\n        }\r\n\r\n        ul {\r\n            margin: 0;\r\n            padding: 0;\r\n            list-style: none;\r\n        }\r\n\r\n        img {\r\n            border: 0;\r\n            vertical-align: middle;\r\n        }\r\n\r\n        a {\r\n            text-decoration: none;\r\n        }\r\n\r\n        .clearfix::after {\r\n            content: \'\';\r\n            display: block;\r\n            clear: both;\r\n        }\r\n\r\n        body {\r\n            background: #eee;\r\n            padding-top: 45px;\r\n        }\r\n\r\n        .review {\r\n            width: 1032px;\r\n            margin: 0 auto;\r\n\r\n            background: #fff;\r\n            padding: 2px 15px 15px;\r\n        }\r\n\r\n        .review h3 {\r\n            font: bold 20px/48px \'Microsoft YaHei UI\';\r\n            color: #333;\r\n        }\r\n\r\n        .review .prev, .review .next {\r\n            width: 26px;\r\n            height: 170px;\r\n            text-indent: -10000px;\r\n        }\r\n\r\n        .review .prev, .review .content {\r\n            float: left;\r\n        }\r\n\r\n        .review .prev {\r\n            background: url(./images/left_arrow.jpg) no-repeat left center;\r\n        }\r\n\r\n        .review .next {\r\n            float: right;\r\n            background: url(./images/right_arrow.jpg) no-repeat right center;\r\n        }\r\n\r\n        .review .slides li {\r\n            float: left;\r\n        }\r\n\r\n        .review .slides li:not(:last-of-type) {\r\n            margin-right: 20px;\r\n        }\r\n\r\n        .review .slides a {\r\n            position: relative;\r\n            width: 230px;\r\n            height: 170px;\r\n            display: block;\r\n        }\r\n\r\n        .review .slides a strong, .review .slides a span {\r\n            position: absolute;\r\n        }\r\n\r\n        .review .slides a strong {\r\n            top: 0;\r\n            left: 0;\r\n            font: 12px/24px \'Microsoft YaHei UI\';\r\n            color: #fff;\r\n            padding: 0 10px;\r\n            background: #4aca6d;\r\n        }\r\n\r\n        .review .slides a span {\r\n            left: 0;\r\n            right: 0;\r\n            bottom: 0;\r\n            font: 14px/20px \'Microsoft YaHei UI\';\r\n            color: #fff;\r\n            background: rgba(0, 0, 0, .5);\r\n            padding: 10px;\r\n        }\r\n\r\n        .review .slides a span:hover {\r\n            text-decoration: underline;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n\r\n    <section class=\"review\">\r\n        <h3>往期回顾</h3>\r\n        <div class=\"slides-wrap clearfix\">\r\n            <a class=\"prev\" href=\"#\" title=\"上一期\">上一期</a>\r\n            <a class=\"next\" href=\"#\" title=\"下一期\">下一期</a>\r\n            <div class=\"content\">\r\n                <ul class=\"slides clearfix\">\r\n                    <li>\r\n                        <a href=\"#\">\r\n                            <img src=\"./images/holder@230x170.png\" alt=\"img\">\r\n                            <strong>第1211期</strong>\r\n                            <span>冬天的静电会损害生理功能吗？</span>\r\n                        </a>\r\n                    </li>\r\n                    <li>\r\n                        <a href=\"#\">\r\n                            <img src=\"./images/holder@230x170.png\" alt=\"img\">\r\n                            <strong>第1211期</strong>\r\n                            <span>晚睡拖延行为背后的心理学机制</span>\r\n                        </a>\r\n                    </li>\r\n                    <li>\r\n                        <a href=\"#\">\r\n                            <img src=\"./images/holder@230x170.png\" alt=\"img\">\r\n                            <strong>第1212期</strong>\r\n                            <span>为什么每一颗大蒜，都有变成“黑蒜”的超级英雄梦？</span>\r\n                        </a>\r\n                    </li>\r\n                    <li>\r\n                        <a href=\"#\">\r\n                            <img src=\"./images/holder@230x170.png\" alt=\"img\">\r\n                            <strong>第1213期</strong>\r\n                            <span>为什么聊天时不能始终盯着对方的眼睛？</span>\r\n                        </a>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </section>\r\n\r\n</body>\r\n</html>\r\n```','2017-08-10 09:01:52','2017-08-20 01:52:13','by-doing-a-job-understand-the-floating-and-relative-positioning'),(268,3,3,'关于 `storage:link` Artisan 命令的一些思考','在 Laravel 中，要访问上传到本地的文件资源，需要先创建一个软连接。使用 `storage:link` Artisan 命令，就可以快速创建这个软链接。\r\n\r\n```\r\n# php artisan storage:link\r\n```\r\n\r\n命令执行完毕后，就会在项目里多出一个 `public/storage`，这个 `storage` 就是一个软链接，它指向 `storage/app/public` 目录。\r\n\r\n```\r\npublic/storage（软连接） → storage/app/public\r\n```\r\n\r\n目录树结构是这样的。\r\n\r\n```\r\npublic/\r\n├── storage（软连接，指向目录 `storage/app/public`）\r\n├── css/\r\n│   └── bootstrap.css\r\n└── js/\r\n    └── bootstrap.js\r\n\r\nstorage/\r\n└── app/\r\n    └── public/\r\n		└── user-avatar.png\r\n```\r\n\r\n### 一、为何要创建软链接？\r\n\r\n项目根目录下的 `public` 是一个特殊的目录——存放可公共访问的资源。就像你看到的，除了 `storage` 这个软链接，还有 CSS 和 JS 文件都放在这里。如果你的域名是 `my.app`，那么访问这些资源的 URL 如下：\r\n\r\n* http://my.app/storage/user-avatar.png\r\n* http://my.app/css/bootstrap.css\r\n* http://my.app/js/bootstrap.js\r\n\r\n细心的你会发现，`http://my.app/storage/user-avatar.png` 实际访问的文件资源的服务器地址是 `/path/to/myapp/storage/app/public/user-avatar.png`。\r\n\r\n如果上传的资源文件存储在本地，Laravel 默认会传到 `storage/app` 里面，这个目录是不可见的，如果想要能公共访问就必须暴露在项目根目录下的 `public` 中，这就是创建软链接的原因 。\r\n\r\n### 二、Laravel 的选择\r\n\r\nLaravel 默认创建软链接的方式已经提过。\r\n\r\n```\r\npublic/storage → storage/app/public\r\n```\r\n\r\n`storage/app/public` 的意思很好理解，就是存储在服务器上，但是暴露给公共（public）使用的资源目录。那么 `public/storage` 呢，为什么要这样命名？下面是我的思考，假如不这么命名，我们能用什么命名方式？\r\n\r\n#### 2.1 第一种命名\r\n\r\n```\r\npublic/public → storage/app/public\r\n```\r\n\r\n这样的好处是软链接 `public` 和被指向的目录名一样了，方便记忆。但是访问资源的路径变成：\r\n\r\n* http://my.app/public/user-avatar.png\r\n* http://my.app/css/bootstrap.css\r\n* http://my.app/js/bootstrap.js\r\n\r\n有一个问题是，你能说 JS 和 CSS 不是 public 的吗？所以这个 pass 掉。\r\n\r\n#### 2.2 第二种命名\r\n\r\n```\r\npublic/uploads → storage/app/public\r\n```\r\n\r\n此时，访问资源的路径变成。\r\n\r\n* http://my.app/uploads/user-avatar.png\r\n* http://my.app/css/bootstrap.css\r\n* http://my.app/js/bootstrap.js\r\n\r\n这容易有误解——上传的文件资源都可以使用 `http://my.app/uploads/` 的形式访问到。\r\n\r\n#### 2.3 Laravel 的选择\r\n\r\n虽然\r\n\r\n```\r\npublic/storage → storage/app/public\r\n```\r\n\r\n的选择不如第一种命名方式方便记忆，但还是保持了某种程度上的语义且不容易误解——\r\n\r\n* http://my.app/storage/user-avatar.png\r\n\r\n用户访问的是服务器上 **存储** 的资源文件，而且这个资源文件是可以公共访问的。','2017-08-11 01:50:14','2017-08-12 23:53:50','about-storage-link-artisan-command'),(269,3,3,'奇妙的 Storage::url','### 发现\r\n\r\n这是我在做头像上传功能时发现的，下面是图片上传的业务逻辑。\r\n\r\n```\r\nclass AvatarController extends Controller\r\n{\r\n    public function update(Request $request)\r\n    {\r\n        $this->validate($request, [\r\n            \'avatar\' => \'required|image|dimensions:max_width=400,max_height=400\',\r\n        ], [\r\n            \'avatar.required\' => \'请先选择上传的头像。\',\r\n            \'avatar.dimensions\' => \'上传头像的宽高都不能大于 400 像素。\',\r\n        ]);\r\n\r\n        $avatar = $request->file(\'avatar\');\r\n\r\n        if ($avatar->isValid()) {\r\n            $user = Auth::user();\r\n\r\n            $path = Storage::putFile(\'public/uploads/avatars\', $avatar);\r\n            $user->avatar = Storage::url($path);\r\n            $user->save();\r\n        }\r\n\r\n        return back();\r\n    }\r\n}\r\n```\r\n\r\n`$avatar` 是从页面接收过来的头像图片。你可能从未想过，短短三行代码就实现了图片上传：\r\n\r\n```\r\n$path = Storage::putFile(\'public/uploads/avatars\', $avatar);\r\n$user->avatar = Storage::url($path);\r\n$user->save();\r\n```\r\n\r\n### 保存图片\r\n\r\n如果没有使用 `disk` 方法指定「硬盘」，Storage 门面默认使用的硬盘就是 `local`，对应存储路径是 `storage/app`。所以 \r\n\r\n```\r\n$path = Storage::putFile(\'public/uploads/avatars\', $avatar);\r\n```\r\n\r\n产生的上传路径（`$path`）的值类似：`public/uploads/avatars/iT8Lg6mmF8qtlskbl54tlsNlYmJLLZnAZzkZsFJH.png`，图片实际存储的位置在 `/path/to/myapp/storage/app/public/uploads/avatars/iT8Lg6mmF8qtlskbl54tlsNlYmJLLZnAZzkZsFJH.png`。\r\n\r\n\r\n### 生成图片 URL\r\n\r\n黑科技来了。你知道 `Storage::url($path)` 会产生什么结果吗？答案揭晓——`/storage/uploads/avatars/iT8Lg6mmF8qtlskbl54tlsNlYmJLLZnAZzkZsFJH.png`。\r\n\r\nOops！`$path` 的 「public」被去掉，然后在头部加了 `/storage`。这就是 Laravel 的 careful。\r\n\r\n### 访问图片\r\n\r\n```\r\n<img src=\"{{ asset(Auth::user()->avatar) }}\" alt=\"用户头像\">\r\n```','2017-08-11 01:51:51','2017-08-11 02:59:43','wonderful-storage-url'),(270,12,12,'python中使用xlrd、xlwt操作excel表格','xlrd使用介绍\r\n\r\n    1、导入模块\r\n        import xlrd \r\n   2、打开Excel文件读取数据\r\n        data = xlrd.open_workbook(\'excelFile.xls\')\r\n   3、使用技巧\r\n        获取一个工作表\r\n        table = data.sheets()[0]          #通过索引顺序获取\r\n        table = data.sheet_by_index(0) #通过索引顺序获取\r\n        table = data.sheet_by_name(u\'Sheet1\')#通过名称获取\r\n\r\n        获取整行和整列的值（数组）　　\r\n        table.row_values(i)\r\n        table.col_values(i)\r\n \r\n        获取行数和列数　　\r\n        nrows = table.nrows \r\n        ncols = table.ncols\r\n       \r\n        循环行列表数据 \r\n        for i in range(nrows):\r\n               print table.row_values(i)\r\n \r\n        单元格\r\n        cell_A1 = table.cell(0,0).value\r\n        cell_C4 = table.cell(2,3).value\r\n \r\n        使用行列索引\r\n        cell_A1 = table.row(0)[0].value\r\n        cell_A2 = table.col(1)[0].value\r\n \r\n        简单的写入\r\n        row = 0\r\n        col = 0\r\n \r\n        # 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error\r\n        ctype = 1 value = \'单元格的值\'\r\n        xf = 0 # 扩展的格式化\r\n        table.put_cell(row, col, ctype, value, xf)\r\n        table.cell(0,0)  #单元格的值\'\r\n        table.cell(0,0).value #单元格的值\'\r\n\r\n\r\n用例如下：\r\n[python] view plain copy\r\n# _*_ coding:utf-8 _*_  \r\n  \r\n#----------------------------------------------------------------------------  \r\n# import modules   \r\n#----------------------------------------------------------------------------  \r\nimport os  \r\nimport xlrd  \r\nfrom datetime import date,datetime  \r\n  \r\n#打开Excel文件  \r\nworkbook = xlrd.open_workbook(\'09-10.11-38-12-HTTP-GOOD-1-Lte1sDataStat_Charts.xlsx\')  \r\n  \r\n#输出Excel文件中所有sheet的名字  \r\nprint workbook.sheet_names()  \r\n  \r\n#根据sheet索引或者名称获取sheet内容  \r\nData_sheet    = workbook.sheets()[0]  \r\nCdfData_sheet = workbook.sheet_by_index(1)  \r\nCharts_sheet  = workbook.sheet_by_name(u\'Charts\')  \r\n  \r\n#获取sheet名称、行数和列数  \r\nprint Data_sheet.name,    Data_sheet.nrows,    Data_sheet.ncols,\\  \r\n      CdfData_sheet.name, CdfData_sheet.nrows, CdfData_sheet.ncols,\\  \r\n      Charts_sheet.name,  Charts_sheet.nrows,  Charts_sheet.ncols  \r\n  \r\n#获取整行和整列的值（列表）      \r\nrows = Data_sheet.row_values(0) #获取第一行内容  \r\ncols = Data_sheet.col_values(1) #获取第二列内容  \r\n#print rows  \r\n#print cols  \r\n  \r\n#获取单元格内容  \r\ncell_A1 = Data_sheet.cell(0,0).value  \r\ncell_C1 = Data_sheet.cell(0,2).value  \r\ncell_B1 = Data_sheet.row(0)[1].value  \r\ncell_D2 = Data_sheet.col(3)[1].value  \r\nprint cell_A1, cell_B1, cell_C1, cell_D2  \r\n  \r\n#获取单元格内容的数据类型  \r\n#ctype:0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error  \r\nprint \'cell(0,0)数据类型:\', Data_sheet.cell(0,0).ctype  \r\nprint \'cell(1,0)数据类型:\', Data_sheet.cell(1,0).ctype  \r\nprint \'cell(1,1)数据类型:\', Data_sheet.cell(1,1).ctype  \r\nprint \'cell(1,2)数据类型:\', Data_sheet.cell(1,2).ctype  \r\n  \r\n#获取单元格内容为日期的数据  \r\ndate_value = xlrd.xldate_as_tuple(Data_sheet.cell_value(1,0),workbook.datemode)  \r\nprint date_value  \r\nprint \'%d:%d:%d\' %(date_value[3:])  \r\n  \r\nd = {\'11:25:59\':[1, 2, 3], \'11:26:00\':[2, 3, 4], \'11:26:01\':[3, 4, 5]}  \r\nprint d[\'11:25:59\']  \r\nprint d[\'11:26:00\']  \r\nprint d[\'11:26:01\']  \r\n  \r\nprint d[\'11:25:59\'][0]  \r\nprint d[\'11:26:00\'][0]  \r\nprint d[\'11:26:01\'][0]  \r\n\r\n**xlwt使用介绍**\r\nXlwt简介：\r\n功能：用于生成97/2000/XP/2003xls文件。\r\nPython版本：Python2.3 to 2.7\r\n当前版本：0.7.5\r\n平台：跨平台\r\n        \r\n相关模块：\r\ncsv             python标准模块。推荐。\r\nxlrd            读取 .xls, .xlsx 文件。\r\nxlutils       xlrd和xlwt的集合。\r\nopenpyxl 读写 Excel 2007 xlsx/xlsm文件 。纯python，效率不高。\r\nMatplotlib      2D作图模块，适用于基于excel作图。\r\nPywin32   python windows扩展 ，不跨平台，通过COM口连接excel。\r\nPyxll           在excel中使用python替代vbs。http://www.pyxll.com/。类似模块有pyinex。Python For Excel http://www.opentradingsystem.com/PythonForExcel/main.html\r\nXlsxWriter      写xlsx文件。纯python。\r\n \r\n快速入门\r\n下面例子，创建一个名为mini.xls的文件，它有一个空sheet：\'xlwt was here\'。代码见mini.py。\r\nfromxlwt import *\r\nw =Workbook()\r\nws = w.add_sheet(\'xlwtwas here\')\r\nw.save(\'mini.xls\') \r\n\r\nWorkbook类初始化时有encoding和style_compression参数。\r\n\r\nencoding，设置字符编码，一般要这样设置：w = Workbook(encoding=\'utf-8\')，就可以在excel中输出中文了。默认是ascii。当然要记得在文件头部添加：\r\n\r\n# -*- coding: utf-8-*-\r\n\r\nstyle_compression 表示是否压缩，不常用。\r\nWorkbook 还有一些属性：\r\nOwner 设置文档所有者。\r\ncountry_code： 国家码\r\nwnd_protect： 窗口保护\r\nobj_protect： 对象保护\r\nProtect： 保护\r\nbackup_on_save： 保存时备份\r\nHpos： 横坐标\r\nVpos： 纵坐标\r\nWidth： 宽度\r\nHeight： 高度\r\nactive_sheet： 活动sheet\r\ntab_width： tab宽度\r\nwnd_visible： 窗口是否可见\r\nwnd_mini： 窗口最小化\r\nhscroll_visible： 横向滚动条是否可见。\r\nvscroll_visible： 纵向滚动条是否可见。\r\ntabs_visible： tab是否可见。\r\ndates_1904： 是否使用1904日期系统\r\nuse_cell_values： 单元格的值\r\ndefault_style： 默认样式\r\ncolour_RGB： 颜色\r\n\r\n方法有：add_style，add_font，add_str，del_str，str_index，add_rt，rt_index，add_sheet，get_sheet，raise_bad_sheetname，convert_sheetindex，setup_xcall，add_sheet_reference。\r\n\r\n用例如下：\r\n[python] view plain copy\r\n# _*_ coding:utf-8 _*_  \r\n  \r\n#----------------------------------------------------------------------------  \r\n# import modules   \r\n#----------------------------------------------------------------------------  \r\nimport os  \r\nimport xlwt           \r\n  \r\n  \r\ndef set_style(name, height, bold = False):  \r\n    style = xlwt.XFStyle()   #初始化样式  \r\n      \r\n    font = xlwt.Font()       #为样式创建字体  \r\n    font.name = name  \r\n    font.bold = bold  \r\n    font.color_index = 4  \r\n    font.height = height  \r\n      \r\n    style.font = font  \r\n    return style  \r\n  \r\n      \r\ndef write_excel():  \r\n    #创建工作簿  \r\n    workbook = xlwt.Workbook(encoding=\'utf-8\')    \r\n    #创建sheet  \r\n    data_sheet = workbook.add_sheet(\'demo\')    \r\n    row0 = [u\'字段名称\', u\'大致时段\', \'CRNTI\', \'CELL-ID\']  \r\n    row1 = [u\'测试\', \'15:50:33-15:52:14\', 22706, 4190202]  \r\n      \r\n    #生成第一行和第二行  \r\n    for i in range(len(row0)):  \r\n        data_sheet.write(0, i, row0[i], set_style(\'Times New Roman\', 220, True))  \r\n        data_sheet.write(1, i, row1[i], set_style(\'Times New Roman\', 220, True))  \r\n      \r\n    #保存文件  \r\n    workbook.save(\'demo.xls\')     \r\n      \r\n      \r\nif __name__ == \'__main__\':   \r\n    write_excel()  \r\n    print u\'创建demo.xlsx文件成功\'','2017-08-11 02:45:25','2017-08-11 02:45:25','use-python-xlrd-xlwt-operation-excel-spreadsheet'),(271,3,3,'zip 命令','`zip` 命令用来将文件压缩成 `.zip` 格式。\r\n\r\n比如，将 another 目录压缩为 `another.zip` 文件的命令如下：\r\n\r\n```\r\n$ sudo zip -r another.zip another\r\n```\r\n\r\n更多使用介绍看 [这里][1]。\r\n\r\n[1]: http://www.cnblogs.com/jishume/articles/2225651.html','2017-08-11 08:40:44','2017-08-11 08:44:54','zip-command'),(272,3,3,'这一天，好像又快要过去了（小诗）','这日复一日\r\n\r\n度日如呲溜\r\n\r\n上一次\r\n\r\n偶听到蝉的叫\r\n\r\n笑。笑\r\n\r\n跳。跳\r\n\r\n那一只蹲在牌子上的鸟?\r\n\r\n孤独骄傲\r\n\r\n现在不见了\r\n\r\n希望它一切都好?\r\n\r\n2017.8','2017-08-11 13:44:50','2017-08-11 13:45:29','on-this-day-it-is-going-to-the-past-poem'),(273,3,3,'input[type=text] 和 select 表单样式设定差异','输入框有默认样式，设定前需要重置样式：\r\n\r\n```\r\ninput {\r\n	margin: 0;\r\n	padding: 0;\r\n	outline: none;\r\n}\r\n```\r\n\r\n### 元素大小\r\n\r\n首先需要明确的是，一个元素的大小：\r\n\r\n* 元素水平大小：`border-left-width` + `padding-left` + `width` + `padding-right` + `border-right-width`。\r\n* 元素垂直大小：`border-top-width` + `padding-top` + `height` + `padding-bottom` + `border-bottom-width`。\r\n\r\n比如，下图里的元素的大小就是 **330 x 34**。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/element_size.png)\r\n\r\n### 输入框\r\n\r\n`input[type=text]` 的 `width` 和 `height` 属性值 **不包含 `border`**。也就是说当你给一个输入框样式：\r\n\r\n```\r\ninput {\r\n    margin: 0;\r\n    padding: 0;\r\n    outline: none;\r\n}\r\n\r\ninput[type=text] {\r\n    width: 328px;\r\n	height: 32px;\r\n	border: 1px solid #e4e9ed;\r\n}\r\n```\r\n\r\n那么，这个输入框大小就是 **330 x 34**。\r\n\r\n### 多选框\r\n\r\n`select`  的 `width` 和 `height` 属性值 **包含 `border`**。也就是说当你给一个多选框样式：\r\n\r\n```\r\nselect {\r\n    width: 160px;\r\n	height: 34px;\r\n	border: 1px solid #e4e9ed;\r\n}\r\n```\r\n\r\n那么最终浏览器的渲染结果如下：\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/select_size.png)\r\n\r\n `width` 水平方向上的 2px， `height` 垂直方向上的 2px 用在 `border` 上了，内容区的大小变为 **158 x 32**。\r\n\r\n### 提交表单\r\n\r\n与多选框一样的是，提交表单（`input[type=submit]`）的 `width` 和 `height` 属性值也是 **包含 `border`** 的。','2017-08-12 03:18:50','2017-08-12 03:18:50','input-type-text-and-select-the-form-style-set-differences'),(274,6,6,'47.1','Activity 1.1\r\n\r\nin case of sth\r\n\r\nused to describe what you should do in a particular situation, especially on official notices\r\n\r\n　In case of fire, break the glass.\r\n \r\n \r\nland v \r\n\r\n 【ARRIVE BY BOAT/PLANE】 [I]\r\n \r\nto arrive somewhere in a plane, boat etc\r\nland on/in/at etc\r\n\r\n　We expect to be landing in Oslo in about fifty minutes.\r\n　In 1969, the first men landed on the moon.\r\n\r\n\r\nattach  v [T] \r\n\r\nto fasten or connect one object to another\r\n= fix attach sth to sth\r\n\r\n　Attach a recent photograph to your application form.\r\n　a small battery attached to a little loudspeaker\r\n \r\nthe attached form/cheque/leaflet etc\r\n\r\n　Please fill in and return the attached reply slip.','2017-08-14 09:26:43','2017-08-14 09:28:05','471'),(275,3,3,'深入理解CSS之`float`（待续）','### 原本作用\r\n\r\n`float` 原本的作用是 [实现文字环绕][1]。\r\n\r\n### 浮动特性\r\n\r\n包裹和破坏。\r\n\r\n#### 包裹\r\n\r\n包裹的表现：\r\n\r\n1. 元素宽高由内容撑开。大约等于内容的宽和高。\r\n2. 隔绝。BFC，浮动元素内部内容不干扰外部元素。\r\n\r\n其它具有包裹性的属性：\r\n\r\n1. `display: inline-block` 和 `display: table-cell`。\r\n2. `position: absolute`（float 近亲）、`position: fixed` 和 `position: sticky`。\r\n3. `overflow: hidden` 和 `overflow: scroll`。\r\n\r\n#### 破坏\r\n\r\n浮动元素的父元素高度会塌陷。\r\n\r\n其它具有破坏性的属性：\r\n\r\n1. `display: none`。\r\n2. `position: absolute`（float 近亲）、`position: fixed` 和 `position: sticky`。\r\n\r\n### float 元素让父级元素高度塌陷\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/inline_boxes_breaking.jpg)\r\n\r\n当图片给予 `float: left;` 属性后，图片的 inline boxes 被破坏，高度线消失，无法与文字这类 inline boxes 同行排列。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/float_from_inline_boxes_after_float_breaking.jpg)\r\n\r\n于是，图片从 inline boxes 链中脱离出来，受定义的方位属性影响，靠左显示（left）。由于有“包裹性”，实体宽度依旧存在，又因为是和文字在同一个文档流中，所以文字和图片不会重叠。图片没有 inline boxes，高度丢失，文字居顶显示，形成新的文字包络线。\r\n\r\n### 清除浮动\r\n\r\n更准确的说，是清除浮动带来的影响，因为浮动还是一直在的。三种方式：\r\n\r\n#### 使用 `clear: both;` 。\r\n\r\n```\r\n// 浮动元素底部插入 `clear: both;`  元素。\r\n<div style=\"clear: both;\"></div>\r\n\r\n// 使用 `::after` 伪类\r\n.clearfix::after {\r\n    content: \'\';\r\n	display: table;\r\n	clear: both;\r\n}\r\n```\r\n\r\n#### 父元素 BFC（IE8+） 或者 haslayout（IE6/IE7）。\r\n\r\n触发 BFC/haslayout 的方式。\r\n\r\n* `float: left` 和 `float: right`。\r\n* `position: absolute` 和 `position: fixed`。\r\n* `overflow: hidden` 和 `overflow: scroll`。（IE7+）\r\n* `display: inline-block` 和 `display: table-cell`。（IE8+）\r\n* `width`、`height` 和 `zoom: 1`。（IE6/IE7）。\r\n\r\n#### 权衡后的方法\r\n\r\n```\r\n.clearfix::after {\r\n	content: \'\';\r\n	display: block;\r\n	height: 0;\r\n	overflow: hidden;\r\n	clear: both;\r\n}\r\n\r\n.clearfix {\r\n	*zoom: 1;\r\n}\r\n```\r\n\r\n或更好的方法：\r\n\r\n```\r\n.clearfix::after {\r\n	content: \'\';\r\n	display: table;\r\n	clear: both;\r\n}\r\n.clearfix {\r\n	*zoom: 1;\r\n}\r\n```\r\n\r\n`.clearfix` 只应该用在包含浮动元素的父元素上，如果滥用在 IE6/IE7 很容易出现问题的。\r\n\r\n### 浮动的特性\r\n\r\n1. 让元素块状块（`display: block`）。\r\n2. 去空格化。\r\n\r\n#### 去空格化\r\n\r\n如果我们写了这样的代码。\r\n\r\n```\r\n<button>按钮1</button>\r\n<button>按钮2</button>\r\n<button>按钮3</button>\r\n<a href=\"#\">link</a>\r\n```\r\n\r\n会得到“元素之间显示有空格”这样的结果。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/no_float_button_group.jpg)\r\n\r\n这是因为，**换行符被解析为一个空格**，等同于\r\n\r\n```\r\n<button>按钮1</button> <button>按钮2</button> <button>按钮3</button> <a href=\"#\">link</a>\r\n```\r\n\r\n如果，我们让 `<button>` 浮动，它们就紧挨在一起了。\r\n\r\n```\r\nbutton {\r\n	float: left;\r\n}\r\n```\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/floated_button_group.jpg)\r\n\r\n因为浮动的特性，标签的换行符被放在了最后，等同于\r\n\r\n```\r\n1. <button>按钮1</button><button>按钮2</button><button>按钮3</button><a href=\"#\">link</a>\r\n2.\r\n3.\r\n4.\r\n```\r\n\r\n后面三行就是之前的三处换行符，因为标签后面的换行符在渲染时会被浏览器忽略，所以就有了“去空格”的效果。\r\n\r\n### float 与流体布局\r\n\r\n\r\n\r\n[1]: https://codepen.io/zhangbao/full/mMBaRQ','2017-08-15 02:08:51','2017-08-16 00:32:19','in-depth-understanding-of-css-float'),(276,3,3,'在服务器上部署运维平台项目的步骤「yunwei」','准备材料：`yunwei_170815.zip`（包含数据库脚本）。\r\n\r\n1. 上传至服务器（`/application/web`）。\r\n\r\n2. 解压至当前目录。\r\n\r\n```\r\n$ sudo unzip yunwei_170815.zip\r\n```\r\n\r\n3. 进入项目，给予必要的权限和软链接设置\r\n\r\n```\r\n$ cd yunwei\r\n$ sudo chmod -R 777 storage/\r\n$ sudo chmod -R 777 bootstrap/cache/\r\n$ sudo ln -s storage/app/public/ public/storage\r\n```\r\n\r\n4. 创建数据库，恢复数据\r\n\r\n```\r\n$ mysql -u root -p < yunwei_170815.sql \r\n```\r\n\r\n5. 配置新网站\r\n\r\n```\r\nsudo vim /application/nginx/conf/nginx.conf\r\n```\r\n\r\n重启服务器。\r\n\r\n```\r\nsudo /application/nginx/sbin/nginx -s reload\r\n```','2017-08-15 05:37:46','2017-08-15 05:39:12','on-the-server-deployment-operations-platform-project-steps-yunwei'),(277,3,3,'深入理解CSS之`absolute`（待续）','绝对定位和浮动几乎可以互用。都具有两个特性。\r\n\r\n1. 包裹（针对自身）。\r\n2. 破坏性（针对父级元素）。\r\n\r\n### 无依赖的绝对定位\r\n\r\n不受 relative 限制的 absolute 定位，行为表现上不使用 top/right/bottom/left 任何一个属性，或使用 auto 作为值。\r\n\r\n绝对定位特征：\r\n\r\n1. 脱离文档流\r\n2. 去浮动、位置跟随\r\n\r\n“去浮动”指绝对定位生效的时候，浮动属性一律无效；“位置跟随”指 （跟在文字后面的）inline、inline-block 元素，当它 absolute 之后，还会跟在文字后面。\r\n\r\n虽然有位置跟随，但是我们依然可以通过与 margin 属性配合的方式，来实现精确定位。\r\n\r\n“无依赖的绝对定位”又称在不影响其它布局的“相对定位”之王！','2017-08-15 08:43:56','2017-08-16 00:32:08','in-depth-understanding-of-css-absolute-to-be-continued'),(278,3,3,'使用 .clearfix 类清除浮动','以下样式兼容 IE6/IE7 样式：\r\n\r\n```\r\n.clearfix::after {\r\n	content: \'\';\r\n	display: table;\r\n	clear: both;\r\n}\r\n\r\n.clearfix {\r\n	*zoom: 1;\r\n}\r\n```','2017-08-16 03:13:20','2017-08-16 03:13:20','using-the-clearfix-class-to-remove-floating'),(279,3,3,'两栏布局，清除浮动影响样式类 .cell','```\r\n.cell {\r\n	display: table-cell;\r\n	width: 9999px;\r\n	*display: inline-block;\r\n	*width: auto;\r\n}\r\n```','2017-08-16 03:56:17','2017-08-16 03:56:17','a-two-column-layout-remove-floating-influence-style-class-the-cell'),(280,3,3,'深入理解CSS之`line-height`（待续）','### 基线\r\n\r\n`line-height` 是两行文字的 **基线** 之间的距离。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/line-height_baseline.png)\r\n\r\n*微软雅黑字体的基线*\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/line-height.png)\r\n\r\n*两个基线之间的距离就是行高*\r\n\r\n### 垂直居中\r\n\r\n其实 `font: 14px/32px \'宋体\'` 并没有让文字垂直居中，只是**近似居中**，只有 `font-size: 0;` 时，文字/图片才是垂直居中的。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/line-height_middle.png)\r\n\r\n*红线是中线，能看到垂直居中只是近似居中*\r\n\r\n### 行内框盒子模型\r\n\r\n```\r\n<p>这是一行普通的文字，这是一个<em>em</em>标签。</p>\r\n```\r\n\r\n上段代码包含 4 中盒子。\r\n\r\n1. “内容区域”（content area）是围绕文字的看不见的盒子，大小（宽、高）只与 `font-size` 的设定有关系。\r\n2. “内联盒子”（inline boxes）让内容在一行显示。直接暴露的文字称为“匿名内联盒子”，比如`这是一行普通...一个`；包裹在 inline 类型标签（span、a、em...）里的内容则直接称为“内联盒子”，比如 `<em>em</em>`。\r\n3. “行框盒子”（line boxes）：每一行内容属于一个“行框盒子”，行框盒子由一个一个内联盒子组成。\r\n4. “包含盒子”：行框盒子组成包含盒子，比如 `<p>...</p>`\r\n\r\n\r\n### 内联元素的高度机理\r\n\r\n内联元素的高度是由 `line-height` 决定的，这有个 [例子][1]。\r\n\r\n内联元素的高度的表现不是行高，而是“内容区域高度”+“行间距”，只不过恰好 `行高 = 内容区域高度 + 行间距`。\r\n\r\n* 内容区域高度（content area）只与字号（`font-size`）和字体（`font-family`）有关，与 `line-height` 没有任何关系。\r\n* 在 simsun （宋体）字体下，内容区域高度等于 `font-size` 值。\r\n\r\n所以更加精确地说，应该是：\r\n\r\n> 在 simsun 字体下，`line-height = 内容区域高度 + 行间距`。\r\n\r\n行间距 = line-height - 内容区域高度。行间距上下拆分，就是“半行间距”，**均分** 或者 **上半部分比下半部分多 1 像素**。\r\n\r\n### 全局行高使用经验\r\n\r\n```\r\nbody {\r\n	font-size: 14px;\r\n	line-height: 1.4286;\r\n}\r\n```\r\n\r\n字号 14px，行高 20px。\r\n\r\n[1]: https://codepen.io/zhangbao/pen/BdmrOx','2017-08-16 04:46:14','2017-08-16 06:07:21','in-depth-understanding-of-css-line-height-to-be-continued'),(281,3,3,'CSS 隐匿文本节点','我们知道，当一个 p 标签里只包含一张图片时，p 标签的高度稍大于图片高度。\r\n\r\n```\r\n<p><img src=\"http://www.baooab.com/wp/wp-content/uploads/2017/08/avatar_2.png\" alt=\"img\"></p>\r\n```\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/p_is_highter_than_img.png)\r\n\r\n这是图片与文字基线对齐的结果。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/img_verticle_baseline_with_text.png)\r\n\r\n当你给图片设置 `vertical-align: bottom;` 属性后，就没有那一块多余空间。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/img_verticle_bottom_with_text.png)\r\n\r\n那么第一张图片里，根本就没有文字，为什么还受“文字基线对齐”影响呢？这就引出了“隐匿文本节点”的概念。\r\n\r\n看下面这个 [例子][1]：\r\n\r\nHTML\r\n\r\n```\r\n<p><img src=\"http://www.baooab.com/wp/wp-content/uploads/2017/08/avatar_2.png\" alt=\"img\"></p>\r\n```\r\n\r\nCSS\r\n\r\n```\r\np {\r\n	margin: 0;\r\n	text-align: center;\r\n}\r\n\r\np > img {\r\n	width: 125px;\r\n	position: absolute;\r\n}\r\n```\r\n\r\n这里使用了“绝对定位”元素的跟随特性，证明了 p 标签里是有一个“隐匿文本节点”虽然看不到，但确实是居中了的，这就解释了为什么图片还受“文字基线对齐”的影响。\r\n\r\n[1]: https://codepen.io/zhangbao/pen/LjOmrQ','2017-08-16 06:21:11','2017-08-16 06:34:57','css-hidden-text-node'),(282,3,3,'深入理解CSS之`vertical-align`（待续）','`vertical-align` 除了支持 `inherit` 属性值外，还支持下列 4 类属性值：\r\n\r\n1. 线类：baseline、top、middle 和 bottom。\r\n2. 文本类：text-top 和 text-bottom。\r\n3. 上标、下标类：sub 和 super。\r\n4. 数值百分比类：20px（相对 baseline 计算的）、20em 和 20%（相对行高计算的）。\r\n\r\n数值是支持负值的，CSS 里支持负值属性的并不多，包括 `margin`、`letter-space`、`word-spacing` 和 `vertical-align`。\r\n\r\n---\r\n\r\n`vertical-align` 属性作用在 inline 水平元素（`inline`、`inline-block`）和 `table-cell` 元素上。\r\n\r\n* inline 元素：`<img>`、`<span>`、`<strong>`、`<em>`、未知元素。\r\n* inline-block 元素：`<input>`、`<button>`。（IE8+）\r\n* table-cell 元素： `<td>`。\r\n\r\n总结下来，即在默认状态下，支持 `vertical-align` 属性的是图片、按钮、文字和单元格。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/vertical_align_middle_demo.png)\r\n\r\n值得注意的是，图片在 float 浮动后，就变成 block 了，`vertical-align` 也会失效。','2017-08-16 07:03:15','2017-08-16 08:42:23','in-depth-understanding-of-css-vertical-align-to-be-continued'),(283,3,3,'inlin-block 元素设定 line-height: 0 之后','一个字符的行高设定为0之后，这个字符占有的高度也是0。\r\n\r\n行高有让字符居中的特性，而居中的 **基准线** 就是内容区（content area）的中间，当行高为0的时候，就会看到基准线在文字中间的情况了。','2017-08-16 09:33:40','2017-08-17 02:51:48','inlin-block-element-to-set-the-line-height-0'),(284,3,3,'朴树歌曲中的呓语','###《生如夏花》\r\n\r\nsei woa la jiu mu\r\n\r\nsei woa la jiu mu\r\n\r\nou woa la yi ye\r\n\r\nai woa la yi ya\r\n\r\nsei woa la jiu mu\r\n\r\nsei woa la jiu mu a\r\n\r\nou woa la yi ya ou siba no ma ji ya \r\n\r\nsei jiu ya\r\n\r\n###《那些花儿》\r\n\r\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=139377&auto=0&height=66\"></iframe>\r\n\r\nda\r\n\r\nxi ai ba lai ba ga\r\n\r\nai ba lai zou ma\r\n\r\nai ba lai zou ba\r\n\r\n啦 啦啦 啦 啦 啦啦 啦 啦 啦啦 ye ba\r\n\r\n啦 啦啦 啦 啦 啦啦 啦 啦 啦啦 zhi ba lai zhi a\r\n\r\n啦 啦啦 啦 啦 啦啦 啦 啦 啦啦 jie ba\r\n\r\nzhi ba lan gan gou bei lai ga nai jie mou zou mou\r\n\r\nna yi~ di za wu bei di za \r\n\r\nnou bu didi za\r\n\r\ndi ba lai za ou mou lai dou\r\n\r\nzhi ba lai zhi ma\r\n\r\njieyi li ga mou mei li ga\r\n\r\nmou nou giyi a','2017-08-16 23:31:43','2017-11-16 06:53:53','hackberry-songs-of-self-pity'),(285,3,3,'宿舍里的窗户','宿舍里走廊面的窗户隔成了两个，每个都是正方形，边长差不多半米。窗户上贴着纸，有些大、有些松，跟窗户的大小不配，可以想到是把纸撕开贴上的，只有纸上边的胶布还扒在窗户上。\r\n\r\n黑红色的窗户和门，我脑后的是大窗户。窗户都敞开着，微有凉风吹来。大半部分都有窗栏护着，露出通透的上部，那是我靠不到的地方。外头有打火机被按下的声音。有女人的咳嗽声和说话声。\r\n\r\n我的左边（我现在趴着）是讲英语的男子的，他的床上有抽纸、一次性杯子、吹风机和大矿泉水空瓶子。它的床有些乱。\r\n\r\n我的床的五分之二、靠墙那一边被其它东西占着――衣服、书、蛋黄派（盐豆和它总形影不离）。\r\n\r\n2017.6','2017-08-16 23:34:20','2017-08-16 23:34:20','the-windows-of-the-dormitory'),(286,3,3,'2017.08.09','（一）\r\n\r\n今天算是破天荒了――来图书馆看书。直播课延迟至下周。\r\n\r\n流着眼泪看书，这个眼泪是情不自禁的，跟情绪无关，在开馆时就进来了，看《堂吉诃德》。打着呵欠流眼泪。\r\n\r\n（二）\r\n\r\n吃晚饭回来的路上，听到人谈论点外卖给的汤是白水。\r\n\r\n我感觉得约束下自己的行为，不能在无聊时间总被手机霸占。现在就是这样。\r\n\r\n（三）','2017-08-16 23:35:27','2017-08-16 23:35:27','20170809'),(287,3,3,'标题党','这才叫冰箱！\r\n\r\n这才叫手机！\r\n\r\n然而接下来发生的一幕，令所有人感动！\r\n\r\n当时我就震惊了！\r\n\r\n浍沟国际啤酒节。\r\n\r\n独家！\r\n\r\n真XX了！\r\n\r\n最后一个真是心酸！\r\n\r\n疯狂！','2017-08-16 23:36:45','2017-08-18 01:40:58','title-party'),(288,3,3,'定位理论和消费者心智空间','这属于「品牌营销」里一个重要环节。\r\n\r\n「心智空间」和「定位」的概念来源美国品牌营销专家 **里斯和特劳特** 在《定位》这本书里提出的，时间在上世纪 60 年代末，70 年代初。\r\n\r\n## 定位\r\n\r\n由于现代社会信息过载，产品过剩，宣传过剩，所以\r\n\r\n> 对一个品牌来说，你只能是某个东西，你不能什么都是，如果你希望你什么都是，最后你就什么都不是。\r\n\r\n例子：提到汽车，Volvo 安全、奔驰尊贵、宝马一流操控性。\r\n\r\n为什么会这样呢？\r\n\r\n**因为产品供给过剩，你不能什么都是，你只能是某一个东西，而且你还要长期的、几十年如一日地宣传你就是这个东西，才能让消费者记住。**\r\n\r\n## 消费者心智\r\n\r\n> 你实际上到底怎么样常常没那么重要，重要的是消费者心里觉得你是什么样的。\r\n\r\n所以定位工作往往围绕消费者的心智认知进行，而不是围绕产品进行。\r\n\r\n定位理论的一个要点：**一旦某个定位取得了一定成功，就得几十年如一日的重复它。不要试图改变已经在消费者心目中定位成功了的那个认知点**。\r\n\r\n另一个要点：**无论多成功的企业，尝试做改变在消费者心目中定位那个认知点的时候，都会吃苦头。**\r\n\r\n那么该怎么做？\r\n\r\n用一个全新的品牌，打造在消费者心目中的另一个定位认知点。\r\n\r\n关于新定位应该启用新品牌的道理，在之后的「品牌延伸陷阱」部分讲到。\r\n\r\n## 应用定位理论\r\n\r\n广州宝洁（P&G）：海飞丝、飘柔、舒肤佳、玉兰油、汰渍。联合利华：清扬，不如海飞丝，这就是**品牌抢先成为行业第一的重要性**，品牌没有抢先成为行业第一该怎么办，在后面会讲到。\r\n\r\n（完）','2017-08-17 05:15:24','2017-08-17 05:27:19','locate-mental-space-theory-and-consumers'),(289,3,3,'如何给品牌起一个好名字？','这一部分属于「市场营销品牌传播」。\r\n\r\n## 名字的重要性\r\n\r\n巴哈马群岛，过去叫「猪岛」；香格里拉，过去叫「中甸县」，90 年代由云南政府改名，名字取自英国小说家詹姆斯·谢尔顿一本书《失去的地平线》（描写中国西南地区的人间天堂）。\r\n\r\n玛丽莲·梦露的「梦露」是 Monroe，通常翻译为「门罗」，但这样就不性感了。\r\n\r\n刘德华叫刘福荣，张国荣叫张荣发，冯德伦叫冯进财。\r\n\r\n吴红巾就是左小祖咒、张爱军就是张玮玮。\r\n\r\n**千万不要草率的起名字。给品牌起名字本质上是一件非常严肃的事情。**\r\n\r\n## 注意点\r\n\r\n1. 准确。\r\n2. 好听好记，有辨识度。\r\n3. 便于传播，有个性。\r\n4. 兼顾价值观和个性。\r\n\r\n### 准确\r\n\r\n* 洗衣粉：立白\r\n* 分发新闻：今日头条\r\n* 汽车：奔驰\r\n* 买家具：宜家\r\n\r\n中华老字号——面目模糊的名字。在今天的商业时代，这样做会吃亏。\r\n\r\n### 好听好记，有辨识度\r\n\r\n好的品牌大多遵守语言的节奏和韵律，就是「听上去不错」。\r\n\r\n* 可口可乐\r\n* 必应搜索\r\n\r\n英文品牌押头韵：Black Berry，Dr. Pepper。中文：可口可乐、可伶可俐（很少）。\r\n\r\n叠字：陌陌、钉钉、探探、QQ、滴滴打车、大姨吗。\r\n\r\nVPN软件（翻墙软件）：红杏。\r\n\r\n糟糕的快递品牌名：中通、圆通、申通。糟糕的汽车品牌：途观、途胜、途安、途昂。\r\n\r\n在前有罗永浩的情况下，还能蹦出来一个罗振宇，还叫老罗、罗胖，实在很不容易。\r\n\r\n### 有个性\r\n\r\n起名字虽然严肃，也要符合品牌定位。只要合适，非常有个性和淘气的品牌名字，都是加分项。\r\n\r\n* 漫画网站：有妖气。\r\n* 微博平台：饭否。\r\n* 知乎。\r\n* 饿了么。\r\n* 去哪儿。','2017-08-17 05:45:33','2017-08-17 06:14:10','how-to-give-a-good-name-brand'),(290,3,3,'在 Laravel 中借助 erusev/parsedown 包解析 Markdown 文本的正确方式','Laravel 在 5.4 版本中天然包含了将 Markdown 语法转换成 HTML 的工具包 [`erusev/parsedown`][1] 。\r\n\r\n它主要的方法有两个：`text` 和 `setMarkupEscaped`。使用方式如下：\r\n\r\n```\r\necho Parsedown::instance()\r\n   ->setMarkupEscaped(true)\r\n   ->text(\"<div><strong>*Some text*</strong></div>\");\r\n\r\n# 输出:\r\n# <p>&lt;div&gt;&lt;strong&gt;<em>Some text</em>&lt;/strong&gt;&lt;/div&gt;</p>\r\n```\r\n\r\n\r\n`text` 指定要转换的 Markdown 文本；`setMarkupEscaped` 设置为 `true` 表示转义文本里的 HTML 标签，比如把 `<` 转换为 `<`，以 **避免外部脚本攻击**。\r\n\r\n它在 Larvel 的 Blade 模板文件里是这样使用的：\r\n\r\n```\r\n{!! Parsedown::instance()->setMarkupEscaped(true)->text($discussion->body) !!}\r\n```\r\n\r\n下面举两个例子：\r\n\r\n1. 当我转义的文本是 `<script> console.log(\'Oops!\'); </script>` 的时候，被解析为\r\n\r\n```\r\n<p>&lt;p&gt;&lt;script&gt; console.log(\'Oops!\');&lt;/script&gt;&lt;/p&gt;</p>\r\n```\r\n\r\n2. 当我转义的文本是 `` ```<script> console.log(\'Oops!\'); </script>``` ``\r\n的时候，被解析为\r\n\r\n```\r\n<p><code>&lt;script&gt; console.log(\'Oops!\'); &lt;/script&gt;</code></p>\r\n```\r\n\r\n更多使用细节，可以查阅这里的 [教程][2]。\r\n\r\n[1]: https://github.com/erusev/parsedown\r\n[2]: https://github.com/erusev/parsedown/wiki/Tutorial:-Get-Started','2017-08-17 06:37:26','2017-08-17 07:19:49','in-laravel-using-erusevparsedown-packet-parsing-markdown-text-the-right-way'),(291,3,3,'让热加载（Eager Loading）带 Eloquent 飞（待续）','热加载这个概念在我 [之前的文章][1] 里有提到过。\r\n\r\n```\r\nphp artisan make:model -m Post\r\nphp artisan make:model -m Author\r\nphp artisan make:model -m Profile\r\n```\r\n\r\n`-m` 表示创建 Model 的同时，还创建对应迁移表文件。\r\n\r\n这些 Model 具备下列的关联：\r\n\r\n```\r\nPost -> belongsTo -> Author\r\nAuthor -> hasMany -> Post\r\nAuthor -> hasOne -> Profile\r\n```\r\n\r\n## 迁移文件\r\n\r\n下面开始写迁移文件内容，位于 `database/migrations/` 文件夹下。\r\n\r\n```\r\n<?php\r\n\r\nuse Illuminate\\Support\\Facades\\Schema;\r\nuse Illuminate\\Database\\Schema\\Blueprint;\r\nuse Illuminate\\Database\\Migrations\\Migration;\r\n\r\nclass CreatePostsTable extends Migration\r\n{\r\n    /**\r\n     * Run the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function up()\r\n    {\r\n        Schema::create(\'posts\', function (Blueprint $table) {\r\n            $table->increments(\'id\');\r\n            $table->unsignedInteger(\'author_id\');\r\n            $table->string(\'title\')->unique();\r\n            $table->text(\'body\');\r\n            $table->timestamps();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reverse the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function down()\r\n    {\r\n        Schema::dropIfExists(\'posts\');\r\n    }\r\n}\r\n```\r\n\r\n```\r\n<?php\r\n\r\nuse Illuminate\\Support\\Facades\\Schema;\r\nuse Illuminate\\Database\\Schema\\Blueprint;\r\nuse Illuminate\\Database\\Migrations\\Migration;\r\n\r\nclass CreateAuthorsTable extends Migration\r\n{\r\n    /**\r\n     * Run the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function up()\r\n    {\r\n        Schema::create(\'authors\', function (Blueprint $table) {\r\n            $table->increments(\'id\');\r\n            $table->string(\'name\');\r\n            $table->text(\'bio\');\r\n            $table->timestamps();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reverse the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function down()\r\n    {\r\n        Schema::dropIfExists(\'authors\');\r\n    }\r\n}\r\n```\r\n\r\n```\r\n<?php\r\n\r\nuse Illuminate\\Support\\Facades\\Schema;\r\nuse Illuminate\\Database\\Schema\\Blueprint;\r\nuse Illuminate\\Database\\Migrations\\Migration;\r\n\r\nclass CreateProfilesTable extends Migration\r\n{\r\n    /**\r\n     * Run the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function up()\r\n    {\r\n        Schema::create(\'profiles\', function (Blueprint $table) {\r\n            $table->increments(\'id\');\r\n            $table->unsignedInteger(\'author_id\');\r\n            $table->date(\'birthday\');\r\n            $table->string(\'city\');\r\n            $table->string(\'state\');\r\n            $table->string(\'website\');\r\n            $table->timestamps();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reverse the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function down()\r\n    {\r\n        Schema::dropIfExists(\'profiles\');\r\n    }\r\n}\r\n```\r\n\r\n## Model\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Post extends Model\r\n{\r\n    public function author()\r\n    {\r\n        return $this->belongsTo(Author::class);\r\n    }\r\n}\r\n```\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Author extends Model\r\n{\r\n    public function posts()\r\n    {\r\n        return $this->hasMany(Post::class);\r\n    }\r\n\r\n    public function profile()\r\n    {\r\n        return $this->hasOne(Profile::class);\r\n    }\r\n}\r\n```\r\n\r\n```\r\n$ php artisan migrate\r\n```\r\n\r\n\r\n## Model 工厂\r\n\r\n编辑 `database/factories/ModelFactory.php` 文件。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n[1]: https://laravel-china.org/articles/5166/quick-print-laravel-database-query-sql-statement#热加载','2017-08-17 07:42:47','2017-08-17 10:24:50','let-the-heat-load-eager-loading-fly-eloquent'),(292,3,3,'Query Builder 的 skip/take、limit/offset 方法','`skip` / `take` 和 `limit` / `offset` 都用来限制 SQL 查询返回的结果条数，除了名字，它们是一样的。\r\n\r\n## `skip`/`take` \r\n\r\n比如：从第 11 条数据开始，取 5 条数据。\r\n\r\n```\r\n$users = DB::table(\'users\')->skip(10)->take(5)->get();\r\n```\r\n\r\n`skip(10)` 表示忽略头 10 条数据，`take(5)` 表示取 5 条数据，`get` 表示执行 SQL 查询，执行的 SQL 语句如下：\r\n\r\n```\r\nselect * from `users` limit 5 offset 10\r\n```\r\n\r\n## `limit`/`offset`\r\n\r\n`limit` 就是 `skip`，`offset` 就是 `take`，它们仅仅是名字不同而已。只不过， `limit` / `offset` 更接近 SQL 语句命名形式。\r\n\r\n```\r\n$users = DB::table(\'users\')->offset(10)->limit(5)->get();\r\n```','2017-08-17 08:14:26','2017-08-17 08:14:43','query-builder-of-the-skiptake-limitoffset-method'),(293,3,3,'深入理解之`z-index`','`z-index` 只对定位元素起作用。这里的「定位元素」指 `position` 取以下属性值之一的：\r\n\r\n* `relative`。\r\n* `absolute`。\r\n* `fixed`。\r\n* `sticky`。\r\n\r\n当设置 `z-idnex` 属性的定位元素，没有发生嵌套时，遵循以下规则：\r\n\r\n* 后来居上\r\n\r\n`z-idnex`  一样。出现在后面的定位元素显示在上面。\r\n\r\n*  `z-idnex` 大的居上\r\n\r\n前面定位元素的 `z-index` 值大于后面的定位元素时，前面的显示在上面。\r\n\r\n## 层叠上下文\r\n\r\n层叠上下文（Stacking Context）是 HTML 元素的一个三维概念，表示元素在 `z轴` 上的水平。\r\n\r\n具有层叠上下文的元素会高过普通元素。\r\n\r\n**具有层叠上下文的元素**：\r\n\r\n1. `<html>` 元素天生具有层叠上下文。\r\n2. `z-idnex` 值为 **数字** 的 **定位元素**。\r\n3. 其它……\r\n\r\n## 层叠水平\r\n\r\n层叠上下文中的每个元素都有层叠水平（Stacking Level），决定同一个层叠上下文中的元素在 z 轴上的显示顺序。\r\n\r\n其显示顺序也是\r\n\r\n* 后来居上\r\n*  `z-idnex` 大的居上\r\n\r\n层叠水平和 `z-index` 不是一个东西。所有元素都有层叠水平，但 `z-index` 只对定位元素生效。','2017-08-18 02:35:08','2017-08-18 02:53:22','in-depth-understanding-of-z-index'),(294,3,3,'标准盒模型的可视尺寸和占据尺寸','这是标准盒子模型：\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/standard_box.png)\r\n\r\n图中 **实线包围** 的区域就是 **可视尺寸**（`clientWidth`，标准的）。\r\n\r\n图中 **虚线包围** 的区域就是 **占据尺寸**（`outerWidth`，非标准的）。','2017-08-18 02:59:46','2017-08-18 02:59:46','standard-box-visual-size-and-occupy-the-size-of-the-model'),(295,3,3,'使用 margin 搞定一侧定宽的自适应布局','没有设定宽高的普通 block 元素有个特点：\r\n\r\n> 可视尺寸的宽度随水平方向 margin  设定而改变。\r\n\r\n由此特点，可以实现一侧定宽的自适应布局。\r\n\r\n```\r\n<div class=\"box\">\r\n	<img src=\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/780908/profile/profile-80.jpg?2\" alt=\"img\">\r\n	<div>z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用z-index 只对定位元素起作用</div>\r\n</div>\r\n```\r\n\r\n```\r\n.box {\r\n	width: 678px;\r\n}\r\n\r\n.box > img {\r\n	width: 150px;\r\n	float: left;\r\n}\r\n\r\n.box > div {\r\n	margin-left: 180px;\r\n}\r\n```\r\n\r\ndemo 看 [这里](https://codepen.io/zhangbao/pen/zdRxMK)。','2017-08-18 03:14:20','2017-08-18 03:14:20','use-margin-fix-side-wide-adaptive-layout'),(296,3,3,'margin 重叠的几种情况','margin 重叠，取大的那一个。\r\n\r\n## 一、适应的元素\r\n\r\n垂直方向上设置了 margin（`margin-top` 和 `margin-bottom`）的 block 水平元素。\r\n\r\n## 二、3 种情况\r\n\r\n1. 相邻的兄弟的元素之间。\r\n2. 父级元素和第一个/最后一个子元素之间。\r\n3.  空的 block 元素（自己跟自己）。\r\n\r\n### 相邻的兄弟的元素\r\n\r\n```\r\n<style>\r\np {\r\n	margin: 1em 0;\r\n}\r\n</style>\r\n\r\n<p>p1</p>\r\n<p>p2</p>\r\n```\r\n\r\np1 和 p2 之间的 margin 只有 `1em`。\r\n\r\n### 父级元素和第一个/最后一个子元素\r\n\r\n```\r\n<style>\r\n.father {\r\n	background: #eee;\r\n}\r\n\r\n.son {\r\n	margin-top: 80px;\r\n}\r\n</style>\r\n\r\n<div class=\"father\">\r\n	<div class=\"son\">son</div>\r\n</div>\r\n\r\n<!--  等同于 -->\r\n<div class=\"father\" style=\"margin-top: 80px;\">\r\n	<div class=\"son\">son</div>\r\n</div>\r\n\r\n<!--  等同于 -->\r\n<div class=\"father\" style=\"margin-top: 80px;\">\r\n	<div class=\"son\" style=\"margin-top: 80px;\">son</div>\r\n</div>\r\n```\r\n\r\n### 父子元素 margin 重叠条件\r\n\r\n| `margin-top` 重叠 |  `margin-bottom` 重叠 | \r\n| -------- | -------- | \r\n| 1. 父元素不是 BFC     | 1. 父元素不是 BFC      | \r\n| 2. 父元素无 `border-top` 设置   | 2. 父元素无 `border-top` 设置     | \r\n| 3. 父元素无 `padding-top` 设置     | 3. 父元素无 `padding-top` 设置     | \r\n| 4. 父元素与第一个子元素之间没有 inline 元素分隔     | 4. 父元素与第一个子元素之间没有 inline 元素分隔     | \r\n|     | 5. 父元素没有 `height`、`min-height` 和 `max-height` 限制  |','2017-08-18 04:52:28','2017-08-18 05:12:05','margin-of-overlapping-several-ways'),(297,3,3,'为何图片没有居中效果？','一张图片设置了 \r\n\r\n```\r\nimg {\r\n	width: 200px;\r\n	margin: 0 auto;\r\n}\r\n```\r\n\r\n为何不居中显示呢？\r\n\r\n因为图片是 inine 水平元素，在没设置高度时，宽度并没有撑满容器。而 `margin: auto` 是用来分配 **剩余空间** 的，既然没有剩余空间可以分配，自然就不会在容器中居中显示了。','2017-08-18 05:51:33','2017-08-18 05:52:00','why-not-centered-effect-picture'),(298,3,3,'margin 无效的几种情况','inline 水平元素的垂直 margin 无效。但有两个前提：\r\n\r\n1. 替换元素除外。比如：`<img>`\r\n\r\n2. 正常书写模式：\r\n\r\n```\r\n<span style=\"margin: 100px;\">span</span>\r\n```\r\n\r\n---\r\n\r\nmargin 重叠：\r\n\r\n兄弟元素之间、父子元素之间。\r\n\r\n---\r\n\r\ndisplay 为 table 类型（比如 `display: table-cell`）的不支持 margin。\r\n\r\n例外的替换元素：\r\n\r\n* 在 Firefox 浏览器中，设定为 table-cell 类型，表现是 inline-block 元素。\r\n* 在 IE 浏览器中，设定为 table-cell 类型，表现也是 table-cell 元素。\r\n\r\n---\r\n\r\n正常流中，`margin-start` 等同于 `margin-left`，`margin-end` 等同于 `margin-right`。\r\n\r\n在垂直流中（`writing-mode: vertical-*`），`margin-start` 等同于 `margin-top`，`margin-end` 等同于 `margin-bottom`。','2017-08-18 07:53:41','2017-08-18 07:53:52','margin-invalid-several-ways'),(299,3,3,'CSS深入理解值`padding`','## 对于 block 水平元素\r\n\r\n* padding 值暴走，一定会影响元素尺寸。\r\n* 当 width 值 **不是 auto**，padding 会影响尺寸。\r\n* width 为 `auto` 或者 `box-sizing: border-box`，同时 padding 值没有暴走，不会影响元素尺寸。\r\n\r\n## 对于 inline 水平元素\r\n\r\n在水平方向上， padding 会影响元素尺寸；在垂直方向上， padding 不会影响元素尺寸，**但会扩大背景色**。\r\n\r\n可调整高度的分割线，用 padding 实现：https://codepen.io/zhangbao/pen/zdRBBm\r\n\r\n```\r\n<style>\r\nspan {\r\n	padding: 14px 6px 3px;\r\n	margin-left: 12px;\r\n	border-left: 1px dashed;\r\n	font-size: 0;\r\n}\r\n</style>\r\n\r\n注册<span></span>退出登录\r\n```\r\n\r\n## 内置 padding 值\r\n\r\n* `ul`、`ol` 默认 `padding-left: 40px;`。\r\n* 所有浏览器 input/textarea 输入框都有内置 padding。\r\n* 所有浏览器 button 按钮都有内置 padding。\r\n* 部分浏览器 select 下拉框有内置 padding，比如 FireFox。IE8+可以通过设置 padding 让 select 变大。\r\n* 所有浏览器 radio/checkbox 选框无内置 padding。\r\n* button 按钮 padding 最难控制。在 Firefox 下设置 button 0 padding——`button::-moz-focus-inner { padding: 0; }`；IE7 文字越多，button 两边空白越大，那么设置 button 0 padding——`button { overflow: visible; }`。','2017-08-18 08:47:05','2017-08-18 09:01:58','understanding-the-css-value-padding'),(300,3,3,'在 Laravel 中打印产生的 SQL','```\r\nRoute::get(\'smile\', function () {\r\n    DB::enableQueryLog();\r\n    DB::table(\'users\')->skip(10)->take(5)->get();\r\n    $queries = DB::getQueryLog();\r\n    dd($queries);\r\n});\r\n```','2017-08-18 09:38:59','2017-08-18 09:56:54','print-the-sql-in-laravel'),(301,3,3,'Laravel 项目开发规范','> 原文链接：https://fsdhub.com/books/laravel-specification\r\n\r\n## 1.1 关于规范\r\n\r\n### 目的\r\n\r\n制定规范的目的在于 **统一编码规则**。\r\n\r\n### 开发哲学\r\n\r\n在统一编码规则之外，还遵循以下「开发哲学」：\r\n\r\n* DRY –「Don\'t Repeat Yourself」。\r\n* 约定俗成 - 「Convention Over Configuration」。\r\n* KISS - 「Keep it Simple, Stupid」，不过度设计。\r\n* 主厨精选 - 让有经验的人来为你选择方案，不独创方案；\r\n* 官方提倡 - 优先选择官方推崇的方案。\r\n\r\n### 程序设计理念\r\n\r\n以下是一些优秀的「程序设计理念」：\r\n\r\n* MVC - Model, View, Controller ，以 MVC 为核心，严格控制 Controller 的可读性和代码行数；\r\n* Restful - 利用「资源化概念」和标准的 HTTP 动词来组织你的程序；\r\n\r\n## 1.2 一种选择\r\n\r\n当一个功能有多种实现方式时，只选其一。\r\n\r\n比如，用户授权，实现方式有：\r\n\r\n* 闭包\r\n* 类方法\r\n* Policy 授权决策类\r\n\r\n那么就毫不犹豫地 **选择其中一种使用**。\r\n\r\n## 2.1 Laravel 版本选择\r\n\r\n应该优先考虑 LTS 版本，不应该使用最新版本的「Laravel 一般发行版」。\r\n\r\n使用以下命令创建 Laravel 项目：\r\n\r\n```\r\ncomposer create-project laravel/laravel project-name --prefer-dist \"5.5.*\"\r\n```\r\n\r\n## 2.2 开发和线上环境\r\n\r\n应该有 3 个项目环境：\r\n\r\n* Local - 开发环境\r\n* Staging - 线上测试环境\r\n* Production - 线上生产环境\r\n\r\n### 软件版本\r\n\r\n应该优先考虑 PHP 7；应该优先考虑 MySQL 5.7；\r\n\r\n## 2.4 配置信息与环境变量\r\n\r\n### 环境变量\r\n\r\n在配置文件中（比如） `config/app.php` 中使用 `env()` 方法获取环境变量；绝不在配置文件以外的范围使用 `env()`。\r\n\r\n### 配置信息\r\n\r\n程序配置信息必须通过 `config()` 方法读取，所有的 `.env` 文件里的信息必须通过 `config()` 来读取。\r\n\r\n\r\n## 2.5 自定义辅助函数\r\n\r\n必须 把所有的「自定义辅助函数」存放于 `bootstrap` 文件夹中。\r\n\r\n并在 `bootstrap/app.php` 文件的最顶部进行加载：\r\n\r\n```\r\n<?php\r\n\r\nrequire __DIR__ . \'/helpers.php\';\r\n\r\n...\r\n```\r\n\r\nhttps://fsdhub.com/books/laravel-specification/\r\n\r\nhttps://fsdhub.com/books/laravel-specification/525/tool-unification','2017-08-19 06:35:59','2017-08-19 06:55:44','laravel-project'),(302,3,3,'2017年8月19号','我在想在以前难道我就没有不知道该做什么的时候吗？\r\n\r\n现在我突然觉得空下来的时间无事可做。我不想唱歌，去哪儿？特别在学习乏力的时候。\r\n\r\n没有人可以交流。','2017-08-19 12:04:52','2017-08-19 12:04:52','on-august-19th-2017'),(303,3,3,'MySQL 统计每个月的帖子数 SQL','## 方法一、\r\n\r\n```\r\nmysql> SELECT year(created_at) year, month(created_at) month, count(*) total from discussions group by year(created_at),month(created_at);\r\n```\r\n\r\n## 方法二、\r\n\r\n```\r\nselect DATE_FORMAT(created_at, \'%Y年%m月\'), count(*) from discussions group by DATE_FORMAT(created_at, \'%Y年%m月\');\r\n```','2017-08-20 01:35:21','2017-08-20 01:45:18','mysql-statistics-on-the-number-of-posts-per-month-sql'),(304,3,3,'Laravel Blade 模板引擎的 `@component` 指令','> 参考链接：https://laravel.com/docs/5.4/blade#components-and-slots\r\n\r\nLaravel 5.4 为 Blade 模板引擎引入了 `@component` 指令，它在一定程度上代替了 `@include` / `@includeIf` 指令的作用，能更加清楚地表示要引入的是组件。\r\n\r\n下面举例子。先定义一个 Alert 组件。\r\n\r\n```\r\n<!-- /resources/views/alert.blade.php -->\r\n\r\n<div class=\"alert alert-danger\">\r\n    <div class=\"alert-title\">{{ $title }}</div>\r\n\r\n    {{ $slot }}\r\n</div>\r\n```\r\n\r\n引入组件\r\n\r\n```\r\n@component(\'alert\')\r\n    @slot(\'title\')\r\n        Forbidden\r\n    @endslot\r\n\r\n    You are not allowed to access this resource!\r\n@endcomponent\r\n```\r\n\r\n在组件中，`$slot` 是一个特殊的变量，它表示传递给组件的内容。引入组件时，除 `@slot` 指令之外的其余部分都被当做 `$slot` 的值、最终插入组件模板中 `{{ $slot }}` 所在的位置上。\r\n\r\n`@slot` 指令用来指定组件中**命名槽变量**，在这里指 `title`——相对于组件默认支持的变量 `slot` 而言，它是用户自己命名的，所以被称为命名槽变量。','2017-08-20 01:38:49','2017-08-20 01:38:49','laravel-blade-at-template-engine-component-instructions'),(305,3,3,'执行 DatabaseSeeder 时产生多条、随机数量的伪数据记录','例如作者（Author）和博文（Post） 是一对多的关系。\r\n\r\nAuthor Model\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Author extends Model\r\n{\r\n    public function posts()\r\n    {\r\n        return $this->hasMany(Post::class);\r\n    }\r\n}\r\n```\r\n\r\nPost Model\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Post extends Model\r\n{\r\n    public function author()\r\n    {\r\n        return $this->belongsTo(Author::class);\r\n    }\r\n}\r\n```\r\n\r\n`DatabaseSeeder::run()` 方法\r\n\r\n```\r\npublic function run()\r\n{\r\n    $authors = factory(App\\Models\\Author::class, 5)->create();\r\n    $authors->each(function ($author) {\r\n        $author\r\n            ->posts()\r\n            ->saveMany(\r\n                factory(App\\Models\\Post::class, rand(20,30))->make()\r\n            );\r\n    });\r\n}\r\n```\r\n\r\n我们先向数据库中插入了 5 条作者记录，然后遍历作者记录、为每位作者随机伪造20条~30条的博文。','2017-08-20 05:41:54','2017-08-20 05:41:54','when-performing-a-databaseseeder-produce-multiple-random-number-of-pseudo-data-records'),(306,3,3,'报错：Failed to open stream：Permission denied\' error','执行 `php artisan migrate:refresh` 命令报错：\r\n\r\n> Failed to open stream：Permission denied\' error\r\n\r\n解决办法：\r\n\r\n```\r\nphp artisan cache:clear \r\n\r\nchmod -R 777 app/storage # for laravel < 5.4\r\nchmod -R 777 storage/ # for laravel >= 5.4\r\n\r\ncomposer dump-autoload\r\n```\r\n\r\n参考链接：https://stackoverflow.com/questions/23540083/failed-to-open-stream-permission-denied-error-laravel','2017-08-20 06:02:52','2017-08-20 06:02:52','error-failed-to-open-stream-permission-denied-error'),(307,3,3,'ORM 和 Eloquent','## ORM\r\n\r\nORM（Object Relational mapping） 称为『对象关系映射』，是针对面向对象的编程语言（比如 PHP）和关系型数据库（比如 MySQL）的一种技术，它的目的是为了实现这两种不同类型的数据系统的 **数据交互**。\r\n\r\n简答点说就是：\r\n\r\n1. 用一个 PHP Class 代表数据库里的一张表，这个 Class 被称为『模型』（Model）。在 Laravel 中，所有继承 `Illuminate\\Database\\Eloquent\\Model` 的类就是一个模型。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Author extends Model\r\n{\r\n\r\n}\r\n```\r\n\r\n2. 类的一个实例表示数据库里的一条记录。\r\n\r\n```\r\n// $author 表示数据库表 `authors` 中主键是 `1` 的那条记录\r\n$author = Author::find(1);\r\n```\r\n\r\n3. 对 Model 操作都会映射成对应的 SQL 语句，你几乎不用写原生 SQL 了\r\n\r\n```\r\n$author->name = \'baooab\'；\r\n$author->save();\r\n\r\n// 产生的 SQL 如下：\r\nupdate `authors` set `name` = \'baooab\', `updated_at` = \'2017-08-20 15:10:43\' where `id` = 1;\r\n```\r\n\r\n## Eloquent\r\n\r\nLaravel 的 ORM 实现称为『Eloquent』，又称『Eloquent ORM』。Laravel 中的模型是 ORM 实现的载体，称 『Eloquent Model』，简称『Model』。','2017-08-20 07:15:44','2017-08-20 07:15:44','orm-and-eloquent'),(308,3,3,'用热加载优化 Eloquent 查询（待续）','> 参考并衍生自：https://laravel-news.com/eloquent-eager-loading\r\n\r\nLaravel 的 ORM 实现称为『Eloquent』，又称『Eloquent ORM』。如果你已经知道了它，但还不知道『热加载』，现在就是充电的时候了。\r\n\r\n## 热加载\r\n\r\n如果在你的代码中，使用查询构造器（Query Builder）的 `with` 方法，就表示你已经在用热加载了。\r\n\r\n```\r\n$author = Author::where(\'name\', \'zhangbao\')->with(\'posts\')->first();\r\n```\r\n\r\n获得用户『zhangbao』的信息，并把他的所有的文章也拿到。它会执行下面两条语句。\r\n\r\n```\r\nselect * from `authors` where `name` = \'zhangbao\' limit 1;\r\n\r\nselect * from `posts` where `posts`.`author_id` in (1);  \r\n```\r\n\r\n现在，你就可以用 `$author->posts` \r\n\r\n\r\n\r\nhttps://laravel-news.com/eloquent-eager-loading','2017-08-20 07:16:04','2017-08-20 07:34:38','heat-load-optimization-eloquent-query-to-be-continued'),(309,3,3,'Laravel 文档阅读：数据库之数据填充','> 翻译、衍生自：https://laravel.com/docs/5.4/seeding\r\n\r\n## 简介\r\n\r\n种子类（Seed Classes）保存在 `database/seeds` 目录。种子类的命名，使用像 `UsersTableSeeder` 这样的约定（Convention）方式。默认，已为你创建了一个名为 `DatabaseSeeder` 的类，在该类内部可以使用 `call` 方法调用其他种子类、控制种子类的执行顺序。\r\n\r\n## 写种子\r\n\r\n一个种子类就是一个种子（Seeder）。使用 Artisan 命令 `make:seeder` 创建种子，所有创建的种子保存在 `database/seeds` 目录。\r\n\r\n```\r\nphp artisan make:seeder UsersTableSeeder\r\n```\r\n\r\n一个种子类默认仅包含一个方法：`run`。这个方法在执行 Artisan 命令 `db:seed` 时被调用。在 `run` 方法内部，定义向数据库插入数据的逻辑。你可以使用查询语句构造器（Query Builder）手动插入数据或者使用 Eloquent 模型工厂方法（Eloquent model factories）。\r\n\r\n下面是使用查询语句构造器手动插入数据的例子：\r\n\r\n```\r\n<?php\r\n\r\nuse Illuminate\\Database\\Seeder;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass DatabaseSeeder extends Seeder\r\n{\r\n    /**\r\n     * Run the database seeds.\r\n     *\r\n     * @return void\r\n     */\r\n    public function run()\r\n    {\r\n        DB::table(\'users\')->insert([\r\n            \'name\' => str_random(10),\r\n            \'email\' => str_random(10).\'@gmail.com\',\r\n            \'password\' => bcrypt(\'secret\'),\r\n        ]);\r\n    }\r\n}\r\n```\r\n\r\n### 使用模型工厂方法\r\n\r\n有时，使用查询语句构造器手动插入数据会很麻烦，比如插入的数据量很大时，那么这时就可以选择使用模型工厂方法。首先，定义好模型工厂方法，接着就可以使用 `factory` 辅助方法向数据库插入数据了。\r\n\r\n下面我们创建了 50 个用户并为每个用户伪造了一篇博文。\r\n\r\n```\r\n/**\r\n * Run the database seeds.\r\n *\r\n * @return void\r\n */\r\npublic function run()\r\n{\r\n    factory(App\\Models\\User::class, 50)->create()->each(function ($u) {\r\n        $u->posts()->save(factory(App\\Models\\Post::class)->make());\r\n    });\r\n}\r\n```\r\n\r\n### 调用种子类\r\n\r\n已经说过，在 `DatabaseSeeder` 类内部使用 `call` 方法调用种子类。\r\n\r\n使用种子类的好处：可以将向数据库填充数据的逻辑拆分到多个文件里，从而避免将填充数据的逻辑统一写在一个文件里造成的文件过于巨大的问题。并且，你可以使用 `call` 方法、更加细粒度地、有选择地调用种子类，并控制种子类的执行顺序。\r\n\r\n下面是一个例子：\r\n\r\n```\r\n/**\r\n * Run the database seeds.\r\n *\r\n * @return void\r\n */\r\npublic function run()\r\n{\r\n    $this->call(UsersTableSeeder::class);\r\n    $this->call(PostsTableSeeder::class);\r\n    $this->call(CommentsTableSeeder::class);\r\n}\r\n```\r\n\r\n##  执行种子\r\n\r\n一旦写好种子类，或者在 `DatabaseSeeder` 类中定义好了调用种子类的逻辑，就可以使用 Artisan 命令 `db:seed` 执行种子、向数据库填充数据了。\r\n\r\nArtisan 命令 `db:seed` 默认运行 `DatabaseSeeder` 类；当然也可以使用 `--class` 选项指定要运行的种子类。\r\n\r\n```\r\nphp artisan db:seed\r\n\r\nphp artisan db:seed --class=UsersTableSeeder\r\n```\r\n\r\n也可以在运行 `migrate:refresh` 命令时，通过指定 `--seed` 选项的方式填充数据。\r\n\r\n```\r\nphp artisan migrate:refresh --seed\r\n```\r\n\r\n这句命令表示：还原&重新执行所有迁移，完成后再向数据库填充数据。','2017-08-21 01:36:57','2017-08-21 02:08:38','laravel-document-reading-the-data-of-database-fill'),(310,3,3,'测试本站 markdown 是否支持注脚写法','我在 [这里][^1] 添加了一个注脚，然而并没有什么卵用。\r\n\r\n[^1]: 我是可爱的脚注一~','2017-08-21 15:11:03','2017-08-22 09:37:32','test-the-markdown-support-footnote-writing'),(311,3,3,'Laravel 文档阅读：数据库起步','> 翻译、衍生自：https://laravel.com/docs/5.4/database\r\n\r\n## 简介\r\n\r\nLaravel 让开发者与多种数据库的交互变得非常简单，主要是利用 [查询语句构造器](https://laravel.com/docs/5.4/queries) 和 [Eloquent ORM](https://laravel.com/docs/5.4/eloquent) 帮您产生与业务逻辑对应的原生 SQL 语句，避免了开发者手动书写 SQL 语句带来的烦恼。现支持的数据库如下：\r\n\r\n* MySQL\r\n* Postgres\r\n* SQLite\r\n* SQL Server\r\n\r\n### 配置\r\n\r\n数据库配置文件是 `config/database.php`。你可以根据实际情况，修改或添加你的数据库信息，指定默认使用的数据库连接（database connections）。\r\n\r\n#### 配置 SQLite\r\n\r\n配置  SQLite 需要先创建一个数据库，使用 `touch database/database.sqlite` 创建，然后再配置你的环境变量——使用绝对路径指向这个新创建的数据库。\r\n\r\n	DB_CONNECTION=sqlite\r\n	DB_DATABASE=/absolute/path/to/database.sqlite\r\n\r\n#### 配置 SQL Server\r\n\r\nLaravel 在配置文件 `config/database.php` 中，已经为您预设了 SQL Server 的连接信息，只需要按照实际情况修改即可：\r\n\r\n	\'sqlsrv\' => [\r\n		\'driver\' => \'sqlsrv\',\r\n		\'host\' => env(\'DB_HOST\', \'localhost\'),\r\n		\'database\' => env(\'DB_DATABASE\', \'forge\'),\r\n		\'username\' => env(\'DB_USERNAME\', \'forge\'),\r\n		\'password\' => env(\'DB_PASSWORD\', \'\'),\r\n		\'charset\' => \'utf8\',\r\n		\'prefix\' => \'\',\r\n	],\r\n\r\n### 读 & 写连接\r\n\r\n有时，您希望项目使用两种数据库——一种负责读，也就是用来执行 `select` 语句；另一种负责写，用来执行 `insert`、`update` 和 `delete` 语句。Laravel 使之变得轻而易举，无论您是使用原生查询、查询语句构造器还是Eloquent ORM，都会始终使用正确的连接。\r\n\r\n具体读 & 写连接的配置方式，看下面的例子可知：\r\n\r\n	\'mysql\' => [\r\n		\'read\' => [\r\n			\'host\' => \'192.168.1.1\',\r\n		],\r\n		\'write\' => [\r\n			\'host\' => \'196.168.1.2\'\r\n		],\r\n		\'driver\'    => \'mysql\',\r\n		\'database\'  => \'database\',\r\n		\'username\'  => \'root\',\r\n		\'password\'  => \'\',\r\n		\'charset\' => \'utf8mb4\',\r\n		\'collation\' => \'utf8mb4_unicode_ci\',\r\n		\'prefix\'    => \'\',\r\n	],\r\n\r\n我们为配置信息添加了两个键：`read` 和 `write`。两个键里又包含 `host` 键。在 `mysql` 中，其余的配置信息是读 & 写连接共用的配置信息。\r\n\r\n在上面例子里，`192.168.1.1` 这台主机用来「读」， `196.168.1.2` 这台主机用来「写」。而其余像用户名、密码、数据库编码等都是两个连接共用的配置。\r\n\r\n### 使用多数据库连接\r\n\r\n`DB` 门面提供了 `connection` 方法，用来获得某个连接。用它就可以实现使用多数据库连接的需求。给 `connection ` 传递是一个「连接名」，这个连接名必然是要在 `config/database.php` 里配置的。\r\n\r\n	$users = DB::connection(\'foo\')->select(...);\r\n\r\n您可以用连接实例的 `getPdo` 方法获得底层 `PDO` 实例。\r\n\r\n	$pdo = DB::connection()->getPdo();\r\n\r\n## 执行原生 SQL 查询\r\n\r\n使用 `DB` 门面可以完成每种类型的查询：`select`、`update`、`insert`、`delete` 和 `statement`。\r\n\r\n#### 执行 `select` 查询\r\n\r\n使用 `DB` 门面的 `select` 方法可执行查询：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Support\\Facades\\DB;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class UserController extends Controller\r\n	{\r\n		/**\r\n		 * Show a list of all of the application\'s users.\r\n		 *\r\n		 * @return Response\r\n		 */\r\n		public function index()\r\n		{\r\n			$users = DB::select(\'select * from users where active = ?\', [1]);\r\n\r\n			return view(\'user.index\', [\'users\' => $users]);\r\n		}\r\n	}\r\n\r\n`select` 方法的第一个参数就是原生的 SQL 语句，第二个参数是绑定到语句的参数。绑定的参数通常是 `where` 子句约束条件，这可保护程序免受 SQL 注入危害。\r\n\r\n`select` 方法返回一个结果数组，每个数组成员都是一个 PHP `StdClass` 对象：\r\n\r\n	foreach ($users as $user) {\r\n		echo $user->name;\r\n	}\r\n\r\n#### 使用命名参数\r\n\r\n你可以选择使用命名参数的形式代替 `?` 占位符：\r\n\r\n	$results = DB::select(\'select * from users where id = :id\', [\'id\' => 1]);\r\n\r\n#### 执行 `insert` 语句\r\n\r\n使用 `DB` 门面的 `insert` 方法插入数据。形如 `select` 方法，`DB:insert` 的第一个参数是原生 SQL 语句，第二个参数是绑定参数：\r\n\r\n	DB::insert(\'insert into users (id, name) values (?, ?)\', [1, \'Dayle\']);\r\n\r\n#### 执行 `update` 语句\r\n\r\n`update` 方法用来更新数据库中已存在的记录，返回的结果是更新的记录数目。\r\n\r\n	$affected = DB::update(\'update users set votes = 100 where name = ?\', [\'John\']);\r\n\r\n#### 执行 `delete` 语句\r\n\r\n`update` 方法用来从数据库中删除记录，类似 `update` 方法，返回的结果是删除的记录数目。\r\n\r\n#### 执行一般语句\r\n\r\n「一般语句」指没有返回结果的 SQL 语句。对于这类操作，可以使用 `DB` 门面上的 `statement` 方法。\r\n\r\n	DB::statement(\'drop table users\');\r\n\r\n### 监听查询事件\r\n\r\n如果你要查阅 Laravel 底层执行的 SQL 语句，可以使用 `listen` 方法，这个方法会在程序执行 SQL 语句时调用。这对 debug 程序和记录 SQL 语句非常有用。你可以在服务提供者 `AppServiceProvider ` 中注册、监听查询事件。\r\n\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use Illuminate\\Support\\Facades\\DB;\r\n	use Illuminate\\Support\\ServiceProvider;\r\n\r\n	class AppServiceProvider extends ServiceProvider\r\n	{\r\n		/**\r\n		 * Bootstrap any application services.\r\n		 *\r\n		 * @return void\r\n		 */\r\n		public function boot()\r\n		{\r\n			DB::listen(function ($query) {\r\n				// $query->sql\r\n				// $query->bindings\r\n				// $query->time\r\n			});\r\n		}\r\n\r\n		/**\r\n		 * Register the service provider.\r\n		 *\r\n		 * @return void\r\n		 */\r\n		public function register()\r\n		{\r\n			//\r\n		}\r\n	}\r\n\r\n## 数据库事务\r\n\r\n你可以用 `DB` 门面的 `transaction` 方法在一个事务里执行一系列操作。如果事务闭包里抛出异常，那么事务就会自动回滚。如果闭包执行成功，那么事务就会自动提交。使用 `transaction` 方法就无需手动回滚或者提交事务了：\r\n\r\n	DB::transaction(function () {\r\n		DB::table(\'users\')->update([\'votes\' => 1]);\r\n\r\n		DB::table(\'posts\')->delete();\r\n	});\r\n\r\n#### 解决死锁\r\n\r\n`transaction` 方法还要第二个参数可供指定——当死锁发生时，事务最大的尝试次数。一旦超过这个指定次数，就会抛出异常：\r\n\r\n	DB::transaction(function () {\r\n		DB::table(\'users\')->update([\'votes\' => 1]);\r\n\r\n		DB::table(\'posts\')->delete();\r\n	}, 5);\r\n\r\n#### 手动使用事务\r\n\r\n如果你要完全手动控制事务的回滚和提交，就要用 `BD` 门面的 `beginTransaction` 方法了：\r\n\r\n	DB::beginTransaction();\r\n\r\n使用 `rollBack` 方法回滚事务：\r\n\r\n	DB::rollBack();\r\n\r\n最后，使用 `commit` 方法提交事务：\r\n\r\n	DB::commit();','2017-08-24 02:32:01','2017-08-24 04:58:34','laravel-document-reading-start-database-to-be-continued'),(312,3,3,'2017年8月24号','我刚才小睡了以下，梦中的感觉并不好，飞逝的场景是昏暗光线下的从前，跟现景没有丝毫联系。\r\n\r\n我好像感觉到一种“痴”得感觉。看了下时间好像也并没有走动！还是我躺下得那一刻！\r\n\r\n坚持感受与表达。?','2017-08-24 12:19:39','2017-08-24 12:19:39','on-august-24-2017'),(313,3,3,'Laravel 文档阅读：数据库之查询语句构造器（上篇）','> 翻译、衍生自：https://laravel.com/docs/5.4/queries\r\n\r\n## 简介\r\n\r\nLaravel 的查询构造器（query builder）提供流畅的接口，帮助你构造、执行数据库查询。这里的「查询」，并不只是指`select` 语句，还有 `update`、`delete` 和 `insert` 语句等。在所有支持的数据库系统中都运行良好。\r\n\r\n\r\nLaravel 的查询构造器使用 PDO 参数绑定保护程序免受 SQL 注入攻击，所以你传递的绑定参数无需进行清理操作了。\r\n\r\n## 查询数据\r\n\r\n#### 获得表格里所有数据\r\n\r\n使用 `DB` 门面的 `table` 方法开启查询。`table` 方法返回给定表格的查询构造器实例，允许你用链式调用的方式为查询添加约束条件，最后使用 `get` 方法获得结果。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Support\\Facades\\DB;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class UserController extends Controller\r\n	{\r\n		/**\r\n		 * Show a list of all of the application\'s users.\r\n		 *\r\n		 * @return Response\r\n		 */\r\n		public function index()\r\n		{\r\n			$users = DB::table(\'users\')->get();\r\n\r\n			return view(\'user.index\', [\'users\' => $users]);\r\n		}\r\n	}\r\n	\r\n`get` 方法返回一个 `Illuminate\\Support\\Collection` 集合实例，集合里的每个元素都是一个 PHP `StdClass` 对象。你可以通过访问对象属性以获得对应字段的值：\r\n\r\n	foreach ($users as $user) {\r\n		echo $user->name;\r\n	}\r\n\r\n#### 获得表格里的一条数据/指定列的值\r\n\r\n使用 `first` 方法获得表格里的一条数据，这个方法返回一个 `StdClass` 对象：\r\n\r\n\r\n	$user = DB::table(\'users\')->where(\'name\', \'John\')->first();\r\n\r\n	echo $user->name;\r\n\r\n如果只是想取出一列值的话，就用 `value` 方法，这个方法会直接返回指定列的值：\r\n\r\n\r\n	$email = DB::table(\'users\')->where(\'name\', \'John\')->value(\'email\');\r\n\r\n#### 获得表格里的一列数据\r\n\r\n使用 `pluck` 方法可获得一个列的值的集合。在下面的例子里，我们获得所有的角色名：\r\n\r\n	$titles = DB::table(\'roles\')->pluck(\'title\');\r\n\r\n	foreach ($titles as $title) {\r\n		echo $title;\r\n	}\r\n\r\n也可以在返回的集合里指定自定义键：\r\n\r\n	$roles = DB::table(\'roles\')->pluck(\'title\', \'name\');\r\n\r\n	foreach ($roles as $name => $title) {\r\n		echo $title;\r\n	}\r\n\r\n### 分块输出数据\r\n\r\n如果要处理成千上万条数据，考虑使用 `chunk` 方法。这个方法一次取出一小块数据，放到闭包里处理。这在写 Artisan 命令处理成千上万条数据非常有用。例如，从 `users` 表里分块、每次输出 100 条记录：\r\n\r\n	DB::table(\'users\')->orderBy(\'id\')->chunk(100, function ($users) {\r\n		foreach ($users as $user) {\r\n			//\r\n		}\r\n	});\r\n\r\n也可以通过在闭包里 `return false` 停止继续分块输出数据。\r\n\r\n	DB::table(\'users\')->orderBy(\'id\')->chunk(100, function ($users) {\r\n		// Process the records...\r\n\r\n		return false;\r\n	});\r\n\r\n### 聚合\r\n\r\n查询构造器也提供了许多聚合方法：`count`、`max`、`min`、`avg` 和 `sum`。在构造好你的查询后即可使用：\r\n\r\n\r\n	$users = DB::table(\'users\')->count();\r\n\r\n	$price = DB::table(\'orders\')->max(\'price\');\r\n\r\n聚合方法也可以结合查询子句使用：\r\n\r\n	$price = DB::table(\'orders\')\r\n					->where(\'finalized\', 1)\r\n					->avg(\'price\');\r\n					\r\n## Select\r\n\r\n有时，并不需要获得数据表所有字段的数据，而是选择性的获得指定几个字段的数据，这时可以使用 `select` 方法：\r\n\r\n	$users = DB::table(\'users\')->select(\'name\', \'email as user_email\')->get();\r\n\r\n`distinct` 方法用于对结果去重：\r\n\r\n	$users = DB::table(\'users\')->distinct()->get();\r\n\r\n如果当前已经有了一个查询语句构造器实例，想在此基础上添加一个 select 子句，那么就要用 `addSelect` 方法了：\r\n\r\n	$query = DB::table(\'users\')->select(\'name\');\r\n\r\n	$users = $query->addSelect(\'age\')->get();\r\n\r\n## 原生表达式\r\n\r\n有时要在一个查询语句里使用原生表达式，那么使用 `DB::raw` 方法就行，传递给该方法的内容会作为字符串插入到最终的查询语句里。\r\n\r\n	$users = DB::table(\'users\')\r\n						 ->select(DB::raw(\'count(*) as user_count, status\'))\r\n						 ->where(\'status\', \'<>\', 1)\r\n						 ->groupBy(\'status\')\r\n						 ->get();\r\n\r\n## Joins\r\n\r\n#### 内连接\r\n\r\n查询语句构造器也可以用来写连接语句（join statements）。「内连接」就是用 `join` 方法，该方法的第一个参数是要连接的表，剩下的参数就是连接约束条件了。不仅如此，你可以在一个构造语句里连接多个表格：\r\n\r\n	$users = DB::table(\'users\')\r\n						->join(\'contacts\', \'users.id\', \'=\', \'contacts.user_id\')\r\n						->join(\'orders\', \'users.id\', \'=\', \'orders.user_id\')\r\n						->select(\'users.*\', \'contacts.phone\', \'orders.price\')\r\n						->get();\r\n\r\n#### 左连接\r\n\r\n左连接使用 `leftJoin` 方法，它的方法签名和 `join` 是一样的：\r\n\r\n	$user = DB::table(\'users\')\r\n						->leftJoin(\'posts\', \'users.id\', \'=\', \'posts.user_id\')\r\n						->get();\r\n\r\n#### 交叉连接\r\n\r\n交叉连接使用 `crossJoin` 方法。\r\n\r\n	$users = DB::table(\'sizes\')\r\n						->crossJoin(\'colours\')\r\n						->get();\r\n\r\n#### 高级连接子句\r\n\r\n如果要使用更加高级的连接子句，就要通过 `join` 方法的第二个参数，它是一个闭包。闭包接收一个 `JoinClause` 对象，用于对 `join`子句添加约束条件：\r\n\r\n	DB::table(\'users\')\r\n				->join(\'contatcs\', function ($join) {\r\n					$join->on(\'users.id\', \'=\', \'contatcs.user_id\')->orOn(...);\r\n				})\r\n				->get();\r\n	\r\n你还可以在 `join` 子句上使用「where」 约束，得用到 `where` 或者 `orWhere` 方法——限定列的取值范围：\r\n\r\n	DB::table(\'users\')\r\n				->join(\'contatcs\', function ($join) {\r\n					$join->on(\'users.id\', \'=\', \'contatcs.user_id\')\r\n							 ->where(\'contacts.user_id\', \'>\', 5);\r\n				})\r\n				->get();\r\n\r\n## Unions\r\n\r\n合并查询使用 `union` 方法。例如，我们把第一个查询合并到第二个查询里：\r\n\r\n	$first = DB::table(\'users\')\r\n					->whereNull(\'first_name\');\r\n\r\n	$users = DB::table(\'users\')\r\n					->whereNull(\'last_name\')\r\n					->union($first)\r\n					->get();\r\n\r\n还有一个 `unionAll` 方法，它的签名和 `union` 是一样的。\r\n\r\n## Where 子句\r\n\r\n在查询语句构造器实例上使用 `where` 方法来添加 where 子句。`where` 方法最基本的用法是给它传递 3 个参数。第一个参数是字段名，第二个参数是操作符（数据库支持的任何操作符），第三个参数是字段值。\r\n\r\n例如，下面的查询查出所有「投票」数是 100 的记录：\r\n\r\n	$users = DB::table(\'users\')->where(\'votes\', \'=\', \'100\')->get();\r\n\r\n为了方便，当验证某个字段是否等于某个值时，可以省略中间的 `=`。\r\n	\r\n	$users = DB::table(\'users\')->where(\'votes\', \'100\')->get();\r\n	\r\n除了 `=` ，这里还有使用其他操作符的例子：\r\n\r\n	$users = DB::table(\'users\')\r\n					->where(\'votes\', \'>=\', 100 )\r\n					->get();\r\n	\r\n	$users = DB::table(\'users\')\r\n					->where(\'votes\', \'<>\', 100)\r\n					->get();\r\n					\r\n	$users = DB::table(\'users\')\r\n					->where(\'name\', \'like\', \'T%\')\r\n					->get();\r\n\r\n你也可以给 `where` 方法传递一个数组，指定多个限制条件：\r\n\r\n	$users = DB::table(\'users\')->where([\r\n		[\'status\', \'=\', 1],\r\n		[\'subscribed\', \'<>\', 1]\r\n	])->get();\r\n\r\n#### Or 子句\r\n\r\n使用 `orWhere` 方法添加 `or` 子句约束。`orWhere` 的方法签名和 `where` 是一样的：\r\n\r\n	$users = DB::table(\'users\')\r\n					->where(\'votes\', \'>\', 100)\r\n					->orWhere(\'name\', \'John\')\r\n					->get();\r\n\r\n#### 其他子句\r\n\r\n##### whereBetween\r\n\r\n`whereBetween` 方法验证字段值是否在给定范围之间。\r\n\r\n	$users = DB::table(\'users\')\r\n						->whereBetween(\'votes\', [1, 100])\r\n						->get();\r\n\r\n##### whereNotBetween\r\n\r\n`whereBetween` 方法验证字段值是否在给定范围之外。\r\n\r\n	$users = DB::table(\'users\')\r\n						->whereNotBetween(\'votes\', [1, 100])\r\n						->get();\r\n\r\n##### whereIn / whereNotIn\r\n\r\n`whereIn` 方法验证字段值是否在给定值列表里。\r\n\r\n	$users = DB::table(\'users\')\r\n						->whereIn(\'id\', [1, 2, 3])\r\n						->get();\r\n\r\n`whereNotIn` 方法验证字段值是否不在给定值列表里。\r\n\r\n	$users = DB::table(\'users\')\r\n						->whereNotIn(\'id\', [1, 2, 3])\r\n						->get();\r\n\r\n##### whereNull / whereNotNull\r\n\r\n`whereNull` 方法验证指定的字段值是否是 `null`。\r\n\r\n	$users = DB::table(\'users\')\r\n						->whereNull(\'updated_at\')\r\n						->get();\r\n\r\n`whereNotNull` 方法验证指定的字段值是否不是 `null`。\r\n\r\n	$users = DB::table(\'users\')\r\n						->whereNotNull(\'updated_at\')\r\n						->get();\r\n\r\n##### whereDate / whereMonth / whereDay / whereYear\r\n\r\n`whereDate` 用来比较字段值是否满足给定的日期。\r\n\r\n	$users = DB::table(\'users\')\r\n					->whereDate(\'created_at\', \'2016-12-31\')\r\n					->get();\r\n\r\n`whereMonth` 用来比较字段值是否满足给定的月份。\r\n\r\n	$users = DB::table(\'users\')\r\n					->whereMonth(\'created_at\', \'12\')\r\n					->get();\r\n\r\n`whereDay` 用来比较字段值是否满足给定的日期。\r\n\r\n	$users = DB::table(\'users\')\r\n					->whereDay(\'created_at\', \'31\')\r\n					->get();\r\n\r\n`whereYear` 用来比较字段值是否满足给定的年份。\r\n\r\n	$users = DB::table(\'users\')\r\n					->whereYear(\'created_at\', \'2016\')\r\n					->get();\r\n\r\n##### whereColumn\r\n\r\n`whereColumn` 用来比较两字段值是否相等：\r\n\r\n	$users = DB::table(\'users\')\r\n					->whereColumn(\'first_name\', \'last_name\')\r\n					->get();\r\n\r\n也可以使用比较操作符。\r\n\r\n	$users = DB::table(\'users\')\r\n					->whereColumn(\'updated_at\', \'>\', \'created_at\')\r\n					->get();\r\n\r\n`whereColumn` 也接受多条件判断，这些条件会使用 `and` 操作符连起来：\r\n\r\n	$users = DB::table(\'users\')\r\n					->whereColumn([\r\n						[\'first_name\', \'=\', \'last_name\'],\r\n						[\'updated_at\', \'>\', \'created_at\']\r\n					])->get();\r\n\r\n### 分组参数\r\n\r\n有时需要创建些高级的 where 子句，比如「where exists」或者内嵌分组参数。交给 Laravel 的查询语句构造器照样 OK。看个例子：\r\n\r\n	DB::table(\'users\')\r\n				->where(\'name\', \'=\', \'John\')\r\n				->orWhere(function ($query) {\r\n					$query->where(\'votes\', \'>\', 100)\r\n						  ->where(\'title\', \'<>\', \'Admin\');\r\n				})\r\n				->get();\r\n\r\n当传递 `Closure` 给 `orWhere` 方法的时候，就表示开始一个分组约束了。 `Closure` 接收一个查询实例用来在圆括号（`()`）内设定限制。上面的例子会产生下面的 SQL：\r\n\r\n	select * from users where name = \'John\' or (votes > 100 and title <> \'Admin\')\r\n\r\n### Where Exists 子句\r\n\r\n`whereExists` 方法用来写 `where exists` SQL 子句。`whereExists` 方法接收一个闭包，包含一个查询语句构造器实例，用于定义「where」子句里的内容：\r\n\r\n	DB::table(\'users\')\r\n				->whereExists(function ($query) {\r\n					$query->select(DB::raw(1))\r\n						  ->from(\'orders\')\r\n						  ->whereRaw(\'orders.user_id = users.id\');\r\n				})\r\n				->get();\r\n\r\n上面的查询产生下面的 SQL：\r\n\r\n	select * from users\r\n	where exists (\r\n		select 1 from orders where orders.user_id = users.id\r\n	)\r\n\r\n### JSON Where 子句\r\n\r\nLaravel 也支持数据库 JSON 字段类型的查询，前提是数据库支持 JSON 字段类型。现在 MySQL 5.7 和  Postgres 都支持。查询 JSON 字段，使用 `->` 操作符：\r\n\r\n	$users = DB::table(\'users\')\r\n					->where(\'options->language\', \'en\')\r\n					->get();\r\n\r\n	$users = DB::table(\'users\')\r\n					->where(\'preferences->dining->meal\', \'salad\')\r\n					->get();','2017-08-25 05:05:48','2017-08-26 13:04:47','laravel-document-reading-database-query-builder-of-on'),(314,3,3,'《哈姆雷特》节选','1. 对于哈姆雷特和他的调情献媚，你必须把他认作一时的感情冲动，一朵初春的紫罗兰早熟而易调，馥郁不能持久，一分钟的芬芳和喜悦，如此而已。\r\n\r\n2. 像新月一样逐渐饱满的人生，不仅是肌肉?和体格的成长，而且随着身体的发展，精神和心灵也同时扩大。\r\n\r\n3. 可是，我的好哥哥，你不要像有些坏牧师一样，指点我上天去的险峻的荆棘之途，自己却在花街柳巷?流连忘返，忘记了自己的箴言。\r\n\r\n4. 爱情?！呸，你讲的话完全像是一个不曾经历过这种危险的女孩子。让我来教你，你应该这样想，你是一个小孩子，把这些假意的表示当作了真心的奉献。你应该把你自己的价值抬高一些。\r\n\r\n5. 我知道在热情燃烧的时候，一个人无论什么盟誓都会说出口来的；这些火焰?，女儿，是光多于热的，一下子就会光消焰灭，因为它们本来是虚幻的，你不能把它们当做真火看待。\r\n\r\n6. 大家握握手分开了吧。你们可以去照你们自己的意思干你们自己的事，――因为各人都有个人的意思和各人的事，――至于我自己，那么我对你们说，我是要去祈祷去的。\r\n\r\n7.','2017-08-26 01:26:30','2017-08-26 02:07:05','the-extracts-of-hamlet'),(315,3,3,'Laravel 文档阅读：数据库之查询语句构造器（下篇）','## `orderBy`、`groupBy`、`limit` 和 `offset`\r\n\r\n#### `orderBy`\r\n\r\n`orderBy` 方法指定结果数据按照某个字段的升序/降序排列。它的第一个参数是排序的字段名，第二个参数是排序方向（`asc` 或者 `desc`）：\r\n\r\n	$users = DB::table(\'users\')\r\n					->orderBy(\'name\', \'desc\')\r\n					->get();\r\n\r\n#### `latest` / `oldest`\r\n\r\n`latest` / `oldest` 方法实现字段按照日期便捷地排序。默认是依据 `created_at` 字段排序的，你也可以传递要排序的字段名以便覆盖默认设定：\r\n\r\n	$user = DB::table(\'users\')\r\n					->latest()\r\n					->first();\r\n\r\n	$user = DB::table(\'users\')\r\n					->latest(\'updated_at\')\r\n					->first();\r\n\r\n#### `inRandomOrder`\r\n\r\n`inRandomOrder` 方法实现查询结果的乱序排列。例如，取得随意的一个用户信息：\r\n\r\n	$randomUser = DB::table(\'users\')\r\n					->inRandomOrder()\r\n					->first();\r\n\r\n#### `groupBy` / `having` / `havingRaw`\r\n\r\n`groupBy` 和 `having` 方法可以用来给查询结果进行分组。`having` 方法的签名类似 `where` 方法：\r\n\r\n\r\n	$users = DB::table(\'users\')\r\n					->groupBy(\'account_id\')\r\n					->having(\'account_id\', \'>\', 100)\r\n					->get();\r\n\r\n `havingRaw` 方法用来设置原生字符串到 `having` 子句中。例如，我们可以找到所有销售额大于 2500刀 的部门：\r\n \r\n	 $users = DB::table(\'orders\')\r\n					->select(\'department\', DB::raw(\'SUM(price) as total_sales\'))\r\n					->groupBy(\'department\')\r\n					->havingRaw(\'SUM(price) > 2500\')\r\n					->get();\r\n\r\n#### `skip` / `take`\r\n\r\n限制从查询返回的结果数，或者在查询中跳过给定数量的结果。你可以使用 `skip` 和 `take` 方法：\r\n\r\n	$users = DB::table(\'users\')->skip(10)->take(5)->get();\r\n\r\n或者使用起到一样作用的 `limit` 和 `offset` 方法：\r\n\r\n	$users = DB::table(\'users\')\r\n					->offset(10)\r\n					->limit(5)\r\n					->get();\r\n\r\n## 条件子句\r\n\r\n有时我们只想在某些条件成立的时候呢才去执行一些条件子句查询。比如，对于 `where` 子句，我们只想在输入数据里包含某个字段的时候，才去执行，那么这时就要用到 `when` 了。\r\n\r\n	$role = $request->input(\'role\');\r\n\r\n	$users = DB::table(\'users\')\r\n					->when($role, function ($query) use ($role) {\r\n						return $query->where(\'role_id\', $role);\r\n					})\r\n					->get();\r\n\r\n在上面这段代码里，只有当闭包的第一个参数（`$role`）判定为 `true`  时才会执行。如果第一个参数的判定值是 `false`，那么就不会执行闭包里的内容。\r\n\r\n`when` 方法还接受第三个参数，跟第二个参数一样，也是一个闭包——当判定条件（第一个参数）为 `false` 时，就会执行这里的逻辑。为了说明这个方法的使用场景，我们来举一个配置默认使用的排序字段的例子：\r\n\r\n	$sortBy = null;\r\n\r\n	$users = DB::table(\'users\')\r\n					->when($sortBy, function ($query) use ($sortBy) {\r\n						return $query->orderBy($sortBy);\r\n					}, function ($query) {\r\n						return $query->orderBy(\'name\');\r\n					})\r\n					->get();\r\n\r\n## 插入\r\n\r\n查询语句构造器还提供一个 `insert` 方法用来项数据库插入数据。`insert` 方法接收一个包含字段键值组成的数组。\r\n\r\n	DB::table(\'users\')->insert(\r\n		[\'email\' => \'john@example.com\', \'votes\' => 0]\r\n	);\r\n\r\n当然 `insert ` 方法也支持同时插入多条数据：\r\n\r\n	DB::table(\'users\')->insert([\r\n		[\'email\' => \'taylor@example.com\', \'votes\' => 0],\r\n		[\'email\' => \'dayle@example.com\', \'votes\' => 0]\r\n	]);\r\n\r\n#### 自增 ID\r\n\r\n如果包含一个自增 ID，那么可以使用 `insertGetId` 来获得插入的记录的 ID 值：\r\n\r\n	$id = DB::table(\'users\')->insertGetId(\r\n		[\'email\' => \'john@example.com\', \'votes\' => 0]\r\n	);\r\n\r\n## 更新\r\n\r\n除了向数据库插入数据，查询语句构造器还提供了更新已存在记录的 `update` 方法。与 `insert` 方法类似， `update` 方法接收一个要更新的、包含字段键值组成的数组。\r\n\r\n	DB::table(\'users\')\r\n				->where(\'id\', 1)\r\n				->update([\'votes\' => 1]);\r\n\r\n### 更新 JSON 字段类型\r\n\r\n更新 JSON 字段类型，需要用到 `->` 语法，不过这仅在支持 JSON 字段类型的数据库中有效。\r\n\r\n	DB::table(\'users\')\r\n				->where(\'id\', 1)\r\n				->update([\'options->enabled\' => true]);\r\n\r\n\r\n### Increment / Decrement\r\n\r\n查询语句构造器也提供了用来增加/减少某个字段值的方法 `increment` / `decrement`。这只是一个语法糖，与手动编写 `update` 语句相比，提供了更具表现力和简洁的 API。\r\n\r\n	DB::table(\'users\')->increment(\'votes\');\r\n\r\n	DB::table(\'users\')->increment(\'votes\', 5);\r\n\r\n	DB::table(\'users\')->decrement(\'votes\');\r\n\r\n	DB::table(\'users\')->decrement(\'votes\', 5);\r\n\r\n这两个方法都至少接受一个参数，那就是要修改的字段。第二个控制增加/减少的数量，默认是 `1`。\r\n\r\n当然，我们还可以额外的提供其他要修改的字段：\r\n\r\n	DB::table(\'users\')->increment(\'votes\', 1, [\'name\' => \'John\']);\r\n\r\n## 删除\r\n\r\n使用 `delete` 方法从数据库表删除记录，可以在使用时用 `where` 子句来添加约束条件：\r\n\r\n	DB::table(\'users\')->delete();\r\n\r\n	DB::table(\'users\')->where(\'votes\', \'>\', 100)->delete();\r\n\r\n如果要清空整张表——删除所有数据、将自动递增主键 ID 设置为 0，那么就要用 `truncate` 方法：\r\n\r\n	DB::table(\'users\')->truncate();\r\n\r\n## 悲观锁\r\n\r\n「悲观锁」作用在 `select` 语句上，如果要使用「共享锁」运行语句，可以在查询上使用 `sharedLock` 方法。共享锁可以保证用户 **在读取数据时**，除非事务提交，否则 **数据不会被修改**。\r\n\r\n	DB::table(\'users\')->where(\'votes\', \'>\', 100)->sharedLock()->get();\r\n\r\n还有一个 `lockForUpdate` 方法，比  `sharedLock` 还厉害——可以保证用户 **在读取数据时，保证数据不被修改或被另一个共享锁所选择**。\r\n\r\n	DB::table(\'users\')->where(\'votes\', \'>\', 100)->lockForUpdate()->get();','2017-08-27 04:44:11','2017-08-27 05:00:13','laravel-document-reading-the-database-query-constructor-next'),(316,3,3,'MySQL Locking Reads','https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html','2017-08-27 05:29:46','2017-08-27 05:29:46','mysql'),(317,3,3,'Elasticsearch API 介绍','构建 Elasticsearch 客户端：\r\n\r\n    $hosts = [\r\n        \'http://elastic:changeme@192.168.1.222:9200\',         // IP + Port\r\n    ];\r\n\r\n    $client = \\Elasticsearch\\ClientBuilder::create()\r\n        ->setHosts($hosts)\r\n        ->build();\r\n		\r\n按照降序查询「2017-08-14」这一日的日志：\r\n\r\n	$params = [\r\n        \'index\' => \'logstash-*\',\r\n        \'type\' => [\'eventlogging\', \'wineventlog\'],\r\n        \'size\' => 15,\r\n        \'from\' => 0,\r\n        \'body\' => [\r\n            \'query\' => [\r\n                \'bool\' => [\r\n                    \'must\' => [\r\n                        [\r\n                            \'match\' => [\'level\' => \'Error|错误\']\r\n                            \r\n                        ],\r\n                        [\r\n                            \'match\' => [\'@timestamp\' => \'2017-08-14\']\r\n                        ],\r\n                    ]\r\n            \'sort\' => [\r\n                \'@timestamp\' => [\'order\' => \'desc\'],\r\n            ],\r\n        ],\r\n    ];\r\n\r\n    $response = $client->search($params);\r\n    \r\n    dd($response);\r\n	\r\n按照降序查询「2017-08-12」- 「2017-08-13」范围内的日志：\r\n\r\n	$params = [\r\n        \'index\' => \'logstash-*\',\r\n        \'type\' => [\'eventlogging\', \'wineventlog\'],\r\n        \'size\' => 15,\r\n        \'from\' => 0,\r\n        \'body\' => [\r\n            \'query\' => [\r\n                \'bool\' => [\r\n                    \'must\' => [\r\n                        [\r\n                            \'match\' => [\'level\' => \'Error|错误\']\r\n                            \r\n                        ]\r\n                    ],\r\n                    \'filter\' => [ \r\n                        [ \r\n                            \'range\' => [ \r\n                                \'@timestamp\' => [\r\n                                    \'lte\' => \'2017-08-13\',\r\n                                    \'gte\' => \'2017-08-12\',\r\n                                ]\r\n                            ]\r\n                        ],\r\n                    ]\r\n                ]\r\n            ],\r\n            \'sort\' => [\r\n                \'@timestamp\' => [\'order\' => \'desc\'],\r\n            ],\r\n        ],\r\n    ];','2017-08-27 23:59:36','2017-08-27 23:59:36','elasticsearch-api-is-introduced'),(318,3,3,'Eloquent Model `create` 的 MassAssignmentException 错误','当我们在 Eloquent Model 上使用 `create` 方法向数据库插入数据时，必须要在 Model 里设置可「批量赋值」的字段。例如，如果要实现向下面这样创建一个用户记录：\r\n\r\n	$user = App\\User::create([\'name\' => \'zhangb\']);\r\n\r\n那么就要保证 `name` 这个字段，在 Model 里是被加入可批量赋值的字段。\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class User extends Model\r\n	{\r\n		// 将 `name` 字段设置为可批量赋值的字段。\r\n		protected $fillable = [\'name\'];\r\n	}\r\n	\r\n这是为了保证从前端传递过来的、请求数据里不包含恶意字段。什么意思呢？因为有时为了方便，创建用户的脚本可能就直接用 `create` 方法：\r\n\r\n	$data = $request->except(\'token\');\r\n	\r\n	$user = App\\User::create($data);\r\n\r\n理想状态下，我们希望前台传递过来的只有一些正常的字段参数。比如： `name`、`password`、`cellphone` 和 `gender`。假设在用户表里还有个标识创建用户是否为管理员的字段 `is_admin`，默认就是 `false`。可以设想，如果没有设置可批量赋值的字段这个功能的话，就很危险了！\r\n\r\n额外攻击者在模仿注册用户操作时，直接添加了一个字段 `is_admin`，并设置为 `true`，那岂不是很危险啦！Ta可就是管理员身份了啊。','2017-08-28 00:30:58','2017-08-28 00:30:58','eloquent-model-create-massassignmentexception-errors'),(319,3,3,'不会引起 MassAssignmentException 的 Eloquent Model 插入数据的方法','大家都知道在 Eloquent Model 中使用 `create` 方法时，要在 Model 中设置 [可批量赋值的属性](http://d.laravel-china.org/docs/5.4/eloquent#mass-assignment)，否则就会报 MassAssignmentException 错误。\r\n\r\n那么，某些场景下我们可能并不需要这样，而是希望：先把数据插入，不管是否设置了可批量赋值的属性，不要报错。\r\n\r\n那么就有两种方法。\r\n\r\n1. 模型实例插入\r\n\r\n		$flight = new Flight;\r\n\r\n		$flight->name = \'balabala\';\r\n\r\n		$flight->save();\r\n\r\n2. 使用 `insert` 方法\r\n\r\n		App\\Models\\Flight::insert([\r\n			\'name\' => \'balabala\'\r\n		]);\r\n		\r\n第二种方式的  `insert` 方法在「Eloquent ORM」部分里并未介绍，这是查询语句构造器实例的方法，因为 Eloquent Model 可以作为查询语句构造器使用，自然就可以用这个方法。','2017-08-28 00:39:01','2017-08-28 01:08:59','wont-cause-massassignmentexception-eloquent-insert-data-model'),(320,3,3,'CSS `.divider` 的样式','这是分割线的样式\r\n\r\n![divider](http://www.baooab.com/wp/wp-content/uploads/2017/08/divider.png)\r\n\r\n它的样式如下：\r\n\r\n	.dropdown-menu .divider {\r\n		height: 1px;\r\n		margin: 9px 0;\r\n		overflow: hidden;\r\n		background-color: #e5e5e5;\r\n	}\r\n\r\n高度是 1px，设置 overflow 属性是为了适配 IE 浏览器，background-color 就是分割线的颜色啦！','2017-08-28 03:00:31','2017-08-29 08:30:50','css-divider-style'),(321,3,3,'给 body padding-top 的地方加一个颜色 bar','这是 Laravel 官网的顶部颜色 bar 样式：\r\n\r\n	body {\r\n		margin: 0;\r\n		color: #525252;\r\n		font-family: \"Source Sans Pro\",sans-serif;\r\n		font-size: 16px;\r\n		background: url(/assets/img/cloud-bar.png) repeat-x #fff;\r\n		padding-top: 10px;\r\n	}\r\n\r\n这里的关键代码，两条：\r\n\r\n	background: url(https://laravel.com/assets/img/cloud-bar.png) repeat-x #fff;\r\n	padding-top: 10px;\r\n\r\n内顶边距 10px，设置背景图片。','2017-08-28 03:03:31','2017-08-28 03:04:10','give-the-body-the-padding-top-place-to-add-a-color-bar'),(322,3,3,'Laravel 文档阅读：Eloquent 起步（上篇）','> 翻译、衍生自：https://laravel.com/docs/5.4/eloquent\r\n\r\n## 简介\r\n\r\nLaravel 的 ORM 实现称为「Eloquent」，又称「Eloquent ORM」。Laravel 中的 Model 是 Eloquent 功能的载体，称为 「Eloquent Model」。一个 Model 对应的是数据库里的一张表，与 Model 的交互，就相当于是和数据库表交互。\r\n\r\n在开始讲 Eloquent 前，先要把数据库配置文件 `config/database.php` 写好了，不会的话，就看 [文档](https://laravel.com/docs/5.4/eloquent)。\r\n\r\n## 定义模型\r\n\r\nLaravel 中的 Model 放在 `app` 目录下，当然你可以按你的心意放，只要 Composer 自动加载的时候能找到就 OK。所有的 Eloquent Model 扩展自 `Illuminate\\Database\\Eloquent\\Model` 类。\r\n\r\n创建 Model 最简单的方式就是使用 Artisan 命令 `make:model`：\r\n\r\n	php artisan make:model User\r\n\r\n如果在创建 Model 的时候，想顺便把迁移文件也创建喽，命令里加上 `--migration` 或者 `-m` 选项就可以了：\r\n\r\n	php artisan make:model User --migration\r\n	\r\n	php artisan make:model User -m\r\n\r\n### Eloquent Model 约定\r\n\r\n我们以 `Flight` Model 为例，默认，它会从我们的 `flights` 数据库表里查询数据：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		//\r\n	}\r\n\r\n#### 表格名\r\n\r\n注意，我们并没有告诉 `Flight` Model 要用哪张表。按照约定，类名的「snake_case」& 复数形式就是 Model 默认使用的表名，除非你在 Model 中手动通过 `table` 属性指定了表名：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		/**\r\n		 * The table associated with the model.\r\n		 *\r\n		 * @var string\r\n		 */\r\n		protected $table = \'my_flights\';\r\n	}\r\n\r\n#### 主键\r\n\r\nEloquent 默认认为每张表的主键字段名都是 `id`，当然，这也可以在 Model 中设定 `$primaryKey` 属性覆盖这一约定。\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		/**\r\n		 * The primary key for the model.\r\n		 *\r\n		 * @var string\r\n		 */\r\n		protected $primaryKey = \'my_id\';\r\n	}\r\n\r\n此外，Eloquent 默认认为主键都是自增的数值类型的。如果你使用的不是自增的或者非数值类型的主键字段，**必须** 要在 Model 设置里设置 `$incrementing` 为 `false`。\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		/**\r\n		 * Indicates if the IDs are auto-incrementing.\r\n		 *\r\n		 * @var bool\r\n		 */\r\n		public $incrementing = false;\r\n	}\r\n\r\n#### 时间戳\r\n\r\n默认，Eloquent 认为每张表里还有 `created_at` 和 `updated_at` 字段。如果你的表格里不需要这两个字段，要在 Model 里将 `$timestamps` 属性设置为 `false`：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		/**\r\n		 * Indicates if the model should be timestamped.\r\n		 *\r\n		 * @var bool\r\n		 */\r\n		public $timestamps = false;\r\n	}\r\n\r\n如果要自定义时间戳保存在数据库里的格式，就需要设置 `$dateFormat` 属性。这个属性决定时间戳字段保存在数据库里的格式，还有保存在序列化数组 / JSON 里的格式：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		/**\r\n		 * The storage format of the model\'s date columns.\r\n		 *\r\n		 * @var string\r\n		 */\r\n		protected $dateFormat = \'U\';\r\n	}\r\n\r\n如果你表格里创建字段不叫 `created_at`，或更新字段不叫 `updated_at`，那也是可以设置的。这是通过在 Model 中设置 `CREATED_AT` 和 `UPDATED_AT` 属性实现的：\r\n\r\n	<?php\r\n\r\n	class Flight extends Model\r\n	{\r\n		const CREATED_AT = \'creation_date\';\r\n		const UPDATED_AT = \'last_update\';\r\n	}\r\n\r\n#### 数据库连接\r\n\r\nEloquent 默认使用的是默认的数据库连接。如果要为一个 Model 设定不同的连接，通过 `$connection` 属性实现：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		/**\r\n		 * The connection name for the model.\r\n		 *\r\n		 * @var string\r\n		 */\r\n		protected $connection = \'connection-name\';\r\n	}\r\n\r\n## 获取模型\r\n\r\n一旦你创建了 Model 和关联的数据库表，就可以从数据库表里取数据啦！别忘记 Eloquent Model 可以当查询语句构造器使用的呀。\r\n\r\n	<?php\r\n\r\n	use App\\Flight;\r\n\r\n	$flights = App\\Flight::all();\r\n\r\n	foreach ($flights as $flight) {\r\n		echo $flight->name;\r\n	}\r\n\r\n#### 添加额外约束条件\r\n\r\nEloquent `all` 方法可以获得数据库表里所有数据。当 Eloquent Model 作为查询语句构造器使用，添加了查询条件后，就要用 `get` 方法获得数据了呦。\r\n\r\n	$flights = App\\Flight::where(\'active\', 1)\r\n				   ->orderBy(\'name\', \'desc\')\r\n				   ->take(10)\r\n				   ->get();\r\n\r\n### `Collection` 实例\r\n\r\nEloquent 方法的 `all` 和 `get` 方法获得的结果，是 `Illuminate\\Database\\Eloquent\\Collection` 实例，`Collection` 类提供了 [大量丰富的有用方法](https://laravel.com/docs/5.4/eloquent-collections#available-methods)： \r\n\r\n	$flights = $flights->reject(function ($flight) {\r\n		return $flight->cancelled;\r\n	});\r\n\r\n你也可以像循环数组那样循环 `Collection` 实例：\r\n\r\n	foreach ($flights as $flight) {\r\n		echo $flight->name;\r\n	}\r\n\r\n### 分块输出数据\r\n\r\n处理数以千计的 Eloquent 记录，可以使用 `chunk` 方法。`chunk` 方法一次取出指定数量的记录，然后交给 `Closure` 处理。在处理大数量数据时，可以节省不少内存空间：\r\n\r\n	Flight::chunk(200, function ($flights) {\r\n		foreach ($flights as $flight) {\r\n			//\r\n		}\r\n	});\r\n\r\n`chunk` 方法的第一个参数是每次分块取出的记录条数，第二个参数是一个闭包，每次取出的数据就是在这里处理的。每次向数据库请求分块数据时，都要向数据库发起一次请求。类似这样：\r\n\r\n	select * from `flights` order by `flights`.`id` asc limit 200 offset 0  \r\n	select * from `flights` order by `flights`.`id` asc limit 200 offset 200  \r\n	select * from `flights` order by `flights`.`id` asc limit 200 offset 400  \r\n\r\n#### 使用游标\r\n\r\n`cursor` 方法允许你用游标来遍历数据库数据记录，而且只执行一个 SQL 查询。当处理大量数据时，`cursor` 方法可以用来极大地减少内存的消耗：\r\n\r\n	foreach (Flight::where(\'foo\', \'bar\')->cursor() as $flight) {\r\n		//\r\n	}\r\n\r\n## 获得单个 Model / 聚合数据\r\n\r\n除了获得所有表格数据，还可以用 `find` 和 `first` 方法获得一条数据。\r\n\r\n	// Retrieve a model by its primary key...\r\n	$flight = App\\Flight::find(1);\r\n\r\n	// Retrieve the first model matching the query constraints...\r\n	$flight = App\\Flight::where(\'active\', 1)->first();\r\n\r\n`find` 方法还接收由主键值组成的数组，返回对应的匹配记录集合：\r\n\r\n	$flights = App\\Flight::find([1, 2, 3]);\r\n\r\n#### Not Found 异常\r\n\r\n有时，当一个 Model 没找到时，我们希望抛出一个异常，这在路由和控制器类里是非常有用的。这时可以使用 `findOrFail` 或者 `firstOrFail` 方法，它们也是从数据库里获得一条数据，但是与 `find` 和 `first` 方法不同的是，如果没找到结果的话，一个 `Illuminate\\Database\\Eloquent\\ModelNotFoundException` 异常会被抛出：\r\n\r\n	$model = App\\Flight::findOrFail(1);\r\n\r\n	$model = App\\Flight::where(\'legs\', \'>\', 100)->firstOrFail();\r\n\r\n如果异常未被捕捉，一个 `404` HTTP 响应就会自动发送给用户。\r\n\r\n	Route::get(\'/api/flights/{id}\', function ($id) {\r\n		return App\\Flight::findOrFail($id);\r\n	});\r\n\r\n## 获得聚合数据\r\n\r\n你也可以使用 `count`、`sum`、`max` 或者查询语句构造器提供的什么其他方法。注意，这些方法返回是对应适当的值而不是完整的 Model 实例：\r\n\r\n	$count = App\\Flight::where(\'active\', 1)->count();\r\n\r\n	$max = App\\Flight::where(\'active\', 1)->max(\'price\');','2017-08-28 05:04:52','2017-08-30 06:21:14','laravel-document-reading-eloquent-start-last'),(326,3,3,'Laravel 文档阅读：Eloquent 起步（下篇）','> 翻译、衍生自：https://laravel.com/docs/5.4/eloquent\r\n\r\n接 [上篇](https://laravel-china.org/articles/5856/laravel-document-reading-eloquent-start-part-one) 。\r\n\r\n## 插入 & 更新 Model\r\n\r\n### 插入\r\n\r\n向数据库插入一条数据，可以采用这样的方式：创建一个模型实例、为实例设置属性，然后调用 `save` 方法：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use App\\Flight;\r\n	use Illuminate\\Http\\Request;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class FlightController extends Controller\r\n	{\r\n		/**\r\n		 * Create a new flight instance.\r\n		 *\r\n		 * @param  Request  $request\r\n		 * @return Response\r\n		 */\r\n		public function store(Request $request)\r\n		{\r\n			// Validate the request...\r\n\r\n			$flight = new Flight;\r\n\r\n			$flight->name = $request->name;\r\n\r\n			$flight->save();\r\n		}\r\n	}\r\n\r\n在上面的例子里，我们把从 HTTP 请求里接受到的 `name` 参数赋值给了 `App\\Flight` 模型实例对象的 `name` 属性。当 `save` 方法调用后，一条数据就被插入数据库了，而且 **`created_at` 和 `updated_at` 字段也会被自动更新**。\r\n\r\n### 更新\r\n\r\n **`save` 方法还可以用来更新** 已存在于数据库中的数据。在更新模型数据前，先要获得模型实例对象，然后设置要更新的字段内容，就可以调用 `save` 方法更新数据了， `updated_at` 时间戳字段会被自动更新：\r\n\r\n	$flight = App\\Flight::find(1);\r\n\r\n	$flight->name = \'New Flight Name\';\r\n\r\n	$flight->save();\r\n\r\n#### 批量更新\r\n\r\n`update` 方法可以用在批量更新数据库记录。在下面的例子里，所有以 `San Diego` 作为 `destination` 的、并且是 `active` 的航班，都要延迟起飞了：\r\n\r\n	App\\Flight::where(\'active\', 1)\r\n			  ->where(\'destination\', \'San Diego\')\r\n			  ->update([\'delayed\' => 1]);\r\n\r\n`update` 方法里列出的字段就是要更新的字段。\r\n\r\n当通过这种方式批量更新数据时，不会触发 `saved` 和 `updated` 事件。因为数据是直接在数据库更新的，没有通过取得、然后再更新的方式。\r\n\r\n### 批量赋值\r\n\r\n也可以用 `create` 方法保存模型实例对象，该方法会返回被插入的模型实例对象。但有前提的，前提是要在 Model 里设置 `fillable` 或者 `guarded` 属性。因为默认 Eloquent Model 是不允许批量赋值的。\r\n\r\n批量赋值漏洞发生在用户通过 HTTP 请求传递了非预期的字段参数，并且那个字段参数对应到你的数据库里的那个字段，是你不想让用户更改的。例如，一个恶毒的用户可能通过 HTTP 请求传递了 `is_admin` 参数，而你呢，是使用 `create` 方法来创建用户的，这就相当于用户把自己改为超级管理员了，这很危险。\r\n\r\n#### `$fillable` 属性\r\n\r\n所以，你需要在 Model 中设置哪些字段是允许批量赋值的。可以通过设置 Model 上的 `$fillable` 属性实现。例如，在 `Flight` Model 上将 `name` 属性设置为可批量赋值的：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		/**\r\n		 * The attributes that are mass assignable.\r\n		 *\r\n		 * @var array\r\n		 */\r\n		protected $fillable = [\'name\'];\r\n	}\r\n\r\n设置好后，我们就可以用 `create` 方法向数据库插入数据了。 `create` 方法返回保存的 Model 实例对象：\r\n\r\n	$flight = App\\Flight::create([\'name\' => \'Flight 10\']);\r\n\r\n如果已有了一个 Model 实例，通过 `fill` 方法的（数组类型的）参数可以填充 Model 数据：\r\n\r\n	$flight->fill([\'name\' => \'Flight 22\']);\r\n\r\n#### `$guarded` 属性\r\n\r\n`$fillable` 属性相当于批量赋值的「白名单」，而 `$guarded` 属性呢就相当于一个「黑名单」。在一个 Model 里，**不可以同时设定  `$fillable` 和 `$guarded` 属性**。在下面的例子中，**除了 `price` 字段**，其他都是可批量赋值的字段：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		/**\r\n		 * The attributes that aren\'t mass assignable.\r\n		 *\r\n		 * @var array\r\n		 */\r\n		protected $guarded = [\'price\'];\r\n	}\r\n\r\n如果要让所有的属性都是可以批量赋值的，那么将 `$guarded` 属性设置为空数组即可：\r\n\r\n	/**\r\n	 * The attributes that aren\'t mass assignable.\r\n	 *\r\n	 * @var array\r\n	 */\r\n	protected $guarded = [];\r\n\r\n### 其他的创建方法\r\n\r\n#### `firstOrCreate` / `firstOrNew`\r\n\r\n这儿还有两个使用了批量赋值创建 Model 的方法：`firstOrCreate` 和 `firstOrNew`。`firstOrCreate` 方法用给到的字段键值去数据库查找是否有匹配的记录，没有匹配记录的话，就会将给出的字段键值数据插入到数据库表中。\r\n\r\n`firstOrNew` 方法与 `firstOrCreate` 类似，也会去数据库查找是否有匹配的记录，不同的是，如果没有匹配记录的话，就会创建并返回一个新的 Model 实例。需要注意的是，通过 `firstOrNew` 方法返回的 Model 实例不会插入到数据库中，如果需要插入到数据库，就需要额外调用 `save` 方法：\r\n\r\n	// Retrieve flight by name, or create it if it doesn\'t exist...\r\n	$flight = App\\Flight::firstOrCreate([\'name\' => \'Flight 10\']);\r\n\r\n	// Retrieve flight by name, or create it with the name and delayed attributes...\r\n	$flight = App\\Flight::firstOrCreate(\r\n		[\'name\' => \'Flight 10\'], [\'delayed\' => 1]\r\n	);\r\n\r\n	// Retrieve by name, or instantiate...\r\n	$flight = App\\Flight::firstOrNew([\'name\' => \'Flight 10\']);\r\n\r\n	// Retrieve by name, or instantiate with the name and delayed attributes...\r\n	$flight = App\\Flight::firstOrNew(\r\n		[\'name\' => \'Flight 10\'], [\'delayed\' => 1]\r\n	);\r\n\r\n#### `updateOrCreate`\r\n\r\n有时你也会遇到这样的情况：更新一个 Model 时，如果 Model 不存在就创建它。用 `updateOrCreate` 一步就可以做到。类似 `firstOrCreate` 方法，`updateOrCreate` 会持久化 Model，所以无需手动调用 `save()`：\r\n\r\n	// If there\'s a flight from Oakland to San Diego, set the price to $99.\r\n	// If no matching model exists, create one.\r\n	$flight = App\\Flight::updateOrCreate(\r\n		[\'departure\' => \'Oakland\', \'destination\' => \'San Diego\'],\r\n		[\'price\' => 99]\r\n	);\r\n\r\n## 删除 Model\r\n\r\n在 Model 实例上调用 `delete` 方法删除它：\r\n\r\n	$flight = App\\Flight::find(1);\r\n\r\n	$flight->delete();\r\n\r\n#### 通过主键删除\r\n\r\n在已知主键的情况下，可以直接删除，而无需先获得。这时，使用 `destory` 方法：\r\n\r\n	App\\Flight::destroy(1);\r\n\r\n	App\\Flight::destroy([1, 2, 3]);\r\n\r\n	App\\Flight::destroy(1, 2, 3);\r\n\r\n#### 删除一组 Model\r\n\r\n当然，也可以在一组 Model 上运行 delete 语句。 在下面的例子中，我们会删除所有 inactive 的航班。类似批量更新，批量删除不会触发模型事件 `deleting` 和 `deleted`。\r\n\r\n	$deletedRows = App\\Flight::where(\'active\', 0)->delete();\r\n\r\n### 软删除\r\n\r\n“软删除”并不是把数据记录从数据库中真的删除，而是在 `deleted_at` 时间戳字段上设置了值，当这个字段的值不是 `null` 时，我们认为这条记录就是被删除了。 为了让一个 Model 支持软删除，需要让 Model 引入 `Illuminate\\Database\\Eloquent\\SoftDeletes` 这个 trait，并且将 `deleted_at` 字段加入到 `$dates` 属性中：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n	use Illuminate\\Database\\Eloquent\\SoftDeletes;\r\n\r\n	class Flight extends Model\r\n	{\r\n		use SoftDeletes;\r\n\r\n		/**\r\n		 * The attributes that should be mutated to dates.\r\n		 *\r\n		 * @var array\r\n		 */\r\n		protected $dates = [\'deleted_at\'];\r\n	}\r\n\r\n当然，在数据库表里也要添加 `deleted_at` 这个字段。Laravel 的 schema 构造器中提供了创建这个字段的方法：\r\n\r\n	Schema::table(\'flights\', function ($table) {\r\n		$table->softDeletes();\r\n	});\r\n\r\n现在，当你调用 `delete` 方法删除 Model 时，`delete_at` 字段就会被设置为当前执行删除操作时的时间，当用查询获得数据时，被软删除的数据记录会被自动排除在外，不显示。\r\n\r\n判断一个 Model 实例是否被删除，使用 `trashed` 方法：\r\n\r\n	if ($flight->trashed()) {\r\n		//\r\n	}\r\n\r\n### 查询软删除 Model\r\n\r\n#### 包括软删除数据\r\n\r\n之前提到过，查询时，被软删除的数据记录会被自动排除在外。你也可以强制查询结果里包含软删除数据，需要在查询上用到 `withTrashed` 方法：\r\n\r\n	$flights = App\\Flight::withTrashed()\r\n					->where(\'account_id\', 1)\r\n					->get();\r\n\r\n`withTrashed` 方法也可以用在关联查询上：\r\n\r\n	$flight->history()->withTrashed()->get();\r\n\r\n#### 只获取软删除数据\r\n\r\n`onlyTrashed ` 方法只返回软删除数据：\r\n\r\n	$flights = App\\Flight::onlyTrashed()\r\n						->where(\'airline_id\', 1)\r\n						->get();\r\n\r\n#### 还原软删除 Model\r\n\r\n还原软删除 Model，需要使用 `restore` 方法：\r\n\r\n	$flight->restore();\r\n\r\n也可以使用  `restore` 方法还原多条数据，不过就像其他的“批量”操作，不会触发任何模型事件：\r\n\r\n	App\\Flight::withTrashed()\r\n			->where(\'airline_id\', 1)\r\n			->restore();\r\n\r\n类似 `withTrashed` 方法，`restore` 方法也可以用在关联方法上：\r\n\r\n	$flight->history()->restore();\r\n\r\n#### 彻底删除 Model\r\n \r\n 如果是真的要把记录从数据库删除，要用到 `forceDelete` 方法：\r\n \r\n	 // Force deleting a single model instance...\r\n	$flight->forceDelete();\r\n\r\n	// Force deleting all related models...\r\n	$flight->history()->forceDelete();\r\n\r\n## 查询范围\r\n\r\n### 全局查询范围\r\n\r\n全局查询范围是给一个 Model 的所有查询添加约束条件。Laravel 自身的软删除功能就是利用了全局查询范围，只从数据库中获得“未删除”的 Model。自定义全局查询范围可以更方便、快捷地给指定 Model 的所有查询添加特定约束。\r\n\r\n#### 写全局查询范围\r\n\r\n查询范围类需要实现 `Illuminate\\Database\\Eloquent\\Scope` 接口，这个接口里需要实现一个方法：`apply`。`apply` 方法可以给查询添加必要的 `where` 约束条件：\r\n\r\n	<?php\r\n\r\n	namespace App\\Scopes;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Scope;\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n	use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n	class AgeScope implements Scope\r\n	{\r\n		/**\r\n		 * Apply the scope to a given Eloquent query builder.\r\n		 *\r\n		 * @param  \\Illuminate\\Database\\Eloquent\\Builder  $builder\r\n		 * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\r\n		 * @return void\r\n		 */\r\n		public function apply(Builder $builder, Model $model)\r\n		{\r\n			$builder->where(\'age\', \'>\', 200);\r\n		}\r\n	}\r\n\r\n注意，如果在全局查询范围类里的查询要使用 select 子句，你应该用 `addSelect` 方法而不是 `select` 方法。这将防止无意中替换现有查询中的 select 子句。\r\n\r\n#### 使用全局约束\r\n\r\n想在指定 Model 上使用全局查询范围，可以通过重写 Model 的 `boot` 方法实现，在方法内部，再调用 `addGlobalScope` 方法：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use App\\Scopes\\AgeScope;\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class User extends Model\r\n	{\r\n		/**\r\n		 * The \"booting\" method of the model.\r\n		 *\r\n		 * @return void\r\n		 */\r\n		protected static function boot()\r\n		{\r\n			parent::boot();\r\n\r\n			static::addGlobalScope(new AgeScope);\r\n		}\r\n	}\r\n\r\n添加查询范围后，执行 `User::all()`，产生的 SQL 语句如下：\r\n\r\n	select * from `users` where `age` > 200\r\n\r\n#### 匿名全局查询范围\r\n\r\nEloquent 也允许使用闭包的方式定义全局查询范围，这对于不想用单独类的简单查询范围特别有用。\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n	use Illuminate\\Database\\Eloquent\\Builder;\r\n\r\n	class User extends Model\r\n	{\r\n		/**\r\n		 * The \"booting\" method of the model.\r\n		 *\r\n		 * @return void\r\n		 */\r\n		protected static function boot()\r\n		{\r\n			parent::boot();\r\n\r\n			static::addGlobalScope(\'age\', function (Builder $builder) {\r\n				$builder->where(\'age\', \'>\', 200);\r\n			});\r\n		}\r\n	}\r\n\r\n#### 删除全局查询范围\r\n\r\n如果对于一个给定的查询，不需要使用全局查询范围，那就要用 `withoutGlobalScope` 方法了，该方法接受全局查询范围类作为它的唯一参数：\r\n\r\n	User::withoutGlobalScope(AgeScope::class)->get();\r\n\r\n如果要删除几个或者全部的全局查询范围，就需要用 `withoutGlobalScopes` 方法了：\r\n\r\n	// Remove all of the global scopes...\r\n	User::withoutGlobalScopes()->get();\r\n\r\n	// Remove some of the global scopes...\r\n	User::withoutGlobalScopes([\r\n		FirstScope::class, SecondScope::class\r\n	])->get();\r\n\r\n### 本地查询范围 \r\n\r\n本地查询范围就是在 Model 中定义的，以方法形式呈现，方法名以 `scope` 开头。Scope 方法应该总是返回一个查询构造器实例：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class User extends Model\r\n	{\r\n		/**\r\n		 * Scope a query to only include popular users.\r\n		 *\r\n		 * @param \\Illuminate\\Database\\Eloquent\\Builder $query\r\n		 * @return \\Illuminate\\Database\\Eloquent\\Builder\r\n		 */\r\n		public function scopePopular($query)\r\n		{\r\n			return $query->where(\'votes\', \'>\', 100);\r\n		}\r\n\r\n		/**\r\n		 * Scope a query to only include active users.\r\n		 *\r\n		 * @param \\Illuminate\\Database\\Eloquent\\Builder $query\r\n		 * @return \\Illuminate\\Database\\Eloquent\\Builder\r\n		 */\r\n		public function scopeActive($query)\r\n		{\r\n			return $query->where(\'active\', 1);\r\n		}\r\n	}\r\n\r\n#### 使用本地查询范围 \r\n\r\nScope 方法定义好后，在查询 Model 的时候就可以使用了。但是使用的时候，就不需要加上 `scope` 前缀了。也可以链式调用不同的 Scope 方法，例如：\r\n\r\n	$users = App\\User::popular()->active()->orderBy(\'created_at\')->get();\r\n\r\n#### 动态查询范围 \r\n\r\n有时，需要定义一个接受参数的 Scope 方法。这也很简单，在 `$query` 之后，添加我们希望接受的参数即可：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class User extends Model\r\n	{\r\n		/**\r\n		 * Scope a query to only include users of a given type.\r\n		 *\r\n		 * @param \\Illuminate\\Database\\Eloquent\\Builder $query\r\n		 * @param mixed $type\r\n		 * @return \\Illuminate\\Database\\Eloquent\\Builder\r\n		 */\r\n		public function scopeOfType($query, $type)\r\n		{\r\n			return $query->where(\'type\', $type);\r\n		}\r\n	}\r\n\r\n现在，你就可以在调用 Scope 方法的时候传递参数过去就行了：\r\n\r\n	$users = App\\User::ofType(\'admin\')->get();\r\n\r\n## 事件\r\n\r\nEloquent Model 在整个生命周期内，提供了几个不同的事件，方便你在对应的关键点上添加处理逻辑：`creating`、`created`、`updating`、`updated`、`saving`、`saved`、`deleting`、`deleted`、`restoring` 和 `restored`。这些事件允许你每次在数据库中保存或更新特定的 Model 类时轻松执行代码。\r\n\r\n当一个新的 Model 第一次保存的时候，会触发 `creating` 和 `created` 事件。当同一个 Model 已存在于数据库中，并且调用了 `save` 方法，那么就会触发 `updating` / `updated` 事件。而且这两种情况，都会触发 `saving` / `saved` 事件，事件的调用顺序依次如下：\r\n\r\n	第一次保存：saving → creating → created → saved\r\n	使用 `save()` 更新已有数据：saving → updating → updated → saved\r\n\r\n在你的 Eloquent Model 中定义一个 `$events` 属性为 Eloquent Model 在整个生命周期的事件点上指定事件处理逻辑的一个映射表，这里需要用到 [事件类](https://laravel.com/docs/5.4/events)。\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use App\\Events\\UserSaved;\r\n	use App\\Events\\UserDeleted;\r\n	use Illuminate\\Notifications\\Notifiable;\r\n	use Illuminate\\Foundation\\Auth\\User as Authenticatable;\r\n\r\n	class User extends Authenticatable\r\n	{\r\n		use Notifiable;\r\n\r\n		/**\r\n		 * The event map for the model.\r\n		 *\r\n		 * @var array\r\n		 */\r\n		protected $events = [\r\n			\'saved\' => UserSaved::class,\r\n			\'deleted\' => UserDeleted::class,\r\n		];\r\n	}\r\n\r\n### 观察者\r\n\r\n如果在一个 Model 中需要监听的事件很多，那么这时就可以用“观察者”将所有监听逻辑组织在一个类中。观察者类中方法名对应事件名。每个事件接受 Model 实例作为他们的唯一参数。Laravel 没有为观察者默认创建文件夹，所以你可能要为你的观察者创建存放它们的文件夹了。在下面的例子中，观察者放在了 `app` 目录下的 `Observers` 文件夹下：\r\n\r\n	<?php\r\n\r\n	namespace App\\Observers;\r\n\r\n	use App\\User;\r\n\r\n	class UserObserver\r\n	{\r\n		/**\r\n		 * Listen to the User created event.\r\n		 *\r\n		 * @param  User  $user\r\n		 * @return void\r\n		 */\r\n		public function created(User $user)\r\n		{\r\n			//\r\n		}\r\n\r\n		/**\r\n		 * Listen to the User deleting event.\r\n		 *\r\n		 * @param  User  $user\r\n		 * @return void\r\n		 */\r\n		public function deleting(User $user)\r\n		{\r\n			//\r\n		}\r\n	}\r\n\r\n是在服务提供者的 `boot` 方法里注册观察者的，使用的是 Model 的 `observer` 方法。在下面的例子里，我们将观察者注册在了 `AppServiceProvider` 中：\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use App\\User;\r\n	use App\\Observers\\UserObserver;\r\n	use Illuminate\\Support\\ServiceProvider;\r\n\r\n	class AppServiceProvider extends ServiceProvider\r\n	{\r\n		/**\r\n		 * Bootstrap any application services.\r\n		 *\r\n		 * @return void\r\n		 */\r\n		public function boot()\r\n		{\r\n			User::observe(UserObserver::class);\r\n		}\r\n\r\n		/**\r\n		 * Register the service provider.\r\n		 *\r\n		 * @return void\r\n		 */\r\n		public function register()\r\n		{\r\n			//\r\n		}\r\n	}','2017-08-29 06:35:08','2017-08-30 07:26:24','laravel-document-reading-eloquent-start-next'),(323,3,3,'getQueryString：获得 URL 参数变量','## 代码\r\n\r\n```\r\nfunction getQueryString(variable) {\r\n       var query = window.location.search.substring(1);\r\n       var vars = query.split(\"&\");\r\n       for (var i=0;i<vars.length;i++) {\r\n               var pair = vars[i].split(\"=\");\r\n               if(pair[0] == variable){return pair[1];}\r\n       }\r\n       return(false);\r\n}\r\n```\r\n\r\n## 使用\r\n\r\nURL 地址：http://www.example.com/index.php?id=1&image=awesome.jpg\r\n\r\n调用 `getQueryString(\"id\")` ，返回「1」。\r\n\r\n调用 `getQueryString(\"image\")`，返回「awesome.jpg」。','2017-08-28 08:56:10','2018-01-08 04:57:04','get-the-url-parameter'),(324,3,3,'2017年8月28号','今天是七夕节，我的一生所爱仍在白云外。\r\n\r\n这是一个普通的星期一，没有什么特别的，唯一不一样的是：我感冒了，我在被子里捂着，希望发汗把病除掉。我的身体发热，鼻孔干燥。\r\n\r\n我一点都不想矫情，我没有倾诉的对象，现在写字是我释怀的一种方式了。\r\n\r\n我在听《一生所爱》。\r\n\r\n我正在拿我麻木情感里的一小部分用来不爱这个世界。\r\n\r\n坚持感受和表达。?我感觉眼屎都快出来了……','2017-08-28 13:57:42','2017-08-28 13:59:21','on-august-28-2017'),(325,3,3,'updated_at、created_at 和 published_at','Eloquent  Model 默认会维护 `updated_at` 和 `created_at ` 字段。如果你的 Model 中不包含/不需要维护这两个字段，可以在 Model 中设置 `$timestamps` 属性为 `false` 即可：\r\n\r\n	<?php\r\n\r\n	namespace App;\r\n\r\n	use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n	class Flight extends Model\r\n	{\r\n		/**\r\n		 * Indicates if the model should be timestamped.\r\n		 *\r\n		 * @var bool\r\n		 */\r\n		public $timestamps = false;\r\n	}\r\n\r\n如果保持默认的 `$timestamps` 属性设置，那么在 Model 上查询  `updated_at` 和 `created_at ` 字段时，返回的都是 Carbon 实例对象。\r\n\r\n	Post::find(1)->created_at;\r\n\r\n	Post::find(1)->updated_at;\r\n\r\n返回内容类似\r\n\r\n	Carbon {#183 ▼\r\n	  +\"date\": \"2017-08-29 10:54:25.000000\"\r\n	  +\"timezone_type\": 3\r\n	  +\"timezone\": \"PRC\"\r\n	}\r\n\r\n如果你的 Model 里自定义了一个 `published_at` 字段，表示发布与否，那么如果想让该字段输出时自动转换为 Carbon 实例对象，就需要在 Model 里设置 `$dates` 属性：\r\n\r\n	protected $dates = [\'published_at\'];\r\n	\r\n	Post::find(1)->published_at->diffForHumans();\r\n	\r\n这样，`published_at` 输出时就是一个 Carbon 实例对象了。\r\n\r\n	Carbon {#183 ▼\r\n	  +\"date\": \"2017-08-29 14:54:25.000000\"\r\n	  +\"timezone_type\": 3\r\n	  +\"timezone\": \"PRC\"\r\n	}\r\n	\r\n	\"2 hours from now\"','2017-08-29 04:26:35','2017-08-29 04:31:19','updated-at-created-at-and-published-at'),(327,3,3,'科学上网 VPN 搭建，使用 shadowsocks','> 原文地址：https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File\r\n\r\n### Install\r\n\r\nDebian / Ubuntu:\r\n\r\n    apt-get install python-pip\r\n    pip install git+https://github.com/shadowsocks/shadowsocks.git@master\r\n\r\nCentOS:\r\n\r\n    yum install python-setuptools && easy_install pip\r\n    pip install git+https://github.com/shadowsocks/shadowsocks.git@master\r\n\r\nWindows:\r\n\r\nSee [Install Shadowsocks Server on Windows](https://github.com/shadowsocks/shadowsocks/wiki/Install-Shadowsocks-Server-on-Windows).\r\n\r\n### Usage\r\n\r\nYou can use a configuration file instead of command line arguments.\r\n\r\nCreate a config file /etc/shadowsocks.json. Example:\r\n\r\n	{\r\n		\"server\":\"my_server_ip\",\r\n		\"server_port\":8388,\r\n		\"local_address\": \"127.0.0.1\",\r\n		\"local_port\":1080,\r\n		\"password\":\"mypassword\",\r\n		\"timeout\":300,\r\n		\"method\":\"aes-256-cfb\",\r\n		\"fast_open\": false\r\n	}\r\n\r\nExplanation of the fields:\r\n \r\n| Name | Explanation |\r\n| -------- | -------- | \r\n| server |	the address your server listens | \r\n| server_port |	server port | \r\n| local_address	| the address your local listens | \r\n| local_port |	local port | \r\n| password	| password used for encryption | \r\n| timeout	| in seconds | \r\n| method	| default: \"aes-256-cfb\", see Encryption | \r\n| fast_open	| use TCP_FASTOPEN, true / false | \r\n| workers	| number of workers, available on Unix/Linux | \r\n\r\nTo run in the foreground:\r\n\r\n	ssserver -c /etc/shadowsocks.json\r\n\r\nTo run in the background:\r\n\r\n	ssserver -c /etc/shadowsocks.json -d start\r\n	ssserver -c /etc/shadowsocks.json -d stop','2017-08-30 02:55:18','2017-08-30 03:01:58','science-and-internet-vpn-set-up-using-shadowsocks'),(328,5,3,'Maven','# Maven\r\nMaven这个单词来自于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项目中用来简化构建过程。当时有一些项目（有各自Ant build文件），仅有细微的差别，而JAR文件都由CVS来维护。于是希望有一种标准化的方式构建项目，一个清晰的方式定义项目的组成，一个容易的方式发布项目的信息，以及一种简单的方式在多个项目中共享JARs。 \r\n\r\n\r\n# 安装及使用\r\n\r\n## 网站\r\nhttps://maven.apache.org/\r\n\r\n## 注意事项\r\n1. java的jdk版本要求在1.7以上\r\n```\r\nchenys@linux-ubuntu:~/tools/apache-maven-3.5.0$ java -version\r\nopenjdk version \"1.8.0_131\"\r\nOpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-2ubuntu1.16.04.3-b11)\r\nOpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)\r\n```\r\n\r\n2. 下载maven：https://maven.apache.org/download.cgi\r\n\r\n3. 添加maven环境变量\r\n```\r\nchenys@linux-ubuntu:/$ sudo vi /etc/profile     #编辑环境变量文件\r\nexport MAVEN_HOME=/home/chenys/tools/apache-maven-3.5.0  \r\nexport PATH=${MAVEN_HOME}/bin:$PATH \r\nchenys@linux-ubuntu:/$ source /etc/profile      ＃使环境变量生效\r\nchenys@linux-ubuntu:/$ mvn -version             ＃查看maven版本\r\nApache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-03T19:39:06Z)\r\nMaven home: /home/chenys/tools/apache-maven-3.5.0\r\nJava version: 1.8.0_131, vendor: Oracle Corporation\r\nJava home: /usr/lib/jvm/java-8-openjdk-amd64/jre\r\nDefault locale: en_US, platform encoding: UTF-8\r\nOS name: \"linux\", version: \"4.4.0-92-generic\", arch: \"amd64\", family: \"unix\"\r\n```\r\n\r\n# Maven软件目录结构\r\n```\r\nchenys@linux-ubuntu:~/tools$ tree -L 1 apache-maven-3.5.0\r\napache-maven-3.5.0\r\n├── bin                            包含maven运行脚本\r\n├── boot                          类加载器框架maven使用该框架加载自己的类库\r\n├── conf                          maven配置文件信息\r\n├── lib                              包含了maven运行时所需的java类库\r\n├── LICENSE\r\n├── NOTICE\r\n└── README.txt\r\n```\r\n\r\n#  Maven命令\r\n```\r\nchenys@linux-ubuntu:~/tools$ mvn help:system      ＃打印系统所有环境变量\r\n```\r\n\r\nmaven创建的java项目常用的目录结构\r\n```\r\nsrc\r\n  --main\r\n	   --java\r\n		  --package\r\n       --resources\r\n  --test\r\n	   --java\r\n		  --package\r\n	   --resources\r\npom.xml\r\n\r\nsrc/main/java        项目的源代码所在目录\r\nsrc/main/resources   项目的资源文件所在的目录\r\nsrc/test/java        项目的测试代码所在目录\r\nsrc/test/resources   项目的测试资源文件所在的目录\r\npom.xml              项目工程的描述文件 \r\n```','2017-08-31 02:58:29','2017-10-25 11:27:21','maven'),(329,3,3,'LaraCon 2017：根据原则写细粒度的 Controller（1️⃣）','* Podcasts 音频栏目\r\n* episodes 集\r\n\r\nMore Controllers，No Patterns。\r\n\r\n一个用户（User）可以创建多个音频栏目（Podcasts），一个音频栏目呢可以与好多集（Episodes）。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/laracon-2-0.png)\r\n\r\n## 之前\r\n\r\n这里有 20 个路由，所有的业务逻辑放在了 2 个控制器里。\r\n\r\n	Route::get(\'/podcasts\', \'PodcastsController@index\');\r\n	Route::get(\'/podcasts/new\', \'PodcastsController@create\');\r\n	Route::post(\'/podcasts\', \'PodcastsController@store\');\r\n	Route::get(\'/podcasts/show\', \'PodcastsController@show\');\r\n	Route::get(\'/podcasts/{podcast}/edit\', \'PodcastsController@edit\');\r\n	Route::match([\'put\', \'patch\'], \'/podcasts/{podcast}\', \'PodcastsController@update\');\r\n	Route::delete(\'/podcasts/{podcast}\', \'PodcastsController@destroy\');\r\n	\r\n	Route::get(\'/podcasts/{podcast}/episodes\', \'PodcastsController@listEpisodes\');\r\n	Route::post(\'/podcasts/{podcast}/update-cover-image\', \'PodcastsController@updateCoverImage\');\r\n	Route::post(\'/podcasts/{podcast}/subscribe\', \'PodcastsController@subcribe\');\r\n	Route::post(\'/podcasts/{podcast}/unsubscribe\', \'PodcastsController@unsubcribe\');\r\n	Route::post(\'/podcasts/{podcast}/publish\', \'PodcastsController@publish\');\r\n	Route::post(\'/podcasts/{podcast}/unpublish\', \'PodcastsController@unpublish\');\r\n\r\n	Route::get(\'/episodes\', \'EpisodesController@index\');\r\n	Route::get(\'/podcasts/{podcast}/episodes/new\', \'EpisodesController@create\');\r\n	Route::post(\'/podcasts/{podcast}/episodes\', \'EpisodesController@store\');\r\n	Route::get(\'/episodes/{episode}\', \'EpisodesController@show\');\r\n	Route::get(\'/episodes/{episode}/edit\', \'EpisodesController@edit\');\r\n	Route::match([\'put\', \'patch\'], \'/episodes/{episode}\', \'EpisodesController@update\');\r\n	Route::delete(\'/episodes/{episode}\', \'EpisodesController@destroy\');\r\n\r\n`PodcastsController` 包含 13 个 actions，`EpisodesController` 包含 7 个 actions。可以看到有一个与“集”相关的业务，放在了 `PodcastsController` 中处理了：\r\n\r\n	Route::get(\'/podcasts/{podcast}/episodes\', \'PodcastsController@listEpisodes\');\r\n\r\n还有，修改 Podcast 的封面、Podcast 的订阅/非订阅、Podcast 的发布/取消发布 功能统一放在了 `PodcastsController` 中，这样依赖，除了 7 个基本的 actions（`index`、`create`、`store`、`show`、`edit`、`update` 和 `delete`），另外还创建了 5 个额外的 actions：`updateCoverImage`、`subcribe`、`unsubcribe`、`publish` 和 `unpublish`。\r\n\r\n整个项目的路由列表如下：\r\n\r\n	Laravel55> php artisan route:list\r\n	+--------+-----------+---------------------------------------+------+----------------------------------------------------------+--------------+\r\n	| Domain | Method    | URI                                   | Name | Action                                                   | Middleware   |\r\n	+--------+-----------+---------------------------------------+------+----------------------------------------------------------+--------------+\r\n	|        | GET|HEAD  | /                                     |      | Closure                                                  | web          |\r\n	|        | GET|HEAD  | api/user                              |      | Closure                                                  | api,auth:api |\r\n	|        | GET|HEAD  | episodes                              |      | App\\Http\\Controllers\\EpisodesController@index            | web          |\r\n	|        | PUT|PATCH | episodes/{episode}                    |      | App\\Http\\Controllers\\EpisodesController@update           | web          |\r\n	|        | GET|HEAD  | episodes/{episode}                    |      | App\\Http\\Controllers\\EpisodesController@show             | web          |\r\n	|        | DELETE    | episodes/{episode}                    |      | App\\Http\\Controllers\\EpisodesController@destroy          | web          |\r\n	|        | GET|HEAD  | episodes/{episode}/edit               |      | App\\Http\\Controllers\\EpisodesController@edit             | web          |\r\n	|        | POST      | podcasts                              |      | App\\Http\\Controllers\\PodcastsController@store            | web          |\r\n	|        | GET|HEAD  | podcasts                              |      | App\\Http\\Controllers\\PodcastsController@index            | web          |\r\n	|        | GET|HEAD  | podcasts/new                          |      | App\\Http\\Controllers\\PodcastsController@create           | web          |\r\n	|        | GET|HEAD  | podcasts/show                         |      | App\\Http\\Controllers\\PodcastsController@show             | web          |\r\n	|        | PUT|PATCH | podcasts/{podcast}                    |      | App\\Http\\Controllers\\PodcastsController@update           | web          |\r\n	|        | DELETE    | podcasts/{podcast}                    |      | App\\Http\\Controllers\\PodcastsController@destroy          | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/edit               |      | App\\Http\\Controllers\\PodcastsController@edit             | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/episodes           |      | App\\Http\\Controllers\\PodcastsController@listEpisodes     | web          |\r\n	|        | POST      | podcasts/{podcast}/episodes           |      | App\\Http\\Controllers\\EpisodesController@store            | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/episodes/new       |      | App\\Http\\Controllers\\EpisodesController@create           | web          |\r\n	|        | POST      | podcasts/{podcast}/publish            |      | App\\Http\\Controllers\\PodcastsController@publish          | web          |\r\n	|        | POST      | podcasts/{podcast}/subscribe          |      | App\\Http\\Controllers\\PodcastsController@subcribe         | web          |\r\n	|        | POST      | podcasts/{podcast}/unpublish          |      | App\\Http\\Controllers\\PodcastsController@unpublish        | web          |\r\n	|        | POST      | podcasts/{podcast}/unsubscribe        |      | App\\Http\\Controllers\\PodcastsController@unsubcribe       | web          |\r\n	|        | POST      | podcasts/{podcast}/update-cover-image |      | App\\Http\\Controllers\\PodcastsController@updateCoverImage | web          |\r\n	+--------+-----------+---------------------------------------+------+----------------------------------------------------------+--------------+\r\n\r\n## 修改\r\n\r\n### 原则一\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/laracon-2-1.png)\r\n\r\n在 `PodcastsController` 中，`updateCoverImage`、`subcribe`、`unsubcribe`、`publish` 和 `unpublish` 都是自定义动作（Custom Actions），不要这样。让这 5 个方法写在更加细粒度的 Controller 中，每个 Controller 只负责基本的增删改查操作。\r\n\r\n先使用资源路由（Resource Routes），简化 `PodcastsController` 和 `EpisodesController` 中的 7 个基本的 actions。\r\n\r\n	// routes/web.php\r\n	\r\n	Route::resource(\'podcasts\', \'PodcastsController\');\r\n	\r\n	Route::get(\'/podcasts/{podcast}/episodes/new\', \'EpisodesController@create\');\r\n	Route::post(\'/podcasts/{podcast}/episodes\', \'EpisodesController@store\');\r\n	Route::resource(\'episodes\', \'EpisodesController\', [\r\n		\'only\' => [\'index\', \'show\', \'edit\', \'update\', \'delete\']\r\n	]);\r\n	\r\n	\r\n	// app/Providers/AppServiceProvider.php\r\n	\r\n	use Illuminate\\Support\\Facades\\Route;\r\n	\r\n	/**\r\n     * Bootstrap any application services.\r\n     *\r\n     * @return void\r\n     */\r\n    public function boot()\r\n    {\r\n        Route::resourceVerbs([\r\n            \'create\' => \'new\'\r\n        ]);\r\n    }\r\n	\r\n此时，整个项目的路由列表变为：\r\n\r\n	Laravel55> php artisan route:list\r\n	+--------+-----------+---------------------------------------+------------------+----------------------------------------------------------+--------------+\r\n	| Domain | Method    | URI                                   | Name             | Action                                                   | Middleware   |\r\n	+--------+-----------+---------------------------------------+------------------+----------------------------------------------------------+--------------+\r\n	|        | GET|HEAD  | /                                     |                  | Closure                                                  | web          |\r\n	|        | GET|HEAD  | api/user                              |                  | Closure                                                  | api,auth:api |\r\n	|        | GET|HEAD  | episodes                              | episodes.index   | App\\Http\\Controllers\\EpisodesController@index            | web          |\r\n	|        | GET|HEAD  | episodes/{episode}                    | episodes.show    | App\\Http\\Controllers\\EpisodesController@show             | web          |\r\n	|        | PUT|PATCH | episodes/{episode}                    | episodes.update  | App\\Http\\Controllers\\EpisodesController@update           | web          |\r\n	|        | GET|HEAD  | episodes/{episode}/edit               | episodes.edit    | App\\Http\\Controllers\\EpisodesController@edit             | web          |\r\n	|        | POST      | podcasts                              | podcasts.store   | App\\Http\\Controllers\\PodcastsController@store            | web          |\r\n	|        | GET|HEAD  | podcasts                              | podcasts.index   | App\\Http\\Controllers\\PodcastsController@index            | web          |\r\n	|        | GET|HEAD  | podcasts/new                          | podcasts.create  | App\\Http\\Controllers\\PodcastsController@create           | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}                    | podcasts.show    | App\\Http\\Controllers\\PodcastsController@show             | web          |\r\n	|        | PUT|PATCH | podcasts/{podcast}                    | podcasts.update  | App\\Http\\Controllers\\PodcastsController@update           | web          |\r\n	|        | DELETE    | podcasts/{podcast}                    | podcasts.destroy | App\\Http\\Controllers\\PodcastsController@destroy          | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/edit               | podcasts.edit    | App\\Http\\Controllers\\PodcastsController@edit             | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/episodes           |                  | App\\Http\\Controllers\\PodcastsController@listEpisodes     | web          |\r\n	|        | POST      | podcasts/{podcast}/episodes           |                  | App\\Http\\Controllers\\EpisodesController@store            | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/episodes/new       |                  | App\\Http\\Controllers\\EpisodesController@create           | web          |\r\n	|        | POST      | podcasts/{podcast}/publish            |                  | App\\Http\\Controllers\\PodcastsController@publish          | web          |\r\n	|        | POST      | podcasts/{podcast}/subscribe          |                  | App\\Http\\Controllers\\PodcastsController@subcribe         | web          |\r\n	|        | POST      | podcasts/{podcast}/unpublish          |                  | App\\Http\\Controllers\\PodcastsController@unpublish        | web          |\r\n	|        | POST      | podcasts/{podcast}/unsubscribe        |                  | App\\Http\\Controllers\\PodcastsController@unsubcribe       | web          |\r\n	|        | POST      | podcasts/{podcast}/update-cover-image |                  | App\\Http\\Controllers\\PodcastsController@updateCoverImage | web          |\r\n	+--------+-----------+---------------------------------------+------------------+----------------------------------------------------------+--------------+\r\n	\r\n我们看下，也许这两个 URI 可以合并呢？\r\n\r\n	| Domain | Method    | URI                                   | Name             | Action                                                   | Middleware   |\r\n	+--------+-----------+---------------------------------------+------------------+----------------------------------------------------------+--------------+\r\n	|        | POST      | episodes                              | episodes.store   | App\\Http\\Controllers\\EpisodesController@store            | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/episodes           |                  | App\\Http\\Controllers\\PodcastsController@listEpisodes     | web          |\r\n	\r\n把\r\n\r\n	Route::get(\'/podcasts/{podcast}/episodes\', \'PodcastsController@listEpisodes\')\r\n	\r\n	// 改为\r\n	\r\n	Route::get(\'/podcasts/{podcast}/episodes\', \'EpisodesController@index\')\r\n	\r\n，那么下一步要做的，就是把 `listEpisodes` 方法里的逻辑正好到 `index` 方法里去。\r\n\r\n	// app/Http/Controllers/EpisodesController.php\r\n\r\n    public function index($id = null)\r\n    {\r\n        // 如果没 id\r\n\r\n        $episodes = Episode::with(\'podcast\')->recent()->paginate(25);\r\n\r\n        return view(\'episodes.index\', [\r\n            \'episodes\' => $episodes,\r\n        ]);\r\n\r\n\r\n        // 如果有 id\r\n\r\n        $podcast = Podcast::with(\'episodes\')->findOrFail($id);\r\n\r\n        abort_unless($podcast->isVisibleTo(Auth::user()), 404);\r\n\r\n        return view(\'podcasts.list-episodes\', [\r\n            \'podcast\' => $podcast,\r\n        ]);\r\n    }\r\n	\r\n先说为什么 **不要这样做** 呢？第一点，这里会有 if else 的判断逻辑，阅读起来会费劲。并且这里的参数 `$id` 的含义并不明显，也许未来除了 Podcast，还会开辟 Videos、Articles 或者其他的什么类型的内容，那么判断变多也会不容易理解。\r\n\r\n这时就要借助一个新的 Controller——`PodcastEpisodesController`。\r\n\r\n	 php artisan make:controller PodcastEpisodesController\r\n\r\n接下来，将 `listEpisodes` 方法的逻辑放在 `PodcastEpisodesController` 的 `index` 方法里。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use App\\Podcast;\r\n	use Illuminate\\Http\\Request;\r\n\r\n	class PodcastEpisodesController extends Controller\r\n	{\r\n		public function index($podcast) \r\n		{\r\n			$podcast = Podcast::with(\'episodes\')->findOrFail($podcast);\r\n\r\n			abort_unless($podcast->isVisibleTo(Auth::user()), 404);\r\n\r\n			return view(\'podcasts.list-episodes\', [\r\n				\'podcast\' => $podcast,\r\n			]);\r\n		}\r\n	}\r\n\r\n所以 `routes/web.php` 中，需要把\r\n\r\n	Route::get(\'/podcasts/{podcast}/episodes\', \'PodcastsController@listEpisodes\');\r\n	\r\n	// 修改为\r\n	Route::get(\'/podcasts/{podcast}/episodes\', \'PodcastEpisodesController@index\');\r\n\r\n还有把\r\n\r\n	Route::get(\'/podcasts/{podcast}/episodes/new\', \'EpisodesController@create\');\r\n	Route::post(\'/podcasts/{podcast}/episodes\', \'EpisodesController@store\');\r\n\r\n	// 修改为\r\n	Route::get(\'/podcasts/{podcast}/episodes/new\', \'PodcastEpisodesController@create\');\r\n	Route::post(\'/podcasts/{podcast}/episodes\', \'PodcastEpisodesController@store\');\r\n\r\n`PodcastEpisodesController` 中添加 `create` 和 `store` 方法：\r\n\r\n	public function create($podcast) {\r\n		$podcast = Auth::user()->podcasts->findOrFail($id);\r\n\r\n		return view(\'episodes.create\', [\r\n			\'podcast\' => $podcast,\r\n		]);\r\n	} \r\n\r\n	public function store($podcast)\r\n	{\r\n		$podcast = Auth::user()->podcasts()->findOrFail($podcast);\r\n\r\n		request()->validate([\r\n			\'title\' => \'required|max:150\',\r\n			\'description\' => \'max:500\',\r\n			\'download_url\' => \'required|url\',\r\n		]);\r\n\r\n		$episode = $podcast->episodes()->create(request([\r\n			\'title\',\r\n			\'description\',\r\n			\'download_url\',\r\n		]));\r\n\r\n		return redirect(\"/episodes/{$episode->id}\");\r\n	}\r\n\r\n现在，`routes/web.php` 看起来是这样的：\r\n\r\n	Route::post(\'/podcasts/{podcast}/update-cover-image\', \'PodcastsController@updateCoverImage\');\r\n	Route::post(\'/podcasts/{podcast}/subscribe\', \'PodcastsController@subcribe\');\r\n	Route::post(\'/podcasts/{podcast}/unsubscribe\', \'PodcastsController@unsubcribe\');\r\n	Route::post(\'/podcasts/{podcast}/publish\', \'PodcastsController@publish\');\r\n	Route::post(\'/podcasts/{podcast}/unpublish\', \'PodcastsController@unpublish\');\r\n\r\n	Route::resource(\'podcasts\', \'PodcastsController\');\r\n\r\n	Route::get(\'/podcasts/{podcast}/episodes\', \'PodcastEpisodesController@index\');\r\n	Route::get(\'/podcasts/{podcast}/episodes/new\', \'PodcastEpisodesController@create\');\r\n	Route::post(\'/podcasts/{podcast}/episodes\', \'PodcastEpisodesController@store\');\r\n\r\n	Route::resource(\'episodes\', \'EpisodesController\', [\r\n		\'only\' => [\'index\', \'show\', \'edit\', \'update\', \'delete\']\r\n	]);\r\n\r\n现在，路由列表看起来是这样的：\r\n\r\n	Laravel55> php artisan route:list\r\n	+--------+-----------+---------------------------------------+------------------+----------------------------------------------------------+--------------+\r\n	| Domain | Method    | URI                                   | Name             | Action                                                   | Middleware   |\r\n	+--------+-----------+---------------------------------------+------------------+----------------------------------------------------------+--------------+\r\n	|        | GET|HEAD  | /                                     |                  | Closure                                                  | web          |\r\n	|        | GET|HEAD  | api/user                              |                  | Closure                                                  | api,auth:api |\r\n	|        | GET|HEAD  | episodes                              | episodes.index   | App\\Http\\Controllers\\EpisodesController@index            | web          |\r\n	|        | GET|HEAD  | episodes/{episode}                    | episodes.show    | App\\Http\\Controllers\\EpisodesController@show             | web          |\r\n	|        | PUT|PATCH | episodes/{episode}                    | episodes.update  | App\\Http\\Controllers\\EpisodesController@update           | web          |\r\n	|        | GET|HEAD  | episodes/{episode}/edit               | episodes.edit    | App\\Http\\Controllers\\EpisodesController@edit             | web          |\r\n	|        | GET|HEAD  | podcasts                              | podcasts.index   | App\\Http\\Controllers\\PodcastsController@index            | web          |\r\n	|        | POST      | podcasts                              | podcasts.store   | App\\Http\\Controllers\\PodcastsController@store            | web          |\r\n	|        | GET|HEAD  | podcasts/new                          | podcasts.create  | App\\Http\\Controllers\\PodcastsController@create           | web          |\r\n	|        | PUT|PATCH | podcasts/{podcast}                    | podcasts.update  | App\\Http\\Controllers\\PodcastsController@update           | web          |\r\n	|        | DELETE    | podcasts/{podcast}                    | podcasts.destroy | App\\Http\\Controllers\\PodcastsController@destroy          | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}                    | podcasts.show    | App\\Http\\Controllers\\PodcastsController@show             | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/edit               | podcasts.edit    | App\\Http\\Controllers\\PodcastsController@edit             | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/episodes           |                  | App\\Http\\Controllers\\PodcastEpisodesController@index     | web          |\r\n	|        | POST      | podcasts/{podcast}/episodes           |                  | App\\Http\\Controllers\\PodcastEpisodesController@store     | web          |\r\n	|        | GET|HEAD  | podcasts/{podcast}/episodes/new       |                  | App\\Http\\Controllers\\PodcastEpisodesController@create    | web          |\r\n	|        | POST      | podcasts/{podcast}/publish            |                  | App\\Http\\Controllers\\PodcastsController@publish          | web          |\r\n	|        | POST      | podcasts/{podcast}/subscribe          |                  | App\\Http\\Controllers\\PodcastsController@subcribe         | web          |\r\n	|        | POST      | podcasts/{podcast}/unpublish          |                  | App\\Http\\Controllers\\PodcastsController@unpublish        | web          |\r\n	|        | POST      | podcasts/{podcast}/unsubscribe        |                  | App\\Http\\Controllers\\PodcastsController@unsubcribe       | web          |\r\n	|        | POST      | podcasts/{podcast}/update-cover-image |                  | App\\Http\\Controllers\\PodcastsController@updateCoverImage | web          |\r\n	+--------+-----------+---------------------------------------+------------------+----------------------------------------------------------+--------------+','2017-08-31 06:04:27','2017-08-31 08:45:31','laracon-2017-according-to-the-principle-of-writing-fine-grained-controller-1'),(330,15,15,'dafd','```\r\n<?php\r\n \r\n\r\n?>\r\n```','2017-08-31 06:23:11','2017-08-31 06:23:11','dafd'),(331,3,3,'LaraCon 2017：Laravel Scout 和 Algolia','> 原文地址：https://streamacon.com/video/laracon-us-2017/day-1-maxime-locqueville\r\n\r\n## 什么是 Laravel Scout\r\n\r\n* Adding full-text search to Eloquent models\r\n* Driver based\r\n* Algolia is one of those drivers\r\n\r\n## 什么是 Algolia\r\n\r\n*  A hosted search API\r\n*  Intuitive relevance\r\n*  Very fast => results in milliseconds\r\n*  Building blocks to build great search UIs\r\n\r\n## 构建搜索步骤\r\n\r\n1. Import & Sync data via Client API\r\n2. 制定/微调结果数据的排序规则\r\n3. Search from Front-end，advanced in 用户体验（User Experience），display instance Search results。\r\n\r\n## 配置\r\n\r\n### `.env`\r\n\r\n`ALGOLIA_APP_ID`、`ALGOLIA_SECRET`。\r\n\r\n### `config/app.php`\r\n\r\n添加服务提供者 `ScoutServiceProvider.php`。\r\n\r\n### Speaker Model\r\n	\r\n	use Laravel\\Scout\\Searchable;\r\n\r\n	use Searchable;\r\n\r\n### 上传数据\r\n\r\n`php artisan scout:import \"App\\Speaker\"`。','2017-08-31 07:25:31','2017-08-31 07:25:31','2017-laracon-laravel-scout-and-algolia'),(332,3,3,'LaraCon 2017：根据原则写细粒度的 Controller（2️⃣）','## 技巧一\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/laracon-2-2.png)\r\n\r\n这句话的意思是说，不要在资源控制器的内部再操作别的资源了。比如\r\n\r\n	Route::post(\'/podcasts/{podcast}/update-cover-image\', \'PodcastsController@updateCoverImage\');\r\n\r\n就是属于在操作 Podcasts 资源的时候操作了图片资源，方法名看起来很不优雅，而且让 `PodcastsController` 也不纯粹了，不要这样。我们将其更改为：\r\n\r\n	Route::post(\'/podcasts/{podcast}/update-cover-image\', \'PodcastCoverImageController@update\');\r\n\r\n下面创建 `PodcastCoverImageController`。\r\n\r\n	php artisan make:controller PodcastCoverImageController\r\n\r\n内容如下：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Http\\Request;\r\n\r\n	class PodcastCoverImageController extends Controller\r\n	{\r\n		public function update($podcast) \r\n		{\r\n			$podcast = Auth::user()->podcasts->findOrFail($podcast);\r\n\r\n			request()->validate([\r\n				\'cover_image\' => [\'required\', \'image\', Rule::dimensions()->minHeight(500), Rule::dimensions()->minWidth(500)],\r\n			]);\r\n\r\n			$podcast->update([\r\n				\'cover_path\' => request()->file(\'cover_image\')->store(\'images\', \'public\'),\r\n			]);\r\n\r\n			return redirect(\"/podcasts/{$podcast->id}\");\r\n		}\r\n	}','2017-08-31 08:45:17','2017-08-31 09:45:24','laracon-2017-according-to-the-principle-of-writing-fine-grained-controller-2'),(333,3,3,'LaraCon 2017：根据原则写细粒度的 Controller（3️⃣）','## 技巧二\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/08/laracon-2-3.png)\r\n\r\n订阅/取消订阅、发布/取消发布 都可以作为单独独立出来的新控制器用。\r\n\r\n这时修改下我们的 `routes/web.php`。\r\n\r\n	Route::post(\'/podcasts/{podcast}/subscribe\', \'PodcastsController@subcribe\');\r\n	Route::post(\'/podcasts/{podcast}/unsubscribe\', \'PodcastsController@unsubcribe\');\r\n\r\n	// 修改为\r\n	Route::post(\'/subscriptions\', \'SubscriptionsController@store\');\r\n	Route::delete(\'/subscriptions/{$id}\', \'SubscriptionsController@destroy\');','2017-08-31 09:55:35','2017-08-31 09:55:35','laracon-2017-according-to-the-principle-of-writing-fine-grained-controller-3'),(334,3,3,'LaraCon 2017','* https://streamacon.com/video/laracon-us-2017/day-1-adam-wathan\r\n* https://streamacon.com/video/laracon-us-2017/day-1-taylor-otwell\r\n* https://streamacon.com/video/laracon-us-2017/day-2-jeffrey-way','2017-09-01 05:34:05','2017-09-01 05:34:05','laracon-2017'),(335,3,3,'line-height 和鼠标的有效可点击区域','对行内元素而言，以 `<a>` 为例：\r\n\r\n	a {\r\n		font-size: 14px;\r\n		line-height: 28px;\r\n	}\r\n\r\n那么鼠标有效可点击区的高度是 `14px`。只有将 `<a>` 转换为 block 块（`block` 或者 `inline-block`）。\r\n\r\n	a {\r\n		display: block;\r\n		font-size: 14px;\r\n		line-height: 28px;\r\n	}\r\n\r\n鼠标有效可点击区的高度才是 `28px`。','2017-09-01 08:32:18','2017-09-09 05:40:11','the-line-height-and-the-content-validity-the-mouse-click-on-the-area'),(336,3,3,'Laravel 文档阅读：Blade 模版','![电影《功夫》截图](http://www.baooab.com/wp/wp-content/uploads/2017/09/kufung-1.png)\r\n\r\n\r\n> 翻译、衍生自：https://laravel.com/docs/5.5/localization 。\r\n> \r\n> 图片来源：周星驰电影作品《功夫》。\r\n\r\n## 简介\r\n\r\nBlade 是 Laravel 提供的模版引擎，它简单、强大。不像其他的 PHP 模版引擎，Blade 允许在视图中使用原生 PHP 代码。实际上，所有的 Blade 视图最终都会被编译为原生 PHP 代码，缓存在 `storage/framework/views` 文件夹中。**Laravel 使用的是这些编译后的缓存文件**，而不是视图文件本身，所以，Blade 对于应用程序来说几乎是零开销的。当你修改了视图文件，那么它会重新编译并缓存，以便使用。Blade 视图文件以 `.blade.php` 作为后缀名，一般存储在 `resources/views` 文件夹中。\r\n\r\n## 模版继承\r\n\r\n### 定义布局文件\r\n\r\nBlade 模版引擎的两个主要优点是 _模版继承_ 和 _区块_。举一个简单的例子，一个项目里，几乎所有的页面都是一样的布局，这时候就可以把这个布局提炼出来，作为“母版页”，继承了这个母版页的页面都有一样的布局效果，称为母版页的“子页”。母版页还叫布局文件，布局文件就是一个 Blade 视图：\r\n\r\n	<!-- Stored in resources/views/layouts/app.blade.php -->\r\n\r\n	<html>\r\n		<head>\r\n			<title>App Name - @yield(\'title\')</title>\r\n		</head>\r\n		<body>\r\n			@section(\'sidebar\')\r\n				This is the master sidebar.\r\n			@show\r\n\r\n			<div class=\"container\">\r\n				@yield(\'content\')\r\n			</div>\r\n		</body>\r\n	</html>\r\n\r\n布局文件里除了基础的 HTML 标签，还用了两个指令：`@section` 和 `@yield`。`@section` 指令定义区块，`@yield` 指令定义区块里的内容。\r\n\r\n下面，来定义布局文件的子页。\r\n\r\n### 继承布局文件\r\n\r\n子页中，使用 Blade 的 `@extends` 指令指定“继承”的布局文件，使用 `@section` 指令为在布局文件中使用 `@section` 和 `@yield` 指令定义的地方注入内容。\r\n\r\n	<!-- Stored in resources/views/child.blade.php -->\r\n\r\n	@extends(\'layouts.app\')\r\n\r\n	@section(\'title\', \'Page Title\')\r\n\r\n	@section(\'sidebar\')\r\n		\r\n\r\n		<p>This is appended to the master sidebar.</p>\r\n	@endsection\r\n\r\n	@section(\'content\')\r\n		<p>This is my body content.</p>\r\n	@endsection\r\n\r\n可以看到，在布局文件中使用 `@yield` 指令定义的地方，在子页中仍然使用 `@section` 注入内容；在布局文件中使用 `@section` 指令定义的一个好处是：在子页中使用 `@section` 注入内容时，可以使用 `@parent` 指令附加（而非重写）在布局文件中的内容，而在布局文件中使用 `@yield` 指令定义的地方是做不到的。 `@parent` 指令会在视图渲染时替换成布局文件里的内容。\r\n\r\n注意，与在布局文件里定义的 `sidebar` 不同的是，子页里使用 `@endsection` 结束，而非 `@show`。因为 `@endsection` 仅用来定义区块，而 `@show` 是用来定义、立马产出区块的。\r\n\r\n从路由中返回视图文件，要用到全局辅助函数 `helper`：\r\n\r\n	Route::get(\'blade\', function () {\r\n		return view(\'child\');\r\n	});\r\n\r\n## 组件 & 插槽\r\n\r\n组件和插槽提供了类似布局和区块的优点。而组件和插槽的心智模型更符合直觉。设想一下，在我们的项目中有一个可重用的“弹框”组件：\r\n\r\n	<!-- /resources/views/alert.blade.php -->\r\n\r\n	<div class=\"alert alert-danger\">\r\n		{{ $slot }}\r\n	</div>\r\n\r\n`{{ $slot }}` 变量表示插入的组件内容。构建此组件，是使用 Blade 的 `@component` 指令。 \r\n\r\n	@component(\'alert\')\r\n		<strong>Whoops!</strong> Something went wrong!\r\n	@endcomponent\r\n\r\n在这个场景里，`{{ $slot }}` 变量的内容就是\r\n\r\n	<strong>Whoops!</strong> Something went wrong!\r\n\r\n有时一个组件需要有多个插槽。这时，只要稍许修改组件代码，定义一个“标题”插槽，这个插槽称命名插槽。命名插槽是通过简单地“打印”匹配其名称的变量来显示内容的：\r\n\r\n	<!-- /resources/views/alert.blade.php -->\r\n\r\n	<div class=\"alert alert-danger\">\r\n		<div class=\"alert-title\">{{ $title }}</div>\r\n\r\n		{{ $slot }}\r\n	</div>\r\n\r\n为命名插槽注入内容，使用 `@slot` 指令。所有不在 `@slot` 指令里的内容都会传递给组件里的 `$slot` 变量：\r\n\r\n	@component(\'alert\')\r\n		@slot(\'title\')\r\n			Forbidden\r\n		@endslot\r\n\r\n		You are not allowed to access this resource!\r\n	@endcomponent\r\n\r\n#### 为组件传递额外数据\r\n\r\n有时需要为组件传递额外数据。为此，可以为 `@component` 指令传递第二个数组参数，指定要传递的额外数据。所有传递过去的额外数据作为变量，在组件模版里都是可取的：\r\n\r\n	@component(\'alert\', [\'foo\' => \'bar\'])\r\n		...\r\n	@endcomponent\r\n\r\n## 显示数据\r\n\r\n向 Blade 视图传递数据，是通过将变量包裹在大括号（`[]`）里实现的：\r\n\r\n	Route::get(\'greeting\', function () {\r\n		return view(\'welcome\', [\'name\' => \'Samantha\']);\r\n	});\r\n\r\n下面，就可以用 `name` 变量显示内容了：\r\n\r\n	Hello, {{ $name }}.\r\n\r\n`{{ }}` 是 Blade 视图的打印语句，当然，打印语句里不限制只能打印变量内容，也可以使用 PHP 函数。实际上，打印语句这里可以使用任何 PHP 代码：\r\n\r\n	The current UNIX timestamp is {{ time() }}.\r\n\r\n#### 显示非转义数据\r\n\r\n默认，所有传递给 Blade `{{ }}` 语句的内容都会使用 `htmlspecialchars` 函数处理、将内容转义，避免 XSS 攻击。如果无需转义输出的内容，可以使用下面的语法：\r\n\r\n	Hello, {!! $name !!}.\r\n\r\n不过千万要小心，应该总是优先选择使用转义的 `{{ }}` 语法以避免 XSS 攻击。因为，有时你很能难避免用户有意的、无意的数据输入。\r\n\r\n### Blade & JavaScript 框架\r\n\r\n由于一些 JavaScript 框架也使用花括号（`{{ }}`）语法解析内容，为了区分开 Blade 和这些用到的 JavaScript 框架，你可以使用 `@` 符号来告诉 Blade 模版渲染引擎说，这个地方不要动，保持原样就可以了：\r\n\r\n	<h1>Laravel</h1>\r\n\r\n	Hello, @{{ name }}.\r\n\r\n上面例子里，`@` 符号会从 Blade 中删除，而 `{{ name }}` 会保持原样，用来给你的 JavaScript 框架渲染使用。\r\n\r\n#### `@verbatim` 指令\r\n\r\n如果使用 JavaScript 框架渲染的模版区域很大，这时就可以用 `@verbatim` 指令包裹这些模版区域，这样就避免了在每个 Blade 打印语句前都跟上 `@` 符号的麻烦：\r\n\r\n	@verbatim\r\n		<div class=\"container\">\r\n			Hello, {{ name }}.\r\n		</div>\r\n	@endverbatim\r\n\r\n## 控制结构\r\n\r\n除了模版继承和显示数据，Blade 还为常见的 PHP 控制结构提供了快捷方式，比如条件判断和循环。这些快捷方式提供了一种非常干净、简洁的控制结构，并且保持了原生 PHP 的形式。\r\n\r\n### If 语句\r\n\r\n构造 `if` 语句使用 `@if`、`@elseif`、`@else` 和 `endif` 指令。这些指令和原生 PHP 的控制功能一一对应：\r\n\r\n	@if (count($records) === 1)\r\n		I have one record!\r\n	@elseif (count($records) > 1)\r\n		I have multiple records!\r\n	@else\r\n		I don\'t have any records!\r\n	@endif\r\n\r\n为了方便，Blade 还提供了 `@unless` 指令：\r\n\r\n	@unless (Auth::check())\r\n		You are not signed in.\r\n	@endunless\r\n\r\n除了讨论过的条件判断指令，Blade 还提供了 `@isset` 和 `@empty` 指令，都与在原生 PHP 里的对应功能相同：\r\n\r\n	@isset($records)\r\n		// $records is defined and is not null...\r\n	@endisset\r\n\r\n	@empty($records)\r\n		// $records is \"empty\"...\r\n	@endempty\r\n\r\n#### 认证\r\n\r\n`@auth` 和 `@guest` 指令用来判断当前用户是认证用户还是游客：\r\n\r\n	@auth\r\n		// The user is authenticated...\r\n	@endauth\r\n\r\n	@guest\r\n		// The user is not authenticated...\r\n	@endguest\r\n\r\n### Switch 语句\r\n\r\n`switch` 语句使用 `@switch`、`@case`、`@break`、`@default` 和 `@endswitch` 指令构建：\r\n\r\n	@switch($i)\r\n		@case(1)\r\n			First case...\r\n			@break\r\n\r\n		@case(2)\r\n			Second case...\r\n			@break\r\n\r\n		@default\r\n			Default case...\r\n	@endswitch\r\n\r\n### 循环\r\n\r\nBlade 还提供了循环方面的指令。再一次，这里的每一个指令都与在原生 PHP 里的对应功能相同。\r\n\r\n	@for ($i = 0; $i < 10; $i++)\r\n		The current value is {{ $i }}\r\n	@endfor\r\n\r\n	[@foreach](https://laravel-china.org/users/5651) ($users as $user)\r\n		<p>This is user {{ $user->id }}</p>\r\n	@endforeach\r\n\r\n	@forelse ($users as $user)\r\n		<li>{{ $user->name }}</li>\r\n	@empty\r\n		<p>No users</p>\r\n	@endforelse\r\n\r\n	@while (true)\r\n		<p>I\'m looping forever.</p>\r\n	@endwhile\r\n\r\n在循环时，也可以结束或者跳过当前的迭代：\r\n\r\n	[@foreach](https://laravel-china.org/users/5651) ($users as $user)\r\n		@if ($user->type == 1)\r\n			@continue\r\n		@endif\r\n\r\n		<li>{{ $user->name }}</li>\r\n\r\n		@if ($user->number == 5)\r\n			@break\r\n		@endif\r\n	@endforeach\r\n\r\n也可以在一行完成这些操作：\r\n\r\n	[@foreach](https://laravel-china.org/users/5651) ($users as $user)\r\n		@continue($user->type == 1)\r\n\r\n		<li>{{ $user->name }}</li>\r\n\r\n		@break($user->number == 5)\r\n	@endforeach\r\n\r\n### `$loop` 变量\r\n\r\n循环时，循环内部有一个可用的变量 `$loop`。这个变量提供了跟循环有关的有用信息，比如当前迭代的索引、是否是第一次/最后依次迭代等：\r\n\r\n	[@foreach](https://laravel-china.org/users/5651) ($users as $user)\r\n		@if ($loop->first)\r\n			This is the first iteration.\r\n		@endif\r\n\r\n		@if ($loop->last)\r\n			This is the last iteration.\r\n		@endif\r\n\r\n		<p>This is user {{ $user->id }}</p>\r\n	@endforeach\r\n\r\n如果是在嵌套的循环里，就可以使用 `$loop` 变量的 `parent` 属性父级循环里的 `$loop` 变量：\r\n\r\n	[@foreach](https://laravel-china.org/users/5651) ($users as $user)\r\n		[@foreach](https://laravel-china.org/users/5651) ($user->posts as $post)\r\n			@if ($loop->parent->first)\r\n				This is first iteration of the parent loop.\r\n			@endif\r\n		@endforeach\r\n	@endforeach\r\n\r\n`$loop` 变量提供的有用属性列举如下：\r\n\r\n\r\n| 属性 | 描述 |\r\n| -------- | -------- |\r\n| `$loop->index`     | 当前循环迭代的索引（从 0 开始）。     |\r\n| `$loop->iteration`     | 当前的循环迭代（从 1 开始）。     |\r\n| `$loop->remaining`     | 剩下的循环迭代。     |\r\n| `$loop->count`     | 循环的总次数。     |\r\n| `$loop->first`     | 是否是整个循环的第一次迭代。     |\r\n| `$loop->last`     | 是否是整个循环的最后一次迭代。     |\r\n| `$loop->depth`     | 当前循环的嵌套水平（从 1 开始）。     |\r\n| `$loop->parent`     | 内层嵌套循环的父级 `$loop` 变量。     |\r\n\r\n\r\n### 注释\r\n\r\nBlade 的注释语法是 `{{--   --}}`。不像 HTMl 注释，Blade 模版注释不会出现在最终渲染的 HTML 代码里：\r\n\r\n	{{-- This comment will not be present in the rendered HTML --}}\r\n\r\n### PHP\r\n\r\n一些情况下，要在视图里嵌入 PHP 代码。这时可以用 `[@php](https://laravel-china.org/users/10050)` 指令在模版里执行一块原生 PHP 代码。\r\n\r\n	[@php](https://laravel-china.org/users/10050)\r\n		//\r\n	@endphp\r\n\r\n虽然 Blade 提供了此功能，但过于频繁的使用它，可能说明你在模版里嵌入太多逻辑代码了，这并不妥当。\r\n\r\n## 引入子视图\r\n\r\nBlade 允许在一个视图里通过 `@include` 指令引入一个视图。使用 `@include` 指令的视图称为父级视图，引入的视图称为子视图。父级视图里的所有变量在子视图里都是可以获得的：\r\n\r\n	<div>\r\n		@include(\'shared.errors\')\r\n\r\n		<form>\r\n			<!-- Form Contents -->\r\n		</form>\r\n	</div>\r\n\r\n虽然子视图会继承父级视图里的所有变量，但是你也可以为引入的子视图传递额外数据，这些数据是以数组形式传递过去的：\r\n\r\n	@include(\'view.name\', [\'some\' => \'data\'])\r\n\r\n当你用 `@include` 指令引入的视图文件不存在时，Laravel 会抛出错误。如果引入的视图文件不确定是否存在，应该使用 `@includeIf` 指令：\r\n\r\n	@includeIf(\'view.name\', [\'some\' => \'data\'])\r\n\r\n如果需要通过一个布尔值判断是否引入子视图，需要使用 `@includeWhen` 指令：\r\n\r\n	@includeWhen($boolean, \'view.name\', [\'some\' => \'data\'])\r\n\r\n注意，不要使用 `__DIR__` 和 `__FILE__` 常量引入 Blade 视图，因为程序实际使用的是编译后的、缓存在 `storage/framework/views` 文件夹中的文件。\r\n\r\n### 为集合渲染视图\r\n\r\n`@each` 指令整合了循环数据和引入视图的功能：\r\n\r\n	@each(\'view.name\', $jobs, \'job\')\r\n\r\n第一个参数是为数组或者集合中每个元素渲染数据时指定的视图，第二个参数是要遍历的数组或者集合，第三个参数是当前迭代的元素数据在子视图里的变量名。在上面的例子里，我们遍历的数组是 `jobs`，在 `view.name` 视图里渲染 `job` 变量，当前迭代的 key 使用 `key` 变量获取。\r\n\r\n也可以为 `@each` 指令传递第四个参数，这是在给定数组元素为空时渲染的视图。\r\n\r\n	@each(\'view.name\', $jobs, \'job\', \'view.empty\')\r\n\r\n注意，使用 `@each` 指令渲染的视图不从父级模版里继承变量。如果子视图还需要这些变量，你应该使用 `[@foreach](https://laravel-china.org/users/5651)` 和 `@include` 指令组合。\r\n\r\n## 堆栈\r\n\r\nBlade 允许你用 `@push` 指令向命名堆栈里推入内容，命名堆栈以 `@stack` 指令定义，可以定义在普通视图或者布局文件里，推入的内容会在视图或者布局文件里渲染出来。这在，为子视图添加额外的 JavaScript 库的场景下，特别有用。\r\n\r\n	<!--  在视图或者布局文件中定义堆栈 -->\r\n	<head>\r\n		<!-- Head Contents -->\r\n\r\n		@stack(\'scripts\')\r\n	</head>\r\n\r\n	<!-- 在子视图中推入堆栈内容 -->\r\n	@push(\'scripts\')\r\n		<script src=\"/example.js\"></script>\r\n	@endpush\r\n\r\n你可以尽你所需的多次向堆栈推入数据。\r\n\r\n## 服务注入\r\n\r\n`@inject` 指令可从 Laravel 的服务提供者中获得服务。传递给 `@inject` 指令的第一个参数是一个变量名，获得的服务就是存放在这个变量里的，第二个参数就是你要解析的服务的类名或接口名。\r\n\r\n	@inject(\'metrics\', \'App\\Services\\MetricsService\')\r\n\r\n	<div>\r\n		Monthly Revenue: {{ $metrics->monthlyRevenue() }}.\r\n	</div>\r\n\r\n## 扩展 Blade\r\n\r\nBlade 允许你用 `directive` 方法创建自定义指令。当 Blade 解析遇到自定义指令时，会将接受到的表达式（expression）放在自定义指令的回调闭包里处理。\r\n\r\n在下面的例子里，我们为创建了一个 `@datatime($var)` 指令，`$var` 应该是一个 `DateTime` 实例：\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use Illuminate\\Support\\Facades\\Blade;\r\n	use Illuminate\\Support\\ServiceProvider;\r\n\r\n	class AppServiceProvider extends ServiceProvider\r\n	{\r\n		/**\r\n		 * Perform post-registration booting of services.\r\n		 *\r\n		 * @return void\r\n		 */\r\n		public function boot()\r\n		{\r\n			Blade::directive(\'datetime\', function ($expression) {\r\n				return \"<?php echo ($expression)->format(\'m/d/Y H:i\'); ?>\";\r\n			});\r\n		}\r\n\r\n		/**\r\n		 * Register bindings in the container.\r\n		 *\r\n		 * @return void\r\n		 */\r\n		public function register()\r\n		{\r\n			//\r\n		}\r\n	}\r\n\r\n可以看到，我们在传递过来的表达式上使用了 `format` 方法。在这个例子里，`@datatime($var)` 指令最终生成的 PHP 代码如下：\r\n\r\n	<?php echo ($var)->format(\'m/d/Y H:i\'); ?>\r\n\r\n注意，在更新自定义指令后，需要删除所有的视图缓存文件，可以用 `view:cache` Artisan 命令实现。\r\n\r\n### 自定义 If 语句\r\n\r\n当自定义指令涉及简单的条件判断时，使用 `Blade::directive` 的方式可能会变得稍复杂些。为此，Blade 引入了 `Blade::if` 方法，使用闭包来快速自定义条件判断指令。例如，我们定义一个指令，判断当前的项目环境，可以选择在 `AppServiceProvider` 的 `boot` 里做这件事情：\r\n\r\n	use Illuminate\\Support\\Facades\\Blade;\r\n\r\n	/**\r\n	 * Perform post-registration booting of services.\r\n	 *\r\n	 * @return void\r\n	 */\r\n	public function boot()\r\n	{\r\n		Blade::if(\'env\', function ($environment) {\r\n			return app()->environment($environment);\r\n		});\r\n	}\r\n\r\n定义好后，咱使用它：\r\n\r\n	@env(\'local\')\r\n		// The application is in the local environment...\r\n	@else\r\n		// The application is not in the local environment...\r\n	@endenv\r\n\r\n是不是很简单呢？?','2017-09-03 14:18:37','2017-09-05 00:50:58','laravel-document-reading-blade-template'),(339,3,3,'Laravel 文档阅读：国际化','> 翻译、衍生自：https://laravel.com/docs/5.5/localization\r\n\r\n## 简介\r\n\r\nLaravel 对国际化的支持非常友好，允许项目支持多种语言。当你看到它的文件夹结构就非常清晰了。\r\n\r\n	/resources\r\n		/lang\r\n			/en\r\n				messages.php\r\n			/zh-CN\r\n				messages.php\r\n\r\nLaravel 的国际化文件都放在 `resources/lang` 下面，每种语言对应其中的一个子文件夹，`en` 指英文国际化文件，`zh-CN` 指中文简体的国际化文件，你可以按照实际需要创建新的语言文件夹和里面的国际化文件。\r\n\r\n所有的国际化文件都是返回一个数组，数组的键是字符串类型的：\r\n\r\n	<?php\r\n\r\n	return [\r\n		\'welcome\' => \'Welcome to our application\'\r\n	];\r\n\r\n## 配置语言环境\r\n\r\n项目使用的默认语言是在 `config/app.php` 配置文件里设定的，你可以按照实际需要修改它。\r\n\r\n		/*\r\n		|--------------------------------------------------------------------------\r\n		| Application Locale Configuration\r\n		|--------------------------------------------------------------------------\r\n		|\r\n		| The application locale determines the default locale that will be used\r\n		| by the translation service provider. You are free to set this value\r\n		| to any of the locales which will be supported by the application.\r\n		|\r\n		*/\r\n\r\n		\'locale\' => \'zh-CN\',\r\n\r\n也可以使用 `App` 门面的 `setLocale` 方法灵活改变语言环境。\r\n\r\n	Route::get(\'welcome/{locale}\', function ($locale) {\r\n		App::setLocale($locale);\r\n\r\n		//\r\n	});\r\n\r\n「回退语言」也是支持的，所谓的回退语言是指当默认语言的国际化文本没有提供时，就会使用回退语言的对应国际化文本，这个也是在 `config/app.php` 中配置的：\r\n\r\n		/*\r\n		|--------------------------------------------------------------------------\r\n		| Application Fallback Locale\r\n		|--------------------------------------------------------------------------\r\n		|\r\n		| The fallback locale determines the locale to use when the current one\r\n		| is not available. You may change the value to correspond to any of\r\n		| the language folders that are provided through your application.\r\n		|\r\n		*/\r\n\r\n		\'fallback_locale\' => \'en\',\r\n\r\n#### 判断当前的语言环境\r\n\r\n可以使用 `App` 门面的 `getLocale` 方法获得当前的语言环境，使用 `isLocale ` 方法检验当前的语言环境是否是给定的值：\r\n\r\n	$locale = App::getLocale();\r\n\r\n	if (App::isLocale(\'en\')) {\r\n		//\r\n	}\r\n\r\n## 定义翻译字符串\r\n\r\n### 使用简短的键\r\n\r\n已经说过，国际化文本保存在 `resources/lang` 目录下。此目录下的每个子目录对应项目中支持的一种语言。\r\n	\r\n	/resources\r\n		/lang\r\n			/en\r\n				messages.php\r\n			/zh-CN\r\n				messages.php\r\n\r\n所有的语言文件都简单的返回一个数组，数组的键是字符串类型的：\r\n\r\n	<?php\r\n\r\n	// resources/lang/en/messages.php\r\n\r\n	return [\r\n		\'welcome\' => \'Welcome to our application\'\r\n	];\r\n\r\n### 使用翻译字符串作为键\r\n\r\n如果一个项目中有大量需要国际化的页面字段，这时定义前面这种「简短的键」，就会面临问题——有时很难分清长相相似的键的区别和在哪里使用了它们。所以，有时使用翻译字符串作为键不失为一种好方法。\r\n\r\n使用翻译字符串作为键的翻译文件是以 JSON 格式存储在 `resources/lang` 中的。例如，如果项目支持西班牙文。\r\n\r\n	// config/app.php\r\n	\r\n	\'locale\' => \'es\',\r\n\r\n那么对应的，就要创建一个 `resources/lang/es.json` 文件：\r\n\r\n	{\r\n		\"I love programming.\": \"Me encanta programar.\"\r\n	}\r\n\r\n## 获得翻译字符串\r\n\r\n使用全局辅助函数 `__` 来获得翻译字符串， `__` 函数的第一个参数使用 **键**（指使用翻译字符串作为键的键） 或者是 **文件.键** 的形式。\r\n\r\n	echo __(\'messages.welcome\');\r\n\r\n	echo __(\'I love programming.\');\r\n\r\n如果使用 Blade 模板引擎打印国际化文本，可以使用 `{{ }}` 语法或者使用 `@lang` 指令：\r\n\r\n	{{ __(\'messages.welcome\') }}\r\n\r\n	@lang(\'messages.welcome\')\r\n\r\n如果没有找到对应的翻译字符串，`__` 函数就会返回翻译字符串键本身。对于上面的例子，如果翻译字符串不存在，`__` 函数就会返回「messages.welcome」这个内容。\r\n\r\n\r\n### 在翻译字符串中定义占位符\r\n\r\n也可以在翻译字符串中定义占位符，所有的占位符使用 `:` 作为前缀。例如，把用户名作为占位符：\r\n\r\n	\'welcome\' => \'Welcome, :name\',\r\n \r\n 替换占位符使用 `__` 函数的第二个参数：\r\n \r\n	 echo __(\'messages.welcome\', [\'name\' => \'dayle\']);\r\n\r\n如果占位符全部是大写字母，或者是首字母大写。那么翻译过来的字符串也会是相应的大写形式：\r\n\r\n	\'welcome\' => \'Welcome, :NAME\', // Welcome, DAYLE\r\n	\'goodbye\' => \'Goodbye, :Name\', // Goodbye, Dayle\r\n\r\n### 复数\r\n\r\n复数形式是个老大难问题，因为不同语言的复数规则是不同的。使用「管道」字符，可以用来区分字符串的单数和复数形式：\r\n\r\n	\'apples\' => \'There is one apple|There are many apples\',\r\n\r\n也可以指定数字范围，创建更加复杂的复数规则：\r\n\r\n	\'apples\' => \'{0} There are none|[1,19] There are some|[20,*] There are many\',\r\n\r\n使用「管道」字符，定义好复数规则后，就可以使用 `trans_choice` 函数获得给定「数量」的字符串文本。在下面的例子中，因为数量大于 1，所以就会返回翻译字符串的复数形式：\r\n\r\n	echo trans_choice(\'messages.apples\', 10);\r\n\r\n## 覆盖包语言文件\r\n\r\n一些包自带语言文件，你不用更改软件包的核心文件来调整默认的翻译，直接创建 `resources/lang/vendor/{package}/{locale}` 文件夹就可以覆盖它们。\r\n\r\n例如，对于包 `skyrim/hearthfire`，如果要覆盖包中 `messages.php` 文件里的英文翻译，就应该创建一个文件 ` resources/lang/vendor/hearthfire/en/messages.php`。在此文件中，你应该只定义要覆盖的内容，没有定义的还是使用原来包语言文件里的翻译内容。','2017-09-05 14:07:56','2017-09-07 01:24:37','laravel-document-reading-internationalization'),(340,3,3,'重拾数学的乐趣：速率和速度的区别','先举一个一针见血的例子：\r\n\r\n> 一个人绕着操场跑了一圈 400 米，用了 100 秒。速率是 400/100 = 4 米/秒，速度是 0/100 = 0 米/秒。\r\n\r\n在操场上跑得这一圈，根本就没速度……\r\n\r\n这就是速率和速度的区别。速度（Velocity）计算的是位移，速率（Speed）计算的是路程。\r\n\r\n位移是起点至终点的直线距离，是有方向的；路程是脚步走过的距离，是长度，但没有方向。干脆说：\r\n\r\n> 速度是有 **方向** 的速率。\r\n> \r\n> 物体以 5 千米/时移动是个 **速率**。\r\n> \r\n> 物体以 5 千米/时 **向西移动** 是个 **速度**。\r\n> \r\n> 物体很快地来回移动，它的速率很快，但速度很慢（零）\r\n\r\n所以，速率更加世俗，因为没有人愿意在急速跑完一圈后，被人告知没有速度。','2017-09-07 08:54:32','2017-09-07 09:03:52','pick-up-the-fun-of-mathematics-rate-and-speed-difference'),(341,3,3,'重拾数学的乐趣：速度','> 参考链接：http://www.shuxuele.com/measure/metric-speed.html\r\n\r\n速度表示动点在某个瞬间运动的快慢和运动方向的矢量，是矢量哦~\r\n\r\n常见的速度单位是：\r\n\r\n* 米每秒（m/s）\r\n* 千米每小时（km/h）\r\n\r\n## 米每秒（m/s）的速度\r\n\r\n以 1m/s 的速度移动就是每秒移动 1 米。\r\n\r\n大约是缓慢步行的速度。\r\n\r\n以 1m/s 的速度步行一小时就走了 3.6 千米。\r\n\r\n## 千米每小时（km/h）的速度\r\n\r\n以 1km/h 的速度移动就是每小时移动 1 千米。\r\n\r\n大约是非常缓慢的步行速度。\r\n\r\n千米每小时时常用来作汽车速度的单位。\r\n\r\n> 高速公路上的车速大约是 100km/h。\r\n\r\n> 以这个速度开 1 小时车就走了 100 千米。\r\n\r\n## 速度\r\n\r\n速度是 **有方向的速率**。\r\n\r\n物体以 5km/h 移动是个速率。\r\n\r\n物体以 5km/h **向西移动** 是个 **速度**。\r\n\r\n物体很快地来回移动，它的速率很快，但速度很慢（零）。','2017-09-07 09:26:06','2017-09-07 09:26:06','to-regain-the-pleasure-of-math-speed'),(342,3,3,'重拾数学的乐趣：加速度','> 参考链接：http://www.shuxuele.com/measure/metric-acceleration.html\r\n\r\n加速度用来描述 **速度** 改变的多快，包括下面几个维度：\r\n\r\n* 加速\r\n* 减速\r\n* 改变方向\r\n\r\n加速度的一般单位是：\r\n\r\n> m/s2\r\n> \r\n> “米每二次方秒”\r\n\r\n为了说明“米每二次方秒”的意义，举一个一针见血的例子：\r\n\r\n> 一个人跑步，在 *1 秒内* 由 5m/s 增加到 6m/s。\r\n> \r\n> 注意，她的速度 **每秒增加了 1 米每秒**。\r\n>\r\n>  留意“每秒”出现了两次。\r\n>  \r\n>  可以这样想：(m/s)/s，但通常写为 m/s<sup>2</sup>。\r\n\r\n\r\n加速度公式：速度改变（m/s） / 时间（s）\r\n\r\n## 三个例子：\r\n\r\n### 例子一\r\n\r\n> 自行车比赛中，你的速度是稳定的 10m/s，现在加速！在 2秒内，你的速度增加快到 14 m/s（方向没变）。\r\n\r\n也就是你的速度在 2 秒内增加了 4 m/s，所以：\r\n\r\n> 加速度 = 速度改变（m/s） / 时间（s）= 4m/s / 2s = 2m/s<sup>2</sup>\r\n\r\n你的速度每秒改变了 2 米每秒（2 米每二次方秒）。\r\n\r\n### 例子二\r\n\r\n> 你跑的速度是 7 m/s，在 2 秒内你停下来了。\r\n\r\n速度从 7 m/s 变成 0，所以这是减速：\r\n\r\n> 加速度 = 速度改变（m/s） / 时间（s）= 0m/s-7m/s / 2s = -3.5m/s<sup>2</sup>。\r\n\r\n### 例子三\r\n\r\n其实加速度是有方向的，但我们通常不会讲出来。\r\n\r\n> 一辆汽车以 16m/s 的速度向西行走，4 秒内，司机调转方向盘，以 16m/s 的速度向东走。\r\n\r\n由 16m/s 向西到 16 m/s 向东的改变是 -32m/s 向西（或者是 32m/s 向东）。\r\n\r\n> 加速度 = 速度改变（m/s） / 时间（s）= -16m/s-16m/s / 4s = -8m/s<sup>2</sup>。\r\n\r\n\r\n?(๑•̀ㅂ•́)و✧','2017-09-08 00:13:17','2017-09-08 00:30:35','to-regain-the-pleasure-of-math-acceleration'),(343,3,3,'JS 数据类型和运算符','## JS 中的数据类型\r\n\r\n一、基本（简单）数据类型\r\n\r\n1. 字符串 String\r\n    * 由 0 个或者多个字符组成的串，放在成对的单引号或双引号中。\r\n    * 例子：\'a\'、\'John\'、\'\'、\' \'、\"I\'m Tom.\"、\'I\\\'m Tom too.\'\r\n    * `\\` 表示转义符号，后面跟上要转义的内容。\r\n2. 数字 Number\r\n    * 由 0-9 之间的任意数字组成，包括整数和小数。数字范围：负无穷（`-Infinity`）到正无穷（`Infinity`）。\r\n    * 最大值：`Number.MAX_VALUE`；最小值：`Number.MIN_VALUE`。\r\n    * `NaN`：「Not a Number」，运算失败时的值，数字类型。\r\n    * `NaN == NaN` 的值是 `false`。\r\n3. 布尔值 Boolean\r\n    * 包含两个值：`true` 和 `false`。\r\n4. 未定义 Undefined\r\n    * 有且只有一个值：`undefined`。\r\n    * 声明但未赋值的变量，值为 `undefined`。\r\n    * Undefined 表示没有给值。\r\n5. 空 Null\r\n    * 有且只有一个值：`null`。\r\n    * Null 表示压根就没有。\r\n\r\n二、复合（复杂）数据类型\r\n\r\n复合数据类型就是 **对象**，Object。\r\n\r\n复合数据放在一对大括号（`{}`）中。每个数据由键值对组成，0 个或者多个。每个数据之间用逗号（`,`）隔开，最后一个数据不能加逗号。\r\n\r\n键值对：`key:value`。`key` 是数据名称，引号可加可不加，当名称不符合变量命名规则时（数字除外），就需要加引号，且引号成是成对出现的。`value` 是数据值，可以是简单数据类型也可以是复杂数据类型。\r\n\r\n使用对象就是操作它的属性。\r\n\r\n    var person = {\r\n        name: \'Wang\',\r\n        age: 30,\r\n        height: \'180cm\',\r\n        weight: \'90kg\',\r\n        driver: true,\r\n        \'girl-friend\': null,\r\n        language: [\'中文\', \'英文\', \'日文\']\r\n    }\r\n    \r\n    person.driver; // true\r\n    person[\'girl-friend\']; // null\r\n\r\n## typeof 运算符\r\n\r\n* 检测数据类型，返回数据类型值（全小写）。\r\n* 返回的数据类型值与数据在系统中定义的类型有区别。\r\n* 是一个运算符。\r\n\r\n语法：typeof 数据 / typeof(数据)\r\n\r\n| 系统中定义的类型 | typeof 返回的数据类型 |\r\n| -------- | -------- |\r\n| String | string |\r\n| Number | number |\r\n| Boolean | boolean |\r\n| Undefined | undefined |\r\n| Null | object |\r\n| Object | object |\r\n\r\nnull 的 typeof 的结果是 object，函数的 typeof 结果为 function。函数、数组和对象都是复合数据类型。JS 没有为函数定义类型。\r\n\r\n## 数据类型转换\r\n\r\n从简易计算器引出数据类型转换。数据类型转换：从一种数据类型转换成另外一种数据类型。\r\n\r\nJS 支持任意一种数据类型转换成以下类型：\r\n    \r\n* 数字\r\n* 字符串\r\n* 布尔值\r\n\r\n把对象转换成上面 3 种类型是没有意义的，因为对象里可以放任意的一种数据类型。\r\n\r\n### 任意类型转成数字\r\n\r\n使用 `Number(要转换的值)`。\r\n\r\n| 转换的值 | 使用 `Number()` 转换的结果 |\r\n| -------- | -------- |\r\n| \'\' | 0 |\r\n| \' \' | 0 |\r\n| \'Tom\' | NaN |\r\n| \'12\' | 12 |\r\n| \'012\' | 12 |\r\n| \'0x12\' | 18 |\r\n| `true`/`false` | 1/0 |\r\n| undefined | NaN |\r\n| null | 0 |\r\n| [] | 0 |\r\n| [\'0x12\'] | 18 |\r\n| {} | NaN |\r\n\r\n数字转数字还是数字，这毋庸置疑。\r\n\r\n对于转换字符串的情况，如果字符串里不是 **纯数字**，那转换结果就是 NaN。\r\n\r\n#### 字符串转数字：`parseInt()` 和 `parseFloat()`\r\n\r\n* `parseInt()`：字符串转整数。\r\n* `parseFloat()`：字符串转浮点型数字。\r\n\r\n传进来的参数必须是 **数字** 或者是 **空格加数字** 开头。这两个方法会从数字开始，一位一位往后找，直到找到的字符不是数字就会停止，然后把找到的数字字符返回并转换成真正的数字。如果没有找到数字的话，就直接返回 NaN 了。\r\n\r\n| 参数值 | `Number.parseInt()` / `parseInt()` 的输出结果 |\r\n| -------- | -------- |\r\n| \'100px\' | 100 |\r\n| \' 12cm\' | 12 |\r\n| \'$12\' | NaN |\r\n| \'12.523\' | 12 |\r\n| \'012\' | 12 |\r\n\r\n`parseFloat()` 与 `parseInt()` 类似，不过会保留数字里的小数部分。\r\n\r\n#### `isNaN()`\r\n\r\n`isNaN()` 用来判断一个值是不是 NaN，会先把参数用 Number() 方法转换。可以用来检测数字。\r\n\r\n    > isNaN(NaN);\r\n    < true\r\n    > isNaN(\'Tom\');\r\n    < true\r\n    > isNaN(\'12\');\r\n    < false\r\n    > isNaN(12);\r\n    < false\r\n\r\n### 任意类型转字符串\r\n\r\n使用 `String(要转换的值)`。\r\n\r\n| 转换的值 | 使用 `String()` 转换的结果 |\r\n| -------- | -------- |\r\n| undefined | \"undefined\" |\r\n| null | \"null\" |\r\n| 123 | \"123\" |\r\n| true | \"true\" |\r\n| false | \"false\" |\r\n| [] | \"\" |\r\n| [1, 2] | \"1,2\" |\r\n| {} | \"[object Object]\" |\r\n\r\n字符串转字符串还是原来的字符串，这毋庸置疑。\r\n\r\n### 任意类型转布尔值\r\n\r\n使用 `Boolean(要转换的值)`。\r\n\r\n| 转换的值 | 使用 `Boolean()` 转换的结果 |\r\n| -------- | -------- |\r\n| undefined | `false` |\r\n| null | `false` |\r\n| \"\" | `false` |\r\n| \" \" | `true` |\r\n| \"0\" | `true` |\r\n| \"1\" | `true` |\r\n| 0 | `false` |\r\n| 1 | `true` |\r\n| NaN | `false` |\r\n| Infinity | `true` |\r\n\r\n空格也是一个字符，转化成布尔值是 `true`。非空字符串转化成布尔值都是 `true`。\r\n\r\n### 隐式类型转换\r\n\r\n类型转换分两种：显式类型转换和隐式类型转换。\r\n\r\n之前使用的 `Number()`、`parseInt()`、`parseFloat()`、`String()` 和 `Boolean()` 都属于显式类型转换——转换时明确指定最终要转换成的类型。\r\n\r\n有些时候，做数据操作时，为了得到某个具体类型的数据，JS 会在内部对当前操作的不同类型的数据做统一数据类型的隐式转换。\r\n\r\n`+`、`-`、`*`、`/` 都会在必要时转换参与计算的数据的类型。\r\n \r\n 对于 `+` 操作符：\r\n \r\n    1 + 2 // 3\r\n    1 + \'q\' // \"1q\"\r\n    1 + true // 2\r\n    1 + false // 1\r\n    true + \'YY\' // \"trueYY\"\r\n    true + true // 2\r\n\r\n布尔 → 数字 → 字符串\r\n\r\n 对于 `-` 操作符，有一个特别的：**会把两边操作数都转换为数字**。\r\n \r\n    1 - \'123\' // -122\r\n    1 - \'\' // 1\r\n    \'123\' - 100 // 23\r\n    \r\n## JS 中的运算符\r\n\r\n### 算术运算符\r\n\r\n> +、-、*、/、%（取模，求余数）、++、--\r\n\r\n#### 取模\r\n\r\n    > 3 % 4\r\n    < 3\r\n    > 4 % 4\r\n    < 0\r\n    > 5 % 4\r\n    < 1\r\n    > 15 % 4\r\n    < 3\r\n\r\n取模就是求余数。\r\n\r\n#### ++、--\r\n\r\n* ++ 递增\r\n* -- 递减\r\n\r\n它俩可以放在操作数的前面，也可以放在操作数的后面。\r\n\r\n    > let i = 8;\r\n    > i++\r\n    < 8\r\n    > i\r\n    < 9\r\n    \r\n    > let j = 8;\r\n    > ++j\r\n    < 9\r\n    > j\r\n    < 9\r\n\r\n`i++`、`++j` 的结果都是让自己加 1，但是时机不一样：\r\n\r\n* `i++` 会先操作 `i`（比如：打印、赋值），然后让 `i` 加 1。\r\n* `++j` 会让 `j` 先加 1，然后再操作 `j`（比如：打印、赋值）。\r\n\r\n### 赋值运算符\r\n\r\n> =、+=、-=、*=、/=、%=\r\n\r\n    a += b;\r\n    // 等同于\r\n    a = a + b;\r\n\r\n举个例子：\r\n\r\n    > let a = \'I am \', b = \'Tom\';\r\n    > a += b;\r\n    < \"I am Tom\"\r\n\r\n*=、/=、%= 和 += 类似，这里不再赘述。\r\n\r\n### 关系运算符\r\n\r\n> <、>、<=、>=、!=、===、!==\r\n\r\n关系运算符的结果是一个布尔值：`true` 或者 `false`。\r\n\r\n### == 和 ===\r\n\r\n`==` 比较两个 **值是否相等**。\r\n\r\n	> 10 == \'10\'\r\n	< true\r\n\r\n`10` 和 `\'10\'` 的值是相等的。\r\n\r\n`===` 会先比较类型，类型不同直接返回 `false`；否则再比较值，值相等返回 `true`，否则会返回 `false`。\r\n\r\n	> 10 === \'10\'\r\n	< false\r\n	\r\n	> \'10\' === \'10\'\r\n	> true\r\n\r\n再来举一些 `undefined` 与 `null` 的例子：\r\n\r\n    > undefined == 0\r\n    < false\r\n    > undefined == false\r\n    < false\r\n    > 0 == null\r\n    < false\r\n    > false == null\r\n    < false\r\n    \r\n    > undefined == null\r\n    < true\r\n\r\n可见，`undefined` 只与 `null` 相等。\r\n\r\n还有，字符串在一起比较，比较的是 [ASCII 码](http://www.cnblogs.com/xmxu/archive/2012/07/10/2584032.html)。\r\n\r\n	> \'b\' > \'B\'\r\n	< true\r\n	> \'A\' > \'B\'\r\n	< false\r\n\r\n### 逻辑运算符\r\n\r\n> &&（与）、||（或）、！（非）和三元运算符\r\n\r\n`&&` 两边的条件必须同时成立，整个条件才成立。\r\n\r\n条件判断会将两边的值 **尝试转换成布尔值**，而且条件判断也是 **有返回值** 的。\r\n\r\n	// 左侧为真，则返回右侧的值\r\n	\r\n	> \'you\' && \'me\' \r\n	< \"me\"\r\n	\r\n	//  左侧为假，则返回左侧的值\r\n	> null && \'me\' \r\n	< null\r\n\r\n`&&` 两边的条件有一个成立，整个条件就成立。\r\n\r\n	> \'❤\' || false\r\n	< \"❤\"\r\n	\r\n	> null || \'❤\'\r\n	> \"❤\"\r\n\r\n	> null || undefined\r\n	> undefined\r\n\r\n`!` 非，取反的意思。最终返回一个布尔值（会转换值类型变成布尔类型）。两个 `!`（`!!`）表示将数据转换成布尔值。\r\n\r\n#### 三元操作符\r\n\r\n三元操作符，又叫三目运算符。这里的「元」是指「操作数」。\r\n\r\n一元操作符：++、--、！、typeof 等。\r\n\r\n二元操作符： +、-、\\*、/、% 等。\r\n\r\n三元操作符：a ? b : c。\r\n\r\n「a ? b : c」表示当 `a` 的布尔值是 `true`，就返回 `b`，否则返回 `c`。a、b 和 c 都可以是表达式。\r\n\r\n	> (1 > 0) ? \'O(∩_∩)O哈！\' : \'%>_<%\'\r\n	< \"O(∩_∩)O哈！\"\r\n	\r\n	> true > 0 ? 100 : (true ? 200 : 300)\r\n	< 100\r\n	> false > 0 ? 100 : (true ? 200 : 300)\r\n	< 200\r\n	> false > 0 ? 100 : (false ? 200 : 300)\r\n	< 300\r\n\r\n### 运算符优先级\r\n\r\n运算符优先级不用刻意去记忆，根据已经学过的数学知识，凭直觉和理性，判断先后该分别运算哪个部分的运算即可。\r\n\r\n全面的可以参考 [这里][1]。\r\n\r\n[1]: https://msdn.microsoft.com/zh-cn/library/z3ks45k7(v=vs.94).aspx\r\n\r\n其中，`.`、`[]`、`()` 的优先级是最高的，想提高优先级，可以简单使用圆括号（`()`）。','2017-09-08 01:48:27','2017-09-08 02:59:45','js-data-types-and-operators'),(344,3,3,'JS 流程控制','**`if` 语句**：\r\n\r\n    if (expression) {\r\n        // \r\n    } else if (expression) {\r\n        // \r\n    } else {\r\n        //\r\n    }\r\n\r\n**`switch` 语句**：\r\n\r\n    function getWeekDay() {\r\n        let day = new Date().getDay();\r\n    \r\n        switch (day) {\r\n            case 0:\r\n                day = \'星期日\';\r\n                break;\r\n            case 1:\r\n                day = \'星期一\';\r\n                break;\r\n            case 2:\r\n                day = \'星期二\';\r\n                break;\r\n            case 3:\r\n                day = \'星期三\';\r\n                break;\r\n            case 4:\r\n                day = \'星期四\';\r\n                break;\r\n            case 5:\r\n                day = \'星期五\';\r\n                break;\r\n            case 6:\r\n                day = \'星期六\';\r\n                break;\r\n            default:\r\n                day = \'你在逗我？\';\r\n        }\r\n\r\n        return day;\r\n    }\r\n\r\n**`for` 循环语句**：\r\n\r\n    for (初始化条件; 条件判断; 条件变化) {\r\n        // \r\n    }\r\n\r\n当 `条件判断` 为 `true` 时，执行循环体代码。从第二次迭代开始，就不再走「初始化条件」的代码了。当循环体代码执行完毕后，执行 `条件变化`。\r\n\r\n**`for in` 循环语句**：用来遍历对象中的数据\r\n\r\n    // 语法\r\n    \r\n    for (let 变量名 in 对象) {\r\n        console.log(对象[变量名]);\r\n    }\r\n\r\n数组也是对象，所以 `for in` 也可以用来遍历数组。\r\n\r\n**while 循环**：\r\n\r\n    while (判断条件) {\r\n        //\r\n    }\r\n\r\n当做循环时，优先考虑使用 `for` 循环，如果 for 循环做不出来的话，那就选择使用 `while` 循环。\r\n\r\n**break** 和 **continue**：\r\n\r\n两者只能用在循环里。\r\n\r\n`break` 在当前迭代中结束当前循环；`continue` 表示忽略当前迭代，继续下一次迭代。\r\n\r\n**return**：\r\n\r\n停止函数执行、并返回一个值（未指定则返回 `undefiend`），只能用在函数里。','2017-09-08 05:06:41','2017-09-08 05:16:44','js-flow-control'),(345,3,3,'Laravel 文档阅读： JavaScript ＆ CSS 脚手架代码','> 翻译、衍生自：https://laravel.com/docs/5.5/frontend\r\n\r\n## 简介\r\n\r\nLaravel 没有非要让你用哪个 Javascript 库或者哪个 CSS 预处理器，但还是热心地开箱提供了 Bootstrap 和 Vue 脚手架代码，这对大多数项目来说都是非常有帮助的。默认，Laravel 使用 NPM 安装这些前端包。\r\n\r\nLaravel 中的 JavaScript 和 CSS 脚手架代码是用 Laravel Mix 编译的。Laravel Mix 是构建在 Webpack 上的一个前端代码构建工具，它隐藏了 Webpack 底层的复杂配置，暴露出极易上手的 API，让你轻松编译前端代码不是梦。\r\n\r\n#### CSS\r\n\r\nLaravel Mix 支持 [SASS](http://sass.bootcss.com/) 和  Less 这两个 CSS 预处理器的编译功能。 CSS 预处理器只是对 CSS 的扩展，是一套语法规则，并不是一门新的编程语言，引入它是为了让样式表结构更加清晰和更好维护。\r\n\r\n本篇文档里只是简单涉及了 CSS 编译，更加详细地编译 SASS 或者 Less 文件的内容需要参考 Laravel Mix 文档。\r\n\r\n#### JavaScript\r\n\r\nLaravel 没有要求开发者使用哪个 JavaScript 框架或者 JavaScript 库来构建项目。事实上，你可以完全不用 JavaScript 库或框架。但是，作为可能是全世界最好用的 PHP 框架，默认，Laravel 还是热心的在项目里提供了 Vue.js 脚手架代码。Vue 在使用组件和有表现力的 API  构建现代的 JavaScript 应用上非常厉害。\r\n\r\n与 CSS 一样，我们也可以使用 Laravel Mix 将 Vue 的多个组件轻松地编译成一个可供浏览器使用的 JavaScript 脚本文件。\r\n\r\n#### 移除前端脚手架代码\r\n\r\n如果不想用 Laravel 提供的前端脚手架代码，使用 Artisan 命令 `preset none` 即可移除。\r\n\r\n	php artisan preset none\r\n\r\n这条命令会移除所有的 Bootstrap 和 Vue 脚手架代码，保留一个空白的 SASS 文件和一些常用的 JavaScript 工具库（包括 lodash、jquery、axios，在 `resources/assets/js/bootstrap.js` 中定义引入的）。\r\n\r\n## 写 CSS\r\n\r\nLaravel 项目根目录下的 `package.json` 文件默认包含了 `bootstrap-sass` 文件。\r\n\r\n	\"devDependencies\": {\r\n		\"axios\": \"^0.16.2\",\r\n		\"bootstrap-sass\": \"^3.3.7\",\r\n		\"cross-env\": \"^5.0.1\",\r\n		\"jquery\": \"^3.1.1\",\r\n		\"laravel-mix\": \"^1.0\",\r\n		\"lodash\": \"^4.17.4\",\r\n		\"vue\": \"^2.1.10\"\r\n	}\r\n\r\n这能帮助开发者用 Bootstrap 框架快速开发一个前端页面原型。如果你不想用 Bootstrap，直接 `php artisan preset none` 去掉就是了，没什么大不了的。不过，这给直接用 Bootstrap 框架开发项目的人带来不少福音。\r\n\r\n在编译 CSS 之前，确保项目使用 NPM，已安装好前端依赖包。\r\n\r\n	npm install \r\n\r\n依赖安装好后，就可以用 Laravel Mix 把 SASS 文件编译成纯 CSS 文件.。我们可以用 `npm run dev` 编译咱们的前端文件，这条命令是按照项目根目录下 `webpack.mix.js` 配置文件中指定的规则编译前端文件的。编译好的 CSS 文件一般就放在 `public/css` 这个目录下面：\r\n\r\n	 npm run dev\r\n\r\n`webpack.mix.js` 文件中，其实已经预设好了编译规则。\r\n\r\n	const { mix } = require(\'laravel-mix\');\r\n\r\n	/*\r\n	 |--------------------------------------------------------------------------\r\n	 | Mix Asset Management\r\n	 |--------------------------------------------------------------------------\r\n	 |\r\n	 | Mix provides a clean, fluent API for defining some Webpack build steps\r\n	 | for your Laravel application. By default, we are compiling the Sass\r\n	 | file for the application as well as bundling up all the JS files.\r\n	 |\r\n	 */\r\n\r\n	mix.js(\'resources/assets/js/app.js\', \'public/js\')\r\n	   .sass(\'resources/assets/sass/app.scss\', \'public/css\');\r\n\r\n瞧（咱们先不看 JS 那段）， Laravel Mix 要把 `resources/assets/sass/app.scss` 编译到 `public/css` 这里去了，编译好的文件名是 `app.css`。\r\n\r\n你也可以看 `app.scss` 文件里的内容：\r\n\r\n	// Fonts\r\n	@import url(https://fonts.googleapis.com/css?family=Raleway:300,400,600);\r\n\r\n	// Variables\r\n	@import \"variables\";\r\n\r\n	// Bootstrap\r\n	@import \"node_modules/bootstrap-sass/assets/stylesheets/bootstrap\";\r\n\r\n就是引入字体，引入咱自定义的变量（会覆盖下面的 Bootstrap SASS 文件里的默认变量），还有 Bootstrap 框架的 SASS 源码。这些东西最后都编译到了 `app.css` 这个文件里。当然这些规则你可以修改的，看你实际的需要了。\r\n\r\n另外，`webpack.mix.js` 文件里的规则也完全可以自定义不使用 SASS，而用 Less，这会在 Laravel Mix 文档里讲到的。\r\n\r\n\r\n## 写 JavaScript\r\n\r\n所有引入项目的 JavaScript 依赖在根目录下的 `package.json` 文件里定义。 `package.json` 与 `composer.json` 类似，但是前者是引入 JavaScript 依赖，后者是引入 PHP 依赖。使用 NPM 来安装项目的 JavaScript 依赖：\r\n\r\n	npm install\r\n\r\n默认，`package.json` 定义了少量依赖，包括 `vue` 和 `axios`，帮助开发者快速开发 JavaScript 程序。你可以按照需要，在 `package.json` 增加或者删除所需的依赖。\r\n\r\n依赖安装好后，就可以使用 `npm run dev` 命令编译脚本了。Webpack 是用于现代 JavaScript 应用程序的模块绑定器。执行 `npm run dev` 命令事时，Webpack 会按照 `webpack.mix.js` 文件里的设定规则进行脚本编译和打包。\r\n\r\n	npm dev\r\n\r\n默认，Laravel `webpack.mix.js` 中的设定规则会编译 `resources/assets/sass/app.scss` 和 `resources/assets/js/app.js` 文件，前者已经说过，这里不再赘述，我们看 `app.js`。\r\n\r\n	/**\r\n	 * First we will load all of this project\'s JavaScript dependencies which\r\n	 * includes Vue and other libraries. It is a great starting point when\r\n	 * building robust, powerful web applications using Vue and Laravel.\r\n	 */\r\n\r\n	require(\'./bootstrap\');\r\n\r\n	window.Vue = require(\'vue\');\r\n\r\n	/**\r\n	 * Next, we will create a fresh Vue application instance and attach it to\r\n	 * the page. Then, you may begin adding components to this application\r\n	 * or customize the JavaScript scaffolding to fit your unique needs.\r\n	 */\r\n\r\n	Vue.component(\'example\', require(\'./components/Example.vue\'));\r\n\r\n	const app = new Vue({\r\n		el: \'#app\'\r\n	});\r\n\r\napp.js 中注册了 Vue 组件，当然，你也可以应用其他什么的框架在你的项目里，只要你愿意。编译好的 JavaScript 文件就放在 `public/js` 目录下。\r\n\r\n注意，在 `app.js` 文件会加载 `resources/assets/js/bootstrap.js` 文件里的内容。我们来看看 `bootstrap.js` 这个文件：\r\n\r\n	window._ = require(\'lodash\');\r\n\r\n	/**\r\n	 * We\'ll load jQuery and the Bootstrap jQuery plugin which provides support\r\n	 * for JavaScript based Bootstrap features such as modals and tabs. This\r\n	 * code may be modified to fit the specific needs of your application.\r\n	 */\r\n\r\n	try {\r\n		window.$ = window.jQuery = require(\'jquery\');\r\n\r\n		require(\'bootstrap-sass\');\r\n	} catch (e) {}\r\n\r\n	/**\r\n	 * We\'ll load the axios HTTP library which allows us to easily issue requests\r\n	 * to our Laravel back-end. This library automatically handles sending the\r\n	 * CSRF token as a header based on the value of the \"XSRF\" token cookie.\r\n	 */\r\n\r\n	window.axios = require(\'axios\');\r\n\r\n	window.axios.defaults.headers.common[\'X-Requested-With\'] = \'XMLHttpRequest\';\r\n\r\n	/**\r\n	 * Next we will register the CSRF Token as a common header with Axios so that\r\n	 * all outgoing HTTP requests automatically have it attached. This is just\r\n	 * a simple convenience so we don\'t have to attach every token manually.\r\n	 */\r\n\r\n	let token = document.head.querySelector(\'meta[name=\"csrf-token\"]\');\r\n\r\n	if (token) {\r\n		window.axios.defaults.headers.common[\'X-CSRF-TOKEN\'] = token.content;\r\n	} else {\r\n		console.error(\'CSRF token not found: https://laravel.com/docs/csrf#csrf-x-csrf-token\');\r\n	}\r\n	\r\n    /**\r\n     * Echo exposes an expressive API for subscribing to channels and listening\r\n     * for events that are broadcast by Laravel. Echo and event broadcasting\r\n     * allows your team to easily build robust real-time web applications.\r\n     */\r\n    \r\n    // import Echo from \'laravel-echo\'\r\n    \r\n    // window.Pusher = require(\'pusher-js\');\r\n    \r\n    // window.Echo = new Echo({\r\n    //     broadcaster: \'pusher\',\r\n    //     key: \'your-pusher-key\'\r\n    // });\r\n\r\n内容看起来很多，但是，去掉注释，单看代码就非常清晰了：在页面窗口对象（`window`）上注册我们的 JavaScript 依赖库，包括 lodash、jquery（引入这个，是为了能用 bootstrap 提供的一些组件功能，例如模型和切换条）、axios（并配置了 X-Requested-With 请求头，说明自己是 Ajax 请求，不是传统的 HTTP 请求，还有 X-CSRF-TOKEN 防攻击令牌），就这么点内容。\r\n\r\n**日后，一些额外新增的 JavaScript 依赖都是在这个 `bootstrap.js` 文件里注册、配置的**。\r\n\r\n### 写 Vue 组件\r\n\r\n默认，Laravel 在 `resources/assets/js/components` 这个目录里，提供了一个 Vue 组件的范例 `Example.vue`。以 `.vue` 为后缀名的文件是单文件形式的 Vue 组件文件的后缀名，在这个文件里包含 HTML 模板代码，JavaScript 代码甚至是为组件单独定义的 CSS 样式！下面请看 `Example.vue` 文件的内容：\r\n\r\n	<template>\r\n		<div class=\"container\">\r\n			<div class=\"row\">\r\n				<div class=\"col-md-8 col-md-offset-2\">\r\n					<div class=\"panel panel-default\">\r\n						<div class=\"panel-heading\">Example Component</div>\r\n\r\n						<div class=\"panel-body\">\r\n							I\'m an example component!\r\n						</div>\r\n					</div>\r\n				</div>\r\n			</div>\r\n		</div>\r\n	</template>\r\n\r\n	<script>\r\n		export default {\r\n			mounted() {\r\n				console.log(\'Component mounted.\')\r\n			}\r\n		}\r\n	</script>\r\n\r\n注意，这里使用了 Bootstrap 的布局样式，没有自定义自己的 CSS 样式。 Bootstrap 的布局样式之所以会生效，是因为在 `resources/assets/sass/app.scss` 文件里引入了 `bootstrap-sass` 库，因而最终编译好的 `app.css` 文件里就有 Bootstrap CSS 样式了。\r\n\r\n注册一个 Vue 组件是在 `app.js` 文件里完成的：\r\n\r\n	Vue.component(\'example\', require(\'./components/Example.vue\'));\r\n\r\n要使用这个组件也非常容易。例如，在执行 `make:auth` Artisan 命令后得到的认证系统里，你可以直接把咱们的组件放在 `home.blade.php` Blade 模板文件中，像这样：\r\n\r\n	@extends(\'layouts.app\')\r\n\r\n	@section(\'content\')\r\n		<example></example>\r\n	@endsection\r\n\r\n记住了，每当你修改了一个 Vue 组件的代码，就要重新执行 `npm run dev` 命令编译它才行。或者，使用更加方便的 `npm run watch` 命令，在你每次修改完一个 Vue 组件的代码后，组件内容会自动重新编译，这很大程度上解决了每次都要重新执行 `npm run dev` 命令的烦恼。\r\n\r\n如果不会 Vue 的话，看它 [文档](https://vuejs.org/guide/) 就 OK 了，文档写得非常好和容易懂。\r\n\r\n### 使用 React\r\n\r\n如果更喜欢用 React 来构建 JavaScript 应用程序的话在 Laravel 也很容易做到！使用 Artisan 命令 `preset react` 即可：\r\n\r\n	php artisan preset react\r\n\r\n这条命令会把默认的 Vue脚手架代码，替换成 React 的，还包括一个 React 的范例页面哦。','2017-09-08 06:22:37','2017-09-09 04:05:40','laravel-document-reading-javascript-and-css-scaffold'),(346,3,3,'安装 Git 和 Node','> 下面内容节选自阮一峰 [「全栈工程师培训材料」](https://github.com/ruanyf/jstraining)。\r\n\r\n## 安装 Git\r\n\r\n请到官网 [git-scm.com](https://git-scm.com/) 或国内的下载站，下载安装包。\r\n\r\n## 安装 Node\r\n\r\n请到 Node 官网 [nodejs.org](https://nodejs.org)，或者国内镜像 [npm.taobao.org/mirrors/node](https://npm.taobao.org/mirrors/node) ，下载安装包。推荐安装最新的稳定版，目前是v6.x。\r\n\r\n安装完成后，命令行执行下面的命令，确认是否安装成功。\r\n\r\n```\r\n$ node -v\r\nv6.9.2\r\n```\r\n\r\nNode 的模块管理器 npm 会一起安装好。由于 Node 的官方模块仓库网速太慢，模块仓库需要切换到阿里的源。\r\n\r\n```\r\n$ npm config set registry https://registry.npm.taobao.org/\r\n```\r\n\r\n执行下面的命令，确认是否切换成功。\r\n\r\n```\r\n$ npm config get registry\r\n```\r\n\r\n（完）','2017-09-08 06:31:58','2017-09-08 06:31:58','install-git-and-node'),(347,3,3,'IE 浏览器用户代理检测','今天，我在锤子科技官网首页的代码里，看到一个升级浏览器的 JS 脚本文件，地址是：http://static.smartisanos.cn/common/unmd5js/update-browser.js 。内容是：\r\n\r\n	(function IEUpgrade(){\r\n		var ua = window.navigator.userAgent.toLowerCase();\r\n		if (/msie/.test(ua)) {\r\n			window.location.href = \'http://www.smartisan.com/update-browser.html\';\r\n		}\r\n	})();\r\n\r\n我看了一下 IE11 的用户代理字符串：\r\n\r\n	Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; LCTE; rv:11.0) like Gecko\r\n\r\n又看了 IE10 的用户代理字符串：\r\n	\r\n	Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)\r\n\r\n还看了 IE9 的用户代理字符串：\r\n\r\n	Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)\r\n\r\n又坚持看了 IE8 的用户代理字符串：\r\n\r\n	Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)\r\n\r\n固执的又看了 IE7 的用户代理字符串：\r\n\r\n	Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)\r\n\r\n然后是 IE6：\r\n\r\n	Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\r\n\r\n于是上面的代码，我就懂什么意思了——**IE10- 的浏览器都会跳转到升级浏览器的页面**。','2017-09-08 07:11:37','2017-09-08 07:11:37','ie-browser-user-agent-detection'),(348,3,3,'JS 函数','## 初见\r\n\r\n重复利用代码。\r\n	\r\n	// 定义	\r\n	funtion 函数名(参数) {\r\n		//\r\n	}\r\n	\r\n	// 调用\r\n	函数名(参数);\r\n\r\n## 函数类型\r\n\r\n函数类型分：函数声明和函数表达式。\r\n\r\n### 函数声明\r\n\r\n之前一直用的就是函数声明：\r\n\r\n	funtion 函数名(参数) {\r\n		//\r\n	}\r\n	\r\n	函数名(参数);\r\n\r\n### 函数表达式\r\n\r\n	var 变量 = function (参数) {\r\n		//\r\n	}\r\n	\r\n	变量(参数);\r\n\r\n举一个例子：\r\n\r\n	let func = function func2() {\r\n		return \':-D\';\r\n	}\r\n\r\n	func2(); // Uncaught ReferenceError: func2 is not defined\r\n	func();  // \":-D\"\r\n\r\n**函数表达式中，不能直接用函数名调用函数**，而要拿被赋值的变量来调用函数内容。\r\n\r\n#### 把函数声明变成函数表达式\r\n\r\n在函数前面加上 `!`、`~`、`+` 和 `-` 都可以让函数声明变成函数表达式。\r\n\r\n第一种方式：\r\n\r\n	! function func() {\r\n		//\r\n	}();\r\n\r\n第二种方式：\r\n\r\n	~ function func() {\r\n		//\r\n	}();\r\n\r\n第三种方式：\r\n\r\n	+ function func() {\r\n		//\r\n	}();\r\n	\r\n第四种方式：\r\n\r\n	- function func() {\r\n		//\r\n	}();\r\n\r\n还有一种方式，让函数声明变成函数表达式——给函数加上圆括号（`()`）。\r\n\r\n第五种方式：\r\n\r\n	(function func() {\r\n		// \r\n	})();\r\n\r\n## 函数参数\r\n\r\n分两种：形式参数和实参。\r\n\r\n* 形式参数：就是在函数声明时，圆括号里的参数，相当于一个占位符。**形参的值是由实参决定的**。\r\n* 实参：在调用函数时，传递给调用函数的值，是实际的参数值。**实参与形参要一一对应。如果有一个实参没有传递，那么它的值就是 `undefined`**。\r\n\r\n## arguments 对象\r\n\r\n代表了所有的实参集合，是一个类数组，只能在函数里使用。类数组就是说它不是数组，只是类似数组——有数字索引，还有 `lenght` 属性。\r\n\r\n	function func (x, y, z) {\r\n		return arguments;\r\n	}\r\n	\r\n	func(12, 34); // [12, 34]\r\n\r\n## 函数返回值\r\n\r\n函数返回值就是函数的返回结果。**一个函数总是会有返回值**。\r\n\r\n当函数执行到 `return` 的时候，函数就会立即停止执行，并且返回 return 之后的结果值；如果函数里没有 `return`，那么函数就会返回一个 `undefined`。\r\n\r\n如果 `return` 后面没有跟值\r\n\r\n	return ;\r\n	\r\n那么等同于返回 `undefined`。\r\n\r\n### 例子\r\n\r\n	// 定义\r\n	(function (d, w) {\r\n        w.$ = function (context) {\r\n            return d.querySelector(context);\r\n        };\r\n\r\n        w.$$ = function (context) {\r\n            return d.querySelectorAll(context);\r\n        };\r\n    })(document, window);\r\n\r\n	// 使用\r\n	let li = $(\'li\'), lis = $$(\'li\');\r\n    console.log(li, lis);\r\n\r\n## CSS 函数\r\n\r\n`getComputedStyle()` 获取计算后样式的一个集合。\r\n\r\n    (function (d, w) {\r\n        w.cl = function (message) {\r\n          console.log(message);\r\n        };\r\n\r\n        w.$ = function (selector) {\r\n            return d.querySelector(selector);\r\n        };\r\n\r\n        w.$$ = function (selector) {\r\n            return d.querySelectorAll(selector);\r\n        };\r\n\r\n        w.css = function (selector, prop, value) {\r\n            let $selector = w.$(selector);\r\n\r\n            if (value === undefined) {\r\n                return w.getComputedStyle($selector)[prop];\r\n            }\r\n\r\n            $selector.style[prop] = value;\r\n        }\r\n    })(document, window);\r\n\r\n    cl(css(\'ul\', \'backgroundColor\', \'pink\'));','2017-09-09 02:03:34','2017-09-09 03:53:48','js-function'),(349,3,3,'JS 作用域和预解析','# JS 作用域和预解析\r\n\r\n作用域是指变量或者函数可访问的一个范围，以函数来划分。**一个函数就是一个作用域**。\r\n\r\n作用域分：全局作用域和局部作用域。\r\n\r\n## 全局作用域\r\n\r\n全局作用域的作用范围是整个文档，在页面中的任何位置都可以访问到。\r\n\r\n全局作用域里有全局变量和全局函数，**全局变量在函数外声明，全局函数在函数外声明**。\r\n\r\n**不使用 `var` 修饰的变量声明会自动成为全局变量**。\r\n\r\n    function func() {\r\n        c = 12;\r\n    }\r\n    \r\n    func();\r\n    c; // 12\r\n\r\n之所以全局变量在整个文档里都可见，是因为全局变量是 `window` 的属性，而 `window` 是全局对象，全局对象在整个文档都是可访问的。\r\n\r\n注意：尽量避免使用全局变量。\r\n\r\n## 局部作用域\r\n\r\n局部作用域是函数范围内的。**在函数内声明的变量和函数，它们的作用范围仅仅在声明的函数里**。\r\n\r\n函数声明可以是嵌套的，嵌套的函数（局部函数）可以访问副函数里面的内容。\r\n\r\n声明局部作用域的例子。\r\n    \r\n    function outer() {\r\n        // 局部变量\r\n        var bar = \'foo\';\r\n        \r\n        // 局部函数\r\n        function inner() {\r\n            //\r\n        }\r\n    }\r\n \r\n ## 作用域链\r\n \r\n 作用域链就是变量和函数的查找规则。\r\n \r\n 查找规则是从里向外（从子级到父级、从自己到祖宗）一级一级往上找，直到找到时停止查找，否则一直向上查找到顶级的 `window` 对象，如果还没找到，就返回 `undefined` 了。\r\n \r\n ## 预解析\r\n \r\n 预解析的结果就是变量提升。预解析是代码执行前的操作步骤，在预解析过程中，会先把代码中**使用 `var` 和 `function` 的变量声明和函数声明放置在作用域最前面，值为 undefined**。\r\n    \r\n    func();\r\n    console.log(greeting);\r\n \r\n    function func() {\r\n        console.log(bar);\r\n        \r\n        var bar = \'foo\';\r\n    }\r\n    \r\n    var greeting = \':-)\';\r\n\r\n 等同于\r\n \r\n    function func() {\r\n        var bar;\r\n        console.log(bar); // undefined\r\n        \r\n        bar = \'foo\';\r\n    }\r\n    var greeting;\r\n \r\n    func();\r\n    console.log(greeting); // undefined\r\n    \r\n    greeting = \':-)\';\r\n    \r\n### 例子讲解\r\n\r\n#### 例子一\r\n\r\n    var c = 10;\r\n    function func() {\r\n        console.log(c); // 10\r\n        c = 20;\r\n    }\r\n    \r\n    func();\r\n    console.log(c); // 20\r\n \r\n #### 例子二\r\n \r\n    var c = 10;\r\n    function func(c) { // 函数参数（`c`）也是局部变量，在函数执行完毕后，就被销毁了。\r\n        console.log(c); // undefined\r\n        c = 20;\r\n    }\r\n    \r\n    func();\r\n    console.log(c); // 10\r\n    \r\n #### 例子三\r\n \r\n    var c = 10;\r\n    function func(c) { // 局部变量 c 被实参赋值为 10，然后在函数执行完毕后，被销毁。\r\n        console.log(c); // 10\r\n        c = 20;\r\n    }\r\n    \r\n    func(c);\r\n    console.log(c); // 10\r\n\r\n## 函数预解析\r\n\r\n函数声明是可以被预解析的，所以可以先调用，后声明。\r\n\r\n    func(); // :-)\r\n    \r\n    function func() {\r\n        console.log(\':-)\');\r\n    }\r\n\r\n等同于 \r\n\r\n    function func() {\r\n        console.log(\':-)\');\r\n    }\r\n    \r\n    func(); // :-)\r\n \r\n 但是函数表表达式就不一样了。\r\n \r\n    func(); // TypeError: func is not a function\r\n    \r\n    var func = function () {\r\n    	console.log(\':-)\');\r\n    };\r\n    \r\n等同于\r\n\r\n    var func;\r\n    func(); // TypeError: func is not a function\r\n    \r\n    func =  function () {\r\n        console.log(\':-)\');\r\n    };\r\n\r\n函数表达式也会发生预解析，并发生提升，但提升的是变量，函数作为值，赋值给变量的操作本身是不会提升的。','2017-09-09 05:34:50','2017-09-09 05:39:24','js-scope-and-resolution'),(350,3,3,'Laravel 文档阅读：用 Laravel Mix 编译资产','> 翻译、衍生自：https://laravel.com/docs/5.5/mix\r\n\r\n## 简介\r\n\r\n*这里的编译的「资产」可以简单理解为项目中的样式表文件和 JavaScript 脚本文件。*\r\n\r\nLaravel Mix 是  Laravel 提供的前端脚本构建工具，能够用几种常用的 CSS 和 JavaScript 预处理器处理项目脚本。 它构建在 Webpack  之上，隐藏了 Webpack 底层的复杂配置，暴露出简单易用的 API，让你轻松编译前端脚本不是梦！\r\n\r\n下面是一个例子，流畅的链式方法调用，对 JavaScript 和 Sass 这两种不同资产类型做管道处理，在一条语句内完成，非常简单：\r\n\r\n	mix.js(\'resources/assets/js/app.js\', \'public/js\')\r\n	   .sass(\'resources/assets/sass/app.scss\', \'public/css\');\r\n\r\n如果你以前用过 Webpack，就知道它的配置是多么的复杂了，因此当你第一眼看见 Laravel Mix 的时候，你就会情不自禁的爱上她。你也并非一定要用  Laravel Mix 开发，可以选择任何你希望使用的构建工具（像 Gulp），甚至不用任何构建工具都可以。\r\n\r\n## 安装 & 设置\r\n\r\n#### 安装 Node\r\n\r\n开始用 Mix 前，必须要保证在你的机器上安装了 Node.js 和 NPM 哦。\r\n\r\n	node -v\r\n	npm -v\r\n	\r\n如果你是用 Homestead 的话，就可以省略这一步了，因为 Homestead 中包含开发 Laravel 程序所需要的一切环境。\r\n\r\n#### Laravel Mix\r\n\r\n对，没有错，这一步就可以直接安装 Laravel Mix 了。在你刚创建的一个 Laravel 项目里，根目录配置文件 `package.json` 中，已经为你预设好了。\r\n\r\n	\"devDependencies\": {\r\n		\"axios\": \"^0.16.2\",\r\n		\"bootstrap-sass\": \"^3.3.7\",\r\n		\"cross-env\": \"^5.0.1\",\r\n		\"jquery\": \"^3.1.1\",\r\n		\"laravel-mix\": \"^1.0\",\r\n		\"lodash\": \"^4.17.4\",\r\n		\"vue\": \"^2.1.10\"\r\n	}\r\n\r\n`package.json` 就像是 `composer.json` 文件。不过前者是安装 Node 依赖包使用的，后者是安装 PHP 依赖包使用的。好，下面开始安装：\r\n\r\n	npm install\r\n\r\n如果你是用 Windows 系统开发的，或者是用了安装在 Windows 系统上的虚拟机（VM）。你就可能需要在执行 `npm install` 命令的时候带上 `--no-bin-links` 选项：\r\n\r\n	npm install --no-bin-links\r\n\r\n## 运行 Mix\r\n\r\nMix 是构建在 Webpack 上的一个配置层。所以执行 Mix 任务时，需要使用 NPM 脚本命令，这些命令在 `package.json` 文件中定义：\r\n\r\n	// Run all Mix tasks...\r\n	npm run dev\r\n\r\n	// Run all Mix tasks and minify output...\r\n	npm run production\r\n\r\n#### 监听资产变化\r\n\r\n`npm run watch` 与前两条命令不同的是，它会在你的终端一直运行、监听所有相关文件的改变，一旦有文件改变，就会自动重新编译：\r\n\r\n	npm run watch\r\n\r\n在某些情况下，这条命令对于 Webpack  不好使，它不给你重新编译的，针对这种情况，考虑使用 `watch-poll` 命令：\r\n\r\n	npm run watch-poll\r\n\r\n## 使用样式表\r\n\r\n`webpack.min.js` 是所有资产编译的入口文件，可以把它看做是包裹了 Webpack 底层复杂配置的一个轻量的配置文件（同样是配置文件，差距就是那么大呢）。在这里面定义了链式的 Mix 任务，每个 Mix 任务就相当于是一个编译规则呢。\r\n\r\n### Less\r\n\r\n`less` 方法用来把 Less 文件编译为 CSS。下面，让我们把原本的 `app.less` 文件输出为 `public/css/app.css` 文件。\r\n\r\n	mix.less(\'resources/assets/less/app.less\', \'public/css\');\r\n\r\n你可以同时调用多个 `less` 方法来满足项目中编译不同地方的样式文件的需要：\r\n\r\n	mix.less(\'resources/assets/less/app.less\', \'public/css\')\r\n	   .less(\'resources/assets/less/admin.less\', \'public/css\');\r\n\r\n如果要自定义编译出来的 CSS 文件名，那么在第二个参数里带上文件完整路径名就 OK 了：\r\n\r\n	mix.less(\'resources/assets/less/app.less\', \'public/stylesheets/styles.css\');\r\n\r\n`less` 方法底层使用的是 Webpack 的 [Less loader 插件](https://github.com/webpack-contrib/less-loader#options)，如果你要深度定制这个插件的配置信息，为 `min.less()` 传递第三个参数（对象类型）就 OK 了。\r\n\r\n	mix.less(\'resources/assets/less/app.less\', \'public/css\', {\r\n		strictMath: true\r\n	});\r\n\r\n### Sass\r\n\r\n`sass` 方法用来把 Sass 文件编译为 CSS。它像下面这样用：\r\n\r\n	min.sass(\'resources/assets/sass/app.scss\', \'public/css\');\r\n\r\n哎哟，不错哦，你有没有感觉跟 `less` 方法很像呢，确实！多次链式调用 `sass` 方法同时编译出多个 CSS 文件也是 OK 的：\r\n\r\n	mix.sass(\'resources/assets/sass/app.sass\', \'public/css\')\r\n	   .sass(\'resources/assets/sass/admin.sass\', \'public/css/admin\');\r\n\r\n有没有看到，第二个 `sass` 方法，我们还自定义了 CSS 输出目录，前面的 `less` 方法也可以这么玩啊（好吧，我不说了……）。\r\n\r\n注意啊，`sass` 方法底层可不是使用 Webpack 的一个什么插件，而是直接使用了 Node.js 的 [node-sass](https://github.com/sass/node-sass#options) 插件。同样，如果要深入定制她的话，给她传递第三个参数就 OK 了：\r\n\r\n	mix.sass(\'resources/assets/sass/app.sass\', \'public/css\', {\r\n		precision: 5\r\n	});\r\n\r\n### Stylus\r\n\r\n类似于 Less 和 Sass，`stylus` 方法用来把 Stylus 编译成 CSS：\r\n\r\n	mix.stylus(\'resources/assets/stylus/app.styl\', \'public/css\');\r\n\r\n也可以安装额外的 Stylus 插件，比如 Rupture。首先使用 `npm install rupture` 安装插件，然后给 `mix.stylus` 配置上它。\r\n\r\n	mix.stylus(\'resources/assets/stylus/app.styl\', \'public/css\', {\r\n		use: [\r\n			require(\'rupture\')()\r\n		]\r\n	});\r\n\r\n### PostCSS\r\n\r\nPostCSS 是一款强大的 CSS 转换器，Laravel Mix 开箱支持它。默认，Mix 使用广受欢迎的 Autoprefixer 插件来自动添加 CSS3 第三方浏览器前缀。你也可以自由的你的应用程序中要用的任何其他插件——首先，使用 NPM 安装插件，然后在 `webpack.mix.js` 中引用它：\r\n\r\n	mix.sass(\'resources/assets/sass/app.scss\', \'public/css\')\r\n	   .options({\r\n			postCss: [\r\n				require(\'postcss-css-variables\')()\r\n			]\r\n	   });\r\n\r\n\r\n### 纯 CSS\r\n\r\n如果是要把多个纯 CSS 样式文件合并成一个，就用 `styles`  方法：\r\n\r\n	mix.styles([\r\n		\'public/css/vendor/normalize.css\',\r\n		\'public/css/vendor/videojs.css\'\r\n	], \'public/css/all.css\');\r\n\r\n### URL 处理\r\n\r\nLaravel Mix 构建在 Webpack 之上，所以需要先理解几个 Webpack  的概念。编译 CSS 时，Webpack 会重写和优化样式表里的 `url()` 规则。想象我们要编译的 Sass 文件里使用了相对路径引入了图片文件：\r\n\r\n	.example {\r\n		background: url(\'../images/example.png\');\r\n	}\r\n\r\n注意，`url()` 里使用绝对路径引入图片的情况不会被处理。比如，`url(\'/images/thing.png\')` 和 `url(\'http://example.com/images/thing.png\')` 就保持原样，不被处理。\r\n\r\n默认，Laravel Mix 和 Webpack 会找到 `eaxmple.png` 文件，把它复制到 `public/images` 目录下，然后重写样式表里的 `url()` 规则。比如，你的 CSS 会被编译为：\r\n\r\n	.example {\r\n	  background: url(/images/example.png?d41d8cd98f00b204e9800998ecf8427e);\r\n	}\r\n\r\n如果你不需要重写 `url()` 里的规则，也可以禁用它：\r\n\r\n	mix.sass(\'resources/assets/app/app.scss\', \'public/css\')\r\n	   .options({\r\n		  processCssUrls: false\r\n	   });\r\n\r\n在 `webpack.mix.js` 中添设定了这个选项后，`url()` 里的规则保持原样不变。还是下面这样：\r\n\r\n	.example {\r\n		background: url(\"../images/thing.png\");\r\n	}\r\n\r\n### Source Maps\r\n\r\n编译资产时，Source Map 默认是禁用的，你可以使用 `mix.sourceMaps()` 方法启用它。虽然在编译时，这样会带来额外的开销，但是在你 debug 的时候非常有用。\r\n\r\n	mix.js(\'resources/assets/js/app.js\', \'public/js\')\r\n	   .sourceMaps();\r\n\r\n## 使用 JavaScript\r\n\r\nMix 提供了几个功能来帮助您处理 JavaScript 脚本文件，例如编译 ECMAScript 2015、模块捆绑、压缩以及合并纯 JavaScript 文件。 更棒的是，这一切不需要一丁点的自定义配置，即可直接使用：\r\n\r\n	mix.js(\'resources/assets/js/app.js\', \'public/js\');\r\n\r\n这一行代码，你就使用了：\r\n\r\n* ES2015 语法。\r\n* 模块。\r\n* 编译 `.vue` 文件。\r\n* 生产环境下的代码压缩。\r\n\r\n### 第三方提取\r\n\r\n把项目的脚本代码和第三方库代码合并到一起有一个缺点：很难长期缓存文件。例如，项目中单个文件代码的修改就会导致，那些第三方库代码也跟着重新编译（不管有没有改动代码），然后浏览器重新加载编译后的文件。\r\n\r\n如果你项目中的 JavaScript 代码经常修改，你就应该考虑把第三方看库文件提取出来放在属于他们的文件里。这样一来，你项目的脚本代码的修改和重新编译，不会影响到体积较大的 `vendor.js` 文件。Mix 的 `extract` 方法就是做这个的：\r\n\r\n	mix.js(\'resources/assets/js/app.js\', \'public/js\')\r\n	   .extract([\'vue\'])\r\n\r\n`extract` 方法的接受的数组参数里，就是你最终要放到 `vendor.js` 文件里的所有库和模块。使用上面的逻辑编译脚本文件后，会产出以下 3 个文件：\r\n\r\n* `public/js/mainfest.js`：Webpack 运行时清单。\r\n* `public/js/vendor.js`：第三方库。\r\n* `public/js/app.js`：项目脚本代码。\r\n\r\n为了避免 JavaScript 错误，确保按照下面的顺序加载文件：\r\n\r\n	<script src=\"/js/manifest.js\"></script>\r\n	<script src=\"/js/vendor.js\"></script>\r\n	<script src=\"/js/app.js\"></script>\r\n\r\n### React\r\n\r\nMix 也会自动安装 React 所需要的 Babel 插件。在你使用 `mix.react()` 而非 `min.js()` 时\r\n\r\n	mix.react(\'resources/assets/js/app.jsx\', \'public/js\');\r\n\r\n在背后，Mix 会下载和引入正确的 `babel-preset-react` 这个 Babel 插件。\r\n\r\n### 原生 JS\r\n\r\n类似 `mix.styles()` 方法，你可以使用 `scripts()` 方法合并和压缩任意数量的 JavaScript 文件：\r\n\r\n	mix.scripts([\r\n		\'public/js/admin.js\',\r\n		\'public/js/dashboard.js\'\r\n	], \'public/js/all.js\');\r\n\r\n这个方法并没有使用到 Webpack 编译 JavaScript 脚本文件。\r\n\r\n注意，还有一个 `mix.babel()` 方法，它是在 `mix.scripts` 方法的基础上做了一些的修改，但支持 ES2015 语法的编译，而且两者的方法签名都是一样的。经过  `mix.babel()` 方法合并的脚本文件会经过 Babel 的编译，将任何 ES2015 代码转换为浏览器支持的原生 JavaScript 代码。\r\n\r\n### 自定义 Webpack 配置\r\n\r\n在上面这些开箱提供的简单 API 背后，Laravel Mix 引用了一个预先配置的 `webpack.config.js` 文件，一般以便能使你尽快上手使用。有时，你可能需要手动修改此文件，引用特殊的加载程序或插件，或者使用 Stylus 而不是 Sass。 在这种情况下，您有两种选择：\r\n\r\n#### 合并自定义配置\r\n\r\nMix 提供了一个有用的 `webpackConfig` 方法来合并、覆盖任何简短的 Webpack 配置项。这种选择比较好，因为它不需要你复制和维护一个 `webpack.config.js` 副本。`webpackConfig` 方法接收一个对象参数，你可以在里面定义任何你想要自定义的 [Webpack 配置项](https://webpack.js.org/configuration/)。\r\n\r\n	mix.webpackConfig({\r\n		resolve: {\r\n			modules: [\r\n				path.resolve(__dirname, \'vendor/laravel/spark/resources/assets/js\')\r\n			]\r\n		}\r\n	});\r\n\r\n#### 自定义配置文件\r\n\r\n如果你要完全自定义你的 Webpack 配置文件的话，就要把 `node_modules/laravel-mix/setup/webpack.config.js` 复制到你的项目根目录下，然后修改 `package.json` 文件里 `--config`  后面的配置文件路径（`--config=webpack.config.js`）。\r\n\r\n如果你采用这种方式的话，未来所有在 Mix 上的更新都要手工合并到你的自定义配置文件里。\r\n\r\n## 复制文件 & 目录\r\n\r\n`copy` 方法用来复制文件从一个位置到另一个位置。当你需要把 `node_modules` 文件夹里的文件复制到 `public` 下时很有用。\r\n\r\n	mix.copy(\'node_modules/foo/bar.css\', \'public/css/bar.css\');\r\n\r\n复制整个文件夹的话，就使用 `copyDirectory` 方法：\r\n\r\n	mix.copyDirectory(\'assets/img\', \'public/img\');\r\n\r\n## 加版本号/清除缓存\r\n\r\n许多开发者会在编译资产文件前加上时间戳或者唯一令牌号，来强制浏览器加载最新编译的脚本文件而不是使用之前的老版本。Mix 用 `version` 方法来解决这个问题。\r\n\r\n`version` 方法会自动给编译出来的脚本文件名附加一个 hash 值，强制浏览器加载最新编译的脚本文件。\r\n\r\n	mix.js(\'resources/assets/js/app.js\', \'public/js\')\r\n	   .version();\r\n\r\n带版本号的脚本文件编译好后，你是不知道确切的文件名的。这是使用 Laravel 全局的 `mix` 方法在视图里加载正确的带版本号的脚本文件。`mix` 方法会自动确定正确的 hash 文件：\r\n\r\n	<link rel=\"stylesheet\" href=\"{{ mix(\'/css/app.css\') }}\">\r\n\r\n因为版本文件在开发期间不常使用，所以可以设定只在执行 `npm run production` 命令时才给资产文件添加版本号：\r\n\r\n	mix.js(\'resources/assets/js/app.js\', \'public/js\');\r\n\r\n	if (mix.inProduction()) {\r\n		mix.version();\r\n	}\r\n\r\n## 浏览器同步加载\r\n\r\n[BrowserSync](https://browsersync.io/) 可以用来自动监听文件改变，在不需要手工刷新的情况下，在浏览器中同步加载更新的文件内容。这时，你要使用 `mix.browserSync()` 方法做到：\r\n\r\n	mix.browserSync(\'my-domain.dev\');\r\n\r\n	// Or...\r\n\r\n	// 更多配置项参考：https://browsersync.io/docs/options\r\n	mix.browserSync({\r\n		proxy: \'my-domain.dev\'\r\n	});\r\n\r\n`browserSync` 方法接收的参数可以是一个（代理）字符串或者是（BrowserSync 配置）对象。接下来，当你使用 `npm run watch` 命令后，每当你修改一个脚本或者 PHP 文件，在浏览器中的页面都会立即更新。\r\n\r\n## 环境变量\r\n\r\n我们可以向 Mix 中注入环境变量，这是通过在 `.env` 文件中设定以 `MIX_` 作为前缀的 Key 做到的：\r\n\r\n	MIX_SENTRY_DSN_PUBLIC=http://example.com\r\n\r\n在 `.env` 文件中，定义好变量后，就可以通过 `process.env` 对象获得这个变量。如果你在 `watch` 时改变了这个值，是需要停止、然后重启 `watch` 才能让变化后的变量值生效。\r\n\r\n	process.env.MIX_SENTRY_DSN_PUBLIC\r\n\r\n## 通知\r\n\r\n如果可用的话，Mix 会在每次编译任务完成后，自动操作系统级别的通知， 给你即时的反馈说编译是否成功了。 不过，如果你希望停用这些通知——比如，你遇到过在你的生产环境的服务器上这可能会再一次触发 Mix，这时，就需要用 `disableNotifications` 方法禁用它了。\r\n\r\n	 mix.disableNotifications();','2017-09-09 07:13:25','2017-09-13 01:58:44','laravel-document-reading-using-laravel-mix-build-assets'),(351,3,3,'JS 闭包','函数嵌套函数，子函数访问父函数的变量，就产生了一个闭包环境。闭包函数里的变量和内部函数在外部是访问不了的。\r\n\r\n如果要让外部能够访问闭包环境里的变量和函数，这就需要在外部函数中返回内部函数或者变量供在其他地方使用。这也是闭包的一个特性。\r\n\r\n## 生命周期\r\n\r\n变量或者函数在相应的作用域里存在的时间。\r\n\r\n* 对于局部变量和函数：当变量或者函数不再使用时，就是它生命周期的结束，它就不存在了。\r\n* 对于全局变量和函数：全局变量和函数，在整个页面中都是可用的，当页面关闭后，它的生命周期就结束了，它就不存在了。\r\n\r\n## 垃圾回收机制\r\n\r\n局部变量和函数是保存在内存当中的，当变量和函数使用完毕后，没有别的地方在引用它的话，垃圾回收机制就会把它给销毁了。\r\n\r\n垃圾回收机制可能会按照固定的时间间隔，周期性清除不再被使用的垃圾变量和函数。\r\n\r\n## 闭包的作用 \r\n\r\n让函数内部的变量和函数在外面可以访问到。\r\n\r\n内存泄漏：不用的变量或者函数不再使用，但是还被引用，一直存在于内存中，对内存造成的浪费，称为内存泄漏。\r\n\r\n\r\n	<ul>\r\n		<li>1</li>\r\n		<li>2</li>\r\n		<li>3</li>\r\n		<li>4</li>\r\n		<li>5</li>\r\n	</ul>\r\n	\r\n	<script>\r\n    var lis = document.querySelectorAll(\'li\');\r\n\r\n    for (var i = 0; i < lis.length; i++) {\r\n        (function (j) {\r\n            lis[j].addEventListener(\'click\', function (ev) {\r\n                console.log(j);\r\n            });\r\n        })(i);\r\n    }\r\n	</script>\r\n	\r\n那么如果写成这样就不行了：\r\n\r\n	<script>\r\n		var lis = document.querySelectorAll(\'li\');\r\n\r\n		for (var i = 0; i < lis.length; i++) {\r\n			lis[j].addEventListener(\'click\', function (ev) {\r\n				(function (j) {\r\n					console.log(j);\r\n				})(i);\r\n			});\r\n		}\r\n	</script>\r\n\r\n因为这样是在循环结束后，在执行点击时，才会触发的以及执行函数，打印出来的还是最后的 `i` 的值（5）。','2017-09-09 08:00:40','2017-09-09 08:00:40','js-closure'),(352,3,3,'优酷 html5 播放器','> 原文链接：https://www.v2ex.com/t/366702\r\n\r\nChorme 打开 console 执行 \r\n\r\n	window.sessionStorage.setItem(\"P_l_h5\", true); \r\n\r\n然后刷新可以打开测试中的 html5 播放器了。','2017-09-09 09:09:38','2017-09-09 09:09:38','youku-html-5-players'),(353,3,3,'??歌唱新生活','1. 《寻水的鱼》，by 许飞。2018年1月。\r\n\r\n---\r\n\r\n## 女生版\r\n<!--\r\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=437292675&auto=0&height=66\"></iframe>\r\n-->\r\n\r\n---- 任素汐\r\n\r\n我要 你在我身旁\r\n\r\n我要 你为我梳妆\r\n\r\n这夜的风儿吹\r\n\r\n吹得心痒痒 我的情郎\r\n\r\n我在他乡 望着月亮\r\n\r\n都怪这月色 撩人的疯狂\r\n\r\n都怪这 Guitar 弹得太凄凉\r\n\r\n欧 我要唱着歌\r\n\r\n默默把你想 我的情郎\r\n\r\n你在何方 眼看天亮\r\n\r\n都怪这夜色 撩人的疯狂\r\n\r\n都怪这 Guitar 弹得太凄凉\r\n\r\n欧 我要唱着歌\r\n\r\n默默把你想 我的情郎\r\n\r\n你在何方 眼看天亮\r\n\r\n我要 美丽的衣裳\r\n\r\n为你 对镜贴花黄\r\n\r\n这夜色太紧张\r\n\r\n时间太漫长 我的情郎\r\n\r\n我在他乡 望着月亮\r\n\r\n## 男生版\r\n\r\n---- 老狼\r\n\r\n我要 你在我身旁\r\n\r\n我要看着你梳妆\r\n\r\n这夜的风?儿吹\r\n\r\n吹得心痒痒 我的姑娘\r\n\r\n我在他乡 望着月亮?\r\n\r\n送你 美丽的衣裳\r\n\r\n看你 对镜贴花?黄\r\n\r\n这夜色太紧张?\r\n\r\n时间太漫长 我的姑娘\r\n\r\n你在何方 眼看天亮\r\n\r\n都怪这夜色 撩人的疯狂\r\n\r\n都怪这吉他? 弹得太凄凉\r\n\r\n哦 我要唱着歌\r\n\r\n默默把你想 我的姑娘\r\n\r\n你在何方 眼看天亮','2017-09-09 10:16:59','2018-01-13 15:23:40','sing-a-new-life-i-want-you-to'),(354,3,3,'修改最新一条 discussion 的 slug','两条语句：    \r\n	\r\n	select id, title, slug from discussions order by id desc  limit 1;\r\n\r\n	update discussions set slug=\'sing-a-new-life-i-want-you-to\' where id = 353;','2017-09-09 10:21:58','2017-09-09 12:04:16','modify-the-latest-slug-of-the-discussion'),(355,3,3,'我要用 emoji','> 来自：http://getemoji.com/\r\n\r\n<style>\r\n	p.zhangb-emoji {\r\n		font-size: 2em;\r\n	}\r\n</style>\r\n\r\n## 动物和自然\r\n\r\n<p class=\"zhangb-emoji\">\r\n? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ☘️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ⭐️ ? ✨ ⚡️ ? ? ☄️ ☀️ ? ⛅️ ? ? ? ☁️ ? ⛈ ? ? ☃️ ⛄️ ❄️ ? ? ? ? ? ? ? ☔️\r\n</p>\r\n\r\n\r\n## 食品和饮料\r\n\r\n<p class=\"zhangb-emoji\">\r\n? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ☕️ ? ? ? ? ? ? ? ? ? ? ? ? ?\r\n</p>\r\n\r\n## 体育活动\r\n\r\n<p class=\"zhangb-emoji\">\r\n⚽️ ? ? ⚾️ ? ? ? ? ? ? ? ? ? ? ⛳️ ? ? ? ? ⛸ ? ⛷ ? ?️‍♀️ ?️ ? ?‍♀️ ?‍♂️ ?‍♀️ ?‍♂️ ⛹️‍♀️ ⛹️ ?‍♀️ ?‍♂️ ?️‍♀️ ?️ ?‍♀️ ? ?‍♀️ ? ?‍♀️ ?‍♂️ ?‍♀️ ? ? ?‍♀️ ? ?‍♀️ ? ? ? ? ? ? ? ? ? ? ? ? ? ?‍♀️ ?‍♂️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\r\n</p>\r\n\r\n## 旅游和物件\r\n\r\n<p class=\"zhangb-emoji\">\r\n? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ✈️ ? ? ? ? ? ? ⛵️ ? ? ? ⛴ ? ⚓️ ? ⛽️ ? ? ? ? ? ? ⛲️ ? ? ? ? ? ? ? ⛱ ? ? ⛰ ? ? ? ? ? ⛺️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ⛪️ ? ? ? ⛩ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?\r\n</p>\r\n\r\n## 工具\r\n\r\n<p class=\"zhangb-emoji\">\r\n⌚️ ? ? ? ⌨️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ☎️ ? ? ? ? ? ? ? ⏱ ⏲ ⏰ ? ⌛️ ⏳ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ⚖️ ? ? ⚒ ? ⛏ ? ⚙️ ⛓ ? ? ? ? ⚔️ ? ? ⚰️ ⚱️ ? ? ? ? ⚗️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ✉️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?️ ? ? ?️‍? ✂️ ? ? ✒️ ? ? ? ✏️ ? ? ? ? ? ?\r\n</p>\r\n\r\n## 笑脸和人物\r\n\r\n<p class=\"zhangb-emoji\">\r\n? ? ? ? ? ? ? ? ☺️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ☹️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ☠️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ✊ ? ? ? ✌️ ? ? ? ? ? ? ☝️ ✋ ? ? ? ? ? ? ? ✍️ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?‍♀️ ? ? ? ? ?‍♀️ ? ?‍♀️ ? ?‍♀️ ? ?‍♀️ ? ?️‍♀️ ?️ ?‍⚕️ ?‍⚕️ ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍? ?‍✈️ ?‍✈️ ?‍? ?‍? ?‍⚖️ ?‍⚖️ ? ? ? ? ? ? ? ? ?‍♀️ ? ? ?‍♂️ ? ?‍♂️ ? ?‍♂️ ? ?‍♂️ ?‍♀️ ?‍♂️ ?‍♀️ ?‍♂️ ? ?‍♂️ ? ?‍♂️ ? ?‍♂️ ? ?‍♂️ ? ? ? ? ?‍♂️ ?‍♀️ ? ?‍♀️ ? ? ? ? ? ?‍❤️‍? ?‍❤️‍? ? ?‍❤️‍?‍? ?‍❤️‍?‍? ? ?‍?‍? ?‍?‍?‍? ?‍?‍?‍? ?‍?‍?‍? ?‍?‍? ?‍?‍? ?‍?‍?‍? ?‍?‍?‍? ?‍?‍?‍? ?‍?‍? ?‍?‍? ?‍?‍?‍? ?‍?‍?‍? ?‍?‍?‍? ?‍? ?‍? ?‍?‍? ?‍?‍? ?‍?‍? ?‍? ?‍? ?‍?‍? ?‍?‍? ?‍?‍? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ⛑ ? ? ? ? ? ? ? ? ☂️\r\n</p>\r\n\r\n<p class=\"zhangb-emoji\">\r\n?? ?? ?? ?? ?? ?? ?? ✊? ?? ?? ?? ✌? ?? ?? ?? ?? ?? ?? ☝? ✋? ?? ?? ?? ?? ?? ?? ?? ✍? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍⚕️ ??‍⚕️ ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍✈️ ??‍✈️ ??‍? ??‍? ??‍⚖️ ??‍⚖️ ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ??‍♀️ ??‍♂️ ??‍♀️ ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ⛹?‍♀️ ⛹? ??‍♀️ ??‍♂️ ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??‍♀️ ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??\r\n</p>\r\n\r\n<p class=\"zhangb-emoji\">\r\n?? ?? ?? ?? ?? ?? ?? ✊? ?? ?? ?? ✌? ?? ?? ?? ?? ?? ?? ☝? ✋? ?? ?? ?? ?? ?? ?? ?? ✍? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍⚕️ ??‍⚕️ ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍✈️ ??‍✈️ ??‍? ??‍? ??‍⚖️ ??‍⚖️ ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ??‍♀️ ??‍♂️ ??‍♀️ ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ⛹?‍♀️ ⛹? ??‍♀️ ??‍♂️ ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??‍♀️ ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??\r\n</p>\r\n\r\n<p class=\"zhangb-emoji\">\r\n?? ?? ?? ?? ?? ?? ?? ✊? ?? ?? ?? ✌? ?? ?? ?? ?? ?? ?? ☝? ✋? ?? ?? ?? ?? ?? ?? ?? ✍? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍⚕️ ??‍⚕️ ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍✈️ ??‍✈️ ??‍? ??‍? ??‍⚖️ ??‍⚖️ ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ??‍♀️ ??‍♂️ ??‍♀️ ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ⛹?‍♀️ ⛹? ??‍♀️ ??‍♂️ ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??‍♀️ ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??\r\n\r\n<p class=\"zhangb-emoji\">\r\n?? ?? ?? ?? ?? ?? ?? ✊? ?? ?? ?? ✌? ?? ?? ?? ?? ?? ?? ☝? ✋? ?? ?? ?? ?? ?? ?? ?? ✍? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍⚕️ ??‍⚕️ ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍✈️ ??‍✈️ ??‍? ??‍? ??‍⚖️ ??‍⚖️ ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ??‍♀️ ??‍♂️ ??‍♀️ ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ⛹?‍♀️ ⛹? ??‍♀️ ??‍♂️ ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??‍♀️ ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??\r\n</p>\r\n\r\n<p class=\"zhangb-emoji\">\r\n?? ?? ?? ?? ?? ?? ?? ✊? ?? ?? ?? ✌? ?? ?? ?? ?? ?? ?? ☝? ✋? ?? ?? ?? ?? ?? ?? ?? ✍? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍⚕️ ??‍⚕️ ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍? ??‍✈️ ??‍✈️ ??‍? ??‍? ??‍⚖️ ??‍⚖️ ?? ?? ?? ?? ?? ?? ?? ?? ??‍♀️ ?? ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ??‍♀️ ??‍♂️ ??‍♀️ ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ??‍♂️ ?? ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ⛹?‍♀️ ⛹? ??‍♀️ ??‍♂️ ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??‍♀️ ?? ?? ??‍♀️ ?? ??‍♀️ ?? ??‍♀️ ??‍♂️ ??\r\n</p>','2017-09-09 10:32:03','2017-09-09 10:36:02','i-want-to-use-emoji'),(356,3,3,'PS教程：光的复合','## 光的色散\r\n\r\n白色阳光经过色散，分成（从上到下）：红、橙、黄、绿、青、蓝、紫。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_1.png)\r\n\r\n### 单色光和复色光\r\n\r\n不能在分散的光称为 **单色光**；由单色光组合而成的是 **复色光**。\r\n\r\n通过实验得知，有 3 个单色光：\r\n\r\n1. 红\r\n2. 绿\r\n3. 蓝\r\n\r\n## RGB 颜色混合\r\n\r\n在一个白色墙壁围绕的空间里，打上白灯，空间看起来是这个样子的\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_2.png)\r\n\r\n这时减弱灯光至微光\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_3.png)\r\n\r\n然后打进来一个红色光圈\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_4.png)\r\n\r\n*因为白色墙壁返回一切色光，所以红色色光打在上面后，返回了红色色光，我们就看到了红色光圈。*\r\n\r\n再把室内的微光去除\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_5.png)\r\n\r\n*整个房间一片漆黑，只有打出的红色光圈。*\r\n\r\n现在加入绿色和蓝色光圈\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_6.png)\r\n\r\n*可以看到 **等量** 的 **绿色光和红色光混合** 后得到了 **黄色光**。*\r\n\r\n下面让绿色光和蓝色光混合\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_7.png)\r\n\r\n*可以看到 **等量** 的 **绿色光和蓝色光混合** 后得到了 **青色光**。*\r\n\r\n最后红色光和蓝色光混合\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_8.png)\r\n\r\n*可以看到，我们得到了  **洋红色（品红色）光** *。\r\n\r\n但红、绿、蓝色光都混合在一起时，我们就得到了白光！\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_9.png)\r\n\r\n当三个色光没有完全吻合时，就会出现 「紫边现象」，处理照片图片时，有时会遇到这种情况。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_10.png)\r\n\r\n那么，这就是  RGB 颜色混合示意图了。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_11.png)\r\n\r\n## 光源色\r\n\r\n光源是指自身可以发光的物体，比如太阳、灯泡和焰火，它们都自带颜色。光源所带的颜色称为光源色。\r\n\r\n固有色：物体本身的颜色特征，这是人类对物体的基本看法，在认识上感觉一个物体就应该是某种颜色（其实看法是比较片面的）。\r\n\r\n眼睛感觉到颜色的过程：\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_12.png)\r\n\r\n这张图里，太阳光找到花朵，然后人的眼睛看到花朵。\r\n\r\n太阳光是复色光，包含红绿蓝 3 个基础色光，当阳光照射到花朵上的时候，花朵吸收了大量的绿色和蓝色色光，反射红色色光，所以，花朵看起来就是红色的了。\r\n\r\n**物体的固有色，就是它反射的的色光的颜色**。\r\n\r\n\r\n而照片中，物体显示的颜色并不一定说是固有色，和光源色有非常密切的关系。以下面一张图为例：\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_13.png)\r\n\r\n被阳光照射的草地偏向黄色，没被照射的草地偏向于青，为什么这样呢？看下 RGB 颜色混合示意图：\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/guang_14.png)\r\n\r\n早上的阳光的色光（黄色）是由红色和绿色复合出来的，草地的固有色是绿色，因此草地的大量绿色光和太阳少量的红色光复合就得到了「阳光下草地的颜色」颜色。\r\n\r\n没有被太阳照射的草地，主要是反射青色天空，其颜色是由蓝色和绿色复合出来的，草地的固有色是绿色，大量和绿色和少量的蓝色复合就得到了「阴影里的草地」颜色。','2017-09-10 02:10:59','2017-09-10 02:12:08','ps-tutorial-light-and-mix'),(357,3,3,'PS教程：颜料的混合','颜料的混合和光的复合的不同的是——前者是减色的过程。\r\n\r\n颜料的三原色是：\r\n\r\n1. 品红（洋红）\r\n2. 黄\r\n3. 青\r\n\r\n平时所说的红黄蓝，只是近似值。\r\n\r\n## 颜色混合\r\n\r\n青色 + 黄色 = 绿\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/yanliao_1.png)\r\n\r\n品红 + 黄 + 青 = 黑\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/yanliao_2.png)\r\n\r\n为什么是黑色呢？\r\n\r\n我们这样想，这是在直接改变固有色的，而不是保存固有色不变，复合色光的过程。\r\n\r\n改变固有色！\r\n\r\n蓝色和绿色得青色，青色能返回蓝色和绿色光，但是不反射（即吸收）红色光的。\r\n\r\n红色和绿色得黄色，青色能返回红色和绿色光，但是不反射蓝色光。\r\n\r\n蓝色和红色的品红，品红能返回蓝色和红色光，但是不反射绿光。\r\n\r\n**所以最后的颜色不反射（即吸收）红色光的，不反射青色光，不反射绿光，几乎就是黑色的了**。\r\n\r\n## CMYK 颜色模式\r\n\r\n所以颜料的混合是一个减色的过程。在印刷行业，是无法提取纯正的红、绿和蓝色的。因此就有了 CMYK 颜色模式：\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/yanliao_3.png)\r\n\r\nC（青色）、M（品红）、Y（黄）、K（黑，这是 `black` 的左后一个字母，是为了跟 RGB 的 「B」区分）颜色模式。\r\n\r\n## 总结\r\n\r\nCMYK 混合模式和 RGB 复合模式是相互交叉的关系，相通而又对立，矛盾而且统一。\r\n\r\nRGB 是色光的复合，是光相加得到新的色光的过程，越加越亮；CMYK 是颜料的混合，混合的越多，反射的色光越暗，这是减法混合。','2017-09-10 02:30:12','2017-09-10 02:35:23','ps-tutorial-a-mixture-of-pigment'),(358,3,3,'PS教程：解锁、新建和移动图层','1. 我们使用 「移动工具（v）」默认是无法移动图层的，因为 **图层已锁定** 了。这是把小锁拖动到垃圾箱，解除锁定，就可以移动图层了。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/PS_1.png)\r\n\r\n2. 当用「选框工具（m）」选择了某一个图层的区域时，`Ctrl + J` 就新建了一个图层，将选择的区域置于其中了。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/PS_2.png)\r\n\r\n下面 `Ctrl + J`  就看到新建的图层内容了\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/PS_3.png)\r\n\r\n3. 「移动工具」还有一个自动选择选项，勾上后，我们拖动哪个图层，哪个图层就会被选中，然后被拖着走。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/PS_4.png)\r\n\r\n4. 锁定图层：选中图层，点击「锁定」区域那个小锁，就可以了。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/PS_5.png)\r\n\r\n5. 锁定背景图层后，还可以使用移动工具选中多个图层。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/09/PS_6.png)','2017-09-10 03:29:16','2017-09-10 03:52:43','ps-this-tutorial-when-there-is-a-layer'),(359,3,3,'今天我要散步了','我叫耿路路出来跑步，他不愿意，说下雨了，我说不下了，他说不去。我就出来了，散步都找不到一个人。\r\n\r\n外面果然下着雨，我没带伞，但我还是早在路上走，我不觉得这有什么。\r\n\r\n我听着《river flows in you》，看着流过的苏州河水。没有感觉不好。\r\n\r\n局促一室之内，先不说思想上的东西，确实能让人憋胖了。\r\n\r\n出来散散步，看看河水，感受城市静谧的一面不是挺好的吗？为什么就不呢。\r\n\r\n我们最后能留下的其实只有感受罢了，应该要丰富一些的。','2017-09-10 12:26:34','2017-09-10 12:31:17','today-im-going-to-walk'),(360,3,3,'电影《功夫》：小弟，别走啊','小弟 小弟 别走啊\r\n\r\n哎呀 不得了啊 不得了\r\n\r\n你有道灵光从天灵盖喷出来 你知道吗？\r\n\r\n年纪轻轻的 就有一身横练的筋骨\r\n\r\n简直是百年一见的练武奇才\r\n\r\n如果有一天 让你打通任督二脉\r\n\r\n那还不飞龙上天啊\r\n\r\n正所谓：我不入地狱 谁入地狱\r\n\r\n警恶惩奸 维护世界和平这个任务 就交给你了 好不好？\r\n\r\n这本《如来神掌秘籍》是无价之宝\r\n\r\n我看与你有缘 收你十块钱 传授给你吧。','2017-09-10 14:28:16','2017-09-10 14:28:16','the-film-kung-fu-the-younger-brother-dont-go-through-it'),(361,7,3,'Docker-镜像导入导出','## 镜像导出\r\n`docker save -o XXXX（镜像备份文件名） XXXX（需要备份镜像）:xxxxx(镜像tag）`\r\n## 镜像导入\r\n`docker load --input XXXX（镜像备份文件）`','2017-09-12 05:46:50','2017-10-25 11:28:01','docker-the-backup-image'),(362,3,3,'一分钟理解 CSS 属性之 `backgorund: xpos ypos;`','点开查阅：https://codepen.io/zhangbao/full/MEgZdv\r\n\r\n**总结**\r\n\r\n背景图片的定位，相当于定位图片左上角那个点在坐标系内的坐标。\r\n\r\n* 坐标系的 X 轴：设定背景图片的那个元素的水平方向，正方向向右。\r\n* 坐标系的 Y 轴：设定背景图片的那个元素的垂直方向，正方向向下。','2017-09-12 06:31:20','2017-09-13 00:19:00','a-minute-understanding-of-css-properties-backgorund-xpos-ypos'),(363,3,3,'2017年9月12号','我现在越来越觉得这样一件事情：就想人家说的什么陪伴就是最长情的告白。做什么事情如果没有长性，很难做成。这几乎是被说烂了的道理，但是，的确是这样。\r\n\r\n还有，读书，一遍，绝对是等于没读的。原因是一样的，因为现在很难有长性去专心地做一件事情。比如，我身边常带的这本《堂吉诃德<上>》，我就看了很久，主要是没有性子去读。今天晚上，稍微读得多一点，快读完了。但我想说的是：没有长性是不行的。\r\n\r\n长性和热力并不矛盾，一个有长性的人，一样是可以有热力的人——这是一个逐渐饱满的过程。\r\n\r\n我发现自己花了太多时间编码和考虑编码，要不然就是脑袋空白。我并不讨厌脑袋空白的状态，也许是在休息呢。但这样并不好，要花时间在生活上，发觉生活上的美好，这是必要的。\r\n\r\n技术一直在变，学无止境，要学习靠近思想的部分和基础的部分，这十分重要。我要努力做到。','2017-09-12 13:56:59','2017-09-12 13:56:59','on-september-12-2017'),(364,3,3,'错误解决： [InvalidArgumentException]  Script \"post-install-cmd\" is not defined in this package','我使用 [Laravel Installer](https://laravel-china.org/articles/5137/install-laravel-installer-in-the-windows-10-system) 安装 Laravel 5.5 项目：\r\n\r\n	laravel new lara55\r\n\r\n在安装的最后报了一个错：\r\n\r\n	> [@php](https://laravel-china.org/users/10050) -r \"file_exists(\'.env\') || copy(\'.env.example\', \'.env\');\"\r\n\r\n\r\n	  [InvalidArgumentException]\r\n	  Script \"post-install-cmd\" is not defined in this package\r\n\r\n\r\n	run-script [--timeout TIMEOUT] [--dev] [--no-dev] [-l|--list] [--] [<script>] [<args>]...\r\n\r\n	Application ready! Build something amazing.\r\n\r\n就是 「[InvalidArgumentException]  Script \"post-install-cmd\" is not defined in this package」，**如果不注意，你几乎看不到**。而且最后提示 「Application ready」，**但这有问题——至少在使用 `npm run dev` / `npm run production` 编译前端脚本时会失败**。\r\n\r\n解决方法是：**升级 Laravel Installer 版本**，我现在的版本是：\r\n\r\n	> laravel -V\r\n	Laravel Installer 1.3.6\r\n\r\n咱升级一下：\r\n\r\n	> composer global update\r\n	Changed current directory to C:/Users/zhangb/AppData/Roaming/Composer\r\n	Loading composer repositories with package information\r\n	Updating dependencies (including require-dev)\r\n	Package operations: 1 install, 5 updates, 0 removals\r\n	  - Updating symfony/process (v3.3.2 => v3.3.9): Loading from cache\r\n	  - Installing symfony/filesystem (v3.3.9): Downloading (100%)\r\n	  - Updating symfony/polyfill-mbstring (v1.4.0 => v1.5.0): Downloading (100%)\r\n	  - Updating symfony/debug (v3.3.2 => v3.3.9): Loading from cache\r\n	  - Updating symfony/console (v3.3.2 => v3.3.9): Loading from cache\r\n	  - Updating laravel/installer (v1.3.6 => v1.4.1): Downloading (100%)\r\n	Writing lock file\r\n	Generating autoload files\r\n\r\n下面在重新安装项目：\r\n\r\n	> laravel new lara55\r\n	> cd lara55\r\n	> php artisan -V\r\n	Laravel Framework 5.5.3\r\n\r\n即可。如果这样的话，那么以后还是使用\r\n\r\n	composer create-project --prefer-dist laravel/laravel lara55 \"5.5.*\"\r\n\r\n的方式更保险些。\r\n\r\n> 参考连接：https://github.com/laravel/framework/issues/20934','2017-09-13 00:08:13','2017-09-13 00:12:34','error-an-invalidargumentexception-script-post-install-cmd-is-not-defined-in-this-package'),(365,3,3,'莎士比亚说','世界上最悲哀的事，就是明明说了，但是真的是白说了。\r\n\r\n因为根本就没保存。\r\n\r\n技术有无限可能，也有无线漏洞，这是个老大难问题。\r\n\r\n到你觉得一切没有问题，那么新的问题也会出来的。所以不要想到结束。\r\n\r\n如果你真的能过很久，你要干嘛呢，你现在想不到，也许以后会想，到最后也想不明白，对的，这不，时间不就过去了。\r\n\r\n之所以烦恼，是不能想动物一样简单活着。\r\n\r\n这样的话，就这样吧。\r\n\r\n对了，这些话不是莎士比亚说说得，是我有感而发。因为真的是太操蛋了。','2017-09-13 12:55:09','2017-09-13 12:56:44','shakespeare-said'),(366,3,3,'2017年9月14号','难得的好天气，外面下蒙蒙细雨，我出来跑了一公里，剩下的路程决定走路。\r\n\r\n基本没人在外面走了，可雨下得真不大。我身体告诉我不舒服，我要出来才行。我渐渐明白，这是一个人的事情。\r\n\r\n你会告诉你自己适合什么生活方式，你要做的就是就是去做到他。因为，基本上，生活的节奏不一样。身体情况也不一样的。\r\n\r\n好了，接着走。我要回去了。?','2017-09-14 12:54:56','2017-09-14 12:55:25','on-september-14-2017'),(367,3,3,'Laravel 文档阅读：中间件','> 翻译、衍生自：https://laravel.com/docs/5.5/middleware\r\n\r\n## 简介\r\n\r\n中间件用来过滤项目中的 HTTP 请求，实际上 Laravel 项目中大量使用了中间件。例如，Laravel 中有一个验证用户是否认证的中间件，如果用户没认证，就跳转到登录页面；如果认证了，就会允许进一步的操作。\r\n\r\n当然，中间件的作用不只在认证上。CORS 中间件负责给项目中的响应设定正确的表头（Headers ）；日志中间件负责记录项目中处理的所有请求信息。\r\n\r\nLaravel 框架中包含了几个中间件，包括负责处理认证和 CSRF 保护的。所有这些中间件位于 `app/Http/Middleware` 目录下。\r\n\r\n## 定义中间件\r\n\r\n使用 Artisan 命令  `make:middleware` 创建中间件：\r\n\r\n	php artisan make:middleware CheckAge\r\n\r\n这个命令会在 `app/Http/Middleware` 目录下创建一个 `CheckAge` 类。在这个中间件里，我们设定年龄大于 200 岁的可以进一步操作（这不扯吗？），小于等于 200 岁的重定向到用户控制台地址 `/home`。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Middleware;\r\n\r\n	use Closure;\r\n\r\n	class CheckAge\r\n	{\r\n		/**\r\n		 * Handle an incoming request.\r\n		 *\r\n		 * @param  \\Illuminate\\Http\\Request  $request\r\n		 * @param  \\Closure  $next\r\n		 * @return mixed\r\n		 */\r\n		public function handle($request, Closure $next)\r\n		{\r\n			if ($request->age <= 200) {\r\n				return redirect(\'home\');\r\n			}\r\n\r\n			return $next($request);\r\n		}\r\n	}\r\n	\r\n允许请求的进一步操作，只需将请求实例 `$request` 放入回调 `$next` 中即可。\r\n\r\n可以把中间件设想成，在最终到达想要执行的业务代码前的一层层「过滤网」，请求必须通过所有的中间件才能达到最终要执行的业务逻辑，否则被中间任何一个中间件拒绝，都会导致请求失败的。\r\n\r\n### 中间件处理时机\r\n	\r\n一个中间件在请求之前或者之后进行任务处理，取决于中间件的代码逻辑放置的位置。例如，下面的中间件在处理请求 **之前** 进行了一些任务操作：\r\n\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Middleware;\r\n\r\n	use Closure;\r\n\r\n	class BeforeMiddleware\r\n	{\r\n		public function handle($request, Closure $next)\r\n		{\r\n			// Perform action\r\n\r\n			return $next($request);\r\n		}\r\n	}\r\n\r\n而下面的中间件是在处理请求 **之后** 才进行任务操作：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Middleware;\r\n\r\n	use Closure;\r\n\r\n	class AfterMiddleware\r\n	{\r\n		public function handle($request, Closure $next)\r\n		{\r\n			$response = $next($request);\r\n\r\n			// Perform action\r\n\r\n			return $response;\r\n		}\r\n	}\r\n	\r\n## 注册中间件\r\n\r\n### 全局中间件\r\n\r\n如果一个中间件在每次的 HTTP 请求时都要用到，那么把它列入到 `app/Http/Kernel.php` 文件里的 `$middleware` 数组中即可。列入在 `$middleware` 数组中的中间件又称为全局中间件。\r\n\r\n### 为路由使用中间件\r\n\r\n使用在路由身上的中间件是在  `app/Http/Kernel.php` 的 `$routeMiddleware` 数组属性中定义的。如果你创建了一个新的给路由使用的中间件，就需要在它添加到 `$routeMiddleware` 这个数组里，并给这个中间件一个 key——相当于中间件的名字。\r\n\r\n	// Within App\\Http\\Kernel Class...\r\n\r\n	protected $routeMiddleware = [\r\n		\'auth\' => \\Illuminate\\Auth\\Middleware\\Authenticate::class,\r\n		\'auth.basic\' => \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,\r\n		\'bindings\' => \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n		\'can\' => \\Illuminate\\Auth\\Middleware\\Authorize::class,\r\n		\'guest\' => \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,\r\n		\'throttle\' => \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\r\n	];\r\n\r\n使用中间件时，就要用到了这个 key。\r\n\r\n	Route::get(\'admin/profile\', function () {\r\n		//\r\n	})->middleware(\'auth\');\r\n	\r\n也可以在一个路由上，同时使用多个中间件。\r\n\r\n	Route::get(\'/\', function () {\r\n		//\r\n	})->middleware(\'first\', \'second\');\r\n\r\n也可以使用中间件的包含命名空间的完整类名（又称完全限定类名）使用中间件：\r\n\r\n	use App\\Http\\Middleware\\CheckAge;\r\n\r\n	Route::get(\'admin/profile\', function () {\r\n		//\r\n	})->middleware(CheckAge::class);\r\n\r\n### 中间件组\r\n\r\n中间件组中包含多个中间件，但它的使用和中间件是完全一样的。中间件组在  `app/Http/Kernel.php` 的 `$middlewareGroups` 属性中定义，每个中间件组还有一个对应的 key。\r\n\r\nLaravel 项目中，预设并使用了两个中间件组：`web` 和 `api`，它们分别用在了 `routes/web.php` 和  `routes/api.php` 上，前者是定义 Web 接口路由的地方，后者是定义 API 接口路由的地方。这两种类型的接口，各自都有一些通用的中间件，然后放在了一个组里进行管理。\r\n\r\n	/**\r\n	 * The application\'s route middleware groups.\r\n	 *\r\n	 * @var array\r\n	 */\r\n	protected $middlewareGroups = [\r\n		\'web\' => [\r\n			\\App\\Http\\Middleware\\EncryptCookies::class,\r\n			\\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class,\r\n			\\Illuminate\\Session\\Middleware\\StartSession::class,\r\n			\\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,\r\n			\\App\\Http\\Middleware\\VerifyCsrfToken::class,\r\n			\\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\r\n		],\r\n\r\n		\'api\' => [\r\n			\'throttle:60,1\',\r\n			\'auth:api\',\r\n		],\r\n	];\r\n\r\n已经说过，中间件组的使用和中间件是完全一样的，不过带来一个好处——一次定义，即可使用多个中间件。中间件组可以分配给路由和控制器 action 使用。\r\n\r\n	Route::get(\'/\', function () {\r\n		//\r\n	})->middleware(\'web\');\r\n\r\n	Route::group([\'middleware\' => [\'web\']], function () {\r\n		//\r\n	});\r\n	\r\n注意，`routes/web.php` 文件里的中间件已经默认使用了 `web` 中间件组，这是在 `RouteServiceProvider` 中定义的，上面的是例子演示，在 `routes/web.php` 中定义路由时，是无需为路由额外分配 `web` 中间件组的。\r\n\r\n## 中间件参数\r\n\r\n可以为中间件传递参数。例如，如果系统有一个需求——需要在验证角色后才允许认证用户的进一步操作。以下面的 `CheckRole` 中间件为例，它接受一个角色名作为参数。\r\n\r\n中间件参数在 `handle` 方法的 `$next` 参数之后定义。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Middleware;\r\n\r\n	use Closure;\r\n\r\n	class CheckRole\r\n	{\r\n		/**\r\n		 * Handle the incoming request.\r\n		 *\r\n		 * @param  \\Illuminate\\Http\\Request  $request\r\n		 * @param  \\Closure  $next\r\n		 * @param  string  $role\r\n		 * @return mixed\r\n		 */\r\n		public function handle($request, Closure $next, $role)\r\n		{\r\n			if (! $request->user()->hasRole($role)) {\r\n				// Redirect...\r\n			}\r\n\r\n			return $next($request);\r\n		}\r\n\r\n	}\r\n\r\n使用中间件参数的方式是在中间件后面加上一个  `:`，然后在 `:` 后面跟上你要传递给中间件的参数。\r\n\r\n	Route::put(\'post/{id}\', function ($id) {\r\n		//\r\n	})->middleware(\'role:editor\');\r\n\r\n## 在 HTTP 响应之后……\r\n\r\n有时，中间件需要在 HTTP 响应发送到浏览器之后才做处理工作。例如，包含在 Laravel 中的会话中间件会在响应发送到浏览器后，再去保存会话数据。针对这样的需求，需要在中间件中定义一个 `terminate` 方法，它会在响应发送到浏览器之后自动被调用。\r\n\r\n	<?php\r\n\r\n	namespace Illuminate\\Session\\Middleware;\r\n\r\n	use Closure;\r\n\r\n	class StartSession\r\n	{\r\n		public function handle($request, Closure $next)\r\n		{\r\n			return $next($request);\r\n		}\r\n\r\n		public function terminate($request, $response)\r\n		{\r\n			// Store the session data...\r\n		}\r\n	}\r\n\r\n`terminate` 方法接受两个参数，请求实例和响应实例。定义好后，将这个中间件放在 `app/Http/Kernel.php` 添加在中间件列表中即可。\r\n\r\n在调用 `terminate` 方法时，Laravel 是从服务容器中找到并创建一个新的中间件实例使用的，如果你只要使用同一个中间件实例，那么就要使用容器的 `singleton` 方法注册中间件了。','2017-09-15 04:42:53','2017-09-17 01:10:47','laravel-document-reading-middleware'),(368,3,3,'Bootstrap 4：你好，世界！','```\r\n<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n<head>\r\n	<meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\r\n	<title>你好，世界！</title>\r\n	<link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\" integrity=\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\" crossorigin=\"anonymous\">\r\n</head>\r\n<body>\r\n	\r\n	<div class=\"container\">\r\n		<div class=\"row\">\r\n			<div class=\"col\">\r\n				<h1>你好，世界！</h1>\r\n				<p>一起用 Bootstrap 构建响应式、移动设备优先的网页吧！</p>\r\n			</div>\r\n			<div class=\"col\">\r\n				<h1>你好，世界！</h1>\r\n				<p>一起用 Bootstrap 构建响应式、移动设备优先的网页吧！</p>\r\n			</div>\r\n		</div>\r\n	</div>\r\n\r\n	<script src=\"https://code.jquery.com/jquery-3.2.1.slim.min.js\" integrity=\"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN\" crossorigin=\"anonymous\"></script>\r\n	<script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js\" integrity=\"sha384-b/U6ypiBEHpOf/4+1nzFpr53nxSS+GLCkfwBdFNTxtclqqenISfwAzpKaMNFNmj4\" crossorigin=\"anonymous\"></script>\r\n	<script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/js/bootstrap.min.js\" integrity=\"sha384-h0AbiXch4ZDo7tp9hKZ4TsHbi047NrKGLO3SEJAg45jXxnGIfYzk4Si90RDIqNm1\" crossorigin=\"anonymous\"></script>\r\n</body>\r\n</html>\r\n```','2017-09-15 08:10:04','2017-09-15 08:10:04','the-bootstrap-4-hello-world'),(369,3,3,'2017年9月16号','我突然想到了一千零一夜，那是古代阿拉伯，夜晚没有灯，大家围坐火炉讲故事。现代的一千零一夜不同，在城市的黑夜，有灯，几乎总能找到可以看书和休息的地方，当然，我现在在上海。当一个人精神压力不大时，身体上的压力可能效果就很明显了——肥胖。过劳死，久坐胖，前者都能看做工伤，何况后者。我们拼命估计工作和学习，另一方面又以补救、讨论工伤的方式反对它。在事情的看法态度上，几乎是没有不矛盾的，我发现。\r\n\r\n在跑步刚开始的路上，我突然发现周边音乐很嘈杂，变得一点都不可爱了。\r\n\r\n我发现晚上跑步一公里，就能看见不一样的生活方式和生活节奏，可见，我的生活范围太过狭隘了，可能我以前所说，都不算数呢。','2017-09-16 12:55:37','2017-09-16 12:55:37','on-september-16th-2017'),(370,3,3,'Laravel 文档阅读：CSRF 保护','> 翻译、衍生自：https://laravel.com/docs/5.5/csrf\r\n\r\n## 简介\r\n\r\n使用 Laravel 能够很简单的避免 [跨站请求伪造（CSRF）][1] 攻击。跨站请求伪造是一种恶意攻击，通过这种操作，认证用户可以执行未经授权的命令。\r\n\r\nLaravel 为每个用户回话自动生成 CSRF 令牌。此令牌用于验证认证用户就是实际向应用程序发出请求的用户。\r\n\r\n在应用程序中凡是使用 HTML 表单的地方，都应该包含一个名为 `_token` 的隐藏域，这个字段值就是 CSRF 令牌，随请求发往后台的时候，会经 CSRF 中间件验证。 咱可以使用 `csrf_field` 辅助函数生成这个隐藏域。\r\n\r\n	<form method=\"POST\" action=\"/profile\">\r\n	    {{ csrf_field() }}\r\n	    ...\r\n	</form>\r\n\r\n刚才提到的 CSRF 中间件，就是名为 `VerifyCsrfToken` 的中间件，位于 `app/Http/Middleware/VerifyCsrfToken.php`，它定义在 `web` 中间件组里，所以对所有的 Web 请求接口都生效。`VerifyCsrfToken` 会验证请求里的令牌和保存在回话里的令牌值是否一样。\r\n\r\n#### CSRF 令牌 & JavaScript\r\n\r\n在构建 JavaScript 驱动型的应用程序时，给你的 JavaScript HTTP 库附加 CSRF 令牌也很方便。默认，`resources/assets/js/bootstrap.js` 文件中为 Axios HTTP 库附加了 CSRF 令牌，令牌是从 HTML 的 `<meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">` 这个标签里取到的。\r\n\r\n	/**\r\n	 * We\'ll load the axios HTTP library which allows us to easily issue requests\r\n	 * to our Laravel back-end. This library automatically handles sending the\r\n	 * CSRF token as a header based on the value of the \"XSRF\" token cookie.\r\n	 */\r\n\r\n	window.axios = require(\'axios\');\r\n\r\n	window.axios.defaults.headers.common[\'X-Requested-With\'] = \'XMLHttpRequest\';\r\n\r\n	/**\r\n	 * Next we will register the CSRF Token as a common header with Axios so that\r\n	 * all outgoing HTTP requests automatically have it attached. This is just\r\n	 * a simple convenience so we don\'t have to attach every token manually.\r\n	 */\r\n\r\n	let token = document.head.querySelector(\'meta[name=\"csrf-token\"]\');\r\n\r\n	if (token) {\r\n	    window.axios.defaults.headers.common[\'X-CSRF-TOKEN\'] = token.content;\r\n	} else {\r\n	    console.error(\'CSRF token not found: https://laravel.com/docs/csrf#csrf-x-csrf-token\');\r\n	}\r\n\r\n如果你不是用 Axios 作为 HTTP 请求库的话（比如用 jQuery），那么就需要你手动配置了。\r\n\r\n## 从 CSRF 保护中排除一组 URIs\r\n\r\n应用程序中，并不是所有的请求都需要经过 CSRF 令牌验证。例如，当你使用 Stripe 处理支付流程并且使用了它们的 wekhook 系统的时候，你就需要把所有与 Stripe 相关的 URI 排除在 CSRF 保护队列之外，因为 Stripe 可不知道要给你的路由发送什么 CSRF 令牌值。\r\n\r\n遇到这种情况，你的路由要么不放在 `routes/web.php` 中（因为这个文件里的路由都附加了 `web` 中间件），当然这很麻烦，所以我们不这么做。怎么做呢？很简单，只要在 `VerifyCsrfToken` 中间件的 `$except` 属性里添加你要排除在 CSRF 保护之外的 URIs 就可以了。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Middleware;\r\n\r\n	use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as BaseVerifier;\r\n\r\n	class VerifyCsrfToken extends BaseVerifier\r\n	{\r\n	    /**\r\n	     * The URIs that should be excluded from CSRF verification.\r\n	     *\r\n	     * @var array\r\n	     */\r\n	    protected $except = [\r\n	        \'stripe/*\',\r\n	    ];\r\n	}\r\n\r\n## X-CSRF-TOKEN\r\n\r\n`VerifyCsrfToken` 中间件除了会检查以 POST 参数形式传递过来的 CSRF 令牌之外，也检查请求头的 `X-CSRF-TOKEN` 字段。我们可以把令牌放在 `meta` 标签里：\r\n\r\n	<meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\r\n\r\n这样一个 `meta` 标签创建好后，我们就可以向 jQuery 这一类库中附加 `X-CSRF-TOKEN` 标头字段，之后的每次 HTTP 请求里都会包含这个信息。\r\n\r\n	$.ajaxSetup({\r\n	    headers: {\r\n	        \'X-CSRF-TOKEN\': $(\'meta[name=\"csrf-token\"]\').attr(\'content\')\r\n	    }\r\n	});\r\n\r\n需要注意的是，在 `resources/assets/js/bootstrap.js` 这个文件中，默认为 Axios 这个 HTTP 请求库附加的 CSRF 令牌，也是从上面的 `meta` 标签里获取的。如果你不是用 Axios 作为 HTTP 请求库的话，就需要向上面设置 jQuery 那样手动配置了。\r\n\r\n## X-XSRF-TOKEN\r\n\r\nLaravel 还将应用程序里的 CSRF 令牌保存在了名为 `XSRF-TOKEN` 的 cookie 里，这个 cookie 在程序的每次相应中都会携带。你可以用这个 cookie 值设置 `X-XSRF-TOKEN` 请求头。\r\n\r\n这个 cookie 主要是为其他一些 JavaScript 框架和库提供便利，比如 Angular 和 Axios，它们会自动将这个名为 `XSRF-TOKEN` 的 cookie 值放在 `X-XSRF-TOKEN` 这个请求头里。\r\n \r\n[1]: https://en.wikipedia.org/wiki/Cross-site_request_forgery','2017-09-17 04:31:15','2017-09-17 04:31:15','laravel-document-reading-csrf-protection'),(371,3,3,'控制器方法和控制器 action？','我们先定义一个控制器 `UsersController`：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use App\\User;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class UsersController extends Controller\r\n	{\r\n			/**\r\n			 * Show the profile for the given user.\r\n			 *\r\n			 * @param  int  $id\r\n			 * @return Response\r\n			 */\r\n			public function show($id)\r\n			{\r\n					return view(\'users.show\', [\'user\' => User::findOrFail($id)]);\r\n			}\r\n	}\r\n\r\n然后，再定义指向这个控制器的路由：\r\n\r\n	Route::get(\'users/{id}\', \'UsersController@show\');\r\n	\r\n## 控制器方法\r\n\r\n在控制器中，`show` 是控制器方法，这是站在控制器角度的说法。\r\n\r\n## 控制器 action\r\n\r\n对于路由\r\n\r\n	Route::get(\'users/{id}\', \'UsersController@show\');\r\n	\r\n`show` 是一个 action，表示一个请求动作，是一个包含业务逻辑的请求动作，它在 `UsersController` 这个控制器中。所以控制器 action 是站在路由角度的说法。\r\n\r\n## 总结\r\n\r\n* 控制器方法，是站在控制器角度的说法。\r\n* 控制器 action，是站在路由角度的说法。\r\n\r\n在 Laravel 文档中，并没有严格区分控制器方法和控制器 action，有时还会混用，所以我们可以简单地认为：控制器方法就是指控制器 action，控制器 action 就是指控制器方法。','2017-09-17 05:36:51','2017-09-17 05:39:18','controller-method-and-controller-action'),(372,3,3,'Laravel 文档阅读：控制器','> 翻译、衍生自：https://laravel.com/docs/5.5/controllers\r\n\r\n我们的业务代码不能都写在路由文件（比如：`routes/web.php`）里。路由的形式有两种：基于闭包和基于控制器的。我们最好把一些相关的路由请求放在一个控制器内管理，对应的，业务代码也转移到了控制器里。Larave 的控制器位于 `app/Http/Controllers` 目录下。\r\n\r\n## 基础控制器\r\n\r\n### 定义控制器\r\n\r\n下面，就是一个基础控制器。这个控制器继承了 Laravel 提供的基类控制器。在基类控制器中提供了几个便捷的方法可以使用，比如 `middleware` 这个方法，就是用来给 [控制器 action][1] 附加中间件的。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use App\\User;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class UsersController extends Controller\r\n	{\r\n	    /**\r\n	     * Show the profile for the given user.\r\n	     *\r\n	     * @param  int  $id\r\n	     * @return Response\r\n	     */\r\n	    public function show($id)\r\n	    {\r\n	        return view(\'users.profile\', [\'user\' => User::findOrFail($id)]);\r\n	    }\r\n	}\r\n\r\n指向这个控制器 action 的路由是这样定义的：\r\n\r\n	Route::get(\'users/{id}\', \'UserController@show\');\r\n\r\n当浏览器发起 `users/xxx` 路径请求的时候，`UsersController` 的 `show` 方法就会被调用，路由参数也会传递给这个方法。\r\n\r\n需要注意的是， **我们的控制器不是非要继承基类控制器的**，只不过，如果不继承基类控制器的话，一些非常好用的方法，比如 `middleware`、`validate` 和 `dispatch` 就无法使用了。\r\n\r\n### 控制器 & 命名空间\r\n\r\n细心观察的话会发现，我们在定义控制器路由的时候，并没有使用控制器的完整命名空间。这是因为在 `RouteServiceProvider` 中，已经为 `routes/web.php` 和 `routes/api.php` 文件中的所有路由预设了 `App\\Http\\Controllers` 的命名空间前缀，所以我们在定义控制器路由时，只需指定 `App\\Http\\Controllers` 后面那部分的内容即可。\r\n\r\n如果 `App\\Http\\Controllers` 目录中的控制器有更深的嵌套层级，比如，我们有一个控制器的完整路径是 `App\\Http\\Controllers\\Photos\\AdminController`，那么在注册控制器路由的时候，就要像这样：\r\n\r\n	Route::get(\'foo\', \'Photos\\AdminController@method\');\r\n\r\n### 单 Action 控制器\r\n\r\n有时，一个控制器只有唯一的一个方法，那么这时只要在控制器中定义一个 `__invoke` 方法就行：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use App\\User;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class ShowProfile extends Controller\r\n	{\r\n	    /**\r\n	     * Show the profile for the given user.\r\n	     *\r\n	     * @param  int  $id\r\n	     * @return Response\r\n	     */\r\n	    public function __invoke($id)\r\n	    {\r\n	        return view(\'users.profile\', [\'user\' => User::findOrFail($id)]);\r\n	    }\r\n	}\r\n\r\n指向这个单 Action 控制器的路由，定义起来就变成下面这样了：\r\n\r\n	Route::get(\'users/{id}\', \'ShowProfile\');\r\n\r\n## 控制器中间件\r\n\r\n在我们的路由文件里，可以为控制器路由指定中间件：\r\n\r\n	Route::get(\'profile\', \'UsersController@show\')->middleware(\'auth\');\r\n\r\n但是，在控制器构造方法里指定中间件更加方便，直接使用 `middleware` 方法，就可以轻松地为我们的控制器 action 分配中间件了：\r\n\r\n	class UsersController extends Controller\r\n	{\r\n	    /**\r\n	     * Instantiate a new controller instance.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function __construct()\r\n	    {\r\n	        $this->middleware(\'auth\');\r\n\r\n	        $this->middleware(\'log\')->only(\'index\');\r\n\r\n	        $this->middleware(\'subscribed\')->except(\'store\');\r\n	    }\r\n	}\r\n\r\n在控制器中也可以使用闭包来注册一个中间件。这为只在一个控制器中使用的中间件带来便利，无需定义一个中间件类了：\r\n\r\n	$this->middleware(function ($request, $next) {\r\n		// ...\r\n\r\n		return $next($request);\r\n	});\r\n\r\n\r\n我们有时会对控制器的一个 action 子集做中间件处理。但这可能说明你的控制器是臃肿的，尝试去把这个控制器拆分成多个、职能更加单一的控制器吧。 \r\n\r\n## 资源控制器\r\n\r\n资源控制器就是指包含 `index`、`create`、`store`、`show`、`edit`、`update` 和 `destroy` 这 7 个方法的控制器。之所以称为「资源控制器」，是因为这 7 个方法包括了操作某个资源所需的全部基本操作，也就是 CRUD 操作。\r\n\r\n在 Laravel 中，在使用 Artisan 命令 `make:controller` 时，通过传递一个额外选项 `--resource` 就可以快速创建这样一个资源控制器，我们以操作图片资源的 `PhotosController` 为例：\r\n\r\n	php artisan make:controller PhotosController --resource\r\n\r\n这样就在 `app/Http/Controllers/PhotosController.php` 的地方创建了一个控制器，接下来在为资源控制器注册资源路由。\r\n\r\n	Route::resource(\'photos\', \'PhotosController\');\r\n\r\n通过这一句代码，我们就定义了 7 个指向到 `PhotosController` 中相应方法的所有路由。我们来看一下：\r\n\r\n对应到资源控制器相应方法的 7 个资源路由。\r\n\r\n| 请求类型 | URI | 控制器 Action | 路由别名 |\r\n| -------- | -------- | -------- | -------- |\r\n| GET       | /photos              | index   | photos.index |\r\n| GET       | /photos/create       | create  | photos.create |\r\n| POST      | /photos              | store   | photos.store |\r\n| GET       | /photos/{photo}      | show    | photos.show |\r\n| GET       | /photos/{photo}/edit | edit    | photos.edit |\r\n| PUT/PATCH | /photos/{photo}      | update  | photos.update |\r\n| DELETE    | /photos/{photo}      | destroy | photos.destroy |\r\n\r\n#### 指定资源模型\r\n\r\n在生成资源控制器的时候，还可以通过指定 `-model` 选项，为控制器中的方法指定模型类型。\r\n\r\n	php artisan make:controller --resource --model=Photo\r\n\r\n#### 表单方法伪造\r\n\r\n由于 HTML 表单不能发出 `PUT`、`PATCH` 和 `DELETE` 类型的请求，所以想要使用这些请求类型的话，就必须得伪造。Laravel 中使用隐藏表单域 `_method` 来告诉应用程序我们的请求类型。我们可以通过 `method_field` 辅助函数来生成这个表单域：\r\n\r\n	{{ method_field(\'PUT\') }}\r\n\r\n或者手动添加：\r\n\r\n	<input name=\"_method\" type=\"hidden\" value=\"PUT\">\r\n\r\n都是一样的。\r\n\r\n### 部分资源路由\r\n\r\n我们在使用 `Route::resource` 定义资源路由的时候，并不想生成全部 7 个路由，比如只需要定义其中的 2 个或者 4 个路由，`Route::resource` 同样可以满足这样的需求，这时需要为它指定第三个参数：\r\n\r\n	Route::resource(\'photos\', \'PhotosController\', [\'only\' => [\r\n	    \'index\', \'show\'\r\n	]]);\r\n\r\n	Route::resource(\'photos\', \'PhotosController\', [\'except\' => [\r\n	    \'create\', \'store\', \'update\', \'destroy\'\r\n	]]);\r\n\r\n### 命名资源路由\r\n\r\n默认，所有的资源路由都有一个名字，当然你也可以按情况覆盖掉相应方法。这是需要用到 `names` 这个数组选项：\r\n\r\n	Route::resource(\'photos\', \'PhotosController\', [\'names\' => [\r\n	    \'create\' => \'photos.build\'\r\n	]]);\r\n\r\n### 命名资源路由参数\r\n\r\n默认，所有的资源路由的路由参数是使用资源名的「单数」形式（如果资源名本身是单数形式，那么路由参数直接使用单数形式）。\r\n\r\n	Route::resource(\'users\', \'AdminUserController\');\r\n\r\n	// 生成的 `show` 路由\r\n	/users/{user}\r\n\r\n\r\n	Route::resource(\'user\', \'AdminUserController\');\r\n	// 生成的 `show` 路由\r\n	/user/{user}\r\n\r\n当然，你也可以覆盖这个约定。这时要用到 `parameters` 这个数组选项：\r\n\r\n	Route::resource(\'users\', \'AdminUserController\', [\'parameters\' => [\r\n	    \'users\' => \'admin_user\'\r\n	]]);\r\n\r\n	// 生成的 `show` 路由\r\n	/users/{admin_user}\r\n\r\n### 本地化资源 URIs\r\n\r\n默认，`Route::resource` 生成的路由地址中包含 `create` 和 `edit` 这两个英语动词。如果需要本地化这两个动词，需要使用 `Route::resourceVerbs` 方法，这个方法可以在 `AppServiceProvider` 的 `boot` 方法里设定：\r\n\r\n	use Illuminate\\Support\\Facades\\Route;\r\n\r\n	/**\r\n	 * Bootstrap any application services.\r\n	 *\r\n	 * @return void\r\n	 */\r\n	public function boot()\r\n	{\r\n	    Route::resourceVerbs([\r\n	        \'create\' => \'crear\',\r\n	        \'edit\' => \'editar\',\r\n	    ]);\r\n	}\r\n\r\n定义好后，使用 `Route::resource(\'fotos\', \'PhotoController\')` 生成的资源路由会产生下面两个的 URIs：\r\n\r\n	/fotos/crear\r\n\r\n	/fotos/{foto}/editar\r\n\r\n*fotos、crear 和 editar 是西班牙语里的照片、创建和编辑。*\r\n\r\n### 补充资源控制器\r\n\r\n如果你还要定义除了默认 7 个资源路由之外的其他路由，那么你应该在调用 `Route::resource` 之前定义这些路由，否则通过 `resource` 方法定义的路由可能会意外覆盖你额外添加的路由：\r\n\r\n	Route::get(\'photos/popular\', \'PhotoController@method\');\r\n\r\n	Route::resource(\'photos\', \'PhotoController\');\r\n\r\n记住，要保证你的控制器职能单一，如果发现除了一些在资源控制器中普遍存在的方法之外，还需要定义一些其他的方法，那么请考虑将控制器拆分成两个或者多个更小的控制器。\r\n\r\n## 依赖注入 & 控制器\r\n\r\n#### 通过构造方法注入\r\n\r\nLaravel 中的控制器都是使用服务容器解析的。所以，你可以在控制器的构造方法里使用依赖注入。声明的依赖会自动注入到控制器实例中：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use App\\Repositories\\UserRepository;\r\n\r\n	class UsersController extends Controller\r\n	{\r\n	    /**\r\n	     * The user repository instance.\r\n	     */\r\n	    protected $users;\r\n\r\n	    /**\r\n	     * Create a new controller instance.\r\n	     *\r\n	     * @param  UserRepository  $users\r\n	     * @return void\r\n	     */\r\n	    public function __construct(UserRepository $users)\r\n	    {\r\n	        $this->users = $users;\r\n	    }\r\n	}\r\n\r\nLaravel 契约类也支持依赖注入。 有时，注入这些依赖可能会让应用程序有更好可测试性。\r\n\r\n#### 方法注入\r\n\r\n除了在构造方法里注入，还可以在控制器方法里注入。一个常见的使用方式是将 `Illuminate\\Http\\Request` 实例注入到控制器方法里：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Http\\Request;\r\n\r\n	class UsersController extends Controller\r\n	{\r\n	    /**\r\n	     * Store a new user.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @return Response\r\n	     */\r\n	    public function store(Request $request)\r\n	    {\r\n	        $name = $request->name;\r\n\r\n	        //\r\n	    }\r\n	}\r\n\r\n如果路由包含参数，那么这些参数要列在这些依赖项之后。例如，如果路由是这样的：\r\n\r\n	Route::put(\'users/{id}\', \'UsersController@update\');\r\n\r\n在控制器方法里，就要在 `Illuminate\\Http\\Request` 依赖声明之后，获取咱们的用户 ID：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Http\\Request;\r\n\r\n	class UsersController extends Controller\r\n	{\r\n	    /**\r\n	     * Update the given user.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @param  string  $id\r\n	     * @return Response\r\n	     */\r\n	    public function update(Request $request, $id)\r\n	    {\r\n	        //\r\n	    }\r\n	}\r\n\r\n## 路由缓存\r\n\r\n先声明！使用闭包形式定义的路由时无法缓存的。要想用缓存，必须将闭包路由转换为控制器路由。\r\n\r\n如果应用程序中，全部使用的是基于控制器方法的路由，那么这时候就可以充分利用 Laravel 路由缓存的功能了！使用路由缓存可以大大地减少应用程序中注册所有路由花费的时间。有些情况，注册路由的过程可能会提升 100 倍！生成路由缓存，执行 Artisan 命令 `route:cache` 即可：\r\n\r\n	php artisan route:cache\r\n\r\n执行这条命令后，路由缓存文件会在每次请求时被加载。需要注意的是，应用程序中每当添加了一个新的路由，都需要重新执行 `route:cache` 命令方可生效。因此，**你应该只在项目部署时才执行 `route:cache` 命令**。\r\n\r\n清除路由缓存使用 `route:clear` 就 OK 了！\r\n\r\n	php artisan route:clear\r\n\r\n[1]: https://laravel-china.org/articles/6102/controller-method-and-controller-action','2017-09-18 02:03:36','2017-09-18 06:42:46','laravel-document-reading-controller'),(373,3,3,'YDNJS（上卷）：关于 this','`this` 关键字在 JavaScript 中是一个很特别的关键字，被自动定义在所有函数的作用域中。我们觉得它难，是想复杂了。\r\n\r\n### 为什么要用 `this`？\r\n\r\n在明白怎样用 `this` 前，先看为什么要用 `this`。\r\n\r\n来看一段代码：\r\n\r\n	function identify(context) {\r\n		return context.name.toUpperCase()\r\n	}\r\n\r\n	var me = {\r\n		name: \'Kyle\'\r\n	}\r\n\r\n	var you = {\r\n		name: \'Reader\'\r\n	}\r\n\r\n	identify(me) // \"KYLE\"\r\n	identify(you) // \"READER\"\r\n\r\n如果使用 `this` 的话，代码可以精简为：\r\n\r\n	function identify() {\r\n		return this.name.toUpperCase()\r\n	}\r\n\r\n	identify.call(me) // \"KYLE\"\r\n	identify.call(you) // \"READER\"\r\n\r\n是的，与其给方法显式传递上下文对象（context），不如在方法内用 `this` 隐式接收上下文对象。这能将 API 设计得更加简洁和易于复用。\r\n\r\n当你的应用程序越来越复杂，大量使用对象和原型时，就知道 `this` 是多么的重要。\r\n\r\n### 误解\r\n\r\n我们对 `this` 有两种常见的错误认识。\r\n\r\n#### 指向函数自身？\r\n\r\n看下面一段代码：\r\n\r\n	function foo() {\r\n		this.count++\r\n	}\r\n\r\n	foo.count = 0;\r\n\r\n	foo()\r\n\r\n	foo.count // 0\r\n\r\n如果 `this` 指向函数自身，那么 `foo.count` 的值应该是 1，但还是 0。所以，**`this` 并不指向函数自身**。\r\n\r\n想指向函数自身，可以使用函数名，函数名就是一个指向函数对象的引用。\r\n\r\n	function foo() {\r\n		foo.count++\r\n	}\r\n\r\n或者强制 `this` 指向 `foo` 函数对象。\r\n\r\n	foo.call(foo)\r\n\r\n#### 指向函数作用域？\r\n\r\n这并不一定。只有当 `this` 被强制指向函数对象的时候，是这样。看段代码：\r\n\r\n	function foo() {\r\n		var a = 2\r\n		this.bar()\r\n	}\r\n\r\n	function bar() {\r\n		console.log(this.a)\r\n	}\r\n\r\n	foo() // undefined\r\n\r\n上面代码里的 `this` 指向的都是 `window` 对象。\r\n\r\n### `this` 到底是什么\r\n\r\n`this` 是函数运行时动态绑定的，只取决于函数的调用方式——在哪里调用的函数？\r\n\r\n函数被调用时，会创建一个活动记录（或称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。`this` 是这个记录的一个属性，能在函数执行的过程中获得并使用。\r\n\r\n### 总结\r\n\r\n`this` 并不指向函数自身，又不指向函数作用域（或词法作用域）。`this` 是函数运行时动态绑定的，只取决于函数在哪里被调用。','2017-09-18 06:36:45','2017-09-18 06:36:45','ydnjs-coil-about-this'),(374,3,3,'Laravel 文档阅读： HTTP 请求','> 翻译、衍生自：https://laravel.com/docs/5.5/requests\r\n\r\n## 获得请求实例\r\n\r\n在控制器方法里，可以通过依赖注入的方式自动获得咱们的请求实例，也就是 `Illuminate\\Http\\Request` 类实例，这是用服务容器注入的。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Http\\Request;\r\n\r\n	class UsersController extends Controller\r\n	{\r\n	    /**\r\n	     * Store a new user.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @return Response\r\n	     */\r\n	    public function store(Request $request)\r\n	    {\r\n	        $name = $request->input(\'name\');\r\n\r\n	        //\r\n	    }\r\n	}\r\n\r\n#### 依赖注入 & 路由参数\r\n\r\n如果控制器方法还要接收路由参数，你应该把接收路由参数的参数位置放在所有依赖注入参数之后。比如，有这么一个路由：\r\n\r\n	Route::put(\'users/{id}\', \'UsersController@update\');\r\n\r\n在控制器方法里，你还要依赖注入请求实例，还要呢，接收路由参数 `id`。那你就要这么做：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Http\\Request;\r\n\r\n	class UsersController extends Controller\r\n	{\r\n	    /**\r\n	     * Update the specified user.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @param  string  $id\r\n	     * @return Response\r\n	     */\r\n	    public function update(Request $request, $id)\r\n	    {\r\n	        //\r\n	    }\r\n	}\r\n\r\n#### 在路由的闭包里获得请求实例\r\n\r\n在基于闭包的路由中，可以依赖注入请求实例：\r\n\r\n	use Illuminate\\Http\\Request;\r\n\r\n	Route::get(\'/\', function (Request $request) {\r\n	    //\r\n	});\r\n\r\n### 请求路径 & 请求方法\r\n\r\n`Illuminate\\Http\\Request` 实例对象提供了许多丰富的、检查应用程序中的 HTTP 请求信息的方法，并且 `Illuminate\\Http\\Request` 类自身继承了 `Symfony\\Component\\HttpFoundation\\Request`。在这里，我们仅讨论几个重要的方法。\r\n\r\n#### 获得请求路径\r\n\r\n`path` 方法返回请求路径信息。如果请求路径是 `http://domain.com/foo/bar`，那么用 `path` 方法得到的值是 `foo/bar`：\r\n\r\n	$uri = $request->path();\r\n\r\n`path` 方法验证当前的请求路径是否匹配给定的模式。你还可以使用通配符 `*`：\r\n\r\n	if ($request->is(\'admin/*\')) {\r\n	    //\r\n	}\r\n\r\n#### 获得请求 URL\r\n\r\n获得请求的完整路径请使用 `url` 和 `fullUrl` 方法。`url` 方法会返回不包含请求字符串的 URL，而 `fullUrl` 方法会返回包含请求字符串的 URL。\r\n\r\n	// Without Query String...\r\n	$url = $request->url();\r\n\r\n	// With Query String...\r\n	$url = $request->fullUrl();\r\n\r\n#### 获得请求方法\r\n\r\n`method` 方法返回 HTTP 请求动词。而 `isMethod` 方法可以判断为指定的 HTTP 请求动词。\r\n\r\n	$method = $request->method();\r\n\r\n	if ($request->isMethod(\'post\')) {\r\n	    //\r\n	}\r\n\r\n### PSR-7 请求\r\n\r\n[PSR-7 标准][1] 也规定了一套关于 HTTP 请求和响应消息的接口。如果你要在应用程序使用 PSR-7 请求对象，而不是 Laravel 请求对象，那么要先安装两个依赖包。Laravel 使用 Symfony HTTP Message Bridge 组件将 Laravel 请求和响应对象转换为兼容 PSR-7 标准的实现。\r\n\r\n	composer require symfony/psr-http-message-bridge\r\n	composer require zendframework/zend-diactoros\r\n\r\n依赖包安装完毕后，就可以在路由闭包或者控制器方法里依赖注入 PSR-7 请求实例对象了：\r\n\r\n	use Psr\\Http\\Message\\ServerRequestInterface;\r\n\r\n	Route::get(\'/\', function (ServerRequestInterface $request) {\r\n	    //\r\n	});\r\n\r\n需要注意的是，如果你从路由或者控制器里返回一个 PSR-7 响应实例，它会被自动转换为 Laravel 响应实例，便于框架处理。\r\n\r\n## `TrimStrings` 和 `ConvertEmptyStringsToNull` 中间件\r\n\r\n在 `App\\Http\\Kernel` 类的 `$middleware` 属性里，包含两个中间件，`TrimStrings` 和 `ConvertEmptyStringsToNull`，它们会在应用程序的每次请求中使用。`TrimStrings` 中间件用来修剪字符串（比如去掉字符串两端的空格）；`ConvertEmptyStringsToNull` 中间件将空字符串转换为 `null`，这就省去了我们一些琐碎的工作，得到规范化的字符串了。\r\n\r\n如果要禁用这两个中间件，只要从 `$middleware` 属性中移除掉就可以了。\r\n\r\n## 获得输入数据\r\n\r\n获得输入数据的过程，就是操作 `Illuminate\\Http\\Request` 实例方法的过程。\r\n\r\n#### 获得所有的输入数据\r\n\r\n使用 `all` 方法。该方法会得到一个数组，数组里就是输入数据。\r\n\r\n	$input = $request->all();\r\n\r\n#### 获得一条输入数据值\r\n\r\n使用 `input` 方法，不论 HTTP 的请求类型如何，`input` 方法都能获得请求里的数据。\r\n\r\n	$name = $request->input(\'name\');\r\n\r\n还可以为 `input` 方法传递第二个参数，作为字段缺省值。当请求字段不在输入数据中，就会使用这个值。\r\n\r\n	$name = $request->input(\'name\', \'Sally\');\r\n\r\n当操作数组形式的输入数据时，使用点（`.`）符号：\r\n\r\n	$name = $request->input(\'products.0.name\');\r\n\r\n	$names = $request->input(\'products.*.name\');\r\n\r\n#### 获得查询字符串\r\n\r\n`input` 方法是从整个请求中搜罗输入数据的，包括表单数据、查询字符串和路由参数等。但如果只是要从查询字符串获得输入数据的话，就使用 `query` 方法：\r\n\r\n	$name = $request->query(\'name\');\r\n\r\n同样，如果查询字段没有出现在查询字符串中，还可以为它指定缺省值：\r\n\r\n	$name = $request->query(\'name\', \'Helen\');\r\n\r\n直接使用 `query()` 方法得到是一个包含所有查询字符串数据的关联数组：\r\n\r\n	$query = $request->query();\r\n\r\n#### 通过动态属性获得数据数据\r\n\r\n可以在 `Illuminate\\Http\\Request` 实例上直接使用动态属获得输入数据。例如，如果传递过来的表单数据里包含一个 `name` 字段，可以这样获得它的值：\r\n\r\n	$name = $request->name;\r\n\r\n使用动态属性时，Laravel 会从请求中尽可能得搜罗输入数据值，如果没找到，再去找路由参数。\r\n\r\n#### 获得 JSON 格式中的数据值\r\n\r\n当项目接收的是 JSON 请求，也就是请求的 `Content-Type` 标头值为 `application/json` 的时候，使用点（`.`）符号获得 JSON 字段值：\r\n\r\n	$name = $request->input(\'user.name\');\r\n\r\n#### 获得局部输入数据\r\n\r\n有时只需要获得输入数据的一个子集，这时要用到 `only` 和 `except` 方法。这两个方法接收一个数组或者参数列表：\r\n\r\n	$input = $request->only([\'username\', \'password\']);\r\n\r\n	$input = $request->only(\'username\', \'password\');\r\n\r\n	$input = $request->except([\'credit_card\']);\r\n\r\n	$input = $request->except(\'credit_card\');\r\n\r\n需要注意的是，`only` 方法中列举的字段如果没有出现在请求字段里，那么最终返回的结果中将不会包含这个字段数据。\r\n\r\n#### 判断输入数据是否存在\r\n\r\n使用 `has` 方法，该方法返回一个布尔值。如果请求数据里包含此字段，就会返回 `true`，否则返回 `false`：\r\n\r\n	if ($request->has(\'name\')) {\r\n	    //\r\n	}\r\n\r\n`has` 方法还可以接收一个数组，返回的结果值表示是否数组里的所有字段都出现在了输入数据中：\r\n\r\n	if ($request->has([\'name\', \'email\'])) {\r\n	    //\r\n	}\r\n\r\n如果要 **判断出现在输入数据中的字段值是否为空，使用 `filled` 方法**：\r\n\r\n	if ($request->filled(\'name\')) {\r\n	    //\r\n	}\r\n\r\n### 旧输入数据\r\n\r\nLaravel 能够将本次请求的数据保留到下一次，这个特性能实现表单验证失败后，再次返回表单填写页的时候，旧输入数据仍然填充在表单里。如果使用了 Laravel 的本身的验证特性，更是不需要你手动使用下面要说的这些方法了，因为内置的验证功能会自动调用这些方法。\r\n\r\n#### 闪存数据到 Session\r\n\r\n`Illuminate\\Http\\Request` 类的 `flash` 方法会将当前输入数据闪存到 Session 中，使得在下一次的请求中还能获得这些数据。\r\n\r\n	$request->flash();\r\n\r\n或者使用 `flashOnly`/`flashExcept` 方法闪存一部分数据到 Session。这两个方法能让一些诸如密码的敏感信息不保存在 Session 中。\r\n\r\n	$request->flashOnly([\'username\', \'email\']);\r\n\r\n	$request->flashExcept(\'password\');\r\n\r\n#### 闪存数据后重定向\r\n\r\n通常我们会在闪存完数据后，重定向到之前的页面。可以在 `redirect` 方法屁股后头跟上 `withInput` 方法实现这个功能：\r\n\r\n	return redirect(\'form\')->withInput();\r\n\r\n	return redirect(\'form\')->withInput(\r\n	    $request->except(\'password\')\r\n	);\r\n\r\n#### 获得旧数据\r\n\r\n获得之前的请求闪存到 Session 里的数据，使用 `Request` 实例的 `old` 方法。`old` 方法会拉出闪存到 Session 中的对应数据：\r\n\r\n	$username = $request->old(\'username\');\r\n\r\nLaravel 还提供了一个全局的 `old` 辅助函数。在 Blade 模板里面使用这个方法显示数据会更加方便。如果 Session 中闪存的数据里不包含该条，就直接返回 `null`：\r\n\r\n	<input type=\"text\" name=\"username\" value=\"{{ old(\'username\') }}\">\r\n\r\n### Cookies\r\n\r\n#### 从请求中获得 Cookie\r\n\r\nLaravel 中生成的 Cookie 都会经过加密，并且使用认证码进行签名，所以客户端上的 Cookie 修改都被视为无效。获得请求里的 Cookie 值，使用 `Illuminate\\Http\\Request` 实例的 `cookie` 方法：\r\n\r\n	$value = $request->cookie(\'name\'); \r\n\r\n#### 为响应附加 Cookie\r\n\r\n`Illuminate\\Http\\Response` 实例中也有一个 `cookie` 方法，让你可以为响应附加 Cookie，这个方法接收的 3 个参数分别是名称、值和有效时间。\r\n\r\n	return response(\'Hello World\')->cookie(\r\n	    \'name\', \'value\', $minutes\r\n	);\r\n\r\n`cookie` 方法还可以接受更多的参数，列举如下：\r\n\r\n	return response(\'Hello World\')->cookie(\r\n	    \'name\', \'value\', $minutes, $path, $domain, $secure, $httpOnly\r\n	);\r\n\r\n通常，这些参数与 PHP 原生 `setcookie` 方法的参数具有相同的目的和意义。\r\n\r\n#### 生成 Cookie 实例\r\n\r\n你也可以选择先生成一个 `Symfony\\Component\\HttpFoundation\\Cookie`实例，在稍晚些将此 Cookie 实例附加到响应上。生成 Cookie 实例使用全局 `cookie` 辅助函数。只有当 Cookie 实例附加到响应实例上后，才会被发送回客户端：\r\n\r\n	$cookie = cookie(\'name\', \'value\', $minutes);\r\n\r\n	return response(\'Hello World\')->cookie($cookie);\r\n\r\n## 文件\r\n\r\n### 获得上传文件\r\n\r\n使用 `Illuminate\\Http\\Request`实例的 `file` 方法或者动态属性获得上传文件。`file` 方法返回 `Illuminate\\Http\\UploadedFile` 实例，`UploadedFile` 这个类继承了 PHP 的 `SplFileInfo` 类，提供了丰富地操作文件的方法。\r\n\r\n	$file = $request->file(\'photo\');\r\n\r\n	$file = $request->photo;\r\n\r\n还可以使用 `hasFile` 方法判断请求里是否包含指定的上传文件：\r\n\r\n	if ($request->hasFile(\'photo\')) {\r\n	    //\r\n	}\r\n\r\n#### 上传文件是否有效\r\n\r\n上传文件获得后，还可以使用 `isValid` 方法检查文件是否没有问题、是有效的：\r\n\r\n	if ($request->file(\'photo\')->isValid()) {\r\n	    //\r\n	}\r\n\r\n#### 上传文件路径 & 扩展名\r\n\r\n`UploadedFile` 类还包括查询文件完整路径和扩展名的方法。`extension` 方法会基于文件内容猜测文件扩展名，得到的这个文件扩展名或许与在客户端提供的扩展名不一样：\r\n\r\n	$path = $request->photo->path();\r\n\r\n	$extension = $request->photo->extension();\r\n\r\n#### 其他文件方法\r\n\r\n在 `UploadedFile` 实例上还有大量其他可以使用的方法。查阅 [API 文档][2] 获得更多信息。\r\n\r\n### 保存上传文件\r\n\r\n保存上传文件，需要先配置 `config/filesystems.php` 文件。`UploadedFile` 类有一个 `store` 方法用来移动上传文件到你的一个「硬盘」里，可能是本地文件系统，也可能是像 Amazon S3 这样的远程云存储服务。 \r\n\r\n`store` 方法接收的路径是相对路径，是相对于文件系统根目录的。该路径不应该包含文件名，因为会自动生成一个唯一 ID 作为文件名。\r\n\r\n`store` 方法接收的第二个可选参数是保存文件使用的硬盘。`store` 方法返回的是相对于硬盘根目录的路径：\r\n\r\n	$path = $request->photo->store(\'images\');\r\n\r\n	$path = $request->photo->store(\'images\', \'s3\');\r\n\r\n如果不使用自动生成的文件名，而是使用自己指定的文件名（包含扩展名），那么就要用 `storeAs` 方法，它接收路径、文件名和硬盘名作为参数：\r\n\r\n	$path = $request->photo->storeAs(\'images\', \'filename.jpg\');\r\n\r\n	$path = $request->photo->storeAs(\'images\', \'filename.jpg\', \'s3\');\r\n\r\n## 配置可信代理\r\n\r\n当你的应用程序运行在终止 TLS / SSL 证书的负载平衡器后面，你可能会看到你的应用程序有时候不生成 HTTPS 链接。通常这是因为您的应用程序正在 80 端口上从你的负载平衡器上转发流量，而且不知道应该生成安全链接。\r\n\r\n为了解决这个问题，需要在你的应用程序中使用 `App\\Http\\Middleware\\TrustProxies` 中间件。这个中间件允许你快速自定义受应用程序信任的负载平衡器或者代理。你的信任代理应该列举在该中间件的 `$proxies` 属性内。除了配置可信代理之外，您还可以配置代理发送的标头，其中包含有关原始请求的信息：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Middleware;\r\n\r\n	use Illuminate\\Http\\Request;\r\n	use Fideloper\\Proxy\\TrustProxies as Middleware;\r\n\r\n	class TrustProxies extends Middleware\r\n	{\r\n	    /**\r\n	     * The trusted proxies for this application.\r\n	     *\r\n	     * @var array\r\n	     */\r\n	    protected $proxies = [\r\n	        \'192.168.1.1\',\r\n	        \'192.168.1.2\',\r\n	    ];\r\n\r\n	    /**\r\n	     * The current proxy header mappings.\r\n	     *\r\n	     * @var array\r\n	     */\r\n	    protected $headers = [\r\n	        Request::HEADER_FORWARDED => \'FORWARDED\',\r\n	        Request::HEADER_X_FORWARDED_FOR => \'X_FORWARDED_FOR\',\r\n	        Request::HEADER_X_FORWARDED_HOST => \'X_FORWARDED_HOST\',\r\n	        Request::HEADER_X_FORWARDED_PORT => \'X_FORWARDED_PORT\',\r\n	        Request::HEADER_X_FORWARDED_PROTO => \'X_FORWARDED_PROTO\',\r\n	    ];\r\n	}\r\n\r\n#### 信任所有代理\r\n\r\n如果你正在使用 Amazon AWS 或其他「云」负载平衡器提供商，可能不知道实际平衡器的 IP 地址。 在这种情况下，您可以使用 `**` 来信任所有代理：\r\n\r\n	/**\r\n	 * The trusted proxies for this application.\r\n	 *\r\n	 * @var array\r\n	 */\r\n	protected $proxies = \'**\';\r\n\r\n[1]: http://www.php-fig.org/psr/psr-7/\r\n[2]: http://api.symfony.com/3.0/Symfony/Component/HttpFoundation/File/UploadedFile.html','2017-09-19 02:40:14','2017-09-19 02:55:48','laravel-document-reading-http-requests'),(375,3,3,'Laravel 文档阅读：HTTP 响应','> 翻译、衍生自：https://laravel.com/docs/5.5/responses\r\n\r\n## 创建响应\r\n\r\n#### 字符串 & 数组\r\n\r\n用户的每个请求无一例外得都要给予一个响应。Laravel 提供了几种不同的响应方式。最简单的响应是从路由或控制器中返回一个字符串。Laravel 会将这个字符串自动转换为完整的 HTTP 响应。\r\n\r\n	Route::get(\'/\', function () {\r\n		return \'Hello World\';\r\n	});\r\n\r\n除了返回字符串，还可以返回一个数组。Laravel 会将这个数组自动转换为 JSON 响应。\r\n\r\n	Route::get(\'/\', function () {\r\n		return [1, 2, 3];\r\n	});\r\n\r\n小提示：从路由或控制器中返回的 Eloquent 集合也会被自动转换为 JSON 响应哦~\r\n\r\n#### 响应对象\r\n\r\n我们一般不会只返回一个字符串或者数组。相反，我们经常返回完整的 `Illuminate\\Http\\Response` 实例或者视图。\r\n\r\n返回一个 `Response` 实例的话，允许我们自定义 HTTP 响应码和标头。`Response` 实例继承了 `Symfony\\Component\\HttpFoundation\\Response` 类，提供了大量构建 HTTP 响应的方法：\r\n\r\n	Route::get(\'home\', function () {\r\n		return response(\'hello world\', 200)\r\n				->header(\'Content-Type\', \'text/plain\');\r\n	});\r\n\r\n#### 为响应附加标头\r\n\r\n记住，`Response` 实例的大多数方法都是可以链式调用的。例如，你可以连续使用几次 `header` 方法，在最终响应给浏览器之前，指定一系列的标头信息。\r\n\r\n	return response($content)\r\n			->header(\'Content-Type\', $type)\r\n			->header(\'X-Header-One\', \'Header Value\')\r\n			->header(\'X-Header-Two\', \'Header Value\');\r\n\r\n或者使用 `withHeaders` 方法指定一个数组参数，一次性指定所有标头信息。\r\n\r\n	return response($content)\r\n			->withHeaders([\r\n				\'Content-Type\' => $type,\r\n				\'X-Header-One\' => \'Header Value\',\r\n				\'X-Header-Two\' => \'Header Value\',\r\n			]);\r\n\r\n#### 为响应附加 Cookie\r\n\r\n使用 `cookie` 方法为响应附加 Cookie，向下面这样：\r\n\r\n	return response($content)\r\n			->header(\'Content-Type\', $type)\r\n			->cookie(\'name\', \'value\', $minutes);\r\n\r\n`cookie` 方法还接收一些参数，不过不常用。如果要使用，只要记住，`cookie` 方法的签名和原生 PHP 方法 `setcookie` 是一样的：\r\n\r\n	->cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly)\r\n\r\n#### Cookie & 加密\r\n\r\n默认，Laravel 生成的所有 Cookie 都会经过加密和签名处理，不能被客户端修改和读取。如果需要列出一个「白名单」，不用对名单里的 Cookie 加密的话，就要用到 `App\\Http\\Middleware\\EncryptCookies` 中间件的 `$except` 属性，位于 `app/Http/Middleware` 目录下：\r\n\r\n	/**\r\n	 * The names of the cookies that should not be encrypted.\r\n	 *\r\n	 * @var array\r\n	 */\r\n	protected $except = [\r\n	    \'cookie_name\',\r\n	];\r\n\r\n## 重定向\r\n\r\n重定向响应是 `Illuminate\\Http\\RedirectResponse` 实例，并且包含重定向所需的正确标头信息。有几种生成 `RedirectResponse` 实例的方式。最简单的是使用全局 `redirect` 辅助函数：\r\n\r\n	Route::get(\'dashboard\', function () {\r\n		return redirect(\'home/dashboard\');\r\n	});\r\n\r\n有时需要重定向到之前地址，比如当提交表单无效时。这时可以使用 `back` 辅助函数。因为这个函数使用了 Session，所以要保证调用 `call` 函数的路由使用了 `web` 中间件组或者是应用了所有的 Session 相关中间件：\r\n\r\n	Route::post(\'user/profile\', function () {\r\n	    // Validate the request...\r\n\r\n	    return back()->withInput();\r\n	});\r\n\r\n### 重定向到命名路由\r\n\r\n直接调用 `redirect()` 方法会返回一个 `Illuminate\\Routing\\Redirector` 实例，你就可以使用这个实例上的方法了。例如，你可以使用 `route` 方法产生一个到命名路由的 `RedirectResponse` 实例：\r\n\r\n	return redirect()->route(\'login\');\r\n\r\n如果路由包含参数，给 `route` 方法传递第二个参数指定：\r\n\r\n	// For a route with the following URI: profile/{id}\r\n\r\n	return redirect()->route(\'profile\', [\'id\' => 1]);\r\n\r\n#### 使用 Eloquent Model 填充路由参数\r\n\r\n如果你重定向的那个路由包含一个叫 `id` 的路由参数，那么可以向 `route` 方法直接传递 Eloquent Model 实例。ID 值会被自动解析：\r\n\r\n	// For a route with the following URI: profile/{id}\r\n	\r\n	return redirect()->route(\'profile\', [$user]);\r\n\r\n如果路由参数使用的不是 `id`，而是其他字段名（比如 `email`），那这个时候就需要在 Eloquent Model 设置 `getRouteKey` 方法了，告诉 Laravel 从 Eloquent Model 中解析 `email` 这个字段值给路由参数：\r\n\r\n	/**\r\n	 * Get the value of the model\'s route key.\r\n	 *\r\n	 * @return mixed\r\n	 */\r\n	public function getRouteKey()\r\n	{\r\n	    return $this->email;\r\n	}\r\n\r\n### 重定向到控制器 Action\r\n\r\n给 `action` 方法传递控制器和 action 名就可以重定向到某个控制器 action。记住，你无需指定包含完整命名空间的控制器类名，只需指定 `App\\Http\\Controllers` 后面那部分的内容，这是在 Laravel 的 `RouteServiceProvider` 中设定的：\r\n\r\n	return redirect()->action(\'HomeController@index\');\r\n\r\n如果路由包含参数，给 `action` 方法传递第二个参数指定：\r\n\r\n	return redirect()->route(\r\n		\'UserController@profile\', [\'id\' => 1]\r\n	);\r\n\r\n### 重定向时携带 Session 闪存数据\r\n\r\n重定向到一个新 URL，并且闪存数据到 Session 经常同时进行。比如，我们在成功操作某一个动作后，返回一条提示操作成功的消息。为了方便，你可以在 `RedirectResponse`实例上直接使用 `with` 方法将消息闪存到 Session 中，一行代码搞定！\r\n\r\n	Route::post(\'user/profile\', function () {\r\n	    // Update the user\'s profile...\r\n\r\n	    return redirect(\'dashboard\')->with(\'status\', \'Profile updated!\');\r\n	});\r\n\r\n重定向后，就可以从 Session 中获得闪存消息了。下面以 Blade 模板文件为例，展示消息内容：\r\n\r\n	@if (session(\'status\'))\r\n		<div class=\"alert alert-success\">\r\n			{{ session(\'status\') }}\r\n		</div>\r\n	@endif\r\n\r\n## 其他响应类型\r\n\r\n`response` 辅助函数可以产生其他类型的响应实例。当以无参的形式调用 `response` 函数的时候，也就是 `response()`——它会返回一个实现了 `Illuminate\\Contracts\\Routing\\ResponseFactory` 契约的实例。在这个契约里提供了一些有用的产生响应的方法。\r\n\r\n### 视图响应\r\n\r\n如果需要指定响应的状态码、标头，而且还要返回一个视图，可以使用 `view` 方法：\r\n\r\n	return response()\r\n		    ->view(\'hello\', $data, 200)\r\n		    ->header(\'Content-Type\', $type);\r\n\r\n当然，如果不用自定义响应状态码或者标头，直接返回视图，那么用全局 `view` 辅助函数完全 OK。\r\n\r\n### JSON 响应\r\n\r\n`json` 方法会自动设置 `Content-Type` 标头为 `application/json`，并且使用 PHP `json_encode` 函数将数组转换为 JSON 数据：\r\n\r\n	return response()->json([\r\n	    \'name\' => \'Abigail\',\r\n	    \'state\' => \'CA\'\r\n	]);\r\n\r\n如果需要创建一个 JSONP 响应，可以让 `json` 方法结合 `withCallback` 方法使用：\r\n\r\n	return response()\r\n		    ->json([\'name\' => \'Abigail\', \'state\' => \'CA\'])\r\n		    ->withCallback($request->input(\'callback\'));\r\n\r\n### 文件下载\r\n\r\n`download` 方法强制浏览器下载指定路径下的文件。该方法接收第二个参数作为文件名（最终用户看到的文件名）。最后，你可以传递第三个包含标头信息的数组参数：\r\n\r\n	return response()->download($pathToFile);\r\n\r\n	return response()->download($pathToFile, $name, $headers);\r\n\r\n	return response()->download($pathToFile)->deleteFileAfterSend(true);\r\n\r\n注意！管理文件下载的 Symfony HttpFoundation 需要下载的文件具有 ASCII 文件名。\r\n\r\n### 文件响应\r\n\r\n`file` 方法用来强制显示文件，比如图片和 PDF 文件（而不是下载）。该方法的第一个参数是文件路径，第二个参数是包含标头信息的数组：\r\n\r\n	return response()->file($pathToFile);\r\n\r\n	return response()->file($pathToFile, $headers);\r\n\r\n## 响应宏\r\n\r\n可以使用 `Response` 门面的 `macro` 方法，自定义可以在各种路由和控制器中重复使用的响应，这就是「响应宏」。例如，在服务提供者的 `boot` 方法里设置咱们的响应宏：\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use Illuminate\\Support\\ServiceProvider;\r\n	use Illuminate\\Support\\Facades\\Response;\r\n\r\n	class ResponseMacroServiceProvider extends ServiceProvider\r\n	{\r\n	    /**\r\n	     * Register the application\'s response macros.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function boot()\r\n	    {\r\n	        Response::macro(\'caps\', function ($value) {\r\n	            return Response::make(strtoupper($value));\r\n	        });\r\n	    }\r\n	}\r\n\r\n`macro` 函数的第一个参数是宏的名字，第二个参数是闭包。宏的闭包会在调用 `response` 辅助函数时候被执行，或者是从 `ResponseFactory` 的实现调用宏的时候被执行。 \r\n\r\n	return response()->caps(\'foo\');','2017-09-20 02:55:35','2017-09-20 02:55:35','laravel-document-reading-the-http-response'),(376,3,3,'Laravel 文档阅读：视图','> 翻译、衍生自：https://laravel.com/docs/5.5/views\r\n\r\n## 创建视图\r\n\r\n视图将业务逻辑和表现层分离。视图文件位于 `resources/views` 目录下。一个简单的视图文件看起来是这样的：\r\n\r\n	<!-- View stored in resources/views/greeting.blade.php -->\r\n\r\n	<html>\r\n	    <body>\r\n	        <h1>Hello, {{ $name }}</h1>\r\n	    </body>\r\n	</html>\r\n\r\n我们可以用全局 `view` 辅助函数返回这个视图：\r\n\r\n\r\n	Route::get(\'/\', function () {\r\n	    return view(\'greeting\', [\'name\' => \'James\']);\r\n	});\r\n\r\n传递给 `view` 函数的第一个参数是视图文件的路径，这个路径是相对于 `resources/views` 这个目录的；第二个参数是传递给视图文件的数据，是一个数组，数组里的数据可在视图文件中取得。在上面的例子里，我们给 `greeting.blade.php` 这个视图文件传递了一个 `name` 变量，在 Blade 模板里使用 `{{ }}` 符号解析、显示了这个变量值。\r\n\r\n当然，如果视图文件是保存在 `resources/views` 这个目录下的子目录里的，我们就要用点（`.`）符号引用视图了。例如，如果视图文件地址是 `resources/views/admin/profile.blade.php`，你就要这样引用它。\r\n\r\n	return view(\'admin.profile\', $data);\r\n\r\n#### 判断视图是否存在\r\n\r\n使用 `View` 门面的 `exists` 方法，判断视图文件是否存在。该方法返回一个布尔值，`true` 表示文件存在，`false` 表示文件不存在。\r\n\r\n	use Illuminate\\Support\\Facades\\View;\r\n\r\n	if (View::exists(\'emails.customer\')) {\r\n	    //\r\n	}\r\n\r\n#### 返回第一个可用视图\r\n\r\n使用 `first` 方法，返回给定的数组列表里，第一个可用的视图文件。这对于要自定义\r\n或重写视图文件的应用程序和包非常有用：\r\n\r\n	return view()->first([\'custom.admin\', \'admin\'], $data);\r\n\r\n当然，也可以通过 `View` 门面调用这个方法：\r\n\r\n	use Illuminate\\Support\\Facades\\View;\r\n\r\n	return View::first([\'custom.admin\', \'admin\'], $data);\r\n\r\n## 向视图传递数据\r\n\r\n之前的例子中已经演示过，你可以以数组的形式向视图传递数据：\r\n\r\n	return view(\'greetings\', [\'name\' => \'维多利亚\']);\r\n\r\n以这种方式传递的数据，都是键值对的形式。在视图文件里，使用键来获得对应的值，比如：`<?php echo $key; ?>`。如果传递给视图的只有一条数据，那么使用 `view` 辅助函数上的 `with` 方法吧！\r\n\r\n	return view(\'greeting\')->with(\'name\', \'Victoria\');\r\n\r\n#### 视图共享数据\r\n\r\n偶尔，所有视图里可能都使用了同样的一些数据，我们称这些数据是「视图共享数据」。共享数据使用的是 `View::share()` 方法，你可以在服务提供者的 `boot` 中设定这些共享数据。下面，我们在 `AppServiceProvider` 中设定了一条共享数据：\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use Illuminate\\Support\\Facades\\View;\r\n\r\n	class AppServiceProvider extends ServiceProvider\r\n	{\r\n	    /**\r\n	     * Bootstrap any application services.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function boot()\r\n	    {\r\n	        View::share(\'key\', \'value\');\r\n	    }\r\n\r\n	    /**\r\n	     * Register the service provider.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function register()\r\n	    {\r\n	        //\r\n	    }\r\n	}\r\n\r\n## 视图 Composers\r\n\r\n「视图 Composers」这个名字听起来很酷炫，但是必须要解释一番才知道意思。\r\n\r\n**视图 Composers 是在视图渲染时，调用的一个回调函数或者类方法**（没错，就干这个的）。你可能会在视图渲染、并为视图绑定数据时用到它，一个视图 Composer 能把这些视图渲染时，做的绑定逻辑维护在一个地方。\r\n\r\n我们在服务提供者中注册视图 Composer。我们使用 `View` 门面访问底层 `Illuminate\\Contracts\\View\\Factory` 契约实现。记住，Laravel 没有为视图 Composer 创建默认目录，你可以自由组织。例如，你可以创建一个 `app/Http/ViewComposers` 目录。\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use Illuminate\\Support\\Facades\\View;\r\n	use Illuminate\\Support\\ServiceProvider;\r\n\r\n	class ComposerServiceProvider extends ServiceProvider\r\n	{\r\n	    /**\r\n	     * Register bindings in the container.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function boot()\r\n	    {\r\n	        // Using class based composers...\r\n	        View::composer(\r\n	            \'profile\', \'App\\Http\\ViewComposers\\ProfileComposer\'\r\n	        );\r\n\r\n	        // Using Closure based composers...\r\n	        View::composer(\'dashboard\', function ($view) {\r\n	            //\r\n	        });\r\n	    }\r\n\r\n	    /**\r\n	     * Register the service provider.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function register()\r\n	    {\r\n	        //\r\n	    }\r\n	}\r\n\r\n> 注意！如果你是在一个新的服务提供者中注册视图 Composer 的，不要忘记在 `config/app.php` 配置文件的 `providers` 数组里，添加该服务提供者。\r\n\r\n注册好 Composer 后，每次 `profile` 视图渲染的时候，都会调用 `ProfileComposer@compose` 方法。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\ViewComposers;\r\n\r\n	use Illuminate\\View\\View;\r\n	use App\\Repositories\\UserRepository;\r\n\r\n	class ProfileComposer\r\n	{\r\n	    /**\r\n	     * The user repository implementation.\r\n	     *\r\n	     * @var UserRepository\r\n	     */\r\n	    protected $users;\r\n\r\n	    /**\r\n	     * Create a new profile composer.\r\n	     *\r\n	     * @param  UserRepository  $users\r\n	     * @return void\r\n	     */\r\n	    public function __construct(UserRepository $users)\r\n	    {\r\n	        // Dependencies automatically resolved by service container...\r\n	        $this->users = $users;\r\n	    }\r\n\r\n	    /**\r\n	     * Bind data to the view.\r\n	     *\r\n	     * @param  View  $view\r\n	     * @return void\r\n	     */\r\n	    public function compose(View $view)\r\n	    {\r\n	        $view->with(\'count\', $this->users->count());\r\n	    }\r\n	}\r\n\r\n就在视图渲染之前，`Illuminate\\View\\View` 实例就会调用 Composer 的 `compose` 方法。在此，你可以使用 `with` 方法向视图绑定数据。\r\n\r\n> 提示！ 视图 Composer 都是通过服务容器解析的，所以可以在 Composer 的构造函数里使用依赖注入。\r\n\r\n#### 把一个 Composer 附加给多个视图\r\n\r\n你可以给 `composer` 方法传递第一个数组参数，数组是视图列表，通过这种方式，把一个 Composer 附加给多个视图。\r\n\r\n	View::composer(\r\n	    [\'profile\', \'dashboard\'],\r\n	    \'App\\Http\\ViewComposers\\MyViewComposer\'\r\n	);\r\n\r\n`composer` 方法也接受星号（`*`）通配符，把一个 Composer 附加给所有视图：\r\n\r\n	View::composer(\'*\', function ($view) {\r\n	    //\r\n	});\r\n\r\n#### 视图 Creators\r\n\r\n视图 Creator 和视图 Composer 几乎是一样的，只是调用时机不同。视图 Creator 是在视图实例化后立即执行的，视图 Composer 是在视图即将渲染时执行的。注册一个视图 Creator，使用 `creator` 方法：\r\n\r\n	View::creator(\'profile\', \'App\\Http\\ViewCreators\\ProfileCreator\');\r\n\r\n[1]: https://laravel.com/docs/5.5/blade','2017-09-20 06:14:34','2017-09-20 06:14:34','laravel-document-reading-view'),(377,3,3,'Laravel 文档阅读：生成 URL','> 翻译、衍生自：https://laravel.com/docs/5.5/urls\r\n\r\n## 简介\r\n\r\nLaravel 提供了几个生成 URL 地址的辅助函数，包括：`url`、`route` 和 `action`。它们的主要作用是：在 Blade 模板中构建链接、构建 API 响应或者构建重定向到应用程序其他部分的响应。\r\n\r\n## 基础\r\n\r\n### 生成基础 URLs\r\n\r\n`url` 辅助函数是生成 URL 的最基础方法。生成的 URL 会自动添加 Scheme（HTTP 或者 HTTPS）和主机地址，这些信息都是从当前请求里获得的：\r\n\r\n	$post = App\\Post::find(1);\r\n\r\n	echo url(\"/posts/{$post->id}\");\r\n\r\n	// http://example.com/posts/1\r\n\r\n### 获得当前 URL\r\n\r\n如果使用 `url` 函数时，没有提供参数，那么 `url()` 会返回一个 `Illuminate\\Routing\\UrlGenerator` 实例，从中可以获得当前 URL 相关的信息：\r\n\r\n	// Get the current URL without the query string...\r\n	echo url()->current();\r\n\r\n	// Get the current URL including the query string...\r\n	echo url()->full();\r\n\r\n	// Get the full URL for the previous request...\r\n	echo url()->previous();\r\n\r\n这些方法就还可以通过 `URL` 门面访问到：\r\n\r\n	use Illuminate\\Support\\Facades\\URL;\r\n\r\n	echo URL::current();\r\n\r\n## 命名路由 URLs\r\n\r\n`route` 辅助函数可以用来生成到指定命名路由的 URL。使用命名路径生成 URL 的方式不与路由的实际 URL 耦合。所以，如果路由 URL 改变后，使用 `route` 函数调用的地方不需要任何修改。例如，应用程序里定义了这么一个路由：\r\n\r\n	Route::get(\'/posts/{post}\', function () {\r\n	    //\r\n	})->name(\'posts.show\');\r\n\r\n下面，我们使用 `route` 函数生成到该命名路由的 URL：\r\n\r\n	echo route(\'posts.show\', [\'post\' => 1]);\r\n\r\n	// http://example.com/posts/1\r\n\r\n如果你经常在生成 URL 的时候，使用 Eloquent Model 的主键。这样的话，你可以直接把 Eloquent Model 作为参数值传递给 `route` 函数，`route` 函数会自动解析出 Model 的主键值。\r\n\r\n	echo route(\'posts.show\', [\'post\' => $post]);\r\n\r\n## 控制器 Action URLs\r\n\r\n`action` 方法通过指定控制器 action 来生成访问的 URL。你无需传递具有完整命名空间的控制类名，只要传递相对于 `App\\Http\\Controllers` 这个命名空间后面的部分即可：\r\n\r\n	$url = action(\'HomeController@index\');\r\n\r\n如果控制器方法接受路由参数，你可以通过第二个参数传递过去：\r\n\r\n	$url = action(\'UserController@profile\', [\'id\' => 1]);\r\n\r\n## 默认值\r\n\r\n对于某些应用程序，你可能希望为某些 URL 参数指定请求范围级别的默认值。假设在你的许多路由中，包含一个 `{locale}` 参数。\r\n\r\n	Route::get(\'/{locale}/posts\', function () {\r\n	    //\r\n	})->name(\'posts.index\');\r\n\r\n每次调用 `route` 函数的时候，都要传递这个 `locale` 参数会很麻烦。对于这种情况呢，你可以使用 `URL::defaults` 方法为这个参数指定默认值，它会在当前请求里总是生效。为了方便，你也可以创建一个中间件，在中间件中调用这个方法，然后让相关路由/路由组使用这个中间件。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Middleware;\r\n\r\n	use Closure;\r\n	use Illuminate\\Support\\Facades\\URL;\r\n\r\n	class SetDefaultLocaleForUrls\r\n	{\r\n	    public function handle($request, Closure $next)\r\n	    {\r\n	        URL::defaults([\'locale\' => $request->user()->locale]);\r\n\r\n	        return $next($request);\r\n	    }\r\n	}\r\n\r\n`locale` 参数的默认值设定好后，通过 `route` 辅助函数生成 URL 的时候，就无需为 `locale` 传递值了。','2017-09-20 09:08:50','2017-09-29 09:22:34','laravel-document-reading-the-url'),(378,3,3,'HTTP 协议、Cookie 和 Session','## HTTP 协议\r\n\r\nHTTP 协议是无状态协议（Stateless）——浏览器发送一个页面的请求地址，通过 HTTP 将请求发送给服务器，然后服务器响应页面内容给浏览器，在这之后，服务器再也不认识这个浏览器是谁，Ta 曾经与我做过什么。为什么呢？因为**中间人  HTTP 协议从来不是一个合格的红娘**。\r\n\r\n	浏览器：红娘，我要从服务器大哥那里，买个炊饼，拜托了。\r\n	\r\n	红娘：好的，我带这个需求过去。\r\n	\r\n	// 红娘趋数步，到服务器大哥卖炊饼处\r\n	\r\n	红娘： 服务器小哥，给我个炊饼。\r\n	\r\n	服务器：好勒，给你，热乎着！\r\n	\r\n	// 红娘趋数步，到浏览器妹妹等候处\r\n	\r\n	红娘：来，炊饼我买到了，给你。\r\n	\r\n	浏览器：好的，我要吃了。\r\n\r\n\r\n## Cookie\r\n\r\nCookie 是保存在浏览器里的一段数据。**在每次请求时，Cookie 都包含在请求标头里，发送给服务器**。这样想——如果这个 Cookie 中存储了用户名和密码数据，每次向服务器发送请求时，都给服务器这个数据看，想想看，如果服务器获得这个字段，然后再从服务器里验证用户名、密码后，发现——哦，原来是我们系统里的这个用户啊，那么是不是就是说，服务器认识了向它发送请求的浏览器了——确实是这样。所以虽然，HTTP 协议是无状态的，但是可以通过 Cookie，让我们认识浏览器的使用者是系统用户。\r\n\r\n	浏览器：红娘，我要从服务器大哥那里，买个炊饼，拜托了（手递信给红娘）。\r\n\r\n	// 红娘携信，趋数步，到服务器大哥卖炊饼处\r\n\r\n	红娘：服务器小哥（手递信给小哥），给我个炊饼。\r\n	\r\n	// 服务器展信阅读，得知是对面的浏览器小妹，知道小妹爱吃芝麻，所以烤了一个多芝麻的炊饼\r\n	\r\n	服务器：来，给你，热乎着！\r\n	\r\n	// 红娘趋数步，到浏览器妹妹等候处\r\n	\r\n	红娘：来，炊饼我买到了，给你。\r\n	\r\n	浏览器：好的，我要吃了（心想，服务器大哥知道了我了）。\r\n	\r\n\r\n## Session\r\n\r\nCookie 数据是保存在浏览器里的，这就暴露出了一个很大的危险——一些私密数据（比如密码）会泄露出去，如果一些不怀好意的人从你的浏览里 Copy 了一份，你在一个网站域名下的 Cookie 数据，那么就是说，这些人可以在别的浏览器中，伪装成你的身份登录系统，胡作非为！\r\n\r\n所以，我们最好不要把这些私密数据暴露在浏览器里，这就是使用 Session 的原因。Session 是保存服务器端的数据，它把原来保存在浏览器端里的私密数据，统统拿来，保存在了自己的身上。\r\n\r\n这就有一个问题，服务器还怎么认识浏览器呢？\r\n\r\n是这样的，在用户第一次登录后，服务器新建了一个 Session（拥有一个唯一值 Session ID），将该 Session ID 设置到 Cookie 里，当登录用户再次向服务器发起请求时，借助 Cookie 携带的这个 Session ID 值，服务器就知道拥有这个 Session ID 的用户信息，然后认识浏览器的使用者是系统的某个用户。','2017-09-21 01:42:19','2017-09-21 02:14:28','the-http-protocol-the-cookie-and-session'),(379,3,3,'Laravel 文档阅读：HTTP 会话','> 翻译、衍生自：https://laravel.com/docs/5.5/session\r\n\r\n## 简介\r\n\r\nHTTP 协议是无状态（stateless）协议，而会话（Session）提供了一种在多个请求之间存储用户信息的办法。Laravel 开箱支持用几款不同的软件（Memcached、Redis 和数据库）提供管理会话的能力，而且基于这几款软件封装的 API 是一样的。\r\n\r\n### 配置\r\n\r\n会话的配置文件是 `config/session.php`，这里面配置项你可以深情款款地看一遍。Laravel 默认使用的会话驱动是 `file`，对于许多项目来说，够用了。对于大型项目，为了获得更好的会话性能，可以考虑使用 `memchached` 或者 `redis` 驱动。\r\n\r\n会话数据保存在哪个地方，取决于 `driver` 配置项取值。Laravel 开箱支持以下驱动：\r\n\r\n* `file` - 会话数据保存在 `storage/framework/sessions` 目录下。\r\n* `cookie` - 会话数据经过加密保存在 Cookie 中。\r\n* `database` - 会话数据保存在关系型数据库中。\r\n* `memchached` / `redis` - 会话数据存储在这两个基于缓存的存储设备中。\r\n* `array` - 会话数据临时保存在数组中，不会被持久化。\r\n\r\n> 提示！ `array` 驱动在测试时使用的，它不会将会话里的数据持久化。\r\n\r\n### 驱动预设\r\n\r\n#### 数据库\r\n\r\n当使用 `database` 会话驱动的时候，你需要在数据库创建一张表格，存储这些会话数据。下面是使用 `Schema` 声明会话表的脚本：\r\n\r\n	Schema::create(\'sessions\', function ($table) {\r\n		$table->string(\'id\')->unique();\r\n		$table->unsignedInteger(\'user_id\')->nullable();\r\n		$table->string(\'ip_address\', 45)->nullable();\r\n		$table->text(\'user_agent\')->nullable();\r\n		$table->text(\'payload\');\r\n		$table->integer(\'last_activity\');\r\n	});\r\n\r\n你可以使用 Artisan 命令生成这个迁移文件：\r\n\r\n	php artisan session:table\r\n\r\n	php artisan migrate\r\n\r\n#### Redis\r\n\r\n在使用 Redis 之前，需要先用 Composer 安装 `predis/predis` 包（~1.0）。然后在 `config/database.php` 中配置你的 Redis 连接，最后为 `config/session.php` 的 `connection` 字段指定使用哪个 Redis 连接。\r\n\r\n## 使用 Session\r\n\r\n### 获得数据\r\n\r\n有两种方式操作会话数据：全局 `session` 辅助函数或者通过 `Request` 实例。首先，先来看通过 `Request` 实例的方式，`Request` 实例在控制器方法里可以依赖注入。记住，控制器方法里的依赖是通过服务容器自动注入的。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Http\\Request;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class UserController extends Controller\r\n	{\r\n	    /**\r\n	     * Show the profile for the given user.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @param  int  $id\r\n	     * @return Response\r\n	     */\r\n	    public function show(Request $request, $id)\r\n	    {\r\n	        $value = $request->session()->get(\'key\');\r\n\r\n	        //\r\n	    }\r\n	}\r\n\r\n`get` 方法还接收第二个参数，它是默认值——当会话中没有要取的 Key 时，就返回这个值。第二个参数还可以是一个闭包，当会话中没有要取的 Key 时，就执行这个闭包里的内容，闭包的返回结果就是默认值：\r\n\r\n	$value = $request->session()->get(\'key\', \'default\');\r\n\r\n	$value = $request->session()->get(\'key\', function () {\r\n	    return \'default\';\r\n	});\r\n\r\n#### 全局 `session` 辅助函数\r\n\r\n你也可以使用全局 `session` 辅助函数获得、保存会话数据。当给 `session()` 函数传递一个字符串参数的时候，它会返回会话中指定 Key 的值。当传递给 `session()` 的是一个包含键值对的数组，数组里的值都会保存到会话里：\r\n\r\n	Route::get(\'home\', function () {\r\n	    // Retrieve a piece of data from the session...\r\n	    $value = session(\'key\');\r\n\r\n	    // Specifying a default value...\r\n	    $value = session(\'key\', \'default\');\r\n\r\n	    // Store a piece of data in the session...\r\n	    session([\'key\' => \'value\']);\r\n	});\r\n\r\n> 提示！ 通过 HTTP 请求实例和全局 `session` 辅助函数操作会话数据的方法几乎没有区别。两种方法都可以在你的测试用例中获得，使用 `assertSessionHas` 方法测试。\r\n\r\n#### 获得所有会话数据\r\n\r\n使用 `all` 方法：\r\n\r\n	$data = $request->session()->all();\r\n\r\n	$data = session()->all();\r\n\r\n#### 判断会话里是否存在指定 Key\r\n\r\n有两个方法用来判断：`has` 和 `exists`。\r\n\r\n* `has` 方法：当指定的 Key 存在于会话中，且值不为 `null` 时，返回 `false`，否则返回 `true`。\r\n\r\n	if ($request->session()->has(\'users\')) {\r\n	    //\r\n	}\r\n\r\n* `exists` 方法：当指定的 Key 存在于会话中，就返回 `true`，否则返回 `false`。\r\n\r\n	if ($request->session()->exists(\'users\')) {\r\n	    //\r\n	}\r\n\r\n### 保存数据\r\n\r\n向会话里保存数据使用 `put` 方法，或者使用 `session` 辅助函数：\r\n\r\n	// Via a request instance...\r\n	$request->session()->put(\'key\', \'value\');\r\n\r\n	// Via the global helper...\r\n	session([\'key\' => \'value\']);\r\n\r\n#### 向数组类型的会话数据里推入数据\r\n\r\n如果会话里有一个字段值是一个数组的话，如果要往这个数组里推入数据，就需要用到 `push` 方法。例如，`user.teams` 这个 Key 保存的是队名，现在我们给这个数组里再加入一个元素：\r\n\r\n	$request->session()->push(\'user.teams\', \'developers\');\r\n\r\n#### 获得 & 删除 Key\r\n\r\n`pull` 方法会在获得 Key 值的同时从会话里删除这个 Key 数据记录。\r\n\r\n	$value = $request->session()->pull(\'key\', \'default\');\r\n\r\n### 闪存数据\r\n\r\n有时，你可能希望保存的会话数据只在下一个请求中有效，这时可以用 `flash` 方法。用这个方法保存的数据只在下一个的请求中能够得到，之后就被删除。闪存数据主要用在保存短生命周期的消息比较有用：\r\n\r\n	$request->session()->flash(\'status\', \'Task was successful!\');\r\n\r\n如果要让闪存数据多维持几个请求周期，可以使用 `reflash` 方法，这个方法会让所有的闪存数据延长一个请求周期。如果只延长特定的一些闪存数据，就用 `keep` 方法：\r\n\r\n	$request->session()->reflash();\r\n\r\n	$request->session()->keep([\'username\', \'email\']);\r\n\r\n### 删除数据\r\n\r\n`forget` 方法用来删除会话数据，如果要删除所有会话数据，请使用 `flush` 方法：\r\n\r\n	$request->session()->forget(\'key\');\r\n\r\n	$request->session()->flush();\r\n\r\n### 重新生成会话 ID\r\n\r\n重新生成会话 ID 的原因，通常是为了避免恶意用户利用 [会话固定][1] 手段攻击你的项目。\r\n\r\n如果你使用了内置的 `LoginController` 的话，它会在你认证的时候自动重新生成会话 ID；如果，你需要手动重新生成会话 ID 的话，请使用 `regenerate` 方法。\r\n\r\n	$request->session()->regenerate();\r\n\r\n## 添加自定义会话驱动\r\n\r\n#### 实现驱动\r\n\r\n你的自定义驱动要实现 `SessionHandlerInterface` 这个接口。这个接口包含几个需要实现的简单方法。一个 `MongoDB` 的实现代码看起来是想这样的：\r\n\r\n	<?php\r\n\r\n	namespace App\\Extensions;\r\n\r\n	class MongoHandler implements SessionHandlerInterface\r\n	{\r\n	    public function open($savePath, $sessionName) {}\r\n	    public function close() {}\r\n	    public function read($sessionId) {}\r\n	    public function write($sessionId, $data) {}\r\n	    public function destroy($sessionId) {}\r\n	    public function gc($lifetime) {}\r\n	}\r\n\r\n> 注意！ Laravel 没有为你的驱动扩展创建默认文件目录。你可以按照你的心意放置，在这里我们是创建了一个 `Extensions` 目录保存我们的 `MongoHandler` 文件。\r\n\r\n由于所有的方法看起来都不知道是什么意思，我这里全部讲一遍：\r\n\r\n* `open` 方法用在基于文件的会话存储系统。因为 Laravel 自带 `file` 会话存储，所以这个方法保持为空就可以了。这个方法有些不使用，不是一个很好的接口设计（之后再讨论），但是 PHP 要求我们去实现它。\r\n* `close` 方法跟 `open` 方法一样，可以直接忽略，保持为空即可。对于大多数驱动，都用不着。\r\n* `read` 方法应该返回匹配指定 `$sessionId` 的那个会话数据的字符串形式，在你的驱动程序中查询或存储会话数据时，无需进行任何序列化或其他编码，因为 Laravel 给你做了。\r\n* `write` 方法应该将给定的 `$data` 字符串数据关联到 `$sessionId`，然后持久化、保存到存储系统里。比如 MongoDB、Dynamo 等。再一次说明，你不应该执行任何序列化操作——Laravel 会为你处理好。 \r\n* `destroy` 方法应该从持久化系统里删除与 `$sessionId` 关联的会话数据。\r\n* `gc` 方法应该删除在 `$lifetime` 之前的所有会话数据，它是一个时间戳。对于自带过期功能的系统，像 Memcached 和 Redis，这个方法保持为空就 OK 了。\r\n\r\n#### 注册驱动\r\n\r\n驱动实现好后，就可以注册它了。为 Laravel 注册驱动要用到 `Session` 门面的 `extend` 方法。你需要在服务提供者的 `boot` 方法里调用 `extend` 方法。可以在现成的 `AppServiceProvider` 中，或者其他新建的服务提供者里：\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use App\\Extensions\\MongoSessionStore;\r\n	use Illuminate\\Support\\Facades\\Session;\r\n	use Illuminate\\Support\\ServiceProvider;\r\n\r\n	class SessionServiceProvider extends ServiceProvider\r\n	{\r\n	    /**\r\n	     * Perform post-registration booting of services.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function boot()\r\n	    {\r\n	        Session::extend(\'mongo\', function ($app) {\r\n	            // Return implementation of SessionHandlerInterface...\r\n	            return new MongoSessionStore;\r\n	        });\r\n	    }\r\n\r\n	    /**\r\n	     * Register bindings in the container.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function register()\r\n	    {\r\n	        //\r\n	    }\r\n	}\r\n\r\n会话驱动注册好后，就可以在 `config/session.php` 配置文件里使用 `mongo` 驱动了。 \r\n\r\n\r\n[1]: https://en.wikipedia.org/wiki/Session_fixation','2017-09-21 06:28:03','2017-09-21 06:31:02','laravel-document-reading-http-sessions'),(380,3,3,'Laravel 文档阅读：验证（上篇）','> 翻译、衍生自：https://laravel.com/docs/5.5/validation\r\n\r\n## 简介\r\n\r\nLaravel 提供了几种方法来验证应用程序的输入数据（incoming data）。默认，Laravel 的基类控制器使用了 `validatesRequests` trait。这个 trait 里提供了一种方便验证传入的 HTTP 请求、带有丰富验证规则的方法。\r\n\r\n## 快速上手\r\n\r\n要了解 Laravel 强大的验证功能，我们需要看一个完整实例——验证表单，并且显示错误消息给用户。\r\n\r\n### 定义路由\r\n\r\n首先，在 `routes/web.php` 中，包含如下两个路由：\r\n\r\n	Route::get(\'posts/create\', \'PostsController@create\');\r\n\r\n	Route::post(\'posts\', \'PostsController@store\');\r\n\r\n`GET` 路由会给用户显示一个创建博客文章的表单，而 `POST` 路由用来保存新的博客文章到数据库。\r\n\r\n### 创建控制器\r\n\r\n接下里，我们看下处理这些路由的控制器 `PostsController`，不过现在 `store` 方法还是空的：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Http\\Request;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class PostsController extends Controller\r\n	{\r\n	    /**\r\n	     * Show the form to create a new blog post.\r\n	     *\r\n	     * @return Response\r\n	     */\r\n	    public function create()\r\n	    {\r\n	        return view(\'posts.create\');\r\n	    }\r\n\r\n	    /**\r\n	     * Store a new blog post.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @return Response\r\n	     */\r\n	    public function store(Request $request)\r\n	    {\r\n	        // Validate and store the blog post...\r\n	    }\r\n	}\r\n\r\n### 书写验证逻辑\r\n\r\n现在，我们在 `store` 方法里验证提交过来的新博客文章的字段 `title` 和 `body`。我们使用 `Illuminate\\Http\\Request` 对象上的 `validate` 方法。如果字段经过验证规则检验通过，则正常执行后面的代码；如果没通过，一个携带正确错误响应的异常会自动发送给用户。对于传统 HTTP 请求，会生成一个重定向响应；对于 AJAX 请求，会生成一个 JSON 响应。\r\n\r\n为了更好理解 `validate` 方法，我们看下 `store` 方法内容：\r\n\r\n	/**\r\n	 * Store a new blog post.\r\n	 *\r\n	 * @param  Request  $request\r\n	 * @return Response\r\n	 */\r\n	public function store(Request $request)\r\n	{\r\n	    $request->validate([\r\n	        \'title\' => \'required|unique:posts|max:255\',\r\n	        \'body\' => \'required\',\r\n	    ]);\r\n\r\n	    // The blog post is valid, store in database...\r\n	}\r\n\r\n我们给 `validate` 方法传递了期望的验证规则。再一次，如果验证失败，一个 一个携带正确错误信息的响应会自动生成；如果验证成功，我们会继续正常执行后面的代码。\r\n\r\n#### 在第一次验证失败时停止\r\n\r\n有时，你希望在第一个验证规则失败时，就停止该字段接下来的规则验证。为此，请使用 `bail` 规则：\r\n\r\n	$request->validate([\r\n		\'title\' => \'bail|required|unique:posts|max:255\',\r\n		\'body\' => \'required\',\r\n	]);\r\n\r\n在上面的例子里，如果 `title` 属性的 `unique` 规则验证失败了，就不再检查 `max` 规则。这些规则是按照顺序从左到右一个一个验证的。\r\n\r\n#### 嵌套属性的验证方式\r\n\r\n如果 HTTP 请求中包含「嵌套」参数，你可以使用「点」（`.`）语法引用它们：\r\n\r\n	$request->validate([\r\n		\'title\' => \'required|unique:posts|max:255\',\r\n		\'author.name\' => \'required\',\r\n		\'author.description\' => \'required\',\r\n	]);\r\n\r\n### 显示验证错误\r\n\r\n如果输入数据字段没有通过验证规则呢？之前提到过，Laravel 会自动重定向到之前的页面，并携带正确的错误信息。另外，这些错误信息是自动 [闪存到会话][1] 中的。\r\n\r\n请注意，我们不必在 `GET` 路由中将错误消息显式绑定到视图。这是因为 Laravel 会自动检查会话数据里的错误消息，并自动将这些错误数据绑定到视图的一个变量 `$errors` 里。`$errors` 变量是 `Illuminate\\Support\\MessageBag` 实例。\r\n\r\n> 提示！ `$errors` 这个变量是通过 `Illuminate\\View\\Middleware\\ShareErrorsFromSession` 中间件绑定给视图的。这个中间件包含在了 `web` **中间件组里，因此 所有视图文件里总是会有这个 `$errors` 变量**，你无需担心它没有，放心使用吧！\r\n\r\n在我们的例子里，当 `store` 方法里的验证规则失败时，我们就会跳转到创建博客文章的页面，在这里我们可以显示错误消息：\r\n\r\n	<!-- /resources/views/posts/create.blade.php -->\r\n	\r\n	<h1>创建博客文章</h1>\r\n\r\n	@if ($errors->any())\r\n		<div class=\"alert alert-danger\">\r\n			<ul>\r\n				@foreach ($errors->all() as $error)\r\n					<li>{{ $error }}</li>\r\n				@endforeach\r\n			</ul>			\r\n		</div>\r\n	@endif\r\n\r\n	<!-- Create Post Form -->\r\n\r\n### 验证可选字段\r\n\r\n默认，Laravel 项目 `App\\Http\\Kernel` 类中定义的全局中间件组里包含 `TrimString` 和 `ConvertEmptyStringsToNull` 这两个。而且输入数据字段的 `null` 值会被验证器看做无效的，如果允许字段为取 `null` 值，那么加上 `nullable` 这个验证规则就可以了。\r\n\r\n	$request->validate([\r\n		\'title\' => \'required|unique:posts|max:255\',\r\n		\'body\' => \'required\',\r\n		\'published_at\' => \'nullable|date\',\r\n	]);\r\n\r\n在这个例子里，我们指定了 `published_at` 字段可以取 `null` 值或者是一个有效的日期表示。如果没有加 `nullable` 这个验证规则，验证器会把 `null` 看做无效日期。\r\n\r\n#### AJAX 请求 & 验证\r\n\r\n对 AJAX 请求使用 `validate` 方法，Laravel 不会自动生成一个重定向响应，相反，Laravel 会生成一个包含验证错误消息的 JSON 响应。该 JSON 响应将使用 422 HTTP 状态代码发送。\r\n\r\n## 表单请求验证\r\n\r\n### 创建表单请求\r\n\r\n对于更加复杂的验证场景，可以使用「表单请求」。何为表单请求？\r\n\r\n> 包含字段验证逻辑的自定义请求类。\r\n\r\n*实际上，这个表单请求类，并不是只能请求提交的表单字段，还可以处理 AJAX 请求提交过来的字段数据。所以更准确的叫法应该是**「包含处理字段验证功能的请求类」**，但太长了，是不？*\r\n\r\n创建一个表单请求类，使用 Artisan 命令 `make:request`：\r\n\r\n	php artisan make:request StoreBlogPost\r\n\r\n生成的这个 `StoreBlogPost` 类，会保存在 `app/Http/Requests` 目录下。如果目录没有不存在，会在第一次运行 `make:request` 命令时创建。接下来，我们在 `rules` 方法里添加一些验证规则：\r\n\r\n	/**\r\n	 * Get the validation rules that apply to the request.\r\n	 *\r\n	 * @return array\r\n	 */\r\n	public function rules()\r\n	{\r\n	    return [\r\n	        \'title\' => \'required|unique:posts|max:255\',\r\n	        \'body\' => \'required\',\r\n	    ];\r\n	}\r\n\r\nSo，这个表单请求类怎么生效呢？你可以在控制器方法里将它作为依赖注入。发起的表单请求会在控制器方法调用前，经表单请求类验证，就是说，你无需在控制器中混杂验证逻辑了：\r\n\r\n	/**\r\n	 * Store the incoming blog post.\r\n	 *\r\n	 * @param  StoreBlogPost  $request\r\n	 * @return Response\r\n	 */\r\n	public function store(StoreBlogPost $request)\r\n	{\r\n	    // The incoming request is valid...\r\n	}\r\n\r\n如果验证失败，会自动生成一个重定向响应到之前的地址。错误数据会被闪存进会话，以便在前端显示。如果时 AJAX 请求，Laravel 会返回一个包含验证错误消息的 JSON 响应。该 JSON 响应使用 422 HTTP 状态代码发送。\r\n\r\n#### 表单请求的 `after` 钩子方法……\r\n\r\n你可以为表单请求添加一个 `after` 钩子方法，这是在 `withValidator` 中定义的。 此方法接收基于当前请求构造的验证器实例对象，让你在实际验证字段之前，调用验证器实例对象的任何方法：\r\n\r\n	/**\r\n	 * Configure the validator instance.\r\n	 *\r\n	 * @param  \\Illuminate\\Validation\\Validator  $validator\r\n	 * @return void\r\n	 */\r\n	public function withValidator($validator)\r\n	{\r\n	    $validator->after(function ($validator) {\r\n	        if ($this->somethingElseIsInvalid()) {\r\n	            $validator->errors()->add(\'field\', \'Something is wrong with this field!\');\r\n	        }\r\n	    });\r\n	}\r\n\r\n### 授权表单请求\r\n\r\n表单请求类也可以包含一个 `authorize` 方法，在此方法内，你可以检查认证用户是否有更新指定资源的权限。例如，你可以判断一个用户是否可以更新指定的博客文章的评论：\r\n\r\n	/**\r\n	 * Determine if the user is authorized to make this request.\r\n	 *\r\n	 * @return bool\r\n	 */\r\n	public function authorize()\r\n	{\r\n	    $comment = Comment::find($this->route(\'comment\'));\r\n\r\n	    return $comment && $this->user()->can(\'update\', $comment);\r\n	}\r\n\r\n由于所有的表达请求类继承了 Laravel 基类请求类，我们可以使用 `user` 方法获得当前认证用户。注意上面调用 `route` 方法的地方，该方法用来获得路由参数 `{comment}`：\r\n\r\n	Route::post(\'comments/{comment}\');\r\n\r\n如果 `authorize` 方法返回 `false`，那么一个携带 403 状态码的 HTTP 响应会自动返回，控制器方法不会执行。\r\n\r\n 如果你要把认证逻辑放在别处，只要让 `authorize` 方法直接返回 `true` 就可以了：\r\n\r\n	 /**\r\n	 * Determine if the user is authorized to make this request.\r\n	 *\r\n	 * @return bool\r\n	 */\r\n	public function authorize()\r\n	{\r\n	    return true;\r\n	}\r\n\r\n### 自定义错误消息\r\n\r\n你可以在表单请求类里使用 `messages` 方法自定义默认显示的错误消息内容。这个方法返回一个带有键值对的数组，键是「属性.规则」的形式，值是对应规则验证失败时的错误消息内容：\r\n\r\n	/**\r\n	 * Get the error messages for the defined validation rules.\r\n	 *\r\n	 * @return array\r\n	 */\r\n	public function messages()\r\n	{\r\n	    return [\r\n	        \'title.required\' => \'A title is required\',\r\n	        \'body.required\'  => \'A message is required\',\r\n	    ];\r\n	}\r\n\r\n## 手动创建验证器\r\n\r\n如果你不用请求实例上的 `validate` 方法，那么可以使用 `Validator` 门面手动创建一个验证器。调用门面上的 `make` 方法，就会生成一个新的验证器实例：\r\n\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Validator;\r\n	use Illuminate\\Http\\Request;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class PostsController extends Controller\r\n	{\r\n	    /**\r\n	     * Store a new blog post.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @return Response\r\n	     */\r\n	    public function store(Request $request)\r\n	    {\r\n	        $validator = Validator::make($request->all(), [\r\n	            \'title\' => \'required|unique:posts|max:255\',\r\n	            \'body\' => \'required\',\r\n	        ]);\r\n\r\n	        if ($validator->fails()) {\r\n	            return redirect(\'post/create\')\r\n	                        ->withErrors($validator)\r\n	                        ->withInput();\r\n	        }\r\n\r\n	        // Store the blog post...\r\n	    }\r\n	}\r\n\r\n传递给 `Validator::make` 方法的第一个参数是验证数据，第二个参数验证规则。\r\n\r\n如果验证失败，你可以使用 `withErrors` 方法闪存错误消息到会话里。当使用这个方法时，视图里的 `$errors` 变量会被自动填充数据，以便之后显示。`withErrors` 方法接收一个验证器实例、`MessageBag` 或者一个 PHP 数组。\r\n\r\n### 自动跳转\r\n\r\n如果你是手动创建验证器，又想在验证失败时，自动跳转的话，请使用验证器实例上的 `validate` 方法。如果验证失败的话，就能自动跳转了，如果是 AJAX 请求的话，就返回一个 JSON 响应：\r\n\r\n	Validator::make($request->all(), [\r\n	    \'title\' => \'required|unique:posts|max:255\',\r\n	    \'body\' => \'required\',\r\n	])->validate();\r\n\r\n### 命名错误包\r\n\r\n如果一个页面里包含多个表单，可以为错误 `MessageBag` 命名。为 `withErrors` 方法传递第二个参数：\r\n\r\n	return redirect(\'register\')\r\n	            ->withErrors($validator, \'login\');\r\n\r\n然后，就可以在 `$errors` 变量上使用命名的 `MessageBag` 实例了：\r\n\r\n	{{ $errors->loogin->first(\'email\') }}\r\n\r\n### 在验证之后的钩子函数\r\n\r\n在验证完成之后，可以为验证器添加回调函数。这样，你可以向消息集合里为验证器进一步添加错误消息。这是要使用验证器器上的 `after` 方法：\r\n\r\n	$validator = Validator::make(...);\r\n\r\n	$validator->after(function ($validator) {\r\n	    if ($this->somethingElseIsInvalid()) {\r\n	        $validator->errors()->add(\'field\', \'Something is wrong with this field!\');\r\n	    }\r\n	});\r\n\r\n	if ($validator->fails()) {\r\n	    //\r\n	}\r\n\r\n## 使用错误消息\r\n\r\n在 `Validatore` 实例上调用 `errors` 方法，会返回一个 `Illuminate\\Support\\MessageBag` 实例，这是实例有很多操作错误消息的方法。在每个视图文件里都可取得的 `$errors` 变量也是 `MessageBag` 类实例。\r\n\r\n#### 获得给定字段的第一条错误消息\r\n\r\n获得给定字段的第一条错误消息，使用 `first` 方法：\r\n\r\n	$errors = $validator->errors();\r\n\r\n	echo $errors->first(\'email\');\r\n\r\n#### 获得给定字段的所有错误消息\r\n\r\n获得给定字段的所有错误消息，使用 `get` 方法：\r\n\r\n	foreach ($errors->get(\'email\') as $message) {\r\n		//\r\n	}\r\n\r\n如果你是验证一个数组表单字段，你可以使用 `*` 字符获得每个数组元素的所有错误消息：\r\n\r\n	foreach ($errors->get(\'attachments.*\') as $message) {\r\n		//\r\n	}\r\n\r\n#### 获得所有字段的错误消息\r\n\r\n获得所有字段的错误消息，使用 `all` 方法：\r\n\r\n	foreach ($errors->all() as $message) {\r\n	    //\r\n	}\r\n\r\n#### 判断某个字段是否有错误消息\r\n\r\n使用 `has` 方法：\r\n\r\n	if ($errors->has(\'email\')) {\r\n	    //\r\n	}\r\n\r\n### 自定义错误消息\r\n\r\n如果需要自定义错误消息，这里有几种方法。首先，`Validator::make` 方法接收的可选第三个参数就是咱们的自定义消息。\r\n\r\n	$messages = [\r\n	    \'required\' => \'The :attribute field is required.\',\r\n	];\r\n\r\n	$validator = Validator::make($input, $rules, $messages);\r\n\r\n`:attribute` 占位符会被字段名替代。你也可以在验证消息里使用其他占位符：\r\n\r\n	$messages = [\r\n	    \'same\'    => \'The :attribute and :other must match.\',\r\n	    \'size\'    => \'The :attribute must be exactly :size.\',\r\n	    \'between\' => \'The :attribute value :input is not between :min - :max.\',\r\n	    \'in\'      => \'The :attribute must be one of the following types: :values\',\r\n	];\r\n\r\n#### 为给定的属性指定自定义消息\r\n\r\n有时，只需要为给定的属性指定自定义消息，这时要使用 `.` 符号，形式是 `属性名.规则`：\r\n\r\n	$messages = [\r\n	    \'email.required\' => \'We need to know your e-mail address!\',\r\n	];\r\n\r\n#### 在语言文件里指定自定义消息\r\n\r\n大多数情况下，你可以在语言文件里指定自定义消息，而不是直接传递给 `Validator`。为此，在你的语言文件 `resources/lang/xx/validation.php` 中的 `custom` 数组里添加自定义消息。\r\n\r\n	\'custom\' => [\r\n	    \'email\' => [\r\n	        \'required\' => \'We need to know your e-mail address!\',\r\n	    ],\r\n	],\r\n\r\n#### 在语言文件里指定自定义属性\r\n\r\n如果你希望使用自定义属性名称替换验证消息的 `:attribute` 占位符部分。为此，在你的语言文件 `resources/lang/xx/validation.php` 中的 `attributes` 数组里添加自定义属性。\r\n\r\n	\'attributes\' => [\r\n	    \'email\' => \'email address\',\r\n	],','2017-09-22 07:22:00','2017-09-22 07:22:00','laravel-document-reading-validation-last'),(381,3,3,'2017年9月22号','坚持是一件很困难的事，我现在做得就是。但这没什么，仍然要做下去。\r\n\r\n用无论什么办法，可以动用前程、愿景、希望、活力、生气、发达等等这些美好的句子，让我做下去。\r\n\r\n我感觉这是没错的，我应该做。加油啊，少年！?','2017-09-22 13:03:51','2017-09-22 13:03:51','on-september-22-2017'),(382,3,3,'Laravel 文档阅读：验证（下篇）','## 可用的验证规则\r\n\r\n以下是所有可用验证规则及其功能的介绍。\r\n\r\n#### accepted\r\n\r\n验证字段值必须是 yes、on、1 或者 true。这在判断是否接收了「服务条款」非常有用。\r\n\r\n#### active_url\r\n\r\n验证字段值根据 `dns_get_record ` PHP 函数判断，必须具有有效的 A 或者 AAAA 记录。\r\n\r\n#### after:date\r\n\r\n验证字段值必须是指定日期之后的。`after:` 后面的日期会传递给 PHP `strtotime` 函数处理：\r\n\r\n	\'start_date\' => \'required|date|after:tomorrow\'\r\n\r\n你还可以传递另一个日期字段作比较。\r\n\r\n	\'finish_date\' => \'required|date|after:start_date\'\r\n\r\n#### after_or_equal:date\r\n\r\n验证字段值必须是指定日期或指定日期之后的。\r\n\r\n#### alpha\r\n\r\n验证字段值必须都是字母字符（指万国码字符，是支持中文的）。\r\n\r\n#### alpha_dash\r\n\r\n验证字段值可以是字母、数字、中划线（`-`）和下划线（`_`）。\r\n\r\n#### alpha_num\r\n\r\n验证字段值可以是字母和数字。\r\n\r\n#### array\r\n\r\n验证字段值必须是 PHP `array`。\r\n\r\n#### before:date\r\n\r\n验证字段值必须是指定日期之前的。`before:` 后面的日期会传递给 PHP `strtotime` 函数处理：\r\n\r\n#### before_or_equal:date\r\n\r\n验证字段值必须是指定日期或指定日期之前的。日期会传递给 PHP `strtotime` 函数处理：\r\n\r\n#### between:min,max\r\n\r\n验证字段的大小必须在给定的最小值和最大值之间。 支持字符串、数字、数组和文件的大小比较，比较规则参考 `size` 规则。\r\n\r\n#### boolean\r\n\r\n验证字段值必须是可以转换为布尔值的，接收的输入数据可以是 `true`、`false`、`1`、`0`、`\"1\"` 或是 `\"0\"`。\r\n\r\n#### confirmed\r\n\r\n该验证字段必须有一个对应的 `foo_confirmation` 字段。例如，如果验证字段是 `password`，就要有一个与之比较 `password_confirmation` 字段。\r\n\r\n#### date\r\n\r\n验证字段值必须是 PHP `strtotime` 函数可以处理的有效日期格式。\r\n\r\n#### date_equal:date\r\n\r\n验证字段必须与给定的日期相同。日期会传递给 PHP `strtotime` 函数处理。\r\n\r\n#### date_format:format\r\n\r\n验证字段必须匹配给定的日期格式。**验证日期字段时，不能同时使用 `date` 和 `date_format` 规则**。\r\n\r\n#### different:field\r\n\r\n验证字段必须与 field 字段有不同的值。\r\n\r\n#### digits:value\r\n\r\n验证字段必须是数字，并且必须具有指定的位数。\r\n\r\n#### digits_between:min,max\r\n\r\n验证字段必须是数字的位数，要保证在 min 和 max 之间。\r\n\r\n#### dimensions\r\n\r\n验证文件必须是图片，还要满足指定的维度约束。\r\n\r\n	\'avatar\' => \'dimensions:min_width=100,min_height=200\'\r\n\r\n可以使用的约束条件包括：min_width、max_width、min_height、max_height、width、height 和 ratio。\r\n\r\nratio 约束表示宽高比，可以用 3/2 和 1.5 这样的浮点数指定宽高比：\r\n\r\n	\'avatar\' => \'dimensions:ratio=3/2\'\r\n\r\n由于这个规则需要接受几个参数，可以使用 `Rule::dimensions` 方法来构造这个规则：\r\n\r\n	use Illuminate\\Validation\\Rule;\r\n\r\n	Validator::make($data, [\r\n		\'avatar\' => [\r\n			\'required\',\r\n			Rule::dimensions()->maxWidth(1000)->maxHeight(500)->ratio(3 / 2),\r\n		],\r\n	]);\r\n\r\n#### distinct\r\n\r\n与数组一起使用，验证字段中不允许出现重复值。\r\n\r\n	\'foo.*.id\' => \'distinct\'\r\n\r\n#### email\r\n\r\n验证字段必须是正确的邮件地址格式。\r\n\r\n#### exists:table,column\r\n\r\n验证字段必须存在于给定的数据库表中。\r\n\r\n#### `exists` 规则的基本使用\r\n\r\n	\'state\' => \'exists:states\'\r\n\r\n#### 指定自定义列名\r\n\r\n	\'state\' => \'exists:states,abbreviation\'\r\n\r\n有时，在 `exists` 语句里还需要指定数据库连接。这时，使用 `连接.表名` 的形式来实现此目的：\r\n\r\n	\'email\' => \'exists:connection.staff,email\'\r\n\r\n如果要自定义规则，使用 `Rule` 类。在这个例子中，我们将验证规则指定为数组，就不用使用 `|` 分隔符了。\r\n\r\n	use Illuminate\\Validation\\Rule;\r\n\r\n	Validator::make($data, [\r\n		\'email\' => [\r\n			\'required\',\r\n			Rule::exists(\'staff\')->where(function ($query) {\r\n				$query->where(\'account_id\', 1);\r\n			}),\r\n		],\r\n	]);\r\n\r\n#### file\r\n\r\n验证字段必须必须是一个有效的上传文件。\r\n\r\n#### filled\r\n\r\n当验证字段存在的时候，不能为空。\r\n\r\n#### image\r\n\r\n验证字段必须是图片（jpeg、png、bmp、gif 或者 svg）。\r\n\r\n#### in:foo,bar,...\r\n\r\n验证字段值必须包含在给定的值列表中。由于此规则需要 `implode`数组，所以这时可以用 `Rule::in` 方法来构造这个规则：\r\n\r\n	use Illuminate\\Validation\\Rule;\r\n\r\n	Validator::make($data, [\r\n		\'email\' => [\r\n			\'required\',\r\n			Rule::in([\'first-zone\', \'second-zone\']),\r\n		],\r\n	]);\r\n\r\n#### in_array:anotherfield\r\n\r\n验证字段值必须存在于另一个字段的值列表中。\r\n\r\n#### integer\r\n\r\n验证字段值必须是个整数。\r\n\r\n#### ip\r\n\r\n验证字段值必须是一个 IP 地址。\r\n\r\n#### ipv4\r\n\r\n验证字段值必须是一个 IPv4 地址。\r\n\r\n#### ipv6\r\n\r\n验证字段值必须是一个 IPv6 地址。\r\n\r\n#### json\r\n\r\n验证字段值必须是一个 JSON 字符串。\r\n\r\n#### max:value\r\n\r\n验证字段的大小必须在小于或者等于给定的值。 支持字符串、数字、数组和文件的大小比较，比较规则参考 `size` 规则。\r\n\r\n#### mimetypes:text/plain,...\r\n\r\n验证文件必须是符合给定 MIME 类型之一的：\r\n\r\n	\'video\' => \'mimetypes:video/avi,video/mpeg,video/quicktime\'\r\n\r\n为了确定上传文件的 MIME 类型，Laravel 将读取文件内容，尝试猜测 MIME 类型，这可能与客户端提供的 MIME 类型不同。\r\n\r\n#### mimes:foo,bar,...\r\n\r\n验证文件必须具有与列出的其中一个扩展名相对应的 MIME 类型。\r\n\r\n#### `mimes` 规则的基本使用\r\n\r\n	\'photo\' => \'mimes:jpeg,bmp,png\'\r\n\r\n虽然我们指定的是扩展名，但是规则实际验证的是文件的 MIME 类型，文件的 MIME 类型是通过读取文件内容，尝试猜测到的 MIME 类型。\r\n\r\n完整的 MIME 类型和对应扩展名对照表参阅 [这里][2] 的地址。\r\n\r\n#### min:value\r\n\r\n验证字段的大小必须在大于或者等于给定的值。 支持字符串、数字、数组和文件的大小比较，比较规则参考 `size` 规则。\r\n\r\n#### nullable\r\n\r\n验证字段可取 `null` 值，这对于可取到 `null` 值的、像字符串和整数这样的基本类型的验证比较有用。\r\n\r\n#### not_in:foo,bar,...\r\n\r\n验证字段值**必须不**包含在给定的值列表中。可以用 `Rule::notIn` 方法来流畅地构造规则。\r\n\r\n	use Illuminate\\Validation\\Rule;\r\n\r\n	Validator::make($data, [\r\n		\'email\' => [\r\n			\'required\',\r\n			Rule::notIn([\'sprinkles\', \'cherries\']),\r\n		],\r\n	]);\r\n\r\n#### numeric\r\n\r\n验证字段值必须是数字。\r\n\r\n#### present\r\n\r\n验证字段必须出现在输入数据中，且值可以为空。\r\n\r\n#### regex:pattern\r\n\r\n验证字段必须匹配给定的正则表达式。\r\n\r\n**注意**：最好将验证规则包含在一个数组里，而不是使用管道符号（`|`）连接，这在正则表达式本身包含 `|` 的情况特别有用。\r\n\r\n#### required\r\n\r\n验证字段必须出现在输入数据中，且值不可为空。在 Laravel 中，一个字段值满足下面任一条件都被视为空值。\r\n\r\n* `null`。\r\n* 空字符串（`\'\'`）。\r\n* 空数组（`[]`）或者空 `Countable` 对象。\r\n* 无路径的上传文件。\r\n\r\n#### required_if:anotherfield,value,...\r\n\r\n验证字段必须出现在输入数据中，且值不可为空，这是有条件的：当另一个字段等于值列表里的任何一个值时。\r\n\r\n#### required_unless:another,value,...\r\n\r\n与 `required_if`相反，除了另一个字段等于值列表里的任何一个值时之外的情况时，当前验证字段才要求必须出现在输入数据中，且值不可为空。\r\n\r\n#### required_with:foo,bar,...\r\n\r\n只有当其他任何一个字段出现的时候，当前验证字段才要求必须出现在输入数据中，且值不可为空。\r\n\r\n#### required_with_all:foo,bar,...\r\n\r\n只有当其他所有字段出现的时候，当前验证字段才要求必须出现在输入数据中，且值不可为空。\r\n\r\n#### required_without:foo,bar,...\r\n\r\n只有当其他任何一个字段不出现的时候，当前验证字段才要求必须出现在输入数据中，且值不可为空。\r\n\r\n#### required_without_all:foo,bar,...\r\n\r\n只有当其他所有字段不出现的时候，当前验证字段才要求必须出现在输入数据中，且值不可为空。\r\n\r\n#### same:field\r\n\r\n当前验证字段值必须等于给定的这个字段值。\r\n\r\n#### size:value\r\n\r\n验证字段必须是与给定值一样的大小。对于字符串数据，value 是指字符数量；对于数字数据，value 是指数值；对于数组数据，value 是指数组的 `count` 值；对于文件，value 是指文件有多少 KB。\r\n\r\n#### string\r\n\r\n验证字段必须是一个字符串，如果可以取值 `null`，再加上 `nullable` 规则就 OK 了。\r\n\r\n#### timezone\r\n\r\n验证字段值是能被 PHP `timezone_identifiers_list` 函数识别的时区标识符。\r\n\r\n#### unique:table,column,except,idColumn\r\n\r\n验证字段值在数据库表里是唯一的。如果没指定 `column`，就使用验证字段名。\r\n\r\n#### 指定自定义列名\r\n\r\n	\'email\' => \'unique:users,email_address\'\r\n\r\n#### 自定义数据库连接\r\n\r\n有时需要为验证器的数据库查询指定自定义连接。`unique:users` 会使用默认的数据库连接查询数据库。需要使用 `连接.数据库表` 的形式覆盖使用得默认连接：\r\n\r\n	\'email\' => \'unique:connection.users,email_address\'\r\n\r\n#### 强制 `unique` 规则忽略指定的 ID\r\n\r\n有时，进行 `unique` 检查时，需要忽略一个 ID 值。例如，「更新用户资料」时，更新的字段包括用户名、邮箱地址和位置。你要验证邮箱地址是否是唯一的，但是如果用户只是更新了用户名，没有更新邮箱地址，那么提交后，就会验证错误的，因为用户已经是邮箱地址的所有者了。\r\n\r\n为了忽略检查用户 ID 的对应的那个邮箱地址，这里要使用 `Rule` 去定义这个规则。\r\n\r\n\r\n	use Illuminate\\Validation\\Rule;\r\n\r\n	Validator::make($data, [\r\n	    \'email\' => [\r\n	        \'required\',\r\n	        Rule::unique(\'users\')->ignore($user->id),\r\n	    ],\r\n	]);\r\n\r\n	// 等同于\r\n\r\n	Validator::make($data, [\r\n	    \'email\' => [\r\n	        \'required\',\r\n	        \"unique:users,email,{ $user->id }\"\r\n	    ],\r\n	]);\r\n\r\n如果表格主键不是 `id`。可以为 `ignore` 方法指定要忽略的那个列名：\r\n\r\n	\'email\' => Rule::unique(\'users\')->ignore($user->id, \'user_id\');\r\n\r\n	// 等同于\r\n\r\n	\'email\' => \"unique:users,email,{ $user->id },user_id\";\r\n\r\n#### 添加额外的 Where 子句\r\n\r\n可以通过自定义 `where` 子句添加额外的查询约束。例如，我们添加约束 `account_id` 值为 1。\r\n\r\n	\'email\' => Rule::unique(\'users\')->where(function ($query) {\r\n		$query->where(\'account_id\', 1);\r\n	});\r\n\r\n### url\r\n\r\n验证字段值必须是一个有效的 URL。\r\n\r\n## 有条件的添加规则\r\n\r\n#### 当存在的时候验证\r\n\r\n在一些场景中，**只有** 当字段存在于输入数组里才去验证它。为了实现这个功能，我们在规则里使用 `sometimes`：\r\n\r\n	$v = Validator::make($data, [\r\n		\'email\' => \'sometimes|required|email\',\r\n	]);\r\n\r\n在上面的例子，只有当字段存在于 `$data` 数组中时，才去验证它。\r\n\r\n*在我看来没必要，同样的功能需求用 `filled` 规则就能实现*。\r\n\r\n	\'email\' => \'filled|email\'\r\n\r\n#### 复杂条件验证\r\n\r\n有时，需要基于更加复杂的条件逻辑添加验证规则。例如，当另一个字段的值大于 100 的时候，当前字段才是 `required` 的；或者有两个字段，只有在另一个字段存在的情况下，才能确定所取的数据类型。这些都不难。首先，创建一个 `Validator` 实例先设定那些验证规则不变的字段：\r\n\r\n	$v = Validator::make([\r\n		\'email\' => \'required|email\',\r\n		\'games\' => \'required|numeric\',\r\n	]);\r\n\r\n设想一下我们有一个为游戏收藏者提供服务的网站。在我们的用户注册的时候，我们想让游戏收藏超过 100 个的用户解释为什么会拥有这么多的游戏。例如，也许他们在运营一家游戏专售店，或者只是因为单纯的喜欢。为了有条件地添加此要求，我们可以在 `Validator` 实例上使用 `sometimes` 方法。\r\n\r\n	$v->sometimes(\'reason\', \'required|max:500\', function ($input) {\r\n		return $input->games >= 100;\r\n	});\r\n\r\n`sometimes` 方法的一地个参数是验证字段；第二个参数是要添加的验证规则；第三个参数是一个闭包，当闭包返回 `true` 时，就会使用验证规则。这种方法使得构建复杂的条件验证变得轻而易举。 你甚至可以同时为几个字段添加条件验证：\r\n\r\n	$v->sometimes([\'reason\', \'cost\'], \'required\', function ($input) {\r\n		return $input->games >= 100;\r\n	});\r\n\r\n> 提示！ 传递给闭包的参数 `$input` 是 `Illuminate\\Support\\Fluent` 实例，用来获得输入和文件。\r\n\r\n## 验证数组字段\r\n\r\n我们使用点（`.`）符号来验证数组类型字段。例如，如果传入的 HTTP 请求中包含 `photos[profile]` 字段，则可以如下验证：\r\n\r\n	$validator = Validator::make($request->all(), [\r\n	    \'photos.profile\' => \'required|image\',\r\n	]);\r\n\r\n你也可以验证数组里的每个元素。例如，验证每个元素的邮箱地址都是唯一的：\r\n\r\n	$validator = Validator::make($request->all(), [\r\n	    \'person.*.email\' => \'email|unique:users\',\r\n	    \'person.*.first_name\' => \'required_with:person.*.last_name\',\r\n	]);\r\n\r\n同样，在语言文件 `resources/lang/xx/validation.php` 中的 `custom` 数组里也可以使用 `*` 来添加自定义消息，这样就可以基于数组字段进行验证了。\r\n\r\n	\'custom\' => [\r\n	    \'person.*.email\' => [\r\n	        \'unique\' => \'Each person must have a unique e-mail address\',\r\n	    ]\r\n	],\r\n\r\n## 自定义验证规则\r\n\r\n### 使用 `Rule` 对象\r\n\r\nLaravel 已然提供了大量丰富有用的验证规则。但有时还是要定义自己的验证规则，这时要使用 `Rule` 对象，使用 Artisan 命令 `make:rule` 生产它。我们以检查字符串是否全部大写为例，自定义规则对象被放在 `app/Rules` 目录下：\r\n\r\n	php artisan make:rule Uppercase\r\n\r\n规则类创建好后，接下来定义它的行为。一个规则类中包含两个方法：`passes` 和 `message`。`passes` 方法接收属性名和属性值，根据最终属性值的验证结果，返回 `true` 或 `false`。`message` 方法返回验证失败时的错误消息。\r\n\r\n	<?php\r\n\r\n	namespace App\\Rules;\r\n\r\n	use Illuminate\\Contracts\\Validation\\Rule;\r\n\r\n	class Uppercase implements Rule\r\n	{\r\n	    /**\r\n	     * Determine if the validation rule passes.\r\n	     *\r\n	     * @param  string  $attribute\r\n	     * @param  mixed  $value\r\n	     * @return bool\r\n	     */\r\n	    public function passes($attribute, $value)\r\n	    {\r\n	        return strtoupper($value) === $value;\r\n	    }\r\n\r\n	    /**\r\n	     * Get the validation error message.\r\n	     *\r\n	     * @return string\r\n	     */\r\n	    public function message()\r\n	    {\r\n	        return \'The :attribute must be uppercase.\';\r\n	    }\r\n	}\r\n\r\n当然，错误消息也可以从语言文件里返回，使用 `trans` 辅助函数：\r\n\r\n	/**\r\n	 * Get the validation error message.\r\n	 *\r\n	 * @return string\r\n	 */\r\n	public function message()\r\n	{\r\n	    return trans(\'validation.uppercase\');\r\n	}\r\n\r\n规则类定义好后，你就可以像使用其它规则一样，在验证器里使用这个规则了。\r\n\r\n	use App\\Rules\\Uppercase;\r\n\r\n	$request->validate([\r\n	    \'name\' => [\'required\', new Uppercase],\r\n	]);\r\n\r\n### 使用扩展\r\n\r\n另一种自定义验证规则的方法是使用 `Validator` 门面上的 `extend` 方法。我们需要在服务提供者里注册这个自定义规则：\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use Illuminate\\Support\\ServiceProvider;\r\n	use Illuminate\\Support\\Facades\\Validator;\r\n\r\n	class AppServiceProvider extends ServiceProvider\r\n	{\r\n	    /**\r\n	     * Bootstrap any application services.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function boot()\r\n	    {\r\n	        Validator::extend(\'foo\', function ($attribute, $value, $parameters, $validator) {\r\n	            return $value == \'foo\';\r\n	        });\r\n	    }\r\n\r\n	    /**\r\n	     * Register the service provider.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function register()\r\n	    {\r\n	        //\r\n	    }\r\n	}\r\n\r\n自定义验证器的闭包里接收 4 个参数：验证的属性名、验证的属性值、传递给规则的 `$parameters` 数组和 `Validator` 实例对象。\r\n\r\n当然，也可以选择给 `extend` 方法传递一个类和方法的形式代替闭包：\r\n\r\n	Validator::extend(\'foo\', \'FooValidator@validate\');\r\n\r\n#### 定义错误消息\r\n\r\n你需要为自定义规则定义错误消息，你可以使用内联自定义消息数组或者在语言文件里定义。这个消息应该放在顶层的那个数组里，而不是在 `custom` 数组里（这里是为规则属性指定错误消息的）。\r\n\r\n	\"foo\" => \"Your input was invalid!\",\r\n\r\n	\"accepted\" => \"The :attribute must be accepted.\",\r\n\r\n	// The rest of the validation error messages...\r\n\r\n在创建一个自定义的验证规则时，你有时可能需要为错误消息自定义占位符。这要使用 `Validator` 门面的 `replacer` 方法。你可以在服务提供者的 `boot` 里写这个。\r\n\r\n	/**\r\n	 * Bootstrap any application services.\r\n	 *\r\n	 * @return void\r\n	 */\r\n	public function boot()\r\n	{\r\n	    Validator::extend(...);\r\n\r\n	    Validator::replacer(\'foo\', function ($message, $attribute, $rule, $parameters) {\r\n	        return str_replace(...);\r\n	    });\r\n	}\r\n\r\n#### 隐式扩展\r\n\r\n默认情况下，被验证字段是个空值，使用的 `required` 规则、 、正常的验证规则，包括自定义扩展，就不再执行了。例如，对于 `null` 值，`unique` 规则不会执行。\r\n\r\n	$rules = [\'name\' => \'unique\'];\r\n\r\n	$input = [\'name\' => null];\r\n\r\n	Validator::make($input, $rules)->passes(); // true\r\n\r\n当被验证字段是个空值时，还希望继续执行规则，那就要写明这个规则属性是必需的。创建这「隐式」扩展，需使用 `Validator::extendImplicit()` 方法：\r\n\r\n	Validator::extendImplicit(\'foo\', function ($attribute, $value, $parameters, $validator) {\r\n	    return $value == \'foo\';\r\n	});\r\n\r\n> 警告！ 一个「隐式」扩展只意味着属性是必需的，实际上是采用无效缺失还是空属性，由你决定。\r\n\r\n[1]: https://laravel-china.org/articles/6165/laravel-document-read-http-session#闪存数据\r\n[2]: https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types','2017-09-23 02:00:58','2017-09-23 02:00:58','laravel-document-reading-validation-next'),(383,3,3,'Laravel 文档阅读：错误 & 日志记录','> 翻译、衍生自：https://laravel.com/docs/5.5/errors\r\n\r\n## 简介\r\n\r\nLaravel 项目里已经为你配置好了错误和异常处理。项目中的异常都是在 `App\\Exceptions\\Handler` 类中处理并渲染给用户的。接下来，我们将深入到该类中进行讲解。\r\n\r\nLaravel 是利用了 [Monolog][1] 这个库记录日志的，这个库里包含了大量的日志处理方法。Laravel 为你配置了这些处理方法，提供了单个日志文件、每日一个日志文件和将错误信息写入系统日志这几个选项供你选择。\r\n\r\n## 配置\r\n\r\n### 错误内容\r\n\r\n`config/app.php` 配置文件中的 `debug` 选项决定错误发生时，显示给用户看的内容是多啊还是少，是详细啊还是简略。默认，这个选项值优先使用 `.env` 文件里 `APP_DEBUG` 字段的设定值。\r\n\r\n对于本地开发环境，把 `APP_DEBUG` 设定为 `true`，而在生产环境，应该总是设置为 `false`。如果在生产环境开启了 Debug 模式，项目中的一些敏感信息就会暴露给终端用户的，后果可能不堪设想。\r\n\r\n### 日志存储\r\n\r\nLaravel 开箱支持以下几种日志记录设定：`single`、`daily`、`syslog` 和 `errorlog`。修改 `config/app.php` 配置文件中的 `log` 选项即可使用你想要的日志存储模式。例如，我们不希望日志都记录在一个文件里，而是一天的日志单独放在一个文件里，那么把 `log` 设定为 `daily` 即可：\r\n\r\n	\'log\' => \'daily\'\r\n\r\n#### 设定日志文件的最大数量\r\n\r\n使用 `daily` 日志模式时，默认 Laravel 只会保存最近 5 日的日志文件。如果要调整，要在 `config/app.php` 再添加个 `log_max_files` 字段指定即可：\r\n\r\n	\'log_max_files\' => 30\r\n\r\n### 日志安全级别\r\n\r\nLaravel 日志管理使用的是 Monolog 这个 PHP 日志库，Laravel 的 日志安全级别就是指 Monolog 所能支持的日志安全级别。由 `config/app.php` 的 `log_level` 字段值决定，默认是 `debug`。\r\n\r\nMonolog 日志安全级别从低到高分别是：`debug`、`info`、`notice`、`warning`、`error`、`critical`、`alert` 和 `emergency`。\r\n\r\n安全级别设定好后，Laravel 会记录包括当前级别在内、所有更高级别的日志类型。就是说，当你设定 `log_level` 的值为 `error` 的时候，被记录的消息范围包括：`error`、`critical`、`alert` 和 `emergency`。\r\n\r\n	\'log_level\' => env(\'APP_LOG_LEVEL\', \'error\'),\r\n\r\n### 自定义 Monolog 配置\r\n\r\n如果你想完全掌控 Monolog 在 Laravel 中的配置，可以使用 `$app` 的 `configureMonologUsing` 方法，这个方法是在 `bootstrap/app.php` 中返回 `$app` 之前调用。\r\n\r\n	$app->configureMonologUsing(function ($monolog) {\r\n	    $monolog->pushHandler(...);\r\n	});\r\n\r\n	return $app;\r\n\r\n#### 自定义频道名\r\n\r\n默认，Monolog 初始化采用的名称与当前环境一致，比如 `production` 或者 `local`。如果需要自定义，要在 `config/app.php` 添加一个 `log_channel` 选项。\r\n\r\n	\'log_channel\' => env(\'APP_LOG_CHANNEL\', \'my-app-name\'),\r\n\r\n## 异常处理程序\r\n\r\n### `report` 方法\r\n\r\n所有异常都是由 `App\\Exceptions\\Handler` 类处理的，这个类中包含两个方法：`report` 和 `render`，我们将分别介绍。`report` 方法用来记录异常，或者将异常日志发送给像 Bugsnnag、Sentry 这样的第三方服务。默认，`report` 方法会简单地把异常直接传递给基类，让基类处理记录日志的操作。当然，记录日志的方式你也可以自在设定。\r\n\r\n例如，我们使用 PHP `instanceof` 比较操作符，根据异常实例的类型记录异常。\r\n\r\n	/**\r\n	 * Report or log an exception.\r\n	 *\r\n	 * This is a great spot to send exceptions to Sentry, Bugsnag, etc.\r\n	 *\r\n	 * @param  \\Exception  $exception\r\n	 * @return void\r\n	 */\r\n	public function report(Exception $exception)\r\n	{\r\n	    if ($exception instanceof CustomException) {\r\n	        //\r\n	    }\r\n\r\n	    return parent::report($exception);\r\n	}\r\n\r\n#### `report` 辅助函数\r\n\r\n有时，需要在报告异常的同时接着出来当前的请求，全局 `report` 辅助函数就是做这个的，它在报告异常的时候，不会产生异常页面。\r\n\r\n	public function isValid($value)\r\n	{\r\n	    try {\r\n	        // Validate the value...\r\n	    } catch (Exception $e) {\r\n	        report($e);\r\n\r\n	        return false;\r\n	    }\r\n	}\r\n\r\n#### 忽略的异常类型\r\n\r\n异常处理器中的 `dontReport` 数组属性，用来设定不被处理的异常类型。例如，例如，404 错误导致的异常以及其他几个类型的错误不会写入日志文件。\r\n\r\n	/**\r\n	 * A list of the exception types that should not be reported.\r\n	 *\r\n	 * @var array\r\n	 */\r\n	protected $dontReport = [\r\n	    \\Illuminate\\Auth\\AuthenticationException::class,\r\n	    \\Illuminate\\Auth\\Access\\AuthorizationException::class,\r\n	    \\Symfony\\Component\\HttpKernel\\Exception\\HttpException::class,\r\n	    \\Illuminate\\Database\\Eloquent\\ModelNotFoundException::class,\r\n	    \\Illuminate\\Validation\\ValidationException::class,\r\n	];\r\n\r\n### `render` 方法\r\n\r\n`render` 方法负责将一个异常转换为发送给浏览器的 HTTP 响应。默认传递给基类的异常都会被处理成一个响应，你或者可以根据异常类型类自定义异常响应界面。\r\n\r\n	/**\r\n	 * Render an exception into an HTTP response.\r\n	 *\r\n	 * @param  \\Illuminate\\Http\\Request  $request\r\n	 * @param  \\Exception  $exception\r\n	 * @return \\Illuminate\\Http\\Response\r\n	 */\r\n	public function render($request, Exception $exception)\r\n	{\r\n	    if ($exception instanceof CustomException) {\r\n	        return response()->view(\'errors.custom\', [], 500);\r\n	    }\r\n\r\n	    return parent::render($request, $exception);\r\n	}\r\n\r\n### 拥有 `report` 和 `render` 方法的异常类\r\n\r\n如果异常类中包含了 `report` 和 `render`，这就避免了我们在 `Handler` 类中检查异常类型，然后 report 和 render 异常带来的麻烦。这两个方法会在异常发生时，自动被框架调用：\r\n\r\n	<?php\r\n\r\n	namespace App\\Exceptions;\r\n\r\n	use Exception;\r\n\r\n	class RenderException extends Exception\r\n	{\r\n	    /**\r\n	     * Report the exception.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function report()\r\n	    {\r\n	        //\r\n	    }\r\n\r\n	    /**\r\n	     * Render the exception into an HTTP response.\r\n	     *\r\n	     * @param  \\Illuminate\\Http\\Request\r\n	     * @return \\Illuminate\\Http\\Response\r\n	     */\r\n	    public function render($request)\r\n	    {\r\n	        return response(...);\r\n	    }\r\n	}\r\n\r\n## HTTP 异常\r\n\r\n你可以使用全局辅助函数 `abort` 直接在程序里抛出异常，比如「页面未找到」的 404 错误，「未认证」 的 401 错误，甚至是 500 「程序内部错误」。\r\n\r\n	abort(404);\r\n\r\n`abort` 抛出的异常会立即被 `Handler` 处理，渲染成错误页面。你也可以使用第二个可选参数，设置响应文本。\r\n\r\n	abort(403, \'Unauthorized action.\');\r\n\r\n### 自定义 HTTP 错误页面\r\n\r\n根据 HTTP 状态码来显示对应的错误页面，在 Laravel 中操作起来非常简单。比如，你要为 404 HTTP 状态码指定一个错误页面，创建 `resources/views/errors/404.blade.php` 文件即可，当 404 异常发生时，会自动采用这个页面。就是说你在 `resources/views/errors/` 目录下，直接以 HTTP 状态码定义的文件，最终都会在对应异常发生时采用、并渲染出来。`abort` 函数产生的 `HttpException` 实例对象会以 `$exception` 变量的形式传递给视图。\r\n\r\n	<h2>{{ $exception->getMessage() }}</h2>\r\n\r\n## 日志记录\r\n\r\nLaravel 在强大的 Monolog 库之上提供了一个简单的抽象层。默认，Laravel 是在 `storage/logs` 目录下创建日志文件的。你可以使用 Log 门面记录日志。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use App\\User;\r\n	use Illuminate\\Support\\Facades\\Log;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class UserController extends Controller\r\n	{\r\n	    /**\r\n	     * Show the profile for the given user.\r\n	     *\r\n	     * @param  int  $id\r\n	     * @return Response\r\n	     */\r\n	    public function showProfile($id)\r\n	    {\r\n	        Log::info(\'Showing user profile for user: \'.$id);\r\n\r\n	        return view(\'user.profile\', [\'user\' => User::findOrFail($id)]);\r\n	    }\r\n	}\r\n\r\n咱们的 Log 提供了在 [RFC 5424][2] 定义的 8 个日志等级，分别是： emergency、alert、critical、error、warning、notice、info 和 debug。\r\n\r\n	Log::emergency($message);\r\n	Log::alert($message);\r\n	Log::critical($message);\r\n	Log::error($message);\r\n	Log::warning($message);\r\n	Log::notice($message);\r\n	Log::info($message);\r\n	Log::debug($message);\r\n\r\n#### 文本信息\r\n\r\n也可以给 Log 的这些方法传递可选的文本信息，这些信息会被格式化，输出在日志信息中。\r\n\r\n	Log::info(\'User failed to login.\', [\'id\' => $user->id]);\r\n\r\n#### 获得底层 Monolog 实例对象\r\n\r\nMonolog 还有许多其他的日志处理方法，如果需要，你可以直接访问底层的 Monolog 实例对象：\r\n\r\n	$monolog = Log::getMonolog();\r\n\r\n[1]: https://github.com/Seldaek/monolog\r\n[2]: https://tools.ietf.org/html/rfc5424','2017-09-23 12:09:18','2017-09-24 07:12:11','laravel-document-reading-error'),(384,3,3,'user-select 和 ::selection','选中文字的背景色：\r\n\r\n	p::selection {\r\n		background: blue;\r\n	}\r\n\r\n禁止用户选中：\r\n\r\n	p {\r\n		user-select: none;\r\n	}','2017-09-24 00:24:47','2017-09-24 00:24:47','the-user-to-select-and-selection'),(385,3,3,'链接样式的应用顺序','a:link、a:visited、a:hover、a:focus、a:active。','2017-09-26 01:55:46','2017-09-26 01:55:46','the-application-of-link-style-order'),(386,3,3,':target ---- 当前活动的目标元素','浏览器地址栏 URL 后面跟有 **锚地址 `#comment`**：\r\n\r\n	demo.html#comment\r\n\r\n它表示指向文档中的元素 `#comment`：\r\n\r\n	<div id=\"comment\">评论内容。</div>\r\n\r\n此时，元素 `div#comment` 就是活动状态的 **目标元素**。\r\n\r\n为活动状态的目标元素设置样式，使用 `:target` 伪类：\r\n\r\n	#comment {\r\n		background: red;\r\n	}\r\n\r\n当我们在浏览器地址栏 URL 中输入 `demo.html#comment`，就看到背景变为红色的评论区域了。','2017-09-26 02:07:48','2017-09-26 02:07:48','the-goal-of-target-the-current-active-elements'),(387,3,3,'CSS 属性选择器','根据元素的属性及属性值来选择元素：\r\n\r\n| 选择器 |描述 |\r\n| -------- | -------- |\r\n| [attribute]     | 获得带有指定属性的元素     |\r\n| [attribute=value]     | 获得带有指定属性和属性值的元素     |\r\n| [attribute~=value]     | 获得属性值中带有指定单词的元素     |\r\n| [attribute\\|=value]     | 获得以指定值开头的属性元素，该值是一个单词     |\r\n| [attribute^=value]     | 获得以指定值开头的属性元素     |\r\n| [attribute$=value]     | 获得以指定值结尾的属性元素     |\r\n| [attribute\\*=value]     | 获得属性值中包含指定值的属性元素     |','2017-09-26 02:26:39','2017-09-26 02:26:54','css-attribute-selectors'),(388,3,3,'不透明度属性：opacity','属性 `opacity`，英文含义是「不透明度」，用来设置元素的透明度效果。\r\n\r\n	.foo {\r\n		opacity: 1\r\n	}\r\n\r\n表示元素完全不透明，完全实心的。\r\n\r\n	.foo {\r\n		opacity: 0\r\n	}\r\n\r\n表示元素完全透明，你看不见。','2017-09-26 02:38:26','2017-09-29 09:15:29','opacity-properties-opacity'),(389,3,3,'JS 字符串和字符串方法','字符串的 `.length` 属性只能读，不想写。\r\n\r\n	\'张宝\'.length // 2\r\n	\'zb\'.length   // 2\r\n\r\n* String.prototype.charAt(index)：通过索引找字符。返回值是字符串。\r\n\r\n		\'张宝\'.charAt(0) // \"张\"\r\n		\'张宝\'.charAt()  // \"张\"\r\n		\'张宝\'.charAt(2) // \"\"\r\n\r\n* String.prototype.charCodeAt(index)：通过索引找字符，找到后转换为 Unicode 编码。返回值是数字或者 NaN。\r\n\r\n		\'张宝\'.charAt(0)   // 24352\r\n		\'张宝\'.charAt()    // 24352\r\n		\'张宝a\'.charAt(2)  // 97\r\n		\'张宝\'.charAt(2)   // NaN\r\n\r\n* String.prototype.indexOf(searchValue[, fromIndex])：通过字符找索引（从左到右第一个匹配的字符位置）。没找到返回 -1。\r\n\r\n* String.prototype.lastIndexOf(searchValue[, fromIndex])：通过字符找索引（从右到左第一个匹配的字符位置）。没找到返回 -1。\r\n\r\n* String.prototype.slice(beginIndex[, endIndex])。返回截取的字符串，从 `beginIndex`（包括） 到 `endIndex`（不包括）。可以接收负值（最后一个字符位置对应 -1，倒数第二个字符对应 -2，...），但是第二个参数要大于第一个参数值。\r\n\r\n		\'zhangbao\'.slice(1, 6) // \"hangb\"\r\n		\'zhangbao\'.slice()     // \"zhangbao\"\r\n		\'zhangbao\'.slice(1)    // \"hangbao\"\r\n\r\n		\'zhangbao\'.slice(-3, -2) // \"b\"     \r\n\r\n* String.prototype.split([separator[, limit]])：用指定的分隔符把字符串转换为数组。\r\n\r\n		\'zhangbao\'.split()     // [\'zhangbao\']\r\n		\'zhangbao\'.split(\'\')   // [ \"z\", \"h\", \"a\", \"n\", \"g\", \"b\", \"a\", \"o\" ]\r\n		\'zhang bao\'.split(\' \') // [ \"zhang\", \"bao\" ]\r\n\r\n		\'zhangbao\'.split(\'a\')  // [ \"zh\", \"ngb\", \"o\" ]\r\n\r\n* String.prototype.substring(indexStart, [indexEnd])：返回截取的字符串。除了**不接受负值**，作用跟 `slice` 方法完全一样。另外，对于合法的参数值，该方法还会把不合理的参数调换位置，然后截取字符。\r\n\r\n		\'zhangbao\'.substring(-3, -2) // \"\"    \r\n\r\n		\'zhangbao\'.substring(4, 2)\r\n		// 等同于\r\n		\'zhangbao\'.substring(2, 4) // \"an\"\r\n\r\n* String.prototype.substr(startIndex[, length])：从开始的索引算起（包含），截取长度为 `length` 的字符串，并返回。\r\n\r\n\r\n		\'zhangbao\'.substr(2, 4)  // \"angb\"\r\n		\'zhangbao\'.substr(2)     // \"angbao\"\r\n		\'zhangbao\'.substr(-2)    // \"ao\"\r\n\r\n* String.prototype.toLowerCase()：把字符串转换为全小写形式。没有参数。\r\n\r\n* String.prototype.toUpperCase()：把字符串转换为全大写形式。没有参数。\r\n\r\n* String.prototype.trim()：去掉字符串的首尾空格。没有参数。\r\n\r\n上面这些方法，都不会影响原字符串的值。','2017-09-26 09:22:11','2017-09-27 06:35:54','js-strings-and-string-method'),(390,3,3,'JSON 字符串','JSON 字符串用双引号（`\"\"`）包围，每条数据以键值对表示，键都用双引号包围，值不一定。然后数据之间用逗号（`,`）隔开。\r\n\r\n用处：JS 与后端进行数据交互时使用。\r\n\r\nJSON 对象上有两个方法：\r\n\r\n* `JSON.parse(text)`：将 JSON 格式的字符串转换为 JSON 对象。\r\n\r\n* ` JSON.stringify(value)`：把一个对象转换为一个 JSON 字符串。','2017-09-26 09:23:10','2017-09-26 09:23:39','json-string'),(391,3,3,'YDNJS（上卷）：this 的绑定对象','> 函数中的 `this` 是在调用时被绑定的，`this` 指向谁完全取决于函数的调用位置。\r\n\r\n确定 `this` 的绑定对象的方式有 4 种。\r\n\r\n## 默认绑定\r\n\r\n默认绑定就是将函数中的 `this` 绑定给了全局对象 `window`。这往往适用于我们调用函数时，不带有任何修饰的情况。\r\n\r\n	function foo() {\r\n		console.log(this.a);\r\n	}\r\n	\r\n	var a = 2;\r\n	\r\n	foo(); // 2\r\n\r\n我们调用函数 `foo` 的方式是直接调用，所以函数执行时，函数中的 `this` 是指向全局对象 `window`， 取 `window` 对象的 `a` 属性，就是取全局变量 `a`，所以打印出的结果是 2。\r\n\r\n## 隐式绑定\r\n\r\n隐式绑定就是将函数作为对象属性调用。这时函数内部的 `this` 指向对象本身。\r\n\r\n	function foo() {\r\n		console.log(this.a);\r\n	}\r\n	\r\n	var obj = {\r\n		a: 2,\r\n		foo: foo\r\n	};\r\n\r\n	obj.foo(); // 2\r\n\r\n上面的代码中，我们以 `obj` 对象的属性形式，调用了 `foo` 函数，这时函数中的 `this` 就是对象 `obj`，`this.a` 就是 `obj.a`，自然就是 2 了。\r\n\r\n还有，对于隐式绑定，函数的调用位置是 **对象属性引用链中的最后一层**。\r\n\r\n	function foo() {\r\n		console.log(this.a);\r\n	}\r\n	\r\n	var obj2 = {\r\n		a: 42,\r\n		foo: foo\r\n	};\r\n	\r\n	var obj1 = {\r\n		a: 2,\r\n		obj2: obj2\r\n	};\r\n\r\n	obj1.obj2.foo(); // 42\r\n\r\n对象属性引用链中的最后一层是 `obj2`，`foo` 是它的一个属性，所以 `foo` 函数执行时，内部 `this` 指向 `obj2` 对象，所以打印结果是 42。\r\n\r\n## 显式绑定\r\n\r\n显示绑定就是使用函数的 `call()` 或者 `apply()` 方法，为执行的函数显式指定上下文执行对象，也就是显式指定执行函数内部的 `this` 指向的对象。\r\n\r\n函数的 `call()` 或者 `apply()` 方法接收的第一个参数是一个对象，在调用函数时会将这个对象绑定给 `this`。就是说是直接给 `this` 指定绑定的对象，因此称为显式绑定。\r\n\r\n	function foo() {\r\n		console.log(this.a);\r\n	}\r\n	\r\n	var obj = {\r\n		a: 2\r\n	};\r\n	\r\n	foo.call(obj); // 2\r\n\r\n## new 绑定\r\n\r\n在传统的面向类的语言中，「构造函数」是类中的一个特殊方法，在使用 `new` 初始化类实例时会被自动调用。\r\n\r\n需要清楚得是：**JavaScript 中 `new` 的机制与面向类的语言中的 `new` 完全不同**。\r\n\r\n在 JavaScript 中，根本就不存在「构造函数」，只有对函数的「构造调用」。JavaScript 中的所有函数都可以用 `new` 调用，这种函数调用称为对函数的「构造调用」。\r\n\r\n使用 `new` 来调用函数，或者说在对函数进行「构造调用」时，会自动执行下列步骤：\r\n\r\n1. 创建一个全新的对象。\r\n2. 新对象执行 `[[Prototype]]` 连接。\r\n3. 被调用函数中的 `this` 绑定到这个新对象。\r\n4. 如果函数没有返回其他对象，则返回这个新对象。\r\n\r\n下面是一个例子：\r\n\r\n	function foo() {\r\n		this.a = a;\r\n	}\r\n\r\n	var bar = new foo(2);\r\n\r\n	bar.a; // 2\r\n\r\n我们使用 `new` 来调用 `foo()` 时，会创建一个全新的对象，然后 `foo` 函数内部的 `this` 就会绑定到这个新对象上。\r\n\r\n## 优先级\r\n\r\n> new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定','2017-09-27 00:38:37','2017-09-27 02:46:22','ydnjs-coil-this-binding-object'),(392,3,3,'JS 回调函数的执行方式','且看下面的代码：\r\n\r\n	function foo() {\r\n		console.log(this.a);\r\n	}\r\n	\r\n	var obj = {\r\n		a: 2,\r\n		foo: foo\r\n	};\r\n	\r\n	var a = \'Oops, global\'; // a 是全局对象属性\r\n	\r\n	setTimeout(obj.foo, 100); // \"Oops, global\"\r\n\r\n定时执行计时器在 100 毫秒后，执行 `obj.foo` 所代表的函数内容，打印出全局变量 `a` 的值。\r\n\r\n原因何在？\r\n\r\nJavaScript 环境中内置的 `setTimeout()` 函数实现和下面的伪代码类似：\r\n\r\n	function setTimeout(fn, delay) {\r\n		// 等待 delay 毫秒\r\n		\r\n		fn();\r\n	}\r\n\r\n可以看到，`setTimeout` 函数等待 delay 毫秒后，执行的 `fn` 函数代表本例中的 `foo` 函数本身，属于直接调用函数，所以函数中的 `this` 就是指向全局 `window` 对象了。','2017-09-27 01:11:18','2017-09-27 01:11:18','js-callback-function-mode-of-execution'),(393,3,3,'JS 硬绑定介绍','所谓「硬绑定」，是绑定够强制，因为你根本修改不了。修改不了的是什么？就是内部被调用函数的上下文对象，也就是内部被调用函数中的 `this` 绑定到的对象。\r\n\r\n有一个函数\r\n\r\n	function foo() {\r\n		console.log(this.a);\r\n	}\r\n	\r\n我们需要把这个函数执行时的上下文对象绑定给 `obj`\r\n\r\n	var obj = {\r\n		a: 2\r\n	};\r\n\r\n这样一来，调用函数 `foo` 的结果总是会打印出 2。为了做到这个，我们需要借助一个外部函数（假设是 `bar`），在它的内部使用 `call()` 方法为函数 `foo` 指定被调用时的上下文对象。\r\n\r\n	var bar = function () {\r\n		foo.call(obj);\r\n	}\r\n\r\n这样我们调用 `bar` 时，总是会打印出 `obj.a` 的值了。\r\n\r\n	bar(); // 2\r\n	setTimeout(bar, 100); // 2\r\n\r\n我们看下最终完整的代码：\r\n\r\n	function foo() {\r\n		console.log(this.a);\r\n	}\r\n	\r\n	var obj = {\r\n		a: 2\r\n	};\r\n\r\n	var bar = function () {\r\n		foo.call(obj);\r\n	}\r\n	\r\n	bar(); // 2\r\n	setTimeout(bar, 100); // 2','2017-09-27 01:34:55','2017-09-27 01:34:55','js-hard-binding'),(394,3,3,'JS 硬绑定应用场景','硬绑定典型的应用场景是创建一个 **包裹函数**，负责接收参数并返回内部函数的调用结果。\r\n\r\n	function foo(something) {\r\n		return this.a + something;\r\n	}\r\n	\r\n	var obj = {\r\n		a: 2\r\n	};\r\n	\r\n	var bar = function () {\r\n		return foo.apply(obj, arguments);\r\n	}\r\n		\r\n	bar(3); // 5\r\n	\r\n\r\n这个包裹函数，我们还不能重复使用，因为绑定对象和调用函数写死了。下面再稍微改造一下，让包裹函数更具通用性：\r\n\r\n	function bind(fn, obj) {\r\n		return function () {\r\n			return fn.apply(obj, arguments);\r\n		};\r\n	}\r\n	\r\n	function foo(something) {\r\n		return this.a + something;\r\n	}\r\n	\r\n	var obj = {\r\n		a: 2\r\n	};\r\n	\r\n	// 接下来创建的 `bar` 函数是调用 `bind` 函数的返回结果，只不过绑定对象和调用函数都是动态添加的。\r\n	// 这样的话，绑定关系的操作（调用 `apply` 函数的地方）就可以复用了。\r\n	var bar = bind(foo, obj);\r\n	\r\n	bar(3); // 5\r\n	\r\n由于硬绑定是一种常用的模式，所以 ES5 提供了内置的方法 Function.prototype.bind，与我们自己实现的 `bind` 方法使用方式类似：\r\n\r\n	var bar = foo.bind(obj);\r\n	\r\n	bar(3); // 5','2017-09-27 02:15:45','2017-09-27 02:15:45','js-hard-binding-application-scenario'),(395,3,3,'Laravel 文档阅读：认证','> 翻译、衍生自：https://laravel.com/docs/5.5/authentication\r\n\r\n想要快速开始？在全新的 Laravel 项目中执行 Artisan 命令 `php artisan make:auth` 和 `php artisan migrate` 即可急速创建一个具有完整功能的认证系统脚手架代码。之后，在浏览器地址栏输入 `http://your-app.dev/register` 就能进入注册页面，完整的路由列表请使用 `php artisan route:list` 命令在控制台查看。  \r\n\r\n## 简介\r\n\r\n使用 Laravel 构建一个认证系统前所未有的简单，因为这个功能是开箱就准备好了的。认证相关功能的配置文件是 `config/app.php`。\r\n\r\n作为核心功能，Laravel 的认证由「guards」和「providers」组成。Guards 定义请求用户的认证方式。例如，使用了 `session` 驱动的 `web` Guard 就是用会话和 Cookie 的方式认证的。\r\n\r\nProvider 定义从持久化存储设备里获得用户信息的方式，Laravel 开箱提供 [Eloquent][1] 和数据库 [查询语句构造器][2] 两种驱动方式的 Provider。你也可以自定义其他的 Provider。\r\n\r\n如果你现在有些懵逼，没有关系！这些配置对于许多项目，都不需要修改，保持默认配置就行了。\r\n\r\n### 数据库注意事项\r\n\r\nLaravel 默认使用的 Provider 使用 Eloquent 驱动，对应的 Eloquent 模型是 `App\\User`。如果你项目里不使用 Eloquent 驱动，你还可以修改为使用 `database` 驱动，它是基于查询语句构造器查询的。\r\n\r\n`App\\User` 模型对应的数据库表中，要确保密码字段至少是 60 个字符长度，当然，保持默认的 255 字符长度是个不错的选择。\r\n\r\n同时，还要保证你的 `users` 表中包含一个可为空的、字符串类型（100 个字符长度）的 `remember_token` 字段，这个字段用来保存用户勾选「记住我」选项时的令牌值。\r\n\r\n## 快速上手\r\n\r\n在 Laravel 中已经预置了认证控制器，位于 `App\\Http\\Controllers\\Auth` 目录下。`RegisterController` 处理用户注册，`LoginController` 处理用户登录，`ForgortPasswordController` 发送密码重置链接，`ResetPasswordController` 处理重置密码逻辑。每个控制器都使用了 trait 引入必要的实现方法。对许多项目来说，你可以一点都不修改它们。\r\n\r\n### 路由\r\n\r\n执行下面这一条 Artisan 命令，就可以快速创建与认证功能相关的路由和视图文件。\r\n\r\n	php artisan make:auth\r\n\r\n在一个全新的 Laravel 项目中，这条命令会生成布局、登录和注册视图，还有认证系统使用的所有路由，一个 `HomeController`（让用户登录之后跳转到面板页面）。\r\n\r\n### 视图\r\n\r\n使用 `make:auth` 创建的视图文件包括 `resources/views/auth` 目录下的。同时，还有一个布局文件 `resources/views/layouts/app.balade.php`\r\n\r\n上面这些视图文件使用了 Boostrap 这个 CSS 框架，你也可以自定义使用的框架。\r\n\r\n### 认证\r\n\r\n现在路由、视图和控制器，数据库表都有了，开始用起来吧！注册新用户，然后登录进去。\r\n\r\n#### 自定义跳转路径\r\n\r\n当用户成功登录后，会跳转到 `/home` 地址，这个地址是在 `LoginController`、`RegisterController` 和 `ResetPasswordController` 中的 `redirectTo` 属性中设定的，你可以修改它，以满足你的需求。\r\n\r\n	protected $redirectTo = \'/\';\r\n\r\n如果在跳转时，还有一些通用的跳转逻辑要处理的话，那么就定义成一个 `redirectTo` 方法：\r\n\r\n	protected function redirectTo()\r\n	{\r\n	    return \'/path\';\r\n	}\r\n\r\n`redirectTo()` 的优先级高于 `redirectTo` 属性。\r\n\r\n#### 自定义认证字段\r\n\r\nLaravel 默认使用 `email` 作为认证关键字段，如果要自定义，在 `LoginController` 中定义一个 `username` 方法即可。例如，下面我们将 `name`（用户名）字段作为认证关键字段：\r\n\r\n	public function username()\r\n	{\r\n	    return \'name\';\r\n	}\r\n\r\n#### 自定义 Guard\r\n\r\n你也可以在认证和注册用户时，使用自定义「Guard」。然后在 `LoginController`、`RegisterController` 和 `ResetPasswordController` 中的 `guard` 方法里使用它（还方法返回一个 Guard 实例对象）。\r\n\r\n	use Illuminate\\Support\\Facades\\Auth;\r\n\r\n	protected function guard()\r\n	{\r\n	    return Auth::guard(\'guard-name\');\r\n	}\r\n\r\n#### 自定义验证/存储\r\n\r\n如果你需要修改注册页面的表单字段，或者要自定义保存用户到数据库里的逻辑，就需要修改 `RegisterController` 了。\r\n\r\n`RegisterController` 的 `validator` 方法验证从前台注册页面传递过来的表单字段，这里定义了对应字段的取值规则。你也可以按照需要修改这里定义的规则。\r\n\r\n`RegisterController` 的 `create` 方法用来在数据库中创建一个新的 `App\\User` 记录（也就是用户数据），使用 Eloquent ORM。你也可以根据需要修改。\r\n\r\n### 访问认证用户\r\n\r\n使用 `Auth` 门面访问认证用户。\r\n\r\n	use Illuminate\\Support\\Facades\\Auth;\r\n\r\n	// 获得当前认证用户\r\n	$user = Auth::user();\r\n\r\n	// 获得当前认证用户的 ID\r\n	$user = Auth::id();\r\n\r\n你也可以使用 `Illuminate\\Http\\Request` 实例访问认证用户。记住，在控制器方法里，`Request` 会被自动注入。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Http\\Request;\r\n\r\n	class ProfileController extends Controller\r\n	{\r\n	    /**\r\n	     * Update the user\'s profile.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @return Response\r\n	     */\r\n	    public function update(Request $request)\r\n	    {\r\n	        // $request->user() returns an instance of the authenticated user...\r\n	    }\r\n	}\r\n\r\n#### 判断是否是认证用户\r\n\r\n如果用户登录了当前系统，那么 `Auth` 门面的 `check` 方法会返回 `true`，否则返回 `false`。\r\n\r\n	use Illuminate\\Support\\Facades\\Auth;\r\n\r\n	if (Auth::check) {\r\n		// 用户已登录\r\n	}\r\n\r\n虽然这种方式能判断用户登录与否，但是一般不这么做，而是在路由定义或者控制器构造函数中使用中间件，判断用户登录与否。咱继续往下看。\r\n\r\n### 保护路由\r\n\r\n我们可以在定义路由的时候，顺便定义使用的中间件。Laravel 有一个 `auth` 中间件，在 `Illuminate\\Auth\\Middleware\\Authenticate` 这个地方，它是在 `App\\Http\\Kernel` 中注册的，就可以用来判断用户的登录/认证了吗。\r\n\r\n	Route::get(\'profile\', function () {\r\n		// 只有认证用户才能进来\r\n	})->middleware(\'auth\');\r\n\r\n当然，你也可以在控制器构造函数里附加中间件。\r\n\r\n	public function __construct()\r\n	{\r\n		$this->middleware(\'auth\');\r\n	}\r\n\r\n#### 指定 Guard\r\n\r\n为路由附加中间件的时候，可以为认证用户指定使用的 Guard，这里指定的 Guard 对应 `auth.php` 中 `guards` 数组选项中的 Key 之一。\r\n\r\n	public function __construct()\r\n	{\r\n		$this->middleware(\'auth:api\');\r\n	}\r\n\r\n### 登录节流\r\n\r\n如果你使用的是 Laravel 内置的 `LoginController` 类，它天然包含了 `Illuminate\\Foundation\\Auth\\ThrottlesLogins` trait。默认，如果用户经过几次失败的登录尝试后，只能再等 1 分钟后才能登录。该节流限制是以用户的用户名/邮箱号地址和 IP 地址作为唯一标识的。\r\n\r\n## 手动认证用户\r\n\r\n如果你不用 Laravel 提供的认证控制器。那么你需要直接使用 Laravel 认证类写认证逻辑了。不过别担心，不难。\r\n\r\n我们通过 `Auth` 门面访问 Laravel 的认证服务，使用 `attempt` 方法。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Support\\Facades\\Auth;\r\n\r\n	class LoginController extends Controller\r\n	{\r\n	    /**\r\n	     * Handle an authentication attempt.\r\n	     *\r\n	     * @return Response\r\n	     */\r\n	    public function authenticate()\r\n	    {\r\n	        if (Auth::attempt([\'email\' => $email, \'password\' => $hashedPassword])) {\r\n	            // Authentication passed...\r\n	            return redirect()->intended(\'dashboard\');\r\n	        }\r\n	    }\r\n	}\r\n\r\n`attempt` 方法接收的是验证字段键值对，提供的数据会用来在数据库表中查找。在上面的例子里，我们在数据库里查询 `email` 字段，如果找到用户，就会将数据库中存储的哈希密码与提供的哈希密码比较，如果一样的话，用户登录成功。\r\n\r\n用户登录成功，`attempt` 方法就会返回 `true`，否则返回 `false`。\r\n\r\n`redirect()` 函数返回一个 `Redirector` 实例对象，该对象的 `intended` 方法会在用户认证成功后，重定向到用户之前（未进入登录页面前）要去的那个 URL 地址。也可以为 `intended` 方法添加一个参数—— fallback URI —— 如果 `intended` 方法去到的那个 URL 无效，就使用这个 URL 地址。\r\n\r\n#### 指定额外条件\r\n\r\n你也可以在调用 `attempt` 方法的时候添加额外要验证的字段。例如，登录时我们顺便检查用户的「激活」状态，只查询激活用户。\r\n\r\n	if (Auth::attempt([\'email\' => $email, \'password\' => $password, \'active\' => 1])) {\r\n	    // The user is active, not suspended, and exists.\r\n	}\r\n\r\n这里登录使用的关键字段是 `email`，你可以在登录控制器中定义 `username` 方法，自行修改使用的关键字段。\r\n\r\n#### 访问特定的 Guard 实例\r\n\r\n你可以在使用 `Auth` 门面的 `guard` 方法时，指定使用的 Guard。就是说，你项目里的认证方式可以有好几种，因为每个 Guard 都有可能对应一中的认证方式，其背后对应的可能是一张数据库表或者是一个 Eloquent Model，它们完全可以单独组织成一个饱满的认证方式。\r\n\r\n比如，我们在 `auth.php` 中定义了一个 `admin` Guard，与 `web` Guard 不同的是，`admin` Guard 是从 `admin` 数据库表里获取认证用户数据的，而 `web` Guard 是从 `users` 数据库表里获取认证用户数据的。\r\n\r\n	if (Auth::guard(\'admin\')->attempt($credentials)) {\r\n	    //\r\n	}\r\n\r\n#### 注销\r\n\r\n注销账号，使用 `Auth` 门面的 `logout` 方法。该方法会从从会话里清除用户认证信息。\r\n\r\n	Auth::logout();\r\n\r\n### 记住用户\r\n\r\n如果你需要提供「记住我」的功能，就要为 `attempt` 方法传递第二个布尔值参数，它会永远记住用户，直到用户手动注销。当然，`users` 表中必须包含一个 `remember_token` 列，用来保存「记住我」产生的令牌。\r\n\r\n	if (Auth::attempt([\'email\' => $email, \'password\' => $password], $remember)) {\r\n	    // The user is being remembered...\r\n	}\r\n\r\n如果使用内置的 `LoginController` 处理登录，那么已经具备了「记住我」功能，这是在引入的 trait 中定义的。\r\n\r\n`Auth` 门面还提供一个 `viaRemember` 方法，用来判断认证用户是否是勾选了「记住我」功能的用户，如果是的话，就会返回 `true`，否则返回 `false`。\r\n\r\n	if (Auth::viaRemember()) {\r\n	    //\r\n	}\r\n\r\n### 其它认证方法\r\n\r\n#### 认证一个用户实例\r\n\r\n如果你已经有一个用户实例了，那么把它带入 `Auth::login` 方法的登录系统。这是因为 `App\\User` 模型实现了 `Illuminate\\Contracts\\Auth\\Authenticatable` 这个接口，所以才可以这样用：\r\n\r\n	Auth::login($user);\r\n\r\n	// 登录然后「记住」用户\r\n	Auth::login($user, true);\r\n\r\n当然，你也可以选择使用的 Guard 实例。\r\n	\r\n	Auth::guard(\'admin\')->login($user);\r\n\r\n#### 通过 ID 认证用户\r\n\r\n如果已知用户主键 ID，也可以登录系统。使用 `Auth::loginUsingId` 方法，它接收的是用户主键。\r\n\r\n	Auth::loginUsingId(1);\r\n\r\n	// 登录然后「记住」用户呀\r\n	Auth::loginUsingId(1, true);\r\n\r\n#### 针对单次请求的用户认证\r\n\r\n还可以使用 `Auth::once` 方法针对单次请求来认证用户，这种方式的认证不使用会话和 Cookie，这在构建无状态的 API 时非常有帮助：\r\n\r\n	if (Auth::once($credentials)) {\r\n		//\r\n	}\r\n \r\n## HTTP 基本认证\r\n\r\n[HTTP 基本认证][3] 提供了一种快速认证用户的方式（不需要额外的「登录」页面）。为了使用它，在路由上附加一个 `auth.basic` 中间件即可，这个中间件在 Laravel 中已经注册好了，你直接用就行。\r\n\r\n	Route::get(\'profile\', function () {\r\n		// 只有认证用户才能进来	\r\n	})->middleware(\'auth.basic\');\r\n\r\n定义好后，当你在浏览器中访问这个路由的时候，会出现一个弹框，让你填入用户名和密码。默认，`auth.basic` 中间件使用 `email` 作为登录的关键字段，你可以在 `LoginController` 中添加 `username` 方法覆盖此约定。\r\n\r\n#### 关于 FastCGI 的注意事项\r\n\r\n如果你是使用 PHP  FastCGI，HTTP 基础认证可能会不生效。这时，将下面的两行配置内容添加到 `.htaccess` 文件即可：\r\n\r\n	RewriteCond %{HTTP:Authorization} ^(.+)$\r\n	RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\r\n\r\n### 无状态 HTTP 基本认证\r\n\r\n你也可以在不借助会话和 Cookie 的情况下使用 HTTP 基本认证，用来作为 API 认证使用，这称为「无状态 HTTP 基本认证」。我们需要新定义一个中间件，在中间件里调用 `Auth` 门面的 `onceBasic` 方法，如果 `onceBasic` 没有返回响应，则允许请求的进一步处理。\r\n\r\n	<?php\r\n\r\n	namespace Illuminate\\Auth\\Middleware;\r\n\r\n	use Illuminate\\Support\\Facades\\Auth;\r\n\r\n	class AuthenticateOnceWithBasicAuth\r\n	{\r\n	    /**\r\n	     * Handle an incoming request.\r\n	     *\r\n	     * @param  \\Illuminate\\Http\\Request  $request\r\n	     * @param  \\Closure  $next\r\n	     * @return mixed\r\n	     */\r\n	    public function handle($request, $next)\r\n	    {\r\n	        return Auth::onceBasic() ?: $next($request);\r\n	    }\r\n\r\n	}\r\n\r\n接下里，我们在路由中使用该中间件：\r\n\r\n	Route::get(\'api/user\', function () {\r\n	    // 只有认证用户才能进来	\r\n	})->middleware(\'auth.basic.once\');\r\n\r\n## 添加自定义 Guard 驱动\r\n\r\n你可以使用 `Auth` 门面的 `extend` 方法自定义认证 Guard 驱动（需要传递 `provider`），这是在服务提供者中注册的。比如，你就可以在现有的 `AuthServiceProvider` 中注册。\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use App\\Services\\Auth\\JwtGuard;\r\n	use Illuminate\\Support\\Facades\\Auth;\r\n	use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n\r\n	class AuthServiceProvider extends ServiceProvider\r\n	{\r\n	    /**\r\n	     * Register any application authentication / authorization services.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function boot()\r\n	    {\r\n	        $this->registerPolicies();\r\n\r\n	        Auth::extend(\'jwt\', function ($app, $name, array $config) {\r\n	            // Return an instance of Illuminate\\Contracts\\Auth\\Guard...\r\n\r\n	            return new JwtGuard(Auth::createUserProvider($config[\'provider\']));\r\n	        });\r\n	    }\r\n	}\r\n\r\n可以看到，`extend` 方法的回调函数里返回的是 `lluminate\\Contracts\\Auth\\Guard` 的一个实现。`Guard` 这个接口里定义的方法，在你的自定义 Guard 驱动中都必须实现。之后，你就可以在 `auth.php` 配置文件中的 `guards` 选项中使用它了。\r\n\r\n	\'guards\' => [\r\n	    \'api\' => [\r\n	        \'driver\' => \'jwt\',\r\n	        \'provider\' => \'users\',\r\n	    ],\r\n	],\r\n\r\n## 添加自定义用户 Provider\r\n\r\n如果你不是使用关系型数据库保存用户数据，就需要实现自定义用户 Provider 驱动。这里会用到 `Auth` 门面的 `provider` 方法：\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use Illuminate\\Support\\Facades\\Auth;\r\n	use App\\Extensions\\RiakUserProvider;\r\n	use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n\r\n	class AuthServiceProvider extends ServiceProvider\r\n	{\r\n	    /**\r\n	     * Register any application authentication / authorization services.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function boot()\r\n	    {\r\n	        $this->registerPolicies();\r\n\r\n	        Auth::provider(\'riak\', function ($app, array $config) {\r\n	            // Return an instance of Illuminate\\Contracts\\Auth\\UserProvider...\r\n\r\n	            return new RiakUserProvider($app->make(\'riak.connection\'));\r\n	        });\r\n	    }\r\n	}\r\n\r\n然后就可以在 `auth.php` 配置文件中使用这个 Provider 驱动了。不过，首先要定义一个使用这个驱动的 Provider。\r\n\r\n	\'providers\' => [\r\n	    \'users\' => [\r\n	        \'driver\' => \'riak\',\r\n	    ],\r\n	],\r\n\r\n然后在 `guards` 配置中使用这个 Provider。\r\n\r\n### `UserProvider` 接口\r\n\r\n`Illuminate\\Contracts\\Auth\\UserProvider` 的实现仅负责从持久化存储设备中获取 `Illuminate\\Contracts\\Auth\\Authenticatable` 实现，这些持久化设备是指 MySQL，Riak 之类的系统。这两个接口允许 Laravel 认证机制，在无论用户数据如何被存储或使用什么类型的类来表示它的情况下，继续运行。\r\n\r\n我们来看下 `Illuminate\\Contracts\\Auth\\UserProvider` 接口：\r\n\r\n	<?php\r\n\r\n	namespace Illuminate\\Contracts\\Auth;\r\n\r\n	interface UserProvider {\r\n\r\n	    public function retrieveById($identifier);\r\n	    public function retrieveByToken($identifier, $token);\r\n	    public function updateRememberToken(Authenticatable $user, $token);\r\n	    public function retrieveByCredentials(array $credentials);\r\n	    public function validateCredentials(Authenticatable $user, array $credentials);\r\n\r\n	}\r\n\r\n`retrieveById` 方法接收的是用户主键，比如 MySQL 数据库里的自增 ID。最后返回匹配这个 ID 的 `Authenticatable` 的实现。\r\n\r\n`retrieveByToken` 方法接收的是用户主键和「记住我」令牌（对应 `remember_token` 字段值）。和 `retrieveById` 方法一样，`Authenticatable` 的实现。\r\n\r\n`updateRememberToken` 方法用新的 `$token` 值，更新 `$user` 的 `remember_token` 字段值。这个新的 `$token` 值可以来源于用户再次「记住我」的登录操作，或者是在注销账号时产生的。\r\n\r\n`retrieveByCredentials` 接收的是一个数组，这个数组数据最终是传递给 `Auth::attempt` 方法的认证字段数据。这个方法会使用 `where` 条件查询子句，使用  `$credentials[\'username\']` 的值在持久化设备里查询，并且返回一个 `Authenticatable` 实现。**此方法不应尝试进行任何密码验证或验证**。\r\n\r\n`validateCredentials` 会比较 `$user` 和给定的 `$credentials` 数组来认证用户，此方法会使用 `Hash::check` 来比较 `$user->getAuthPassword()` 与 `$credentials[\'password\']` 的值，并且返回一个布尔值 `true` 或者 `false`，表示提供的认证数据是否正确。\r\n\r\n### `Authenticatable` 接口\r\n\r\n现在我们来看 `UserProvider` 中的方法，先来看 `Authenticatable` 接口的方法。记住，Provider 应该从 `retrieveById` 和 `retrieveByCredentials` 方法中实现这个接口，\r\n\r\n	<?php\r\n\r\n	namespace Illuminate\\Contracts\\Auth;\r\n\r\n	interface Authenticatable {\r\n\r\n	    public function getAuthIdentifierName();\r\n	    public function getAuthIdentifier();\r\n	    public function getAuthPassword();\r\n	    public function getRememberToken();\r\n	    public function setRememberToken($value);\r\n	    public function getRememberTokenName();\r\n\r\n	}\r\n\r\n这个接口比较简单，`getAuthIdentifierName` 返回用户主键字段名；`getAuthIdentifier` 方法用户主键值。以 MySQL 作为后台数据库说明，主键就是自增主键；`getAuthPassword` 返回用户的哈希密码。此接口允许身份验证系统与任何 User 类一起使用，无论您正在使用什么 ORM 或存储抽象层。Laravel 内置的 `App\\User` 模型就实现了这个接口，所以你可以用它作为的实现参考例子。\r\n\r\n## 事件\r\n\r\n在认证过程中，会触发许多事件，你可以在 `EventServiceProvider` 中为这些事件添加监听者。\r\n\r\n	/**\r\n	 * The event listener mappings for the application.\r\n	 *\r\n	 * @var array\r\n	 */\r\n	protected $listen = [\r\n	    \'Illuminate\\Auth\\Events\\Registered\' => [\r\n	        \'App\\Listeners\\LogRegisteredUser\',\r\n	    ],\r\n\r\n	    \'Illuminate\\Auth\\Events\\Attempting\' => [\r\n	        \'App\\Listeners\\LogAuthenticationAttempt\',\r\n	    ],\r\n\r\n	    \'Illuminate\\Auth\\Events\\Authenticated\' => [\r\n	        \'App\\Listeners\\LogAuthenticated\',\r\n	    ],\r\n\r\n	    \'Illuminate\\Auth\\Events\\Login\' => [\r\n	        \'App\\Listeners\\LogSuccessfulLogin\',\r\n	    ],\r\n\r\n	    \'Illuminate\\Auth\\Events\\Failed\' => [\r\n	        \'App\\Listeners\\LogFailedLogin\',\r\n	    ],\r\n\r\n	    \'Illuminate\\Auth\\Events\\Logout\' => [\r\n	        \'App\\Listeners\\LogSuccessfulLogout\',\r\n	    ],\r\n\r\n	    \'Illuminate\\Auth\\Events\\Lockout\' => [\r\n	        \'App\\Listeners\\LogLockout\',\r\n	    ],\r\n\r\n	    \'Illuminate\\Auth\\Events\\PasswordReset\' => [\r\n	        \'App\\Listeners\\LogPasswordReset\',\r\n	    ],\r\n	];\r\n\r\n\r\n[1]: https://laravel-china.org/articles/5856/laravel-document-reading-eloquent-start-part-one\r\n[2]: https://laravel-china.org/articles/5814/laravel-document-reading-the-query-constructor-of-the-database-part-one\r\n[3]: https://en.wikipedia.org/wiki/Basic_access_authentication','2017-09-27 04:28:10','2017-09-27 04:29:10','laravel-document-reading-authentication'),(396,3,3,'JS Math 对象方法','* Math.ceil()：向上取整。参数是数字。\r\n\r\n		↑\r\n		|6\r\n		|5\r\n		|4\r\n		|3\r\n		|2\r\n		|1\r\n		|0\r\n		|-1\r\n		|-2\r\n		|-3\r\n		|-4\r\n		|-5\r\n		|-6\r\n		|\r\n\r\n		Math.ceil(0.1);  // 1\r\n		Math.ceil(-5.8); // -5\r\n\r\n* Math.floor()：向下取整。参数是数字。\r\n	\r\n		Math.floor(0.1);  // 0\r\n		Math.floor(-5.8); // -6\r\n\r\n* Math.round()：四舍五入（变大）。\r\n\r\n		Math.round(4.5);  // 5\r\n		Math.round(-4.6); // -5。当对负数四舍五入时，看离谁比较近，就取哪个。\r\n		Math.round(-4.5); // -4。当负数距离两段一样时，取在上的值。\r\n	\r\n* Math.abs()：求绝对值。\r\n\r\n* Math.random()：取 0~1 之间的随机数，包含 0 不包含 1。[0, 1)。\r\n\r\n常用的一些随机取整数值的方法：\r\n\r\n	1. x~y：  Math.round(Math.random() * (y - x) + x)\r\n	2. 0~y：  Math.round(Math.random() * y)\r\n	3. 1~y：  Math.ceil(Math.random() * y) || 1\r\n	4. 0~y-1：Math.floor(Math.random() * y)','2017-09-27 06:40:52','2017-09-27 06:40:52','js-math-object-method'),(397,3,3,'JS 数组方法','## 添加数据\r\n\r\n### push()\r\n\r\n为数组添加数据，在最后一个位置。返回最终的数组长度。参数是要添加的数据。\r\n\r\n### unshift()\r\n\r\n为数组添加数据，在第一个位置。返回最终的数组长度。参数是要添加的数据。\r\n\r\n## 删除数据\r\n\r\n### pop()\r\n\r\n删除数组最后一个数据。返回被删除数据。没有参数。\r\n\r\n### shift()\r\n\r\n删除数组第一个数据。返回被删除数据。没有参数。\r\n\r\n## 操作数据\r\n\r\n### forEach\r\n\r\n遍历数组元素。\r\n\r\n	Array.prototype.forEach(function callback(currentValue, index, array) {\r\n	    //your iterator\r\n	}[, thisArg]);\r\n\r\n* `currentValue`：当前迭代的数组元素。\r\n* `index`：当前迭代的数组元素的索引值。\r\n* `array`：遍历的数组对象。\r\n\r\n### sort\r\n\r\n对数组元素排序，返回排好序的数组，原数组也变化了。\r\n\r\n	Array.prototype.sort()\r\n	Array.prototype.sort(compareFunction)\r\n\r\n默认是从小到大排序的。\r\n\r\n	[4,1,7,2].sort(function (a,b) {\r\n		return a - b;\r\n	});\r\n	// [1, 2, 4, 7]\r\n\r\n	[4,1,7,2].sort(function (a,b) {\r\n		return b - a;\r\n	});\r\n	// [7, 4, 2, 1]\r\n\r\n随机排序。\r\n\r\n	Array.prototype.sort(function () {\r\n		return 0.5 - Math.random();\r\n	});\r\n\r\n### concat\r\n\r\n连接两个或两个以上数组，返回最终组成的新数组。\r\n\r\n	var new_array = old_array.concat(value1[, value2[, ...[, valueN]]]);\r\n\r\n### reverse\r\n\r\n颠倒数组中元素顺序，原数组也改变了。\r\n\r\n	Array.prototype.reverse()\r\n\r\n	[\'one\', \'two\', \'three\'].reverse(); // [\'three\', \'two\', \'one\']\r\n\r\n### join\r\n\r\n	Array.prototype.join()\r\n	Array.prototype.join(separator)\r\n\r\n将数组中的元素连接成一个字符串。原来数组不改变。\r\n\r\n	[\'red\', \'green\'].join(); \r\n\r\n	// 等同于\r\n	[\'red\', \'green\'].join(\',\'); // \"red,green\"\r\n\r\n	[\'red\', \'green\'].join(\' \'); //  \"red green\"\r\n\r\n### slice\r\n\r\n	Array.prototype.slice()\r\n	Array.prototype.slice(beginIndex)\r\n	Array.prototype.slice(beginIndex, endIndex)\r\n\r\n截取数组元素，组成一个新的子集数组并返回。截取范围是从 `beginIndex` 开始（包含）到 `endIndex` （不包含）。原来数组不改变。\r\n\r\n	var a = [\'zero\', \'one\', \'two\', \'three\'];\r\n	var sliced = a.slice(1, 3);\r\n\r\n	console.log(a);      // [\'zero\', \'one\', \'two\', \'three\']\r\n	console.log(sliced); // [\'one\', \'two\']\r\n\r\n	a.slice(-2); // [\"two\", \"three\"]\r\n	a.slice(-3, -2); // [\"one\"] \r\n\r\n### splice\r\n\r\n替换数组元素，可以为数组添加、删除元素。\r\n\r\n	array.splice(startIndex)\r\n	array.splice(startIndex, deleteCount)\r\n	array.splice(startIndex, deleteCount, item1, item2, ...)\r\n\r\n从 `startIndex` 算起（包含），删除 `deleteCount` 个元素，添加的元素 item1, item2, ... 放在 `startIndex`的位置处。\r\n\r\n例子：\r\n\r\n	var arr = [\'angel\', \'clown\', \'mandarin\', \'sturgeon\'];\r\n\r\n	// 情况一：删除从索引 2 处（包含）开始的元素\r\n	arr.splice(2);\r\n\r\n	arr; // [\'angel\', \'clown\']\r\n\r\n	// 情况二：添加元素，在 start 索引之前\r\n	arr.splice(2, 0, \'zb\', \'zs\');\r\n\r\n	arr; // [\"angel\", \"clown\", \"zb\", \"zs\", \"mandarin\", \"sturgeon\"]\r\n\r\n	// 情况三：删除和添加元素\r\n	arr.splice(2, 1, \'zb\', \'zs\');\r\n\r\n	arr; // [\"angel\", \"clown\", \"zb\", \"zs\", \"sturgeon\"]\r\n\r\n### filter\r\n\r\nArray.prototype.filter() 用来过滤出满足条件的数组元素，会返回一个新数组，原数组保持不变。\r\n\r\n```\r\nvar words = [\'spray\', \'limit\', \'elite\', \'exuberant\', \'destruction\', \'present\'];\r\n\r\nvar result = words.filter(function (word) {\r\n    return word.length > 6;\r\n});\r\n\r\nresult; // [\"exuberant\", \"destruction\", \"present\"]\r\nwords; // [\"spray\", \"limit\", \"elite\", \"exuberant\", \"destruction\", \"present\"]\r\n```\r\n\r\n### map\r\n\r\nArray.prototype.map() 用来对给定数组的每个元素处理后，返回处理过后的一个新数组，原数组保持不变。\r\n\r\n```\r\nvar array1 = [1, 4, 9, 16];\r\n\r\nvar map1 = array1.map(function (x) {\r\n    return x * 2;\r\n});\r\n\r\nmap1; // [2, 8, 18, 32]\r\narray1; // [1, 4, 9, 16]\r\n```','2017-09-27 08:44:40','2017-11-28 04:58:14','js-array-methods'),(398,3,3,'CSS：vertical-align 属性介绍','`vertical-align` 描述垂直方向上的对齐方式，能应用在两类元素上：\r\n\r\n1. 行内元素。指定行内元素在行框内的垂直对齐方式。\r\n2. 表单元格。指定表单元格中元素的垂直对齐方式。\r\n\r\n需要注意的是：\r\n\r\n`vertical-align` 不影响块级元素中的内容垂直对齐方式。\r\n\r\n	div {\r\n		vertical-align: middle; /* 这样设置并不能让 div 中的元素垂直居中对齐 */\r\n	}\r\n\r\n## 可取值\r\n\r\n这里我们只讨论可取值是「关键字」的情况，共 8 种：\r\n\r\n1. baseline（默认）\r\n2. sub\r\n3. super\r\n4. top\r\n5. middle\r\n6. bottom\r\n7. text-top\r\n8. text-bottom\r\n\r\n### 基线对齐（默认）\r\n\r\n`vertical-align:baseline` 要求元素基线与其父元素的基线对齐。我们来看一个例子：\r\n\r\n	<!-- CSS -->\r\n	p {\r\n	  font-size: 14px;\r\n	}\r\n\r\n	p span {\r\n	  font-size: 28px;\r\n	}\r\n\r\n	<!-- HTML -->\r\n	<p>x我爱上海<img src=\"weibo.png\">吗？</p>\r\n	<p>x我爱<span>上海</span>吗？</p>\r\n\r\n因为基线对齐是默认值，所以我们不需要额外设置了。我们来看下效果图：\r\n\r\n![基线对齐](http://www.baooab.com/wp/wp-content/uploads/2017/09/vertical-align-baseline.png)\r\n\r\n咱们所说的「父元素的基线」，在上面的例子里就是除 `span` 和 `img` 标签之外文本的基线，因为这些文本的基线取决于父元素（也就是 `p` 标签）的设置，所以称为「父元素的基线」，其实这样称呼并不准确。\r\n\r\n图片和表单元素没有基线的，那么就是它们的 **底端** 与父元素的基线对齐的；`span` 标签里的字体是 28px，它的基线也是与父元素的基线保持对齐。\r\n\r\n### 底端对齐\r\n\r\n`vertical-align:bottom` 是让元素行内框（inline box）的底端的与行框（line box）的底端对齐。\r\n\r\n	<!-- CSS -->\r\n	body {\r\n		line-height: 1;\r\n	}\r\n	\r\n	p {\r\n	  font-size: 14px;\r\n	}\r\n\r\n	p span {\r\n	  font-size: 28px;\r\n	}\r\n	\r\n	p span, p img {\r\n		vertical-align: bottom;\r\n	}\r\n\r\n	<!-- HTML -->\r\n	<p>x我爱上海<img src=\"weibo.png\">吗？</p>\r\n	<p>x我爱<span>上海</span>吗？</p>\r\n\r\n我们设置 `line-height: 1` 是为了保证元素的 `文本内容区高度 = 字体高度`。我们看下效果图：\r\n\r\n![底端对齐](http://www.baooab.com/wp/wp-content/uploads/2017/09/vertical-align-bottom.png)\r\n\r\n图中的粉色区域就是行框（line box）区域，红色背景区域就是文本的行内框区域（其实是内容区域，不过可以简单理解为行内框区域）。\r\n\r\n为图片设置 `vertical-align:bottom`，就是让图片底端与行框底端对齐。\r\n\r\n### 顶端对齐\r\n\r\n与底端对齐类似，就是让元素行内框（inline box）的顶端的与行框（line box）的顶端对齐。\r\n\r\n![顶端对齐](http://www.baooab.com/wp/wp-content/uploads/2017/09/vertical-align-top.png)\r\n\r\n为图片设置 `vertical-align:top`，就是让图片顶端与行框顶端对齐。\r\n\r\n### 居中对齐\r\n\r\n设置 `vertical-align:middle` 会让行内框元素的中点与父元素基线上方 1.5ex 处的一个点对齐。大多数浏览器会把 1ex 处理成 0.5em，所以行内框元素的中点与父元素基线上方 0.25em 处的一个点对齐。\r\n\r\n![居中对齐](http://www.baooab.com/wp/wp-content/uploads/2017/09/vertical-align-middle.png)','2017-09-28 01:23:06','2017-09-28 03:51:21','css-vertical-the-align-attribute-is-introduced'),(399,3,3,'CSS：line-height 属性介绍','`line-height` 是指行高，定义了元素中 **文本基线之间的（最小）距离**。\r\n\r\n## 行框图\r\n\r\n![行框图](http://www.baooab.com/wp/wp-content/uploads/2017/09/line-box.png)\r\n\r\n下面是这种图里涉及到的概念介绍：\r\n\r\n1. 基线（baseline）：是一行文本排列显示的参考线。可以认为是小写字母 `x` 下边缘所在的那条线。\r\n2. 内容区（content area）：就是文本所占据的空间大小。对于宋体，内容区的高度等于字体大小（font-size），就是说如果 `font-size: 14px`，那么内容区大小就是 14px；对于一般英文字体（如图），字母可能在基线下显示，而且每个字母的实际高度也不可能一样。所以，可以简单认为，`内容区高度 >= 显示出来的字体大小`。\r\n3. 行间距：`行高 - 内容区高度` 的出来的结果就是行间距了。行间距分布在内容区的上部和下部，当行间距是偶数时，上部和下部的值就是行间距的一半；如果得到的行间距是奇数，那么最终上部会比下部多 1px。\r\n4. 行框（line box）：就是包围行高的区域。\r\n\r\n## 行高和继承\r\n\r\n### 继承父类行高\r\n\r\n	body {\r\n		font-size: 14px;\r\n	}\r\n	\r\n	body > div {\r\n		line-height: 1em; /* 等于 10px */\r\n	}\r\n	\r\n	body > div > p {\r\n		font-size: 18px;\r\n	}\r\n\r\n`p` 标签中的行高是 10px！为什么会这样？\r\n\r\n因为 `p` 标签的行高继承自父级 `div`，`1em` 经过计算是 10px，所以 `p` 标签中的行高是 10px。\r\n\r\n### 根据自己的 `font-size` 计算行高\r\n\r\n更好的办法是为 **`line-height` 指定一个数**，这个数称为「缩放因子」。\r\n\r\n	body {\r\n		font-size: 14px;\r\n	}\r\n	\r\n	body > div {\r\n		line-height: 1.5;  /* 行高是 font-size 的 1.5 倍 */\r\n	}\r\n	\r\n	body > div > p {\r\n		font-size: 18px;\r\n	}\r\n\r\n这里 `p` 标签中的行高是 27px（18 * 1.5）！为什么会这样？\r\n\r\n因为 `p` 标签的行高继承自父级 `div`，也就是 `1.5`，即 `font-size` 的 1.5 倍。这里的 `font-size` 是指子元素自己的，所以最终的计算结果就是 27px 了。\r\n\r\n也就是说缩放因子是直接继承给所有子元素的，而不是将最终的计算值继承给所有子元素。','2017-09-28 01:23:33','2017-09-28 02:06:18','css-the-line-height-attribute-is-introduced'),(400,3,3,'Laravel 文档阅读：授权','> 翻译、衍生自：https://laravel.com/docs/5.5/authorization\r\n\r\n## 简介\r\n\r\n除了开箱提供的认证服务，在 Laravel 中对用户授权某个资源的操作权限也非常容易实现。Laravel 授权的方式主要分两种：Gates 和策略（Policies）。\r\n\r\nGates 和策略的关系像路由和控制器的。Gates 提供基于路由的授权方式；而策略将针对某个资源的操作逻辑组织起来，放在一个地方管理。我们会先介绍 Gates，然后再介绍策略。\r\n\r\n我们不需要在「项目里的授权，是选择使用 Gates，还是选择使用策略呢？」这个问题上纠结。许多项目里，都会混用这两种授权方式，而且运行良好。基本上，使用 Gates 的地方都是资源不相关的，比如查看管理员面板页；相反，策略是资源相关的，当你是具体授权某个资源的操作权限时，使用策略是没错啦。\r\n\r\n## Gates\r\n\r\n我们通常在 `App\\Provider\\AuthServiceProvider` 类中使用 `Gate` 门面来定义 Gates。已经说过，Gates 是基于闭包判断用户是否有操作权限的，回调闭包的第一个参数是用户实例，额外可选的第二个参数是相关的 Eloquent Model 实例：\r\n\r\n	/**\r\n	 * Register any authentication / authorization services.\r\n	 *\r\n	 * @return void\r\n	 */\r\n	public function boot()\r\n	{\r\n	    $this->registerPolicies();\r\n\r\n	    Gate::define(\'update-post\', function ($user, $post) {\r\n	        return $user->id == $post->user_id;\r\n	    });\r\n	}\r\n\r\nGates 也可以以 `Class@method` 的形式定义授权逻辑，像控制器一样：\r\n\r\n	/**\r\n	 * Register any authentication / authorization services.\r\n	 *\r\n	 * @return void\r\n	 */\r\n	public function boot()\r\n	{\r\n	    $this->registerPolicies();\r\n\r\n	    Gate::define(\'update-post\', \'PostPolicy@update\');\r\n	}\r\n\r\n在上面的例子中，我们称在 Gates 定义中的 `\'update-post\'` 叫「能力」（Ability）。 \r\n\r\n#### 资源 Gates\r\n\r\n使用 `Gate::resource` 方法一次定义多个 Gates：\r\n\r\n	Gate::resource(\'posts\', \'PostPolicy\');\r\n\r\n这一句相当于手动定义了下面的 Gates：\r\n\r\n	Gate::define(\'posts.view\', \'PostPolicy@view\');\r\n	Gate::define(\'posts.create\', \'PostPolicy@create\');\r\n	Gate::define(\'posts.update\', \'PostPolicy@update\');\r\n	Gate::define(\'posts.delete\', \'PostPolicy@delete\');\r\n\r\n默认，会定义 `view`、`create`、`update` 和 `delete` 能力。如果要覆盖或添加，使用 `resource` 方法的第三个数组参数。数组的 Key 是能力名，Value 是方法名。下面的例子里，我们定义了两个 Gates 能力：`posts.image` 和 `posts.photo`：\r\n\r\n	Gate::resource(\'photos\', \'PostPolicy\', [\r\n		\'image\' => \'updateImage\',\r\n		\'photo\' => \'updatePhoto\',\r\n	]);\r\n\r\n### 授权操作\r\n\r\n使用 Gates 授权操作，是用到 `allows` 和 `denies` 方法。需要注意的是，你不需要传递当前的认证用户实例给这两个方法，因为 Laravel 会自动为我们的 Gates 传递用户实例的：\r\n\r\n	if (Gate::allows(\'update-post\', $post) {\r\n		// The current user can update the post...\r\n	})\r\n\r\n	if (Gate::denies(\'update-post\', $post)) {\r\n		// The current user can\'t update the post...\r\n	}\r\n\r\n如果需要判断一个指定用户账号是否有进行某个操作的权限，那么在使用 `forUser` 方法吧！\r\n\r\n	if (Gate::forUser($user)->allows(\'update-post\', $post) {\r\n		// The current user can update the post...\r\n	})\r\n\r\n	if (Gate::forUser($user)->denies(\'update-post\', $post)) {\r\n		// The current user can\'t update the post...\r\n	}\r\n\r\n## 创建策略\r\n\r\n### 生成策略\r\n\r\n策略是针对特定模型或资源、方便得组织它们的授权逻辑在一个地方的类。例如，在一个博客系统中，我们用 `Post` 模型对应的策略类 `PostPolicy`（注意，这里的跟上面的不一样）来授权认证用户创建和更新博客相关的权限。\r\n\r\n你可以使用 Artisan 命令 `make:policy` 生成策略。生成的策略放在 `app/Policies` 目录下，如果这个目录不存在，它会在第一次执行此命令时创建：\r\n\r\n	php artisan make:policy PostPolicy\r\n\r\n`make:policy` 命令会生成一个空的策略类。如果需要生成带有基本「CRUD」策略方法的策略类。那么在执行 `make:policy` 命令是跟上 `--model` 选择吧：\r\n\r\n	php artisan make:policy PostPolicy --model=Post\r\n\r\n> 提示:-D 所有的策略都是通过 Laravel 的服务容器解析的，因此你可以在策略类的构造函数里添加任何你需要依赖注入的实例。\r\n\r\n### 注册策略\r\n\r\n策略类生成完毕后需要注册它。`AuthServiceProvider` 的 `policies` 数组属性就是干这个的，在这里为你的 Eloquent Model 添加对应的策略类映射。注册后，Laravel 在对给定 Model 资源授权的时候，就知道来找哪个策略类了：\r\n\r\n	<?php\r\n\r\n	namespace App\\Providers;\r\n\r\n	use App\\Post;\r\n	use App\\Policies\\PostPolicy;\r\n	use Illuminate\\Support\\Facades\\Gate;\r\n	use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\r\n\r\n	class AuthServiceProvider extends ServiceProvider\r\n	{\r\n	    /**\r\n	     * The policy mappings for the application.\r\n	     *\r\n	     * @var array\r\n	     */\r\n	    protected $policies = [\r\n	        Post::class => PostPolicy::class,\r\n	    ];\r\n\r\n	    /**\r\n	     * Register any application authentication / authorization services.\r\n	     *\r\n	     * @return void\r\n	     */\r\n	    public function boot()\r\n	    {\r\n	        $this->registerPolicies();\r\n\r\n	        //\r\n	    }\r\n	}\r\n\r\n## 写策略类\r\n\r\n### 策略方法\r\n\r\n策略类注册完毕后，再来看看怎样为每个操作添加对应的策略方法。在接下来的例子里，我们为 `PostPolicy` 定义一个 `update` 方法，用来判断是否指定的用户拥有更新博客的权限。\r\n\r\n`update` 方法接受两个参数：`User` 实例和 `Post` 实例，我们最终返回 `true` 或者 `false` 来说明用户是否有权限进行操作。在此，我们使用的是用户的 `id` 字段来匹配博客的 `user_id` 字段的。\r\n\r\n	<?php\r\n\r\n	namespace App\\Policies;\r\n\r\n	use App\\User;\r\n	use App\\Post;\r\n\r\n	class PostPolicy\r\n	{\r\n	    /**\r\n	     * Determine if the given post can be updated by the user.\r\n	     *\r\n	     * @param  \\App\\User  $user\r\n	     * @param  \\App\\Post  $post\r\n	     * @return bool\r\n	     */\r\n	    public function update(User $user, Post $post)\r\n	    {\r\n	        return $user->id === $post->user_id;\r\n	    }\r\n	}\r\n\r\n你可以继续为你的其他操作添加对应策略方法，比如 `view` 或者 `delete` 啦，还有一点，策略方法的名字你是可以自由取的。\r\n\r\n> 提示:-D 在控制台执行使用 `--model` 选项生成策略类的时候，会自动生成针对增删改查操作的 `create`、`delete`、`update` 和 `view` 策略方法。\r\n\r\n### 无 Model 策略方法\r\n\r\n「无模型策略方法」是指策略方法里不需要传入模型实例的情况。最常见的场景就是创建操作，我们假设它对应 `create` 策略方法。例如，你可能会判断一个用户是否有创建博客的权限，这时就不需要有博客实例对象了，只要给个认证用户就行了：\r\n\r\n	/**\r\n	 * Determine if the given user can create posts.\r\n	 *\r\n	 * @param  \\App\\User  $user\r\n	 * @return bool\r\n	 */\r\n	public function create(User $user)\r\n	{\r\n	    //\r\n	}\r\n\r\n### 策略过滤\r\n\r\n对于一些用户，我们会碰到无论如何要给他整个策略类中所有方法的操作权限（想想管理员）。为了实现这个功能，在策略类中定义一个 `before` 方法就 OK。`before` 方法会在所有策略方法调用之前调用：\r\n\r\n	public function before($user, $ability)\r\n	{\r\n	    if ($user->isSuperAdmin()) {\r\n	        return true;\r\n	    }\r\n	}\r\n\r\n如果要拒绝用户的所有操作权限，直接返回 `false`。如果返回 `null` 的话，就跟没设置 `before` 方法一样一样的。\r\n\r\n> 重点提示( ⊙ o ⊙ ) 如果 Gates 能力对应的策略方法在策略类中未定义，`before` 方法是不会被调用的。\r\n\r\n## 使用策略授权操作\r\n\r\n### 通过 User Model\r\n\r\nLaravel 中的 User Model 中包含两个有用的授权方法：`can` 和 `cant`。`can` 方法接收两个参数，第一个参数是操作名，第二个就是相关 Model 实例了。下面的例子里，我们判断用户是否有更新指定 `Post` Model 实例的权限：\r\n\r\n	if ($user->can(\'update\', $post)) {\r\n	    //\r\n	}\r\n\r\n`can` 方法会自动调用正确的策略类的 `update` 方法并返回一个布尔值。如果没有知道的话，就会去 Gates 中找有没有一个能力叫 `update` 的。\r\n\r\n#### 无 Model 操作\r\n\r\n前面已经说过，对于创建这一类授权呢，定义时是不需要给 Model 实例的。那么在使用这样的一类授权方法时，怎么写呢？这时候，给 `can` 方法传递对应 Model 类名就 OK。\r\n\r\n	use App\\Post;\r\n\r\n	if ($user->can(\'create\'), Post::class) {\r\n		// Executes the \"create\" method on the relevant policy...\r\n	}\r\n\r\n### 通过中间件\r\n\r\nLaravel 提供了一个授权操作的中间件（`Illuminate\\Auth\\Middleware\\Authorize`），它会在你的请求到大路由或者控制器的时候，判断用户是否有相关权限。这个中间件已经在 `App\\Http\\Kernel` 类中设置了，并且赋予了 `can` 这个 Key。我们来看下，针对更新博客的操作，咱们怎么去使用它：\r\n\r\n	use App\\Post;\r\n\r\n	Route::put(\'/posts/{post}\', function (Post $post) {\r\n	    // The current user may update the post...\r\n	})->middleware(\'can:update,post\');\r\n\r\n`can` 冒号后面用逗号隔开的就是两个参数。第一个参数是操作名，第二个参数是我们传递给策略方法的路由参数，在这里我们使用了隐式模型绑定，所以一个 `Post` 模型实例会被传递给策略方法。如果用户授权未通过，一个带有 `403` 状态码的 HTTP 响应就会通过该中间件生成。\r\n\r\n#### 无 Model 操作\r\n\r\n一样的，对于不需要给 Model 实例的授权操作（比如创建）判断方法，我们需要给中间件传递的第二个参数是类名：\r\n\r\n	Route::post(\'/post\', function () {\r\n	    // The current user may create posts...\r\n	})->middleware(\'can:create,App\\Post\');\r\n\r\n### 通过控制器辅助函数\r\n\r\n除了 `User` Model 提供的辅助函数，Laravel 为所有继承了 `App\\Http\\Controllers\\Controller` 基类的控制器都提供了 `auhtorize` 辅助方法。类似 `can` 方法，`authorize` 方法接受操作名和相关 Model 实例对象作为参数。如果操作经过验证未授权，`authorize` 方法会抛出一个 `Illuminate\\Auth\\Access\\AuthorizationException` 异常，Laravel 默认的异常处理器会把它转换为一个带有 403 状态码的 HTTP 响应：\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use App\\Post;\r\n	use Illuminate\\Http\\Request;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class PostController extends Controller\r\n	{\r\n	    /**\r\n	     * Update the given blog post.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @param  Post  $post\r\n	     * @return Response\r\n	     */\r\n	    public function update(Request $request, Post $post)\r\n	    {\r\n	        $this->authorize(\'update\', $post);\r\n\r\n	        // The current user can update the blog post...\r\n	    }\r\n	}\r\n\r\n#### 无 Model 操作\r\n\r\n再一次，对于不需要给 Model 实例的授权操作判断方法，我们需要给 `authorize` 方法传递的第二个参数是类名：\r\n\r\n	/**\r\n	 * Create a new blog post.\r\n	 *\r\n	 * @param  Request  $request\r\n	 * @return Response\r\n	 */\r\n	public function create(Request $request)\r\n	{\r\n	    $this->authorize(\'create\', Post::class);\r\n\r\n	    // The current user can create blog posts...\r\n	}\r\n\r\n### 通过 Blade 模板\r\n\r\n在 Blade 模板中，提供了两个用来判断用户是否具有操作权限的指令：`@can`和 `cannot`。它们在判断页面是否该显示一些内容上比较有用，使用方式如下：\r\n\r\n	@can(\'update\', $post)\r\n	    <!-- The Current User Can Update The Post -->\r\n	@elsecan(\'create\', $post)\r\n	    <!-- The Current User Can Create New Post -->\r\n	@endcan\r\n\r\n	@cannot(\'update\', $post)\r\n	    <!-- The Current User Can\'t Update The Post -->\r\n	@elsecannot(\'create\', $post)\r\n	    <!-- The Current User Can\'t Create New Post -->\r\n	@endcannot\r\n\r\n上面的指令其实是 `@if` 和 `@unless` 的快捷形式的写法。等同于\r\n\r\n	@if (Auth::user()->can(\'update\', $post))\r\n	    <!-- The Current User Can Update The Post -->\r\n	@endif\r\n\r\n	@unless (Auth::user()->can(\'update\', $post))\r\n	    <!-- The Current User Can\'t Update The Post -->\r\n	@endunless\r\n\r\n#### 无 Model 操作\r\n\r\n你可以用 `@can` 和 `@cannot` 指令处理无 Model 操作的权限判断场景，需要传递的是相关类名：\r\n\r\n	@can(\'create\', App\\Post::class)\r\n	    <!-- The Current User Can Create Posts -->\r\n	@endcan\r\n\r\n	@cannot(\'create\', App\\Post::class)\r\n	    <!-- The Current User Can\'t Create Posts -->\r\n	@endcannot','2017-09-29 09:07:10','2017-09-29 09:12:28','laravel-document-reading-authorization'),(401,3,3,'Laravel 文档阅读：加密','> 翻译、衍生自：https://laravel.com/docs/5.5/encryption\r\n\r\n## 简介\r\n\r\nLaravel 加密器使用 OpenSSL 来提供 AES-256 和 AES-128 加密。强烈建议你使用 Laravel 内置的加密工具，而不是用你的「本土化」加密算法。Laravel 中的所有加密值都使用了消息认证码（MAC）签名，因此能保证底层值经过加密后不能被修改。\r\n\r\n## 配置\r\n\r\n在使用 Laravel 加密器之前，你必须先要配置 `config/app.php` 文件中的 `key` 选项。可以用 `php artisan key:generate` 命令生成这个 密钥，因为命令底层是使用了 PHP 的安全随机字节生成器来生成密钥的。如果这个密钥没有正确配置，Laravel 中的所有加密值都是不安全的。\r\n\r\n## 使用加密器\r\n\r\n#### 加密一个值\r\n\r\n可以使用辅助函数 `encrypt` 加密一个值。所有加密值都使用了 OpenSSL 的 AES-256-CBC 加密算法加密。此外，所有的加密值都使用了消息认证码（MAC）进行签名，以便检测对加密字符串的任何修改。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use App\\User;\r\n	use Illuminate\\Http\\Request;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class UsersController extends Controller\r\n	{\r\n	    /**\r\n	     * Store a secret message for the user.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @param  int  $id\r\n	     * @return Response\r\n	     */\r\n	    public function storeSecret(Request $request, $id)\r\n	    {\r\n	        $user = User::findOrFail($id);\r\n\r\n	        $user->fill([\r\n	            \'secret\' => encrypt($request->secret)\r\n	        ])->save();\r\n	    }\r\n	}\r\n\r\n#### 无序列化加密\r\n\r\n`encrypt` 加密方法在加密过程中会对加密值序列化，所以我们可以为该方法传递对象和数组。但是，对于非 PHP 客户端来说，是无法处理这个加密值的，对这类客户端，我们需要取消对数据的序列化步骤。无序列化的加密和解密一个值，需要使用 `Crypt` 门面的 `encryptString` 和 `decryptString` 方法：\r\n\r\n	use Illuminate\\Support\\Facades\\Crypt;\r\n\r\n	$encrypted = Crypt::encryptString(\'Hello World.\');\r\n\r\n	$decrypted = Crypt::decryptString($encrypt);\r\n\r\n #### 解密一个值\r\n\r\n 使用 `decrypt` 方法来解密经 `encrypt` 方法加密的值。如果传递给 `decrypt` 方法的加密值无法正确解密，例如 MAC 无效时，将会抛出一个 `Illuminate\\Contracts\\Encryption\\DecryptException` 异常：\r\n\r\n	use Illuminate\\Contracts\\Encryption\\DecryptException;\r\n	\r\n	try {\r\n		$decrypted = decrypt($encryptedValue);\r\n	} catch (DecryptException $e) {\r\n		//\r\n	}','2017-09-30 01:40:07','2017-09-30 01:40:07','laravel-document-reading-encryption'),(402,3,3,'Laravel 文档阅读：哈希','> 翻译、衍生自：https://laravel.com/docs/5.5/hashing\r\n\r\n## 简介\r\n\r\nLaravel 的 Hash 门面为存储用户密码提供了安全的 Bcrypt 哈希。如果你是使用内置的 `LoginController` 和 `RegisterController` 类来构建认证系统的，那么你的用户密码在注册和认证过程中已经自动使用了 Bcrypt。\r\n\r\n> 提示。Bcrypt 是哈希密码的理想选择，因为它的「影响因子」是可调整的，这就是说生成哈希的时间可以随着硬件功率的增加而增加。\r\n\r\n## 基本用法\r\n\r\n你可以通过调用 `Hash` 门面的 `make` 方法来哈希一个明文密码。\r\n\r\n	<?php\r\n\r\n	namespace App\\Http\\Controllers;\r\n\r\n	use Illuminate\\Http\\Request;\r\n	use Illuminate\\Support\\Facades\\Hash;\r\n	use App\\Http\\Controllers\\Controller;\r\n\r\n	class UpdatePasswordController extends Controller\r\n	{\r\n	    /**\r\n	     * Update the password for the user.\r\n	     *\r\n	     * @param  Request  $request\r\n	     * @return Response\r\n	     */\r\n	    public function update(Request $request)\r\n	    {\r\n	        // Validate the new password length...\r\n\r\n	        $request->user()->fill([\r\n	            \'password\' => Hash::make($request->newPassword)\r\n	        ])->save();\r\n	    }\r\n	}\r\n\r\n`make` 方法允许你使用 `rounds` 选项来管理 bcrypt 哈希算法的影响因子；然而，使用 `make` 方法的默认值，已经够够的了。\r\n\r\n	$hashed = Hash::make(\'password\', [\r\n	    \'rounds\' => 12\r\n	]);\r\n\r\n#### 比对哈希值和文本字符串\r\n\r\n`check` 方法用来验证给定的纯文本字符串是否能对应到给定的一个哈希值。如果你使用的是 Laravel 内置的 `LoginController` 了，你已经在用它了。\r\n\r\n	if (Hash::check(\'plain-text\', $hashedPassword)) {\r\n		// The passwords match...	\r\n	}\r\n\r\n#### 检查密码是否需要重新哈希\r\n\r\n`needsRehash` 方法用来确定由于密码哈希后，哈希值使用的工作因子是否已更改：\r\n\r\n	if (Hash::needsRehash($hashed)) {\r\n	    $hashed = Hash::make(\'plain-text\');\r\n	}','2017-09-30 02:11:07','2017-09-30 02:11:07','laravel-document-reading-hash'),(403,3,3,'Ubuntu 16.04  和 Apache 环境下配置 HTTPS','## 安装 certbot\r\n\r\n来到 [Certbot 官网](https://certbot.eff.org/) ，选择系统和服务器类型，我的是 Ubuntu 16.04 和 Apache，查看安装教程。我这里直接放我的全局操作指令：\r\n\r\n	$ sudo apt-get update\r\n	$ sudo apt-get install software-properties-common\r\n	$ sudo add-apt-repository ppa:certbot/certbot\r\n	$ sudo apt-get update\r\n	$ sudo apt-get install python-certbot-apache \r\n\r\n准备工作做好后，先创建存放配置文件的文件夹：\r\n\r\n	$ sudo mkdir /etc/letsencrypt/configs\r\n\r\n编辑配置文件：\r\n\r\n	$ sudo vim /etc/letsencrypt/configs/www.baooab.com.conf\r\n	\r\n\r\n	# 写你的域名和邮箱\r\n	domains = www.baooab.com\r\n	rsa-key-size = 2048\r\n	email = your-email\r\n	text = True\r\n\r\n	# 把下面的路径修改为 example.com 的目录位置\r\n	authenticator = webroot\r\n	webroot-path = /var/www/html\r\n\r\n然后生成咱们的证书\r\n\r\n	$sudo certbot -c /etc/letsencrypt/configs/www.baooab.com.conf certonly\r\n\r\n成功的话，会得到类似下面的提示：\r\n\r\n	IMPORTANT NOTES:\r\n	 - Congratulations! Your certificate and chain have been saved at:\r\n	   /etc/letsencrypt/live/www.baooab.com/fullchain.pem\r\n	   Your key file has been saved at:\r\n	   /etc/letsencrypt/live/www.baooab.com/privkey.pem\r\n	   Your cert will expire on 2018-02-04. To obtain a new or tweaked\r\n	   version of this certificate in the future, simply run certbot\r\n	   again. To non-interactively renew *all* of your certificates, run\r\n	   \"certbot renew\"\r\n	 - If you like Certbot, please consider supporting our work by:\r\n\r\n	   Donating to ISRG / Let\'s Encrypt:   https://letsencrypt.org/donate\r\n	   Donating to EFF:                    https://eff.org/donate-le\r\n\r\n在命令执行过程中，会问你的邮箱号和域名地址，我的是 www.baooab.com 了。\r\n\r\n现在，我们就获得了两个证书：`fullchain.pem` 和 `privkey.pem`。`fullchain.pem` 是证书，`privkey.pem` 是密钥文件。 \r\n\r\n## 配置 Apache\r\n\r\n首先启用 Apache SSL 模块。\r\n\r\n	$ a2enmod ssl\r\n\r\n然后在 Apache 配置文件 `/etc/apache2/sites-enable/000-default.conf` 中添加 HTTPS 使用的 443 端口虚拟机信息。\r\n\r\n	<VirtualHost *:443>\r\n			ServerAdmin webmaster@localhost\r\n			DocumentRoot /var/www/html\r\n			ErrorLog ${APACHE_LOG_DIR}/error.log\r\n			CustomLog ${APACHE_LOG_DIR}/access.log combined\r\n			SSLEngine on\r\n			SSLCertificateFile /etc/letsencrypt/live/www.baooab.com/fullchain.pem\r\n			SSLCertificateKeyFile /etc/letsencrypt/live/www.baooab.com/privkey.pem\r\n	</VirtualHost>\r\n\r\n接下来重启 Apache（如果失败，使用 ` journalctl | tail` 命令查看原因）：\r\n\r\n	/etc/init.d/apache2 restart\r\n	\r\n看咱们的 443 端口开了没\r\n\r\n	$ netstat -nlt\r\n	Active Internet connections (only servers)\r\n	Proto Recv-Q Send-Q Local Address           Foreign Address         State\r\n	tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN\r\n	tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN\r\n	tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN\r\n	tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN\r\n\r\nOK，现在就可以了！\r\n\r\n需要注意的是，如果使用阿里云 ECS 服务器的话，需要 **添加新的安全组规则**，才能将 443 端口开放出来。\r\n\r\n## 更新证书\r\n\r\n使用 certbot 提供的 https 服务的一次有效期是 3 个月，所以需要续约，续约的话使用\r\n\r\n	certbot renew \r\n\r\n命令就可以了 :-D\r\n\r\n## 参考链接\r\n\r\n1. https://certbot.eff.org/\r\n2. https://ksmx.me/letsencrypt-ssl-https/\r\n3. https://www.maketecheasier.com/apache-server-ssl-support/\r\n4. https://askubuntu.com/questions/629995/apache-not-able-to-restart','2017-09-30 05:02:58','2017-11-06 04:38:08','ubuntu-1604-and-apache-environment-configuration-https'),(404,3,3,'CSS 盒子模型和 box-sizing','### 盒子模型\r\n\r\n一个 HTML 元素在页面里占据的大小由 4 部分决定：内容区、内边距、边框和外边距。\r\n\r\n看下面这张图：\r\n\r\n![盒子模型图](http://www.baooab.com/wp/wp-content/uploads/2017/09/box-model.png)\r\n\r\nContent Edge 包围的区域就是内容区。\r\n\r\nPadding Edege 和 Content Edge 之间的区域是内边距。\r\n\r\nBorder Edge 和 Padding Edge 之间的区域，也就是淡蓝色这块区域就是边框。\r\n\r\nMargin Edge 和 Border Edge 之间的区域，是外边距。\r\n\r\n### `box-sizing`\r\n\r\n`box-sizing` 是一个 CSS 属性，它决定 CSS 盒子模型中元素的 `width` 和 `height` 属性所代表的区域，可以取两个值：\r\n\r\n1. `content-box`（默认）。 \r\n2. `border-box`。\r\n\r\n`box-sizing: content-box` 表示设定的 `width` 和 `height` 代表的是 Content Edge 包围的区域，也就是「内容区」。\r\n\r\n`box-sizing: border-box` 表示设定的 `width` 和 `height` 所代表的是 Border Edge 包围的区域，也就是「边框 + 内边距 + 内容区」。\r\n\r\n#### 拓展\r\n\r\n早期的 IE 浏览器（IE7-）的盒子模型中，元素的 `width` 和 `height` 属性所代表的区域是「边框 + 内边距 + 内容区」这个范围，这与 W3C 规定的盒子模型不一致。而且当时也没有 `box-sizing` 可以设置（IE8 才支持这个属性），所以 IE7- 的这个处理被看做 BUG，并且为了与 W3C 的盒子模型做区别，就有了广为流传的「标准（W3C）盒子模型」和「IE 盒子模型」之分。\r\n\r\n不过现在已经不考虑了，因为现在所有主流浏览器和 IE8+ 都是采用标准盒子模型的。\r\n\r\n![标准盒子模型和 IE 盒子模型图](http://www.baooab.com/wp/wp-content/uploads/2017/09/W3C_and_Internet_Explorer_box_models.png)','2017-09-30 10:03:13','2017-09-30 10:03:13','css-box-model-and-box-sizing'),(405,3,3,'JS 变量声明关键字 var','JavaScript 其实也是编译语言，它的编译是在执行代码前的几毫秒甚至更短。\r\n\r\n在 JavaScript 中声明变量可以用 `var`，对于它你可能还有不了解的地方，而这与 JavaScript 编译规则有关。\r\n\r\n在同一个作用域下使用 `var` 重复声明一个变量时，只有第一个生效，其余的声明编译器都会忽略。\r\n\r\n	var foo = \'China\';\r\n\r\n	var foo;\r\n\r\n	console.log(foo) // \"China\"\r\n\r\n也就是说，上面的代码等同于（在编译后的结果）\r\n\r\n	var foo = \'China\';\r\n\r\n	console.log(foo); // \"China\"\r\n\r\n而如果是这样的代码，会打印 `\"中国\"` 字符串。\r\n	\r\n	var foo = \'China\';\r\n\r\n	var foo = \'中国\';\r\n\r\n	console.log(foo); // \"中国\"\r\n	\r\n原因是，虽然 `var` 声明被忽略，但是赋值语句仍然有效。等同于\r\n\r\n	var foo = \'China\';\r\n\r\n	foo = \'中国\';\r\n\r\n	console.log(foo); // \"中国\"\r\n\r\n如果我们把 console 的位置换一下，改成这样：\r\n\r\n	var foo = \'China\';\r\n\r\n	console.log(foo); \r\n\r\n	var foo = \'中国\';\r\n\r\n打印的结果说是什么呢？答案是 `\"China\"`！因为只有变量声明会提升，但是赋值语句是不能提升的（还在原来的位置），也就是说上面的代码，等同于\r\n\r\n	var foo = \'China\';\r\n\r\n	console.log(foo); \r\n\r\n	foo = \'中国\';\r\n\r\n哈哈，开心~','2017-09-30 13:12:23','2017-10-11 04:47:40','js-keyword-var-variable-declarations'),(406,3,3,'JavaScript 变量声明提升和函数声明提升','在 JavaScript 中，使用 `var` 声明的变量和函数声明都会发生提升，所谓「提升」，是变量和函数的声明在编译阶段，会被自动放到所属作用域的顶部。\r\n\r\n咱们下面的例子：\r\n\r\n1. 变量声明提升\r\n\r\n先看这一段代码：\r\n\r\n	console.log(a); // Uncaught ReferenceError: a is not defined\r\n\r\n	a = 23;\r\n\r\n它会报错，是因为 `a` 这个变量没有声明。但是如果我们把代码改为这样：\r\n\r\n	console.log(a); // undefined\r\n\r\n	var a = 23;\r\n\r\n这里并没有报错，打印出 `undefined`，说明变量 `a` 是声明了的——这就是变量声明提升。其实上面的代码等同于\r\n\r\n	var a; \r\n\r\n	console.log(a); // undefined\r\n\r\n	a = 23;\r\n\r\n2. 函数声明提升\r\n\r\n与变量提升类似，函数声明也会被提升到作用域顶层。\r\n\r\n	foo(); // \"easy\"\r\n	\r\n	function foo() {\r\n		console.log(\'easy\');\r\n	}\r\n\r\n	// 等同于\r\n	\r\n	function foo() {\r\n		console.log(\'easy\');\r\n	}\r\n	\r\n	foo();\r\n\r\n3. 如果声明的变量名和函数声明形式的函数名一样，那么结果那个算数呢？\r\n\r\n首先需要说明的是，**这种情况压根就不该发生**，如果发生，说明你的程序设计是有问题的！\r\n\r\n那么如果万一不消息出现了，那么结果那个算数呢？我们来回答这个问题——函数声明代码会 **先于** 变量声明放在作用域顶部。也就是说\r\n	\r\n	console.log(foo);\r\n\r\n	var foo = \'bar\';\r\n	\r\n	function foo() {\r\n		console.log(\'Oops!\');\r\n	}\r\n\r\n上面的 `foo` 会打印出什么结果呢？我们先看它的编译后的结果是啥。\r\n\r\n	function foo() {\r\n		console.log(\'Oops!\');\r\n	}\r\n	\r\n	var foo;\r\n	\r\n	console.log(foo);\r\n\r\n	foo = \'bar\';\r\n	\r\n咱已经说了，函数声明代码会 **先于** 变量声明放在作用域顶部，而且提升的只是声明，赋值语句不会提升的。所以，最终的打印结果可想而知，是 **`foo` 函数本身**。','2017-09-30 13:41:10','2017-09-30 13:42:12','javascript-variable-declarations-and-function-declarations');
INSERT INTO `discussions` VALUES (407,3,3,'JS DOM','JavaScript 由三部分组成：ECMAScript、DOM、BOM。我们之前学习都是 ECMAScript，现在学习 DOM。\r\n\r\n### 节点\r\n\r\n	<div class=\"box\" style=\"background: #ededed;\">\r\n		<h2>标题</h2>\r\n		<p>内容内容内容内容内容内容。</p>\r\n		<!-- 这是注释 -->\r\n	</div>\r\n\r\n	<script>\r\n		function $(selector) {\r\n			return document.querySelector(selector);\r\n		}\r\n\r\n		function c() {\r\n			console.log(...arguments);\r\n		}\r\n\r\n		var $box = $(\'.box\');\r\n\r\n		c($box.attributes);\r\n		c($box.childNodes);\r\n\r\n	</script>\r\n\r\n1. `.attributes`：属性节点列表。对应到 HTML 标签的特性列表。\r\n\r\n2. `.childNodes`：直接子节点列表（注释和换行都算是一个 Child Node）。\r\n\r\n3. `.nodeName`：节点的名称。\r\n\r\n4. `.nodeType`：节点的类型。\r\n\r\n| 类型 | nodeName | nodeType|\r\n| ------ | --------- | ---------- |\r\n| 元素（标签） | DIV... | 1 |\r\n| 特性 | class... | 2 |\r\n| 文本 | #text | 3 |\r\n| 注释 | #comment | 8 | \r\n\r\n### tagName 和 parentNode\r\n\r\n`nodeName` 是节点名称，任何节点都有该属性。而 `tagName` 是标签名，只有元素节点（标签元素）才有这个属性。\r\n\r\n`parentNode` 用来获得父节点。看例子：\r\n\r\n	<ul>\r\n		<li><span>1</span></li>\r\n		<li><span>2</span></li>\r\n		<li><span>3</span></li>\r\n		<li><span>4</span></li>\r\n	</ul>\r\n\r\n	<script>\r\n		function $(selector) {\r\n			return document.querySelector(selector);\r\n		}\r\n\r\n		function $$(selector) {\r\n			return document.querySelectorAll(selector);\r\n		}\r\n\r\n		function c() {\r\n			console.log(...arguments);\r\n		}\r\n\r\n		var $spans = $$(\'ul span\');\r\n\r\n		for (var i = $spans.length - 1; i >= 0; i--) {\r\n			$spans[i].addEventListener(\'click\', function () {\r\n				this.parentNode.style.display = \'none\';\r\n			});\r\n		}\r\n\r\n	</script>\r\n\r\n页面根（最顶层）节点是 `#document`。\r\n\r\n### children\r\n\r\n获得元素的第一层子元素，是一个集合（HTMLCollection）——代表所有子元素。\r\n\r\n但这是非标准接口。\r\n\r\n我们可以通过 `childNodes` 和 `nodeType` 来自定义一个工具函数实现这个功能。\r\n\r\n	function getChildren(dom) {\r\n		var tempArr = [];\r\n		var childNodes = dom.childNodes;\r\n\r\n		for (var i = 0; i < childNodes.length; i++) {\r\n			if (childNodes[i].nodeType === 1) {\r\n				tempArr.push(childNodes[i]);\r\n			}\r\n		}\r\n\r\n		return tempArr;\r\n	}\r\n\r\n### 兄弟节点\r\n\r\n* `previousElementSibling`：上一个兄弟节点。\r\n\r\n* `nextElementSibling`：下一个兄弟节点。\r\n\r\n* `firstElementChild`：找到父元素第一个元素子节点。\r\n\r\n* `lastElementChild`：找到父元素最后一个元素子节点。\r\n\r\n### offsetParent\r\n\r\n`offsetParent` 获取离本元素最近的有定位的父级元素。如果父级都没有定位，那就直接返回 `body`（IE8以及以上）。\r\n\r\nbody 身上没有 offsetParent 属性。\r\n\r\n遵循原则：给父级定位。\r\n\r\n### offsetLeft 和 offsetTop\r\n\r\n`offsetLeft` 获取与「离本元素最近的有定位的父级元素」在横向上的距离。结果值不带单位，并且边框宽度不计算在内。\r\n\r\n`offsetTop` 获取与「离本元素最近的有定位的父级元素」在纵向上的距离。结果值不带单位，并且边框宽度不计算在内。\r\n\r\n注意，如果没有定位的父级元素的话，默认是到 html 元素的距离。但有兼容问题。\r\n\r\n遵循原则：给父级定位或者初始化时为 body 设置 `margin: 0`。 \r\n\r\n### getBoundingClientRect()\r\n\r\n`getBoundingClientRect()` 用来获得元素的盒模型信息，得到的结果值是没有单位的。\r\n\r\n包含的属性信息包括：\r\n\r\n* width：宽度（包含边框）。\r\n* height：高度（包含边框）。\r\n* left：从元素的最左边到可视区的最左边的距离。\r\n* right：从元素的最右边到可视区的最左边的距离。\r\n* top：从元素的最上边到可视区的最上边的距离。\r\n* bottom：从元素的最下边到可视区的最上边的距离。\r\n\r\n### 属性操作\r\n\r\n之前属性操作的方法：\r\n\r\n1. `.属性名`\r\n2. `[属性名]`\r\n\r\n#### getAttribute()\r\n\r\n`.getAttribute()`：用来获得元素的属性值（或标签里的特性值）。就是说它获取不到 JS 对象的上的自定义属性，但是元素对象所对应的标签的自定义特性是可以取到的。\r\n\r\n对于 HTML5 中的自定义特性（以`data-` 作为前缀），使用 `.属性名` 和 `[属性名]` 的形式也获取不到，但可以用 `obj.dataset.属性名` 取到的。\r\n\r\n#### setAttribute()\r\n\r\n	setAttribute(\'name\', \'value\');\r\n\r\n#### removeAttribute()\r\n\r\n	removeAttribute(\'name\');\r\n\r\n### 获取元素的宽高\r\n\r\n`offsetWidth`，返回元素的宽度（包含边框）；`clientWidth`，返回元素的宽度（不包含边框）。\r\n\r\n`offsetHeight`，返回元素的高度（包含边框）；`clientHeight`，返回元素的高度（不包含边框）。\r\n\r\n### 可视区的宽高\r\n\r\n宽：`document.documentElement.clientWidth`。\r\n\r\n高：`document.documentElement.clientHeight`。\r\n\r\n### DOM 元素操作\r\n\r\n#### 创建元素\r\n\r\n`createElement()`\r\n\r\n	document.createElement(tagName)\r\n\r\n只能用来创建节点，不能创建文本、注释节点。创建出来的元素对象可以像在文档中查找到的元素一样进行任何操作。\r\n\r\n#### 添加元素\r\n\r\n1. `appendChild()`\r\n\r\n向指定元素（elem）**中** 的末尾添加新元素（newElem）。\r\n\r\n	elem.appendChild(newElem)\r\n\r\n`appendChild` 返回值是我们新创建的标签元素，而且这个方法只能添加标签节点，没有法添加其他类型节点。\r\n\r\n2. `insertBefore()`\r\n\r\n		parentElem.insertBefore(childElem, referElem)\r\n\r\n两个参数都是必给的。而且当第二个参数是 `null` 或者 `undefined` 的时候，`insertBefore` 的作用相当于 `appendChild`。\r\n\r\n`insertBefore` 返回值是我们新插入的标签元素。\r\n\r\n#### 删除和替换元素\r\n\r\n1. `removeChild()`\r\n\r\n		parentElem.removeChild(childElem)\r\n\r\n该方法返回删除的元素。\r\n\r\n2. `replaceChild(newElem, oldChild)`\r\n\r\n该方法返回被替换的元素。\r\n\r\n`newElem` 是要替换进去的元素；`oldChild` 是被替换的旧元素。\r\n\r\n如果用父级里的一个元素替换另一个子元素，则被替换的另一个子元素被删除，那个替换子元素的移动位置到这里（被删除子元素的原位置）来。\r\n\r\n#### cloneNode\r\n\r\n	要克隆的节点.cloneNode(一个布尔值)\r\n\r\n参数：`true` 或 `false`（默认）。返回克隆出来的节点。\r\n\r\n参数为 `true` 时，克隆包括元素本身在内的所有子节点；参数为 `false` 时，只克隆元素本身，不克隆子节点。\r\n\r\n克隆仅是克隆 HTML 和 CSS，JS 是不会被克隆的。如果被克隆元素身上有 JS 功能（比如事件），那么在克隆元素身上不会有的。\r\n\r\n如果被克隆元素身上有 id，那么克隆元素身上也有 id，那么就会重名，不符合标准，所以不要忘记在重置克隆元素的 id 值。\r\n\r\n#### DOM 操作方法的特性\r\n\r\n`appendChild`、`insertBefore` 和 `replaceChild` 如果操作的元素是页面上的已有元素，**那么其实是将已有元素移动**，而不是复制一份----类似于「剪切」操作。\r\n\r\n\r\n### innerHTML 和 DOM 方法的区别\r\n\r\n`innerHTML` 是将元素原来的内容清空，重新添加所有新的内容，会丢失之前所有的事件啦等 JS 内容。\r\n\r\nDOM 方法是对原来内容的追加，不影响原来的元素上的事件啦等 JS 内容部分。\r\n\r\n### 动态与静态获取元素\r\n\r\n动态获取元素是说 `getElementsByTagName`；静态获取元素是说 `querySelectorAll`。\r\n\r\n`querySelectorAll`：\r\n\r\n	1 →\r\n	2\r\n	3\r\n	4\r\n	5\r\n		第一次循环\r\n	2 →\r\n	3\r\n	4\r\n	5\r\n	1 ←\r\n		第二次循环\r\n	3 →\r\n	4\r\n	5\r\n	1\r\n	2 ←\r\n		第三次循环\r\n	4 →\r\n	5\r\n	1\r\n	2\r\n	3 ←\r\n		第四次循环\r\n	5 →\r\n	1\r\n	2\r\n	3\r\n	4 ←\r\n		第五次循环\r\n	1\r\n	2\r\n	3\r\n	4\r\n	5 ←\r\n\r\n\r\n`getElementsByTagName`：\r\n\r\n	1 →\r\n	2\r\n	3\r\n	4\r\n	5\r\n		第一次循环\r\n	2\r\n	3 →\r\n	4\r\n	5\r\n	1 ←\r\n		第二次循环\r\n	2\r\n	4\r\n	5 →\r\n	1\r\n	3 ←\r\n		第三次循环\r\n	2\r\n	4\r\n	1\r\n	3 →\r\n	5 ←\r\n		第四次循环\r\n	2\r\n	4\r\n	1\r\n	5\r\n	3 ← →\r\n		第五次循环\r\n	2\r\n	4\r\n	1\r\n	5\r\n	3 ←\r\n\r\n\r\n所有的 `getElement*` 方法都是动态获取的，DOM 上的属性比如 `children` 也都是动态获取的。\r\n\r\n### DOM 操作表格\r\n\r\n表格中的 `tbody` 标签可以不写，浏览器解析时，会自动加上。但是 **还是建议写**，向标准靠近。\r\n\r\n	<table>\r\n		<thead>\r\n			<tr>\r\n				<td>*</td>\r\n				<td>*</td>\r\n			</tr>\r\n		</thead>\r\n		<tbody>\r\n			<tr>\r\n				<td>*</td>\r\n				<td>*</td>\r\n			</tr>\r\n			<tr>\r\n				<td>*</td>\r\n				<td>*</td>\r\n			</tr>\r\n		</tbody>\r\n		<tfoot>\r\n			<tr>\r\n				<td>*</td>\r\n				<td>*</td>\r\n			</tr>\r\n		</tfoot>\r\n	</table>\r\n \r\n 操作表格前，需要先拿到表格。\r\n\r\n 	var $table = document.querySelector(\'table\');\r\n\r\n1. 获得表格头：\r\n\r\n		var $tHead = $table.tHead;\r\n\r\n`tHead` 返回表格头，包含表格头里的所有内容。一个表格只包含一个 `<thead>`。\r\n\r\n2. 获得表格主体：\r\n\r\n		var $tBodyies = $table.tBodies;\r\n\r\n`tBodies` 返回表格主体内容，是一个数组。因为一个表格中可包含多个 `<thead>`\r\n。让第一个 `tbody` 中的内容背景设定为绿色：\r\n\r\n	$tBodyies[0].style.background = \'green\';\r\n\r\n3. 获得表格底部：\r\n\r\n		var $tFoot = = $table.tFoot;\r\n\r\n`tFoot` 返回表格底部内容。一个表格只包含一个 `<tfoot>`。\r\n\r\n4. 获得表格行：\r\n	\r\n		$table.rows\r\n		$tHead.rows\r\n		$tBodyies[0].rows\r\n		$tFoot.rows\r\n\r\n返回值是一个数组，对应到表格里一行一行的数据。\r\n\r\n5. 获得表格的单元格。\r\n\r\n		行.cells\r\n\r\n返回一行的所有单元格，是个数组。而且不能对整个的单元数组进行操作（因为没有对应的 HTML 标签），只能对单个单元格进行操作。\r\n\r\n	$tHead.rows[0].cells[0].style.fontSize = \'24px\';\r\n\r\n	$tBodyies[0].rows[0].cells[1].style.fontSize = \'24px\';\r\n\r\n	$tFoot.rows[0].cells[0].style.fontSize = \'24px\';\r\n\r\n### DOM 操作表单\r\n\r\n我们获得表单元素\r\n\r\n	var $form = document.querySelector(\'form\');\r\n\r\n每个表单元素都有一个 `name` 属性，我们在表单上使用 `.name属性值` 就能获得对应表单元素了。\r\n\r\n例如，我们有如下的一些表单元素：\r\n\r\n	<input type=\"text\" name=\"username\">\r\n\r\n	<input type=\"radio\" name=\"gender\" value=\"male\">男\r\n	<input type=\"radio\" name=\"gender\" value=\"female\">女\r\n\r\n	<input type=\"checkbox\" name=\"interset\" value=\"eat\">吃饭\r\n	<input type=\"checkbox\" name=\"interest\" value=\"sleep\">睡觉\r\n	<input type=\"checkbox\" name=\"interest\" value=\"play\">打豆豆\r\n\r\n	<select name=\"address\">\r\n		<option value=\"Beijing\">北京</option>\r\n		<option value=\"Tianjin\">天津</option>\r\n		<option value=\"Shanghai\">上海</option>\r\n		<option value=\"Anhui\">安徽</option>\r\n	</select>\r\n\r\n我们分别获得它们的值：\r\n\r\n	$form.username.value\r\n\r\n	$form.gender.value\r\n\r\n	var $interests = $form.interest // 这是个数组，对应所有兴趣组的复选框\r\n\r\n	$form.address.value\r\n	$form.address.selectedIndex // 获得下拉框里内容对应的索引值。\r\n\r\n上面这些，除了复选框的情况，其他都是可以直接获得值的。我们来看看复选框，怎样获得选中的复选框的值列表。\r\n\r\n	var checkedV = [];\r\n\r\n	for (var i = 0; i < $interests.length; i++) {\r\n		if ($interests[i].checked) {\r\n			checkedV.push($interests[i].value);\r\n		}\r\n	}\r\n\r\n	console.log(checkedV);\r\n\r\n#### 表单事件\r\n\r\n在表单中输入数据时，会触发 `input` 事件。\r\n\r\n选择下拉框内容时，如果内容较上一次是改变的，就会触发 `change` 事件。\r\n\r\n当表单提交的时候，会触发 `submit` 事件；当表单重置的时候，出触发 `reset` 事件。注意，这都是发生在表单元素上的。\r\n\r\n表单方法：\r\n	\r\n	表单.submit() // 手动提交表单\r\n\r\n	表单.reset() // 手动重置表单\r\n\r\n`表单.submit()` 方法会触发表单的 `submit` 事件；`表单.reset()` 方法会触发表单的 `reset` 事件。\r\n\r\n手动提交不同于点击（提交/重置）按钮提交，是属于主动提交的。','2017-10-01 12:57:19','2017-10-01 13:02:10','js-d'),(408,3,3,'2017年国庆','> 晚上睡觉，竟然又热起来了。\r\n\r\n我明天就要回家了。现在我没有想到要做什么事情，所以就写点什么吧。\r\n\r\n2017年算是过去很大半了。我早上整理了下衣服、洗了床单，之后也没什么事情做。\r\n\r\n今天国庆。我刚才想到软一峰在微博说：刚才整理以前的笔记……我也想有这件事情做，所以就写起来啦！\r\n\r\n我不想刻意可以夸大我并不存在的情感。但这也不好，因为总是闷着。罗永浩说，行为的高调有时会正向作用在情绪上的，让人有积极的情绪，我相信。\r\n\r\n我在听着歌呢，听到千与千寻。耿路路之前曾经说：我想我差不多明年就有女朋友了，也许就不在上海了。为什么？我爸妈要离开上海……但也说不定。其实我喜欢这样的回答，虽然他讲后我调侃他。\r\n\r\n我也在想明年我差不多也有女朋友了，然后找了一份工资和环境还不错的公司，但又不会一辈子做开发，然后学学吉他唱唱歌，学吉他并不是必须的，只是想到干唱歌好像是人都能，但会点乐器总感觉更酷些。\r\n\r\n在我的认识里，我总感觉要生活、情感丰富些好，否则好像生活整个很无聊（好像是那些年台词？）的，没改变的。\r\n\r\n对了，我都140多斤了，我感觉自己胖了，当然这种感觉很久了，前几天时间坚持跑了一段时间长跑，不过现在又搁置了。不过，回来后会接上的，并不是自制力好怎么样，因为不跑，有时候身体真的感到很难受。所以，这是不得不的选择。','2017-10-01 13:30:20','2017-10-01 15:09:11','201'),(409,3,3,'2017年10月2号','我到家了，浍沟街有些变化，有了牌子，还有烧烤的地方，都是烟。\r\n\r\n阿奶养的那条狗被偷了，十多斤，那天还是下雨天。我说家里好，阿奶说别人不那么说，说家里脏。\r\n\r\n北屋里堆得豆子，我踩着进来的。树叶北风吹得哗哗的，还有叶子落下来，家里面还有蚊子，还说现在还多呢。秋天了，北屋里还堆了些复合肥和化肥，是豆子收完后要散下去的。冥冥中我感觉这样种地的日子看起来不会很长了。\r\n\r\n晚上窗户外听到的是风吹树叶的声音，没有别的嘈杂的东西了。我感觉有些心情平复。','2017-10-02 13:48:30','2017-10-02 13:48:30','in-october-2017-no-2'),(410,3,3,'[转载]在 JavaScript 中触发事件','> https://stackoverflow.com/questions/2490825/how-to-trigger-event-in-javascript\r\n\r\n## 答案1\r\n\r\nYou can use fireEvent on IE 8 or lower, and w3c\'s dispatchEvent on most other browsers. To create the event you want to fire, you can use either createEvent or createEventObject depending on the browser.\r\n\r\nHere is a self-explanatory piece of code (from prototype) that fires an event dataavailable on an element:\r\n\r\n	var event; // The custom event that will be created\r\n\r\n	if (document.createEvent) {\r\n	event = document.createEvent(\"HTMLEvents\");\r\n	event.initEvent(\"dataavailable\", true, true);\r\n	} else {\r\n	event = document.createEventObject();\r\n	event.eventType = \"dataavailable\";\r\n	}\r\n\r\n	event.eventName = \"dataavailable\";\r\n\r\n	if (document.createEvent) {\r\n	element.dispatchEvent(event);\r\n	} else {\r\n	element.fireEvent(\"on\" + event.eventType, event);\r\n	}\r\n\r\n*需要注意的是：`fireEvent()` 是非标准方法（IE6 ~IE10 支持），`dispatchEvent` 是标准方法（IE9+和所有现代浏览器）。*\r\n\r\n## 答案2\r\n\r\nA working example:\r\n\r\n	// Add an event listener\r\n	document.addEventListener(\"name-of-event\", function(e) {\r\n	  console.log(e.detail); // Prints \"Example of an event\"\r\n	});\r\n\r\n	// Create the event\r\n	var event = new CustomEvent(\"name-of-event\", { \"detail\": \"Example of an event\" });\r\n\r\n	// Dispatch/Trigger/Fire the event\r\n	document.dispatchEvent(event);\r\n\r\nFor older browsers [polyfill](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill) and more complex examples, see MDN docs.\r\n\r\nSee support tables for EventTarget.dispatchEvent and CustomEvent.','2017-10-09 07:22:06','2017-10-09 07:41:57','dispatchevent-and-fireevent-triggering-event-to-be-continued'),(411,3,3,'JS Polyfill 收集','1. [eligrey/classList.js][1]：Cross-browser `element.classList`。IE8+\r\n\r\n[1]: https://github.com/eligrey/classList.js','2017-10-10 02:17:36','2017-10-10 02:18:13','js-polyfill-collection'),(412,3,3,'YDNJS（上卷）：对象','JavaScript 中的内置对象包括：\r\n\r\n1. String\r\n2. Number\r\n3. Boolean\r\n4. Object\r\n5. Function\r\n6. Array\r\n7. Date\r\n8. RegExp\r\n9. Error\r\n\r\n这些 **这些内置对象实际上是一些内置函数**。\r\n\r\n我们之所以可以在基本类型上使用对象属性和方法（比如在字符串字面量上使用 `length` 属性和 `charAt` 方法），是因为 **JavaScript 引擎会自动为我们将这些基本类型值转换为对应的对象形式**。\r\n\r\n	\'I am a student\'.length; // 14\r\n	\'I am a teacher\'.charAt(3); // \"m\"\r\n	\r\n	42.359.toFixed(2); //  42.36\r\n\r\n对象有属性，访问对象属性的方式有两种：`.` 操作符和 `[]` 操作符。\r\n\r\n	var myObj = {\r\n		a: 2\r\n	};\r\n	\r\n	myObj.a; // 2\r\n	myObj[\'a\'] // 2\r\n\r\n`.a` 语法通常称为 **“属性访问”**，`[\'a\']` 语法通常被称为 **“键访问”**。我们最常使用属性访问。这两种语法形式的主要区别是：\r\n\r\n1. `.` 操作符：要求属性名满足标识符的命名规范。\r\n2. `[]` 操作符：可以接收任意 UTF-8/Unicode 字符串作为属性名。比如，如果要引用“Super-Fun!”这个属性的话，就必须使用 `[\'Super-Fun!\']` 的形式，因为“Super-Fun!”不是一个有效的标识符属性名。\r\n\r\n**对象的属性名永远是个字符串**，如果使用字符串（string）字面量之外的其它值作为属性名的话，那么首先会被转换成一个字符串，即使数字也不例外。\r\n\r\n如果对象的一个属性是函数，那么把这个函数称为“方法”是不妥的——特别是在函数中包含 `this` 的时候，由于 `this` 是在函数执行时动态绑定的，具体的值跟调用位置有关。所以，从技术上来说，函数永远不会属于一个对象。\r\n\r\n最保险的说法是，“函数”和“方法”在 JavaScript 中是可以互换的。\r\n\r\n**数组和普通对象都根据其对应的行为和用途进行了优化**，所以 **最好只用对象来存储键/值对，只用数组来存储数值下标/值对**。','2017-10-10 05:41:02','2017-10-10 07:01:19','ydnjs-coil-object'),(413,3,3,'YDNJS（上卷）：对象属性描述符','从 ES5 开始，所有的对象都具有了属性描述符。\r\n\r\n## 描述符的默认值\r\n\r\n我们使用声明（文字）形式给一个普通对象定义一个普通属性。\r\n\r\n	var obj = {\r\n		a: 2\r\n	};\r\n	\r\n	// Object.getOwnPropertyDescriptor(obj, \'a\');\r\n	// {\r\n	// 	value: 2, \r\n	// 	writable: true, \r\n	// 	enumerable: true, \r\n	// 	configurable: true\r\n	// }\r\n\r\n我们虽然没有手动指定 `a` 的属性描述符，但是 **这里使用了属性描述符的默认值**。\r\n\r\n除了数据值（value），还包括其它 3 个特性：writable（可写）、enumerable（可枚举）和 configurable（可配置）。\r\n\r\n如果不使用属性描述符的默认值，可以使用 `object.defineProperty(..)` 来添加一个新属性或者修改一个已有属性（如果 configurable 为 true）。\r\n\r\n	Object.defineProperty(obj, \'a\', {\r\n		value: 2,\r\n		writable: true,\r\n		configurable: true,\r\n		enumerable: true\r\n	});\r\n	\r\n	obj.a; // 2\r\n\r\n看，我们用 `defineProperty` 添加了一个普通属性并显式指定了一些特性。但一般不这么做，除非是要修改属性描述符。\r\n\r\n## Writable\r\n\r\nwritable 决定是否可以修改属性的值。\r\n\r\n	Object.defineProperty(obj, \'a\', {\r\n		value: 2,\r\n		writable: false, // 不可写\r\n		configurable: true,\r\n		enumerable: true\r\n	});\r\n	\r\n	obj.a = 3;\r\n	obj.a; // 2\r\n\r\n属性值修改静默失败了。如果在严格模式下，就会报 `TypeError` 错误。\r\n\r\n## Configurable\r\n\r\nconfigurable 设置为 `true` 时，说明属性是可配置的，即可以使用 `defineProperty(..)` 方法修改属性描述符。\r\n\r\n	var obj = {\r\n		a: 2\r\n	};\r\n	\r\n	obj.a = 3;\r\n	obj.a; // 3\r\n	\r\n	Object.defineProperty(obj, \'a\', {\r\n		value: 4,\r\n		writable: true,\r\n		configurable: false, // 属性修改为不可配置的了\r\n		enumerable: true\r\n	});\r\n	\r\n	obj.a; // 4\r\n	obj.a = 5;\r\n	obj.a; // 5\r\n	\r\n	Object.defineProperty(obj, \'a\', {\r\n		value: 4,\r\n		writable: true,\r\n		configurable: true,\r\n		enumerable: true\r\n	}); // TypeError \r\n\r\n看，最后一次使用 `defineProperty` 时报 `TypeError` 错了——无论是不是处于严格模式，都会报这个错。\r\n\r\n所以，把 configurable 修改成 `false` 是单向操作，无法撤销！\r\n\r\n把 configurable 修改成 `false` 还会禁止属性的删除（delete obj.a）。\r\n\r\n## Enumerable\r\n\r\n该描述符控制属性是否会出现在对象的属性枚举中，比如 `for..in` 循环。设置成 `false` 就不会出现在枚举中，否则，出现在枚举中。','2017-10-10 06:58:47','2017-10-10 07:28:50','ydnjs-coil-object-property-descriptors'),(414,3,3,'YDNJS（上卷）：[[Prototype]]','JavaScript 中的对象（默认）都有一个特殊的内置属性 `[[Prototype]]`，其实是对其他对象的引用。\r\n\r\n## [[Prototype]]\r\n\r\n`[[Prototype]]` 引用可为空，但很少见。\r\n\r\n有一个对象 `myObj`：\r\n\r\n	var myObj = {\r\n		a: 2\r\n	};\r\n	\r\n	myObj.a; // 2\r\n\r\n我们通过 `myObj.a` 访问到了值 2。这是一个获得对象属性的操作，是一个 [[Get]] 操作，对于 [[Get]] 操作，它查找属性的流程如下：\r\n\r\n	第一步：检查对象本身是否有这个属性。有的话返回，没有走「第二步」。\r\n	第二步：继续访问对象的 [[Prototype]] 链，寻找属性。有的话返回，没有走「第三步」。\r\n	第三步：继续访问 [[Prototype]] 链所代表的对象的 [[Prototype]] 链上是否有该属性，找到的话返回，没有的话，继续重复、向上查找原型链上的属性...\r\n	第四步：最终找到 `Object.prototype` 这个对象身上，如果还没找到要找的属性，就返回 `undefined`。\r\n\r\n可以看到，[[Get]] 操作会持续找要匹配的属性名，没有的话，就会查找完整条 [[Prototype]] 链，最终找到 [[Prototype]] 链顶端（`Object.prototype` 对象），没有就返回 `undefined`。\r\n\r\n## Object.prototype\r\n\r\n[[Prototype]] 链的尽头就是 `Object.prototype` 了，这是一个 JavaScript 内置对象。\r\n\r\nJavaScript 中的所有的普通（自己创建的）或者内置（自带的）对象的 [[Prototype]] 链顶端都是设置为 `Object.prototype` 这个对象。\r\n\r\n因此在对象上，可以使用一些通用的方法，比如 `.toString()`、`.valueOf()`、`hasOwnProperty(..)` 以及之后要介绍的 `.isPropertyOf(..)`。','2017-10-10 23:37:59','2017-10-10 23:45:50','ydnjs-coil-prototype'),(415,3,3,'YDNJS（上卷）：函数有一个特殊的属性 prototype！','JavaScript 中只有对象，没有类。\r\n\r\n实际上，JavaScript 才是真正应该被称为「面向对象」的语言，因为它是少有的可以不通过类，直接创建对象的语言。\r\n\r\n## 函数的 prototype 属性\r\n\r\n在 JavaScript 中，之所以会有「类」的错觉，是因为**函数默认都会有一个名为 `prototype` 的公有并且不可枚举的属性**，这个属性会指向另一个对象：\r\n\r\n	function Foo() {}\r\n	\r\n	Foo.prototype; // {}\r\n\r\n`Foo.prototype` 所指向的对象通常被称为 **Foo 的原型**。\r\n\r\n我们来看下代码：\r\n\r\n	function Foo() {}\r\n	\r\n	var a = new Foo();\r\n	\r\n	Object.getPrototypeOf(a) === Foo.prototype; // true\r\n\r\n调用 `new Foo()` 时会创建一个新对象 `a`，其中的一步就是将新对象 `a` 内部的 [[Prototype]] 链接（关联）到 `Foo.prototype` 所指向的对象。\r\n\r\n## Object.create(..) 方法\r\n\r\n生成一个关联到其它对象的新对象，可以使用 `Object.create(..)` 方法。看下面的例子：\r\n\r\n	var anotherObj = {\r\n		a: 2\r\n	};\r\n	\r\n	// 创建一个关联到 anotherObj 的对象\r\n	var myObj = Object.create(anotherObj);\r\n	\r\n	myObj.a; // 2\r\n\r\n现在 `myObj` 对象的 [[Prototype]] 关联到了 `anotherObj`。显然 `myObj.a` 并不存在，仅是尽管如此，属性访问仍然成功地（在 `anotherObj` 中）找到值 2。\r\n\r\n如果在 `anotherObj` 也找不到 `a` 并且 `anotherObj` [[Prototype]] 链不为空的话，就会继续查找下去……这个过程会持续到找到匹配的属性名为止，要不然一直查找到 [[Prototype]] 链顶端的 `Object.prototype` 对象，还找不到就返回 `undefined` 了。','2017-10-11 00:22:42','2017-10-11 00:59:32','ydnjs-coil-the-function-has-a-special-property-prototype'),(416,3,3,'YDNJS（上卷）：对函数的「构造调用」','在 JavaScript 中，根本就不存在「构造函数」，只有对函数的「构造调用」。换句话说，在 JavaScript 中对于 「构造函数」的最准确的解释是，所有带 `new` 的函数调用。\r\n\r\n思考下面的代码：\r\n\r\n	function Foo() {\r\n		// ...\r\n	}\r\n	\r\n	Foo.prototype.constructr === Foo; // true\r\n	\r\n	var a = new Foo();\r\n	a.constructor === Foo; // true\r\n\r\n`Foo.prototype` 默认有一个共有并且不可枚举的属性 `.constructor`，这个属性引用的是与原型对象关联的函数（本例是 `Foo`）。\r\n\r\n注意到，`a` 对象上并没有 `.constructor` 这个属性， `a.constructor` 取得是 `Foo.prototype` 的 `.constructor` 属性的值——这是因为通过 `new Foo()` 创建的 `a` 对象的内部 [[Prototype]] 链关联了 `Foo.prototype` ，而 `a.constructor` 最终查找了 [[Prototype]]  链指向的那个对象（也就是 `Foo.prototype`）属性的缘故。\r\n\r\n再思考下面的代码：\r\n\r\n	function Foo() {}\r\n	\r\n	Foo.prototype = {}; // 创建一个新的原型对象\r\n	\r\n	var a1 = new Foo();\r\n	a1.constructor === Foo; // false\r\n	a1.constructor === Object; // true！\r\n\r\n这很好理解——`a1` 并没有 `.construtor` 属性，所以它会委托 [[Prototype]] 链上的 `Foo.prototype`，但是 `Foo.prototype` 对象也没有这个属性（而默认的 Foo.prototype 原型对象时有的），所以会继续委托，这次就会委托给原型链顶端的 `Object.prototype` 了，`Object.prototype` 有 `.constructor` 属性，指向内置的 `Object(..)`  函数。','2017-10-11 04:05:49','2017-10-20 05:23:37','ydnjs-coil-the-function-of-structural-call'),(417,3,3,'YDNJS（上卷）：直接修改对象的 [[Prototype]] 关联','使用 `Object.create(..)` 关联对象会带来性能损失：垃圾回收旧对象、丢失 `.constructor` 属性。\r\n\r\n	function Foo() {}\r\n	\r\n	function  Bar() {}\r\n	\r\n	Bar.prototype.constructor; // Bar\r\n	\r\n	// Object.create 生成了一个新对象给 Bar.prototype 引用了，Bar.prototype 原来的对象稍后会被垃圾回收机制回收。\r\n	Bar.prototype = Object.create(Foo.prototype);\r\n	\r\n	// 此时的 Bar.prototype 已没有自己的 `.constructor` 属性，这里显示的是 Foo.prototype.constructor 的值。\r\n	Bar.prototype.constructor; // Foo\r\n\r\n---\r\n\r\n在 ES6 之前，我们只能通过 `__proto__` 来修改对象的 [[Prototype]] 关联，但是这个方法并不是标准的并且无法兼容所有浏览器。ES6 添加了辅助函数 `Object.setPrototypeOf(..)` 这个标准且可靠的方法来修改关联。\r\n\r\n	// ES6 之前需要抛弃默认的 Bar.prototype\r\n	Bar.prototype = Object.create(Foo.prototype);\r\n	\r\n	// 从 ES6 开始可以直接修改现有的 Bar.prototype 了\r\n	Object.setPrototypeOf(Bar.prototype, Foo.prototype);\r\n\r\n如果忽略掉 `Object.create(..)` 方法带来的轻微性能损失，它比 ES6 及其之后的方法更短、可读性更高。','2017-10-11 05:43:16','2017-10-11 06:00:36','ydnjs-coil-modify-the-object-directly-prototype'),(418,3,3,'YDNJS（上卷）：instanceof 和 isPrototypeOf()','## instanceof\r\n\r\n`instanceof` 操作符的左操作数是一个普通的对象，右操作数是一个函数：\r\n\r\n	function Foo() {\r\n		// ...\r\n	}\r\n	\r\n	Foo.prototype.blah = ...;\r\n	\r\n	var a = new Foo();\r\n	\r\n	a instanceof Foo; // true\r\n\r\n`instanceof` 回答的问题是：在 `a` 的整条 [[Prototype]] 链中是否出现了 `Foo.prototype`。但是这个方法只能处理对象（a）和函数（带 `.prototype` 属性的 `Foo`）之间的关系。如果是**处理对象与对象之间的关系，`instanceof` 无能为力**。\r\n\r\n这时，就要使用 `isPrototypeOf(..)` 方法了。\r\n\r\n## isPrototypeOf(..)\r\n\r\n来，我们起来实现跟前面一样的检查效果。\r\n\r\n	Foo.prototype.isPrototypeOf(a); // true\r\n\r\n`isPrototypeOf(..)` 方法回答的问题是： `Foo.prototype` 对象是否在 `a` 的整条 [[Prototype]] 链中出现了（跟前面的作用是一样的，不过看待角度不一样而已）。\r\n\r\n两个对象之间的关联判断就是这样：\r\n\r\n	// 非常简单：b 对象是否在 `a` 的整条 [[Prototype]] 链中出现了。\r\n	b.isPrototypeOf(a);\r\n\r\n我们也可以直接获得一个对象的 [[Prototype]] 链，或者换个说法——访问对象内部的 [[Prototype]] 属性。两个方法：\r\n\r\n1. `__proto__` 属性（非标准）：\r\n\r\n		a.__proto__ === Foo.prototype; // true\r\n\r\n2. `Object.getPrototypeOf(..)`：\r\n\r\n		Object.getPrototypeOf(a) === Foo.prototype; // true \r\n\r\n还有设置对象内部的 [[Prototype]] 属性的 `Object.setPrototypeOf(..)` 方法，但一般不建议使用——**最好把内部的 [[Prototype]] 属性看做是只读属性，从而增加代码的可读性**。','2017-10-11 06:31:59','2017-10-11 06:35:03','ydnjs-coil-instanceof-and-isprototypeof'),(419,3,3,'table 的 border-collapse 属性与 border-spacing 属性','如果要设置 [`border-spacing`][1] 属性，需要确保 [`border-collapse: separate;`][2]。\r\n\r\n	table {\r\n		border-collapse: separate;\r\n		border-spacing:15px;\r\n	}\r\n	\r\n	/* 再设置边框 */\r\n	table, th, td {\r\n		border: 1px dashed #000;\r\n	}\r\n\r\n如果合并单元格边框的话，直接设置 `border-collapse:collapse;` 即可。\r\n\r\n	table {\r\n		border-collapse:collapse;\r\n	}\r\n\r\n	table, td, th {\r\n		border:1px solid #000;\r\n	}\r\n\r\n[1]: http://www.w3school.com.cn/cssref/pr_tab_border-spacing.asp\r\n[2]: http://www.w3school.com.cn/cssref/pr_tab_border-collapse.asp','2017-10-12 03:14:58','2017-10-12 03:14:58','table-border-the-collapse-and-border-spacing-attribute'),(420,3,3,'YDNJS（上卷）：对象不变性','有时候会希望属性或者对象是不可变的，在 ES5 中有很多实现方式。但很重要的一点是：**所有的实现方式都是浅不变性的，只会影响目标对象和它的直接属性**。\r\n\r\n	myObj.foo; // [1, 2, 3]\r\n	myObj.foo.push(4); \r\n	myObj.foo; // [1, 2, 3, 4]\r\n\r\n虽然 `myObj` 是不可变的，但是它的属性 `foo` 引用的对象内容是可以改变的。\r\n\r\n## 常量属性\r\n\r\n设置 `writable: false` 和 `configurable: false` 就可以创建一个常量属性。\r\n\r\n	var myObj = {};\r\n	\r\n	Object.defineProperty(myObj, \'FAVORITE_NUMBER\', {\r\n		value: 22,\r\n		writable: false,\r\n		configurable: false\r\n	});\r\n	\r\n## 禁止扩展\r\n\r\n如果禁止一个对象添加新属性，使用 `Object.preventExtensions(..)`：\r\n\r\n	var myObj = {\r\n		a: 2\r\n	};\r\n	\r\n	Object.preventExtensions(myObj);\r\n	\r\n	myObj.b = 3;\r\n	myObj.b; // undefined\r\n\r\n但是可以删除属性：\r\n\r\n	delete myObj.a; \r\n	myObj; // {}\r\n\r\n## 密封\r\n\r\n所谓的「密封」就是说对象的 `configurable` 属性描述符设置为 `false` 了。使用 `Object.seal(..)` 方法，它在现有对象上调用了 `Object.preventExtensions(..)` 方法并把所有现有属性标记为 `configurable: false`。\r\n\r\n密封之后，对象不能添加新属性，也不能重新配置属性以及删除任何现有属性，但可以修改属性的值：\r\n\r\n	var myObj = {\r\n		a: 2\r\n	};\r\n	\r\n	Object.seal(myObj);\r\n\r\n	myObj.b = 3;\r\n	myObj.b; // undefined\r\n	\r\n	delete myObj.a; // false\r\n\r\n	myObj.a = 22;\r\n	myObj.a; // 22\r\n\r\n## 冻结\r\n\r\n`Object.freeze(..)` 方法是在现有对象上调用了 `Object.seal(..)` 方法并把所有现有属性标记为 `writable: false`，这样也无法修改属性值了。\r\n\r\n`Object.freeze(..)` 方法处理后的对象是最高级别的不可变性。\r\n\r\n## 总结\r\n\r\n| 方法 | 添加属性 | 配置属性 | 删除属性 | 修改属性 |\r\n| -------- | -------- | -------- | -------- |  -------- | \r\n| `Object.preventExtensions(..)` | ✘     | ✔     | ✔     | ✔     |\r\n| `Object.seal(..)`   | ✘     |  ✘      |  ✘     | ✔      |\r\n| `Object.freeze(..)`  | ✘    | ✘     | ✘     | ✘     |','2017-10-12 05:35:11','2017-10-12 05:42:04','ydnjs-coil-the-invariance-of-the-object'),(421,3,3,'2017年10月12号','我刚才稍微有点深入睡眠，但还没有。\r\n\r\n我想起（也许是想象到）一种美妙，仰看这陈旧的世界周遭，感觉充满灰尘和恋旧，我很小，对身边的事情都不熟悉。\r\n\r\n也许是听 Moon River 的副作用吧，我突然感觉到一种有价值的追求。\r\n\r\n---\r\n\r\n我突然感觉世界没有变，人还是要考虑到情感上过得去过不去。\r\n\r\n没有粗糙和简陋，只有不断的坚持和使用才带来价值。','2017-10-12 12:05:54','2017-10-12 12:08:39','on-october-12-2017'),(422,3,3,'CSS 揭秘：半透明边框','如果在一个具有白色背景的元素上，设置一个半透明的白色边框。下面这样的样式看起来不会有效果（看起来整个一白色方块）。\r\n\r\n	background: white;\r\n	border: 10px solid rgba(255, 255, 255, .5);\r\n\r\n因为，**元素的背景颜色默认延伸到边框**。半透明白色 + 白色 = 白色，所以边框看起来也是白色的。\r\n\r\n## background-clip\r\n\r\nCSS3 中新增了一个 `background-clip` 属性，用来设定元素的背景颜色延伸到的区域，有三个取值：\r\n\r\n1. `border-box`（默认）：背景颜色延伸到边框。\r\n2. `padding-box`：背景颜色延伸到内边距。\r\n3. `content-box`：背景颜色保持在内容区。\r\n\r\n需要注意的是，这个属性对背景图片的影响不确定，而且 **控制背景图片的延伸区域应该使用 `background-origin` 属性**。\r\n\r\n## 解决方案\r\n\r\n半透明边框的问题就是用 `background-clip` 这个属性的解决的，之所以发生问题，是因为背景颜色延伸到边框了，所以我们 **将背景设定为延伸到内边距** 就行了。\r\n\r\n	background: white;\r\n	border: 10px solid rgba(255, 255, 255, .5);\r\n	background-clip: padding-box;\r\n	\r\n参见：http://play.csssecrets.io/translucent-borders','2017-10-18 01:08:21','2017-10-20 03:08:49','css-disclosure-translucent-border'),(423,3,3,'CSS 揭秘：多重边框','多重边框就是一个元秦外围看起来有多个边框，有时为了实现这个效果，我们可能会使用多个元素来模拟多重边框----这很丑陋。\r\n\r\n## box-shadow 方案\r\n\r\n大多数人用过或者滥用过 `box-shadow` 来生成投影。不为人知的是它还有第四个参数----扩张半径（spread）。\r\n\r\n	box-shadow: h-shadow v-shadow blur spread color inset;\r\n\r\n当 `box-shadow` 没有设置阴影水平偏移（h-shadow）、阴影垂直偏移（v-shadow）和模糊范围（blur）时，设置的 **扩张半径相当于元素边框**。\r\n\r\n	background: yellowgreen; \r\n	box-shadow: 0 0 0 5px gray;\r\n\r\n但这完全可以用 `border` 完成一样额效果。\r\n	\r\n	background: yellowgreen; \r\n	box-shadow:  5px solid  gray;\r\n	\r\n但 `box-shadow` 支持 **逗号分隔语法，我们可以创建任意数量的投影**。\r\n\r\n	background: yellowgreen; \r\n	box-shadow: 0 0 0 5px gray, 0 0 0 10px deeppink;\r\n\r\n得到的效果是：5px 的灰色边框外面，有一个 5px 的深粉色边框。这是因为：`box-shadow` 是层层叠加的，第一层阴影位于最顶层，如果要在边框外再指定一道 5px 的边框，那需要的扩展半径就是 `10px`（10px + 5px）。\r\n\r\n使用 `box-shadow` 生成的边框，需要注意的是：\r\n\r\n1. 只能绘制出来实线。\r\n2. 支持 `border-radiuds` 属性。\r\n\r\n		background: #655; \r\n		border: 2px dashed #fff; \r\n		box-shadow: 0 0 0 5px #655;\r\n		border-radius: 5px;\r\n		\r\n2. 边框不占据实际页面空间，不影响页面布局元素。所以有外部扩展半径的元素，需要设置合理的外边距值（`margin`）；有内部扩展半径的元素，需要设置合理的内边距值（`padding`）。\r\n\r\n## outline 方案\r\n\r\n如果只需要设置两层边框，那么可以使用 `outline`（描边）属性实现。而且与 `box-shadow` 只能实现实线边框不同的是，**我们可以实现虚线边框效果**。 \r\n\r\n	background: #655; \r\n	border: 2px dashed #fff; \r\n	outline: 5px solid #655;\r\n	\r\n我们还可以使用 `outline-offset` 属性设置描边的偏移距离。\r\n\r\n	outline-offset: 5px;\r\n\r\n但与 `box-shadow` 方案相同的是： \r\n\r\n1. 边框不占据实际页面空间。\r\n2. 并不支持 `border-radius` 属性。','2017-10-18 02:02:59','2017-10-18 02:02:59','css-revealed-multiple-frames'),(424,3,3,'CSS 揭秘：灵活的背景','可以使用 `backgorund` 属性为元素设定背景图片。\r\n\r\n	background: #7a92af url(http://www.baooab.com/wp/wp-content/uploads/2017/10/cha.png) no-repeat right bottom;\r\n		\r\n效果如下，我们将背景图片的位置定位到了 **右下角**。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/10/cha2.png)\r\n\r\n这可能不是想要的效果，我们希望背景图片要稍微往里一些----就是说与右边界空一段距离，与下边界空一段距离。\r\n\r\n##  background-postion 的扩展语法方案\r\n\r\n这时候可以使用 `background-postion` 的扩展语法：\r\n\r\n	background-position: right 12px bottom 10px;\r\n\r\n它的意思是：背景图片距离右边界 12px，距离下边界 10px。\r\n\r\n参考：http://play.csssecrets.io/extended-bg-position\r\n\r\n## background-origin 方案\r\n\r\n### 默认背景图片的位置\r\n\r\n与背景颜色不同的是，**默认背景图片的位置延伸到内边距** 而不是延伸到边框。\r\n\r\n	background: #7a92af url(http://www.baooab.com/wp/wp-content/uploads/2017/10/cha.png) no-repeat;\r\n	border: 5px dashed darkred;\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/10/cha3.png)\r\n\r\n关于背景图片的延伸区域，我们通过 `background-origin` 属性设定，它包含一下三个值：\r\n\r\n1. `border-box` ：背景图片延伸到边框。\r\n2. `padding-box`（默认）：背景图片延伸到内边距。\r\n3. `cotent-box`：背景图片保持在内容区。\r\n\r\n`background-postion` 的 bottom、right、top、left 的位置默认就是以 `padding-box` 为准的，是靠着 `padding-box` 的边界布局的。\r\n \r\n ### background-origin 实现\r\n \r\n 如果考虑到 background-postion 的扩展语法的兼容性，咱们可以不使用这个扩展语法，而是使用 `padding` 和 `background-postion` 来实现----将背景图片保持在内容区，并且设定元素内边距来实现距离边界距离的效果。\r\n \r\n	 background-position: right bottom;\r\n	 background-origin: content-box; /* 将背景图片保持在内容区 */\r\n	 padding: 0 12px 10px 0;\r\n\r\n这样也能实现一样的效果。\r\n\r\n参考：http://play.csssecrets.io/background-origin\r\n\r\n\r\n## calc() 方法\r\n\r\n还有一种更简单的方法，就是使用 `calc()` 自动计算函数。\r\n\r\n	background: #7a92af url(http://www.baooab.com/wp/wp-content/uploads/2017/10/cha.png) no-repeat;\r\n	background-position: calc(100% - 12px) calc(100% - 10px);\r\n\r\n1. `calc(100% - 12px)` 表示水平方向上的距离----离右边界 12px。\r\n2. `calc(100% - 10px)` 表示垂直方向上的距离----离下边界 10px。\r\n\r\n参考：http://play.csssecrets.io/background-position-calc','2017-10-18 04:57:39','2017-10-18 05:56:41','css-disclosure-flexible-background'),(425,3,3,'CSS 揭秘：条纹背景','我们创建一个从黄色到绿色的线性渐变效果：\r\n\r\n	background: linear-gradient(yellow, green);\r\n\r\n这是一个垂直方向上的渐变效果，起点（顶部）是黄色，终点是绿色（底部），中间都是过渡色。\r\n\r\n## 色标\r\n\r\n过渡区域是可以调整的，默认的过渡效果占据垂直方向上的 100% 区域。也就是说\r\n\r\n	background: linear-gradient(yellow, green);\r\n	\r\n	// 等同于\r\n	background: linear-gradient(yellow 0 , green 100%);\r\n\r\n100% 的过渡区域就是 **100% - 0** 得到的结果。如果调整过渡区域到 60%，那么我们就可以写\r\n\r\n	background: linear-gradient(yellow 20%, green 80%);\r\n\r\n它表示：**黄色从距离顶部 20% 的高度开始过渡，之前都是纯黄色；绿色从距离底部 20% 的高度往下不再过渡，之后都是纯绿色。就是说过渡区域缩小到中间 60% （80% - 20%）的部分了**，20% 表示过渡效果的起点，80% 表示过渡效果的终点。\r\n\r\n我们把 20% 和 80% 位置处的水平那条线（假想出来的）称为「色标」，默认的色标位置在 0 和 100% 位置处，我们刚才做的就是拉近两色标之间的距离，来缩小过渡区域。\r\n\r\n## 水平条纹\r\n\r\n### 两条巨大的水平条纹\r\n\r\n当两个色标之间的距离拉近的足够小（即为 0 ）时，就会有两条巨大的水平条纹效果。\r\n\r\n	background: linear-gradient(yellow 50%, green 50%);\r\n\r\n### 元素填满水平条纹\r\n\r\n**渐变其实是图片，只不过这个图片是由代码生成的**。所以我们可以像设置背景图片一样设置渐变效果。下面我们通过 `background-size` 属性来调整渐变尺寸----宽 100%，高 30px。\r\n\r\n	background: linear-gradient(yellow 50%, black 0); // 这里的 `0` 表示色标值跟前一个一样，也就是 50%。\r\n	background-size: 100% 30px;\r\n\r\n默认渐变效果（也即背景图片）会填满整个元素空间的。在这里，如果被设置渐变效果的元素的高度大于 30px，我们就能看到整个元素里填满了水平条纹的效果。\r\n\r\n### 三条水平条纹\r\n\r\n实现三条水平条纹的原理是这样的：我们的色标一共有 4 个，上面两个合并在 33.3% 的位置上、下面两个合并在 66.6% 的位置上。\r\n\r\n	background: linear-gradient(yellow 33.3%, black 0, black 66.6%, blue 0);\r\n	background-size: 100% 45px;\r\n\r\n## 垂直条纹\r\n\r\n实现垂直条纹跟水平条纹几乎一样，差别在于：需要在开头加一个表示渐变方向的参数 `to right`。在水平条纹中，我们也可以加上这个参数，只不过这个参数的默认值就是 `to bottom`，已经符合我们实现水平条纹的需要了。接下来还需要把 `background-size` 的值颠倒一下。\r\n\r\n	background: linear-gradient(to right, yellow 33.3%, black 0, black 66.6%, blue 0);\r\n	background-size: 30px 100%;\r\n	\r\n	background: linear-gradient(to right, yellow 33.3%, black 0, black 66.6%, blue 0);\r\n	background-size: 33.34% 100%;\r\n\r\n## 斜向条纹\r\n\r\n对于非水平和垂直的斜向条纹，我们使用 `repeating-linear-gradient` 属性创建，下面是一个例子：\r\n\r\n	background: repeating-linear-gradient(45deg, yellow, yellow 15px, black 0, black 30px);\r\n	\r\n`repeating-linear-gradient` 表示重复渲染过渡效果。每一个过渡效果的宽度是 30px，前 15px 的宽度是黄色，后 15px 的宽度是黑色，并且过渡背景顺时针转动了 45 度。\r\n\r\n与 `linear-gradient` 不同的是，`repeating-linear-gradient` 渲染出来的是充满元素的整个效果，而不是 `linear-gradient` 所表示的一个个过渡块平铺出来的效果（虽然能实现，但是需要精确和重复多个的声明）。\r\n\r\n而且使用 `repeating-linear-gradient` 是无需设置 `background-size` 属性的。\r\n\r\n### 同色系条纹\r\n\r\n如果我们想要的条形图案是由同一个色系的颜色组成的。那么可以这样实现：**将最深的颜色指定为背景色，把半透明的白色条纹叠加到背景色上来得到浅色条纹**。\r\n\r\n	background: #58a;\r\n	background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px,\r\n	transparent 0, transparent 30px);\r\n\r\n我们的背景色是 `#58a`，图案顺时针转动 30 度，从左下角到右上角的过渡色就变成了浅色、深色、浅色、深色……','2017-10-19 00:23:09','2017-10-19 02:19:01','css-linear-gradient'),(426,3,3,'encodeURI 和 encodeURIComponent','## encodeURI\r\n\r\n`encodeURI(URIstring)` 方法不会对 ASCII 字母（包括标点符号 - _ . ! ~ * \' ( )）、其他字符（;/?:@&=+$,#）和数字进行编码，但是 **会对汉字和空格符编码**。\r\n\r\n	document.write(encodeURI(\"http://www.w3school.com.cn\")+ \"<br />\")\r\n	document.write(encodeURI(\"http://www.w3school.com.cn/My first/\"))\r\n	document.write(encodeURI(\",/?:@&=+$#\"))\r\n	\r\n	// 打印如下结果\r\n	http://www.w3school.com.cn\r\n	http://www.w3school.com.cn/My%20first/\r\n	,/?:@&=+$#\r\n\r\n## encodeURIComponent\r\n\r\n`encodeURIComponent(URIstring)` 方法不会对 ASCII 字母（包括标点符号 - _ . ! ~ * \' ( )）和数字进行编码，但是 **会对其他字符（;/?:@&=+$,#）、汉字和空格符编码**。\r\n\r\n	document.write(encodeURI(\"http://www.w3school.com.cn\")+ \"<br />\")\r\n	document.write(encodeURI(\"http://www.w3school.com.cn/My first/\"))\r\n	document.write(encodeURI(\",/?:@&=+$#\"))\r\n\r\n	// 打印如下结果\r\n	http%3A%2F%2Fwww.w3school.com.cn\r\n	http%3A%2F%2Fwww.w3school.com.cn%2Fp%201%2F\r\n	%2C%2F%3F%3A%40%26%3D%2B%24%23\r\n\r\n## 参考链接\r\n\r\n1. http://w3school.com.cn/jsref/jsref_encodeuri.asp\r\n2. http://w3school.com.cn/jsref/jsref_encodeURIComponent.asp','2017-10-19 07:04:34','2017-10-19 07:09:11','the-encodeuri-and'),(427,3,3,'【阅读】如何每月高效工作200小时？环境、身体、头脑缺一不可','> 原文链接：http://reader.s-reader.com/article/58/3446852.html\r\n\r\n那些新闻其实并不能让我们知情而只会哗众取宠，传播负面情绪，完全是影响注意力的。跟踪最新的政治危机或者一些丑闻对你来说能有什么好处呢？对于这些事件你做不了任何有意义的事情。\r\n\r\n你其实并不真的需要在手机上使用Facebook、Twitter或者任何新闻流，除非你是记者。聊天应用足够让你保持联系了；想了解什么新东西读Pocket的保存文章是个消遣时间的好办法，如果你没有更好的事情去做的话。\r\n\r\n拼命赶工不是生产力——这只是缺乏通过良好规划和高度专注而实现的真正生产力之后的一种紧急的补救措施。\r\n\r\n每天至少要保证7小数的睡眠，但一些人需要8小时，这些都没问题。白天当我觉得头昏脑涨的时候我会小睡30到60分钟，因为睡觉可以清楚我们大脑里面的毒素，让思维清晰。咖啡喝得再多也没有这种效果。\r\n\r\n现在大概每个人都知道缺乏身体锻炼会害死人，但如果你觉得这还不够的话，其危害还包括记忆和思维。我们的祖先为了生存要进行大量的移动，我们的身体因此也发生了进化，所以表现好的血流量往往会更高。而那些一周去两次健身房的一般都不会有太大帮助——我们需要一整天的定期活动来保持生产力和健康。\r\n\r\n研究人员发现，久坐3个小时就会导致血流降低，因此动脉就得扩大来做出响应。然而，这段时间只需要站起来走5分钟就能防止这种情况发生。\r\n\r\n可以在桌面电脑上安装一个应用，提醒你每小时要休息3到5分钟。很重要的的一点：让它完全把屏幕都关了，连“跳过”或者“延迟”的按钮都不要有，否则的话你可以会无视这些休息。\r\n\r\n不要吃经过重度加工的垃圾食品，小心糖分和食盐的摄入量，注意控制总的卡路里，多喝水和茶，少喝含糖饮料，可能的话尽量在家煮饭，食材以蔬菜植物为主。\r\n\r\n坚持是关键。往往你需要数月的时间才能看到结果，所以不要早早就举白旗。\r\n\r\n但如果任何东西都不能帮助集中注意力时，不妨完全放松下来让你的大脑休息一下。不要看手机或者消费任何类型的内容——只需走走，做做锻炼或者小憩一下。\r\n\r\n我不是要建议你要“辞掉工作跟着激情走”那种陈腔滥调——这样是不成熟的，而且也不是每个人都有一个爱好。我的意思是说你得找到一件值得去做的事情，找一件感觉你付出的努力对这个世界是有帮助的事情去做。\r\n\r\n在改善生产力的时候，不要指望一周内就有改善，因为大脑需要大量时间对新行为进行重构。相反，可以制订小一点的绩效指标，比如“每个月进步5%”。','2017-10-19 09:25:34','2017-10-25 11:23:17','reading-how-to-efficient-work-200-hours-a-month-environment-body-and-mind-be-short-of-one-cannot'),(428,3,3,'JavaScript 正则表达式学习笔记','正则表达式用来操作字符串。\r\n\r\n先来回顾一下操作字符串的一些方法：\r\n\r\n1. `indexOf()`：通过字符找下标。\r\n2. `substring()`：截取字符串。\r\n3. `charAt()`：通过下标找字符。\r\n4. `split()`：分隔字符串成数组。\r\n\r\n## 找出一个字符串里的一段段数字组合的集合\r\n\r\n	var str = \'jdkfdj451212t45lfgb67ffgg5940540m344ioirto89085\';\r\n	var res = [];\r\n	var tempStr = \'\';\r\n\r\n	for (var i = 0; i < str.length; i++) {\r\n		if (isNumberable(str[i])) {\r\n			tempStr += str[i];\r\n		} else if (tempStr !== \'\') {\r\n			res.push(tempStr);\r\n			tempStr = \'\';\r\n		}\r\n	}\r\n\r\n	if (tempStr !== \'\') {\r\n		res.push(tempStr);\r\n		tempStr = \'\';\r\n	}\r\n\r\n	console.log(res); // [\"451212\", \"45\", \"67\", \"5940540\", \"344\", \"89085\"]\r\n\r\n	function isNotNumberable(input) {\r\n		return isNaN(input);\r\n	}\r\n\r\n	function isNumberable(input) {\r\n		return ! isNotNumberable(input);\r\n	}\r\n\r\n### 使用正则表达式\r\n\r\n	var str = \'jdkfdj451212t45lfgb67ffgg5940540m344ioirto89085\';\r\n	var res;\r\n\r\n	res = str.match(/\\d/g); // [\"4\", \"5\", \"1\", \"2\", \"1\", \"2\", \"4\", \"5\", \"6\", \"7\", \"5\", \"9\", \"4\", \"0\", \"5\", \"4\", \"0\", \"3\", \"4\", \"4\", \"8\", \"9\", \"0\", \"8\", \"5\"]\r\n\r\n	res = str.match(/\\d+/g); // [\"451212\", \"45\", \"67\", \"5940540\", \"344\", \"89085\"]\r\n\r\n## 正则的概念\r\n\r\n正则表达式，又称规则表达式。使用一些特殊的符号（字符）代表一些特定的内容，用来查找和匹配符合规则的字符串。\r\n\r\n定义正则表达式的方式分两种：\r\n\r\n1. 直接量（字面量）形式（推荐）： `/正则表达式/[修饰符]`。\r\n2. 对象形式：new RegExp(字符串[, 修饰符])。\r\n\r\n正则在匹配 `/` 符号时会特殊对待，如果要匹配的字符是 \"/\" 的话，就需要用 `\\` 这个转义字符转义。\r\n\r\n### 转义符 `\\`\r\n\r\n1. `\\n`：换行。\r\n2. `\\\'`：单引号。\r\n3. `\\\"`：双引号。\r\n4. `\\d`：数字（digital）。\r\n\r\n## 正则常用方法\r\n\r\n### test\r\n\r\n`正则.test(字符串)`：查看字符串中是否有与正则表达式匹配的子集。\r\n\r\n	/bao/.test(\'zhangbao\'); // true\r\n	/oab/.test(\'zhangbao\'); // false\r\n\r\n	if (/\\d/.test(\'zhangbao1\')) {\r\n		console.log(\'有数字\');\r\n	} else {\r\n		console.log(\'没数字\');\r\n	}\r\n	// \"有数字\"\r\n\r\n### search\r\n\r\n`被搜索字符串.search(要查找的字符串或者正则)`：找到被搜索字符串中与要查找的字符串/正则匹配的第一个索引位置。\r\n\r\n与 `search` 不同的是，`indexOf` 不接受正则对象作为参数的。\r\n\r\n	\'zhangbao\'.search(\'a\'); // 2\r\n\r\n	\'zhangbao\'.search(\'c\'); // -1\r\n\r\n	\'zhang2bao\'.search(/\\d/); // 5\r\n\r\n正则表达式还支持 **修饰符**，在第二个 \"/\" 之后添加，比如我们使用修饰符 `i`（忽略大小写）来匹配字符串。\r\n\r\n	\'zhangbao\'.search(/G/); // -1\r\n\r\n	\'zhangbao\'.search(/G/i); // 4\r\n\r\n### match\r\n\r\n`字符串.match(字符串/正则)`：匹配指定的字符串或者正则，把匹配的结果放入一个数组并返回，否则返回 `null`。\r\n\r\n有返回值的情况分两种：\r\n\r\n	1. 参数不是加 `g` 修饰符（全局匹配）的正则：不纯粹的数组。\r\n	2. 参数是加 `g` 修饰符的正则：纯碎的数组。\r\n\r\n看结果：\r\n	\r\n	// 1. 参数不是加 `g` 修饰符的正则（默认只找匹配的第一个）\r\n	\'zhangbao\'.match(\'g\'); // [\"g\", index: 4, input: \"zhangbao\"]\r\n	\'zhangbao\'.match(/g/); // [\"g\", index: 4, input: \"zhangbao\"]\r\n\r\n	\'zhangbao\'.match(\'c\'); // null\r\n	\'zhangbao\'.match(/c/); // null\r\n\r\n	// 2. 参数是加 `g` 修饰符的正则\r\n	\'zhangbao\'.match(/g/g); // [\"g\"]\r\n	\'zhangbao\'.match(/a/g); // [\"a\", \"a\"]\r\n\r\n	\'zhangbao\'.match(/c/g); // null\r\n\r\n下面开始讲 **量词**，以 `+` 为例，它表示匹符合 1 个或 1 个以上的字符。\r\n\r\n	\'zhang22bao23\'.match(/\\d+/g); // [\"22\", \"23\"]\r\n\r\n### replace\r\n\r\n`字符串.replace(字符串或者正则, 字符串或者函数)`：替换匹配到的字符串。返回替换后的字符串，原字符串不改变。\r\n\r\n	\'zhangbao\'.replace(\'a\', \'啊\'); // \"zh啊ngbao\"\r\n	\'zhangbao\'.replace(/a/g, \'啊\'); // \"zh啊ngb啊o\"\r\n\r\n当第二个参数是函数时，必须要有返回值，否则返回 \"undefined\" 字符串。\r\n\r\n	\'zhangbao\'.replace(\'a\', function () {}); // \"zhundefinedngbao\"\r\n\r\n	// 第一个参数（$0）表示匹配的字符\r\n	// 第二个参数（$1）表示匹配的字符索引位置\r\n	// 第三个参数（$0）表示原字符串\r\n	\'zhangbao\'.replace(\'a\', function ($0, $1, $2) {\r\n		return $0 + \'2\';\r\n	}); // \"zha2ngbao\"\r\n\r\n	\'zhangbao\'.replace(/a/g, function ($0, $1, $2) {\r\n		return $0 + \'2\';\r\n	}); // \"zha2ngba2o\"\r\n\r\n## 分组与子项\r\n\r\n分组用圆括号（`()`）表示，放在括号里的内容就是一个子项，每一个括号括起来的内容都可以看做一个子项。\r\n\r\n	\'zh-ang-b-ao\'.match(/[a-z]-/ig); // [\"h-\", \"g-\", \"b-\"]\r\n	\'zh-ang-b-ao\'.match(/[a-z]+-/ig); // [\"zh-\", \"ang-\", \"b-\"]\r\n\r\n	// 这个 `+` 号是针对前面 `()` 里的整体内容而言的\r\n	\'zh-ang-b-ao\'.match(/([a-z]-)+/ig); // [\"h-\", \"g-b-\"]\r\n	\r\n	/*\r\n		对于不使用 `g` 修饰符的 `match` 方法来说，「还会返回匹配的子项」\r\n	*/\r\n	\r\n	\'kai\'.match(/(k)(a)(i)/g); // [\"kai\"]\r\n\r\n	\'kai\'.match(/(k)(a)(i)/); // [\"kai\", \"k\", \"a\", \"i\"]\r\n\r\n	/* ============================= */\r\n\r\n	// 这里回调函数会调用 3 次\r\n	// 第一次：$0 是 \"zh-\"，$1 是 \"zh\"，$2 是 \"-\"，$3 是 0\r\n	// 第二次：$0 是 \"ang-\"，$1 是 \"ang\"，$2 是 \"-\"，$3 是 3\r\n	// 第三次：$0 是 \"b-\"，$1 是 \"b\"，$2 是 \"-\"，$3 是 7\r\n	\'zh-ang-b-ao\'.replace(/([a-z]+)(-)/ig, \r\n		function ($0, $1, $2, $3, $4) {\r\n		console.log(`${$0} ${$1} ${$2} ${$3} ${$4}`);\r\n	});\r\n	// 即使说回调函数的参数\r\n	// 固定不变的是：第一个参数（整体匹配的字符串），倒数第二个参数（匹配的整体字符串的索引值）和倒数第一个参数（被替换的原字符串）的意思。\r\n	// 中间数量可变的参数是匹配的子项字符。\r\n\r\n## 格式化日期\r\n\r\n`\\d` 在正则里表示数字，`\\D` 在正则里表示非数字。\r\n\r\n## 中括号与匹配中文\r\n\r\n### 中括号\r\n\r\n中括号 `[]` 表示匹配其中的任意一个字符，只代表一个字符。\r\n\r\n`-` 表示区间，`[1-9]` 表示匹配 1 到 9 之间任意一个字符；`[a-z]` 表示 a 到 z 之间任意一个字符。\r\n\r\n`^`表示排除的意思。`^[1-9]` 表示匹配的是除 1 到 9 之外的任意一个字符。\r\n\r\n### 中文\r\n\r\n中文区间：`[\\u4e00-\\u9fa5]`。\r\n\r\n	\'张宝是90小孩。\'.match(/[\\u4e00-\\u9fa5]/g); // [\"张\", \"宝\", \"是\", \"小\", \"孩\"]\r\n\r\n	decodeURI(\'\\u4e00\'); // \"一\"\r\n	decodeURI(\'\\u9fa5\'); // \"龥\"\r\n\r\n## 量词\r\n\r\n量词表示范围，包围在花括号（`{n, m}`）里。这里的 `n` 和 `m` 是数字。\r\n\r\n1. `{n}`：重复 n 次。\r\n2. `{n,}`：至少重复 n 次，最多不限。\r\n3. `{n,m}`：至少重复 n 次，最多重复 m 次。\r\n\r\n常量关键词 `+`、`?` 等同于这样的花括号定义：\r\n\r\n1. `*`：`{0,}`。至少重复 0 次，最多不限。\r\n2. `+`：`{1,}`。至少重复 1 次，最多不限。\r\n3. `?`：`{0,1}`。至少重复 0 次，最多重复 1 次。\r\n\r\n## 验证 QQ 号\r\n\r\n1. 全是数字。\r\n2. 不能以 0 开头。\r\n3. 数字的个数 5-12。\r\n\r\n	\'10000\'.test(/^[1-9]\\d{4,11}$/);\r\n\r\n`/^` 匹配字符开始的位置；`$/` 匹配字符结束的位置。\r\n\r\n`\\s` 匹配空格，`\\S` 匹配非空格字符。咱们去除首尾空格。\r\n\r\n	\' zhangbao \'.replace(/^\\s+|\\s+$/g, \'\'); // \"zhangbao\"\r\n\r\n## 转义字符\r\n\r\n1. `\\d`：数字。\r\n2. `\\D`：非数字。\r\n3. `\\s`：空格。\r\n3. `\\S`：非空格。\r\n4. `\\w`：数字、字母和下划线。\r\n5. `\\W`：非数字、字母和下划线。\r\n6. `.`：任意一个字符。\r\n7. `\\.`：匹配 `.` 这个字符。\r\n8. `\\b`：匹配单词的边界----包括起始位置、结束位置和空格的前后。\r\n9. `\\b`：匹配非单词的边界\r\n\r\n	\'zhang bao\'.replace(/\\b/g, \'|\'); // \"|zhang| |bao|\"\r\n	\'zhang bao\'.replace(/\\B/g, \'|\'); // \"z|h|a|n|g b|a|o\"\r\n\r\n## 正则获取 class\r\n\r\n	<ul id=\"list\">\r\n		<li class=\"box you\">box you</li>\r\n		<li class=\"box and\">box and</li>\r\n		<li class=\"box me\">box me</li>\r\n		<li class=\"box you\">box you2</li>\r\n	</ul>\r\n\r\n	function getElementsByclassName(parent, className) {\r\n		var elems = document.getElementsByTagName(\'*\');\r\n		// \"\\\" 符号在字符串中属于转义符号，创建正则时还需要用 \"\\\" 再转义成一个斜线。\r\n		// new RegExp(\'\\\\bfoo\\\\b\')\r\n		// 等同于\r\n		// /\\bfoo\\b/\r\n		var regExp  = new RegExp(\'\\\\b\' + className + \'\\\\b\');\r\n		var res = [];\r\n		\r\n		for (var i = 0; i< elems.length; i++) {\r\n			if (regExp.test(elems[i].className)) {\r\n				console.log(elems[i].className);\r\n				res.push(elems[i]);\r\n			}\r\n		}\r\n		\r\n		return res;\r\n	}\r\n\r\n	var $ul = document.getElementById(\'list\');\r\n	var boxes = getElementsByclassName($ul, \'you\');\r\n\r\n	for (var i = 0; i < boxes.length; i++) {\r\n		boxes[i].style.background = \'red\';\r\n	}\r\n\r\n## 重复子项\r\n\r\n`\\1`，`\\2`... 重复子项，与对应的子项对应，后面是从 1 累加的数字。\r\n\r\n	var str = \'abcd\';\r\n	var regExp1 = /(a)(b)(c)\\1/;\r\n	var regExp2 = /(a)(b)(c)\\2/;\r\n\r\n	regExp1.test(str); // true\r\n	regExp2.test(str); // false\r\n\r\n	var regExp3 = /\\w\\w/; // 即使字符串里的两个字符不一样，也能匹配成功\r\n	var regExp4 = /(\\w)\\1/; // 只匹配两个字符一样的情况，比如 `11`、`bb` 和 `__`\r\n\r\n### 找出自字符串中重复最多的那个字符\r\n\r\n	var str = \'eeeeeeeeeejjjjjjjjjfgggggggg0000000gkkkkkkmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\';\r\n\r\n	function findMaximumChar(str) {\r\n		var char = \'\', \r\n				maximum = 0,\r\n				regExp = /(\\w)\\1+/g;\r\n\r\n		str.replace(regExp, function ($0) {\r\n			console.log($0);\r\n			if ($0.length > maximum) {\r\n				char = $0.substring(0, 1);\r\n				maximum = $0.length;\r\n			}\r\n		});\r\n		\r\n		return {\r\n			char,\r\n			maximum\r\n		};\r\n	}\r\n\r\n	findMaximumChar(str); \r\n	// {\r\n	// 	 char: \'m\',\r\n	// 	 maximum: 32\r\n	// }','2017-10-20 02:37:05','2017-11-22 03:46:20','javascript-regular-expression-study-notes'),(429,3,3,'JavaScript API：Object.defineProperty 方法介绍','`Object.defineProperty` 用来定义对象属性，它的语法如下：\r\n\r\n> Object.defineProperty(obj, prop, descriptor)\r\n\r\n但基本不用它定义对象属性，而是用对象的点（`.`）或者中括号操作符（`[]`）定义属性。\r\n\r\n	obj.foo = \'bar\';\r\n	// 或者\r\n	obj.[\'foo\'] = \'bar\';\r\n\r\n## 使用场景\r\n\r\n那么在什么情况下使用 `Object.defineProperty` 呢？答案是 **在定义属性时，需要明确指定属性描述符的时候，才使用 `Object.defineProperty` 方法**。\r\n\r\n## 默认属性冻结\r\n\r\n使用 `Object.defineProperty` 方法定义属性时，如果不指定第三个参数（即描述符对象），那么 **默认该属性是冻结** 的----不可枚举、不可配置和不可写的。\r\n\r\n	var o = {};\r\n\r\n	Object.defineProperty(o, \'foo\', {\r\n		value: \'bar\'\r\n	});\r\n	\r\n	// 等同于\r\n	Object.defineProperty(o, \'foo\', {\r\n		value: \'bar\',\r\n		enumerable: false,\r\n		writable: false,\r\n		configurable: false\r\n	});\r\n	\r\n## 参考链接\r\n	\r\n* [`Object.assign()`，MDN][1]\r\n\r\n[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty','2017-10-22 03:31:05','2017-10-22 03:41:43','javascript-object-defineproperty-method-is-introduced'),(430,3,3,'JavaScript API：Object.assign 方法介绍','`Object.assign` 方法用于合并对象，将源对象（source）的所有可枚举属性，复制到目标对象（target）。语法如下：\r\n\r\n> Object.assign(target, ...sources)\r\n\r\n## 方法使用\r\n\r\n1. 一个源对象\r\n\r\n		Object.assign({foo: 0}, {bar: 1}); \r\n		// {foo: 0, bar: 1}\r\n\r\n2. 多个源对象 \r\n\r\n		Object.assign({foo: 0}, {bar: 1}, {baz: 2});\r\n		// {foo: 0, bar: 1, baz: 2} \r\n\r\n3. 相同键的键值覆盖\r\n\r\n		Object.assign({foo: 0}, {foo: 1}, {foo: 2});\r\n		// {foo: 2} \r\n\r\n4. 忽略键值是 `null` 和 `undefined` 的源对象\r\n\r\n		Object.assign({foo: 0}, null, {bar: 1}, undefined);\r\n		// {foo: 0, bar: 1} \r\n\r\n需要注意的是，`Object.assign` 方法实现的是浅拷贝，不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象中得到的是这个对象的引用。\r\n\r\n	const obj1 = {a: {b: 1}};\r\n	const obj2 = Object.assign({}, obj1);\r\n\r\n	obj1.a.b = 2;\r\n	obj2.a.b // 2\r\n\r\n## 常见用途\r\n\r\n为属性指定默认值。\r\n\r\n	const DEFAULTS = {\r\n	  logLevel: 0,\r\n	  outputFormat: \'html\'\r\n	};\r\n	\r\n	function processContent(options) {\r\n	  options = Object.assign({}, DEFAULTS, options);\r\n	  console.log(options);\r\n	}\r\n	\r\n	processContent({ logLevel: 1 });\r\n	// {logLevel: 1, outputFormat: \"html\"}\r\n\r\n## Polyfill\r\n\r\n	if (typeof Object.assign != \'function\') {\r\n	  // Must be writable: true, enumerable: false, configurable: true\r\n	  Object.defineProperty(Object, \"assign\", {\r\n		value: function assign(target, varArgs) { // .length of function is 2\r\n		  \'use strict\';\r\n		  if (target == null) { // TypeError if undefined or null\r\n			throw new TypeError(\'Cannot convert undefined or null to object\');\r\n		  }\r\n\r\n		  var to = Object(target);\r\n\r\n		  for (var index = 1; index < arguments.length; index++) {\r\n			var nextSource = arguments[index];\r\n\r\n			if (nextSource != null) { // Skip over if undefined or null\r\n			  for (var nextKey in nextSource) {\r\n				// Avoid bugs when hasOwnProperty is shadowed\r\n				if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n				  to[nextKey] = nextSource[nextKey];\r\n				}\r\n			  }\r\n			}\r\n		  }\r\n		  return to;\r\n		},\r\n		writable: true,\r\n		configurable: true\r\n	  });\r\n	}\r\n\r\n## 参考链接\r\n\r\n1. [`Object.assign()`，MDN][1]\r\n2. [对象的扩展之 `Object.assign()`，阮一峰][2]\r\n\r\n[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n[2]: http://es6.ruanyifeng.com/#docs/object#Object-assign','2017-10-22 04:03:14','2017-10-22 04:03:14','javascript-api-object-assign-method-is-introduced'),(431,3,3,'网页中文字体设置指南','Windows 系统的特有字体是「微软雅黑（`Microsoft Yahei`）」，苹果的特有字体是「苹方字体（`PingFang SC`）」\r\n\r\n![微软雅黑](http://www.kendraschaefer.com/wp-content/uploads/2012/06/chinese-microsoft-yahei.jpg)\r\n\r\n*微软雅黑字体*\r\n\r\n![苹方字体](http://img.iplaysoft.com/wp-content/uploads/2016/pingfang/pingfang_banner.jpg)\r\n\r\n*苹果苹方字体*\r\n\r\n## 字体支持\r\n\r\n**其实这两种字体都是「黑体（`SimHei`）」变种**。微软雅黑字体在处理开始和收尾的地方都是 **圆润** 的，而苹果苹方在处理开始和收尾的地方 **稍显尖锐**，按照他们的说法这种字体是为电子显示屏而设计的，无论是简体中文还是繁体中文都能够清晰的显示，我本人也是这么认为的。\r\n\r\n下图是 Windows 系统和苹果的 Mac 系统对中文字体的支持情况：\r\n\r\n| Windows | OS X |\r\n| -------- | -------- |\r\n| 黑体：SimHei     | 冬青黑体: Hiragino Sans GB [NEW FOR SNOW LEOPARD]     |\r\n| 宋体：SimSun     | 华文细黑：STHeiti Light [STXihei]     |\r\n| 新宋体：NSimSun     | 华文黑体：STHeiti     |\r\n| 仿宋：FangSong     | 华文楷体：STKaiti     \r\n| 楷体：KaiTi     | 华文宋体：STSong     |\r\n| 仿宋_GB2312：FangSong_GB2312     |  华文仿宋：STFangsong     |\r\n| 楷体_GB2312：KaiTi_GB2312    |      |\r\n| 微软雅黑体：Microsoft YaHei [as of Win7]     |      |\r\n\r\n## 我的选择\r\n\r\n因为苹果苹方字体在 Windows 系统默认并不支持，那么如果想在 Window 系统中显示这种字体的话，最为便捷的方式，是找一个与之类似的字体使用，**我的选择是：华文细黑（`STXihei`）**，再次的话是黑体（`SimHei`）。\r\n\r\n就是说：\r\n\r\n	font-family: \'PingFang SC\', STXihei, SimHei, \'Microsoft Yahei\', Georgia, serif;\r\n\r\n## 参考链接\r\n\r\n1. [Blog\r\nJUNE 11, 2012\r\nChinese Standard Web Fonts: A Guide to CSS Font Family Declarations for Web Design in Simplified Chinese][1]。\r\n2. [苹果苹方中文字体介绍][2]\r\n\r\n[1]: http://www.kendraschaefer.com/2012/06/chinese-standard-web-fonts-the-ultimate-guide-to-css-font-family-declarations-for-web-design-in-simplified-chinese/\r\n[2]: http://www.iplaysoft.com/pingfang.html','2017-10-22 09:34:13','2017-10-22 10:01:35','web-page-font-settings-in-chinese-guide'),(432,3,3,'移动网页开发指南（概念篇）','设备像素比：window.devicePixelRatio\r\n\r\n设备像素比 = 物理像素（分辨率）/设备独立像素。\r\n\r\n在视网膜屏幕的 iphone5 上，屏幕物理像素 640 像素，独立像素还是 320 像素，因此，`window.devicePixelRatio` 等于2.\r\n\r\n当我们在页面头部设置：`<meta name=\"viewport\" content=\"width=device-width\">`，这里的 `device-width` 指的是 设备独立像素。\r\n\r\n在移动设备中，可以使用 `screen.width` 或者 `document.documentElement.clientWidth` 获得设备独立像素的宽；使用 `screen.height` 或者 `document.documentElement.clientHeight` 获得设备独立像素的高。\r\n\r\n以 iphone5 为例，其设备独立像素的宽和高分别是 320 和 568。','2017-10-22 10:50:50','2017-10-23 00:52:21','mobile-web-development-guide-concept'),(433,3,3,'2017年10月22号：之前说的','我们宿舍的两个小伙子在一起看游戏解说，声音有点大。外面风很大，空气也有点污染，我没有跑步。\r\n\r\n明天就上班了，周末除了看前端视频，我什么都没做，看了天气，明天的最低温度比今天少四度——13°，我关注天气。\r\n\r\n我没有读书，快到年底了，这一年我看的书太少了。\r\n\r\n现在给我的故事是长大要围绕钱活动、围绕女朋友忧愁，我不以为然，这并不是最主要的。\r\n\r\n---\r\n\r\n我刚才稍微有点深入睡眠，但还没有。\r\n\r\n我想起（也许是想象到）一种美妙，仰看这陈旧的世界周遭，感觉充满灰尘和恋旧，我很小，对身边的事情都不熟悉。\r\n\r\n也许是听 Moon River 的副作用吧，我突然感觉到一种有价值的追求。\r\n\r\n---\r\n\r\n我左掰屁股的内里有块地方的肌肉不受我控制的在动，类似于肌肉痉挛似的不受控制。','2017-10-22 12:19:37','2017-10-23 03:30:37','on-october-22-2017-said-before'),(434,3,3,'Laravel 文档阅读：Laravel Homestead（待续）','Laravel Homestead 是 Laravel 官方提供的开发 Laravel 项目所需的开发环境，让本地开发和团队协作变得简单。Laravel Homestead 是一个 Vagrant Box。Vagrant 用来管理虚拟机，Vagrant Box 是一个虚拟机镜像，Vagrant Box 让管理和配置虚拟机更加简便和优雅。\r\n\r\nHomestead 可以运行在 Windows、Mac 和 Linux 系统上，包括 Nginx 服务器、PHP 7.1、MySQL、PostgreSQL、Redis、Memcached、Node 和其他开发 Laravel 项目所需要的软件环境。\r\n\r\n### 包含的软件\r\n\r\n- Ubuntu 16.04\r\n- Git\r\n- PHP 7.1\r\n- Nginx\r\n- MySQL\r\n- MariaDB\r\n- Sqlite3\r\n- PostgreSQL\r\n- Composer\r\n- Node (With Yarn, Bower, Grunt, and Gulp)\r\n- Redis\r\n- Memcached\r\n- Beanstalkd\r\n- Mailhog\r\n- ngrok\r\n\r\n## 安装和设置\r\n\r\n### 第一步\r\n\r\n安装  VirtualBox 5.1 和 Vagrant。\r\n\r\n#### 安装 Homestead Vagrant Box\r\n\r\nVirtualBox 5.1 和 Vagrant 安装完成后，还需要安装 Homestead Vagrant Box，可能需要一些时间，因为这是在下载整个的虚拟机镜像文件：\r\n\r\n	vagrant box add laravel/homestead\r\n\r\n#### 安装 Homestead\r\n\r\nHomestead Git 仓库是为了管理 `laravel/homestead` 这个 Vagrant Box 而设置的----配置 Laravel 项目的本地环境到虚拟机环境的地址映射。\r\n\r\n	cd ~\r\n\r\n	git clone https://github.com/laravel/homestead.git Homestead\r\n\r\n默认是在 master 分支，我们需要切换到最新的稳定版本（参见 [Github 发行页](https://github.com/laravel/homestead/releases)）。\r\n\r\n	cd Homestead\r\n\r\n	// Clone the desired release...\r\n	git checkout v6.5.0\r\n\r\n下面初始化咱们的配置文件（创建文件 `Homestead.yaml`）：\r\n\r\n	// Mac / Linux...\r\n	bash init.sh\r\n\r\n	// Windows...\r\n	init.bat\r\n\r\n### 配置 Homestead\r\n\r\n。。。','2017-10-23 02:26:49','2017-10-23 02:38:08','laravel-document-reading-laravel-favored'),(435,3,3,'美好心灵的永恒阳光','我醒来的时候，已经晚上十点了，耿路路这时候刚回来，他总会加班，但并没有抱怨，这没有什么可说的。\r\n\r\n我又咳嗽了，很烦。阿双寄来的在我回来上海前，在嘉兴落下的些衣服已经到了。我的床铺也乱，没有整理。本来想给自己这篇记录起一个有意义的名字，现在看来不用了。\r\n\r\n我不读书很长时间了，莎士比亚、塞万提斯、诗经以及《红楼梦》，我感觉到深深的歉意。你明明知道这是心灵美好的一种寄托习惯，却被无谓的想法耽搁了。\r\n\r\n美好心灵的永恒阳光，既然提到了，我就要说说——它不是早上十点前或者下午三点后的太阳，也不是晒了能帮助补充维生素D的太阳，那是一种内心坚强和乐观，它没有重量，不可量化，只存在于独立自由的内心，它是照耀前程的太阳。','2017-10-24 15:22:29','2017-10-24 15:22:29','eternal-sunshine-of-the-mind'),(436,3,3,'此像素非彼像素，非彼像素','> 这是 [一篇 2010 年的文章](https://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html)，很老了。翻译完这篇文章后，我感觉对于移动网页的开发。我多想了两个问题：图片变模糊？字体使用 em 而不是像素？这根本就不是一开始就应该担心的事情。作为网页开发人员，我只要知道能从手机屏幕上得到多大的使用空间就行了，其他问题都会顺其自然的发现并解决的。还有一点：当设置 `<meta name=\"viewport\" width=\"device-width\">` 后，1 CSS 像素等于 1 设备像素了，也就是说 CSS 像素基本就等同于设备像素了。\r\n\r\n新的 iPhone 即将面世，它采用 960x640，而不是 480x320。昨天 John Gruber 解释了苹果为什么要这么做。他也想知道这会给网页开发者带来什么后果。\r\n\r\n碰巧我最近也在跨浏览器地研究手机的宽度和高度。并且可以合理的确定，这些变化对网页开发者的影响仅有 1%。\r\n\r\n这剩下的 1% 是个很棘手的问题，但苹果可以通过插入一个中间像素层（intermediate layer of pixels）来解决这个问题（John 提到在 Android 中已经存在这个层了）。\r\n\r\n## 网页开发者需要的是什么？\r\n\r\n我知道网页开发者的关注点在哪里----CSS 像素----也就是在 CSS 声明里的\"像素\"，比如：`width: 300px` 和 `font-size: 14px`。\r\n\r\n其实，CSS 像素跟实际的设备像素密度（actual pixel density of the device）没有关系，甚至与中间像素层都没有关系。它们本质上是专门为网页开发者创建的抽象单元（abstract construct）。\r\n\r\n我们拿缩放（zooming）来通俗地解释上面这句话。当用户做放大操作时，`width: 300px` 的元素会占据越来越多的屏幕空间，于是使用设备（物理）像素测量时就变得越来越宽。但以 CSS 像素的角度考虑，元素的宽度始终保持在 300px。这里的缩放效果根据需要扩张了 CSS 像素。\r\n\r\n当缩放因子（zooming factor）是 100% 的时候，1 CSS 像素等于 1 设备像素（虽然即将到来的中间像素层会取代设备像素的位置）。下面的图片就描述了缩放 100% 的情况，看不到效果的原因，1 CSS 像素和 1 设备像素完全重叠了。\r\n\r\n![1 CSS 像素和 1 设备像素完全重叠图](https://www.quirksmode.org/mobile/pix/viewport/csspixels_100.gif)\r\n\r\n（需要提醒你的是，\"缩放 100%\"在 Web 开发中没有什么意义。缩放级别对我们来说不重要，我们需要知道的是现在有多少 CSS 像素容纳在屏幕上。）\r\n\r\n下面两张图片显示了当用户做缩小、放大操作时发生的情况。第一张图片显示的是当用户缩小时的设备像素（深蓝色背景）和 CSS 像素（浅蓝色前景）----CSS 像素变小了，1 设备像素交叠了几个 CSS 像素；第二张图片显示的是用户放大时的设备像素和 CSS 像素----1 CSS 像素交叠了几个设备像素。\r\n\r\n![用户做缩小操作图](https://www.quirksmode.org/mobile/pix/viewport/csspixels_out.gif)\r\n\r\n![用户做放大操作图](https://www.quirksmode.org/mobile/pix/viewport/csspixels_in.gif)\r\n\r\n因此，`width: 300px` 的元素总是 300 CSS 像素宽，而它等同于多少设备像素则取决于缩放因子。\r\n\r\n（在手机上，使用 `screen.width` 除以 `window.innerWidth` 就可以得到缩放因子。但这存在浏览器兼容问题，希望在不远的将来有关于这方面的完整报告出现。作为一名网页开发者如果对缩放因子不关注的话，但要知道设备屏幕里到底可以容纳多少（设备或 CSS）像素。）\r\n\r\n这个系统不会改变。如果改变了，所有针对 iPhone 优化的网站都会立即废掉。这是苹果不惜一切代价要避免的。\r\n\r\n因此，一个完全缩小的网站仍然显示为 980 CSS 像素，它等于多少设备像素对我们来说不重要。\r\n\r\n## 棘手的问题\r\n\r\n有两个棘手的问题：`device-width` 媒体查询（media query）和 `<meta name=\"viewport\" width=\"device-width\">` 标签。这两者都是与设备像素协作的，而不是 CSS 像素。因为它表达的是页面上下文，而不是内部的 CSS。\r\n\r\n### 媒体查询\r\n\r\n`device-width` 媒体查询测量设备宽度，以设备像素统计。`width` 媒体查询测量的是整个页面的宽度，以 CSS 像素统计，原因我以后解释，在 iPhone 上 `width` 至少是 980px。\r\n\r\n![device-width 和 width 的介绍](https://www.quirksmode.org/mobile/pix/viewport/mobile_mediaqueries.jpg)\r\n\r\n`device-width` 媒体查询的工作方式如下：\r\n\r\n	div.sidebar {\r\n		width: 300px;\r\n	}\r\n\r\n	@media all and (max-device-width: 320px) {\r\n		// 设备宽度小于 320px 时使用的样式\r\n		div.sidebar {\r\n			width: 100px;\r\n		}\r\n	}\r\n\r\n现在侧边栏是 300 CSS 像素宽，当设备宽度小于 320px 时，就变成 100 CSS 像素宽了。\r\n\r\n顺便提一下，理论上可以使用厘米或者英寸来查询设备屏幕（@media all and (max-device-width: 9cm)）。不幸的是，包括 iPhone 在内的设备对此的支持都不太好。这儿的问题是，像英寸这样的物理单位（physical units）通常转换为 CSS 像素。我测试了迄今为止所有的浏览器，测出 `width: 1in` 基本等于 `width: 96px`。所以这些媒体查询是不可靠的。\r\n\r\n### `<meta>` 标签\r\n\r\n一般来说 `<meta name=\"viewport\" content=\"width=device-width\">` 很有用。这个标签最开始是苹果专有的，现在越来越多的浏览器都支持了，它实际的布局视图（layout viewport）正好适合设备。\r\n\r\n那什么是布局视图？浏览器使用百分比宽度计算元素尺寸、并且使用 CSS 像素计算的一块区域。例如 `div.sidebar {width: 20%}`。它通常比设备屏幕大些：在 iPhone 上是 980px，在 Opera 上是 850px，在 Android 上是 800px 等。\r\n\r\n![layout viewport 图](https://www.quirksmode.org/mobile/pix/viewport/mobile_layoutviewport.jpg)\r\n\r\n使用了 `<meta name=\"viewport\" content=\"width=device-width\">` 后，布局视图的宽度被限制为设备像素所表现的设备宽度。在 iPhone 中是 320。\r\n\r\n![没有 meta 标签的情况图](https://www.quirksmode.org/mobile/pix/viewport/mq_none.jpg)\r\n\r\n这样设置后，页面就会变得足够窄以适应屏幕大小。下面这张图片是没有使用 CSS `width` 语句和 `<meta>` 标签的情况，整个设备屏幕延伸到布局视图的可用宽度。\r\n\r\n这或许不是你想要的，你希望堂文字在屏幕上合适的显示，这就是 `<meta name=\"viewport\" content=\"width=device-width\">` 要完成的工作----整个视口缩小（在 iPhone 中是 320px），文字得以合适的显示。\r\n\r\n![使用了 meta 标签的情况图](https://www.quirksmode.org/mobile/pix/viewport/mq_yes.jpg)\r\n\r\n## 苹果的变化\r\n\r\n现在，苹果的分辨率变化对 `device-width` 媒体查询和 `<meta>` 标签会造成什么影响？我还不清楚，但我认为对网页开发人员不会有任何改变。\r\n\r\n### `<meta>` 标签\r\n\r\n`<meta>` 标签最容易解释。苹果特意发明了它，是为了让人们能够在 iPhone 屏幕上适用他们的内容，并把它推给了开发者。就是说，现在 `<meta>` 标签读出来的设备宽度是无法改变的。\r\n\r\n事实上，Nexus One 已经为苹果公司开辟了一条新的道路。其官方屏幕宽度（纵向模式）是 480px，但是当你使用 `<meta>标签查询时，显示屏幕宽度 320px，也就是官方宽度的 2/3。如果我理解正确的话，这就是 John Gruber 所说的关于 Nexus 显示缺少一个子像素，也就是少了 1/3 的像素。这正好符合 Nexus 对 `<meta>` 标签的准确解释。\r\n\r\nGoogle 已经插入了一个被称为 dips 的图层，即设备独立像素（device-independent pixels）。此层位于官方屏幕大小和 CSS 像素（网页开发人员接触的）之间。\r\n\r\n我期待新版 iPhone 复制 Nexus 的方式，当使用 `<meta>` 标签进行媒体查询时，报告出来的屏幕尺寸是 320px（也就是分辨率宽度的一半）。之所以不是三分之二，是因为新版 iPhone 像素密度高于 Nexus。\r\n\r\n### 媒体查询\r\n\r\n这使得 `device-width` 媒体查询成为唯一的问题区域。在 Nexus 上它使用 480px 作为屏幕宽度，但 320px 可能更合适。我们得看看苹果是怎么做的。\r\n\r\n更为根本的问题是，dips 是否将用于媒体查询。总的来说，对于网页开发者来说，正式的设备大小不重要，而是想知道我们能从屏幕上得到多少内容，而且 dips 好像是最适合的。\r\n\r\n不幸的是，Nexus 现在没那么做。媒体查询的设备宽度仍显示 480px，而不是 320px。但也许苹果可以为网页开发人员解决这个问题。\r\n\r\n所以，现在的情况是，对于正常的一个 Web 网站我们清楚，对 `<meta>` 标签的使用我们也清楚。但遇到媒体查询时，我们就不清楚了。\r\n\r\n敬请关注。','2017-10-25 02:40:42','2017-11-03 08:22:20','a-pixel-is-not'),(437,3,3,'《JavaScript 高级程序设计》第13章：事件（一）','事件实现了 HTML 与 JavaScript 之间的交互，它指特定的交互瞬间。IE8 是最后一个仍然使用其专有事件系统的浏览器。\r\n\r\nHTML5 为 BOM 指定了规范。\r\n\r\n## 事件流\r\n\r\n### 事件冒泡\r\n\r\n事件冒泡（event bubbling）指事件由最具体的元素逐级向上传播到较为不具体的节点（`document` 对象）。现代浏览器都支持事件冒泡，一直冒泡到 `window` 对象。\r\n\r\nIE8- 事件流就是事件冒泡流，且只有事件冒泡流。\r\n\r\n### 事件捕获\r\n\r\n事件捕获（event capturing）指从不太具体的节点到最具体的节点。“DOM2 级事件”规范要求事件应该从 `document` 对象开始传播，但浏览器都是从 `window` 对象开始捕获事件的。\r\n\r\n建议读者使用事件冒泡，在有特殊需求时再使用事件捕获。\r\n\r\n### DOM 事件流\r\n\r\n“DOM2 级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。\r\n\r\n理论上事件捕获阶段不包括处于目标阶段，处于目标阶段被看成是冒泡阶段的一部分。但是实际的浏览器厂商，**在事件捕获和事件冒泡阶段都会触发目标对象上的事件**，就是说有两个机会在目标对象上操作事件，事件触发的先后在于声明的先后，先声明先触发。\r\n\r\n## 事件处理程序\r\n\r\n### HTML 事件处理程序\r\n\r\n每种事件，都有一个与之对应的同名 HTML 特性（`on + 事件名` 形式）。比如点击事件的 `onclick`。\r\n\r\n特性中的内容是 JavaScript 代码，优先使用单引号，避免使用双引号。因为双引号是 HTML 语法字符，如果想正常使用，必须转化为对应的 HTML 实体形式（比如 `&quot;`）。这些常见的 HTML 语法字符包括 `&`、`\"`、`<` 和 `>` 等。\r\n\r\n在函数（即“JavaScript 代码”）中，可以像访问局部变量一样访问 `document` 以及该元素本身。如果当前元素是一个表单元素，外部包围个 `<form>` 标签，那么还可以访问表单字段。因为这个函数使用 `with` 扩展了作用域：\r\n\r\n    function () {\r\n        with(document) {\r\n            with(this.form) {\r\n                with(this) {\r\n                    // 元素属性值\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    <form>\r\n        <input name=\"username\">\r\n        <input type=\"submit\" value=\"打印用户名\" onclick=\"alert(username.value);\">\r\n    </form>\r\n\r\n### DOM0 级事件处理程序\r\n\r\n每个元素（包括 `window` 和 `document`）都有自己的事件处理程序属性，通常全部小写，例如 `onclick`。这个属性值是一个函数，就是事件处理程序。\r\n\r\n事件处理程序中的 `this` 指向当前事件元素。\r\n\r\n这种方式添加的事件处理程序只会在事件流的冒泡阶段触发。将事件处理属性值设置为 `null` 即可删除事件处理程序。\r\n\r\n    btn.onclick = function () {\r\n        alert(\'clicked\');\r\n    };\r\n    \r\n    btn.onclick = null;\r\n\r\n这种事件只支持绑定一个事件处理程序。因为本质上会发生属性覆盖。\r\n\r\n### DOM2 级事件处理程序\r\n\r\n“DOM2 级事件”定义了两个方法，用来添加和删除事件处理程序：`addEventListener` 和 `removeEventListener`。\r\n\r\n两个方法都可以接收三个参数：事件名、事件处理函数和一个布尔值。这个布尔值表示“是否在捕获阶段触发事件处理函数”----`false`（默认），表示在冒泡阶段触发事件处理函数；`true` 表示在捕获阶段触发事件处理函数。\r\n\r\n大多数情况下将事件处理程序添加到事件流的冒泡阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。\r\n\r\n**跟 DOM0 级事件处理程序一样，事件处理程序中的 `this` 指向当前事件元素**。但比 DOM0 级事件处理程序要好的是 **可以为同一事件类型添加多个事件处理程序**。\r\n\r\n通过 `addEventListener` 添加的事件处理程序只能用 `removeEventListener` 来移除。通过 `addEventListener`  添加的匿名函数不能移除。\r\n\r\n### IE 事件处理程序\r\n\r\nIE 事件处理程序就是指 IE8- 浏览器中的专有事件系统，只存在于 IE 浏览器中的。它使用两个跟 DOM2 级事件处理程序类型的方法：`attachEvent` 和 `detachEvent`。\r\n\r\n需要注意的是：\r\n\r\n1. 因为 IE8 及更早版本只支持事件冒泡，所以通过 `attachEvent` 添加的事件处理程序都在冒泡阶段触发。\r\n2. 方法接收的第一个参数是 `on + 事件名` 的形式（比如 `onclick`），而非 `addEventListener` 方法的直接事件名的形式（比如 `click`）。\r\n3. **最主要的区别**：`attachEvent` 中的 `this` 等于 `window` 对象！\r\n\r\n通过 `attachEvent` 添加的事件处理程序只能用 `detachEvent` 来移除。通过 `attachEvent`  添加的匿名函数不能移除。\r\n\r\n### 跨浏览器的事件处理程序\r\n\r\n    var EventUtil = {\r\n      addHandler: function (elem, type, handler) {\r\n        // DOM2 Level Event\r\n        if (elem.addEventListener) {\r\n          elem.addEventListener(type, handler, false);\r\n        // IE Event. IE8-\r\n        } else if (elem.attachEvent) {\r\n          elem.attachEvent(\'on\' + type, handler);\r\n        // DOM0 Level Event\r\n        }  else {\r\n          elem[\'on\' + type] = handler;\r\n        }\r\n      },\r\n      removeHandler: function (elem, type, handler) {\r\n        if (elem.removaEventListener) {\r\n          elem.removaEventListener(type, handler, false);\r\n        } else if (elem.detachEvent) {\r\n          elem.detachEvent(\'on\' + type, handler);\r\n        } else {\r\n          elem[\'on\' + type] = null;\r\n        }\r\n      }\r\n    };\r\n\r\n## 事件对象\r\n\r\n### DOM 中的事件对象\r\n\r\n触发 DOM 上的某个事件时，会产生一个事件对象，该对象会传入到事件处理函数。触发的事件类型不一样，事件对象上可用的属性和方法也不一样。\r\n\r\n下面列出所有事件对象中都会有的常用成员属性（都是只读的）。\r\n\r\n| 属性/方法 | 类型 | 说明 |\r\n| -------- | -------- | -------- |\r\n| `type`     | String     | 事件类型     |\r\n| `bubbles`     | Boolean     | 事件是否冒泡     |\r\n| `stopPropagation()`     | Function     | `bubbles` 为 `true` 时，用来取消事件冒泡     |\r\n| `cancelable`     | Boolean     | 是否可以取消事件的默认行为     |\r\n| `preventDefault()`     | Function     | `cancelable` 为 `true` 时，用来取消事件的默认行为     |\r\n| `currentTarget`     | Element     | 当前正在处理事件的元素     |\r\n| `target`     | Element     | 事件目标元素     |\r\n\r\n在事件处理程序内部，对象 `this` 始终等于 `currentTarget` 的值，而 `target` 是指事件的目标对象。如果是直接在目标元素上指定事件的，那么 `this`、`currentTarget` 和 `target` 是一样的值。\r\n\r\n### IE 中的事件对象\r\n\r\n这里针对的是 IE8- 浏览器，分 DOM0 级方法和 `attachEvent` 方法两种情况。\r\n\r\n针对 DOM0 级方法，事件对象是作为 `window` 对象的一个属性存在的。\r\n\r\n    btn.onclick = function () {\r\n        alert(window.event.type); // \"click\"\r\n    };\r\n\r\n针对 `attachEvent` 方法，既可以通过 `window` 对象访问事件对象，也可以使用事件处理函数中接收的事件对象。\r\n\r\n    btn.attachEvent(\'onclick\', function (event) {\r\n        alert(event.type); // \"click\"\r\n    });\r\n\r\n下面列出 IE 中的事件对象常用成员属性（都是可读写的）：\r\n\r\n| 属性/方法 | 类型 | 说明 |\r\n| -------- | -------- | -------- |\r\n| `cancelBubble`     | Boolean     | 等同于 DOM 中的 `stopPropagation()` 方法。默认值 `false`，表示不取消事件冒泡；**为 `true` 时，表示取消事件冒泡**。     |\r\n| `returnValue`     | Boolean     | 等同于 DOM 中的 `preventDefault()` 方法。默认值 `true`，表示不取消事件的默认行为；**为 `false` 时，表示取消事件的默认行为**。   |\r\n| `srcElement`     | Element     | 事件目标元素     |\r\n\r\n### 跨浏览器的事件对象\r\n\r\n这是对“跨浏览器的事件处理程序”脚本的补充，添加了获取事件对象、取消默认行为和取消事件冒泡的方法，不过新增的这些方法都需要传递一个事件对象（针对 IE8- 的 DOM0 级方法事件处理函数中没有接收事件对象的情况，也要给函数添加一个 event 对象，虽然是 `undefined`，在封装方法里处理了这个逻辑，以保证获得事件对象）。\r\n\r\n    var EventUtil = {\r\n      addHandler: function (elem, type, handler) {\r\n        if (elem.addEventListener) {\r\n          elem.addEventListener(type, handler, false);\r\n        } else if (elem.attachEvent) {\r\n          elem.attachEvent(\'on\' + type, handler);\r\n        }  else {\r\n          elem[\'on\' + type] = handler;\r\n        }\r\n      },\r\n      removeHandler: function (elem, type, handler) {\r\n        if (elem.removaEventListener) {\r\n          elem.removaEventListener(type, handler, false);\r\n        } else if (elem.detachEvent) {\r\n          elem.detachEvent(\'on\' + type, handler);\r\n        } else {\r\n          elem[\'on\' + type] = null;\r\n        }\r\n      },\r\n      getEvent: function (event) {\r\n        return event ? event : window.event;\r\n      },\r\n      getTarget: function (event) {\r\n        return event.target || event.srcElement;\r\n      },\r\n      preventDefault: function (event) {\r\n        if (event.preventDefault) {\r\n          event.preventDefault();\r\n        } else {\r\n          event.returnValue = false;\r\n        }\r\n      },\r\n      stopPropagation: function (event) {\r\n        if (event.stopPropagation) {\r\n          event.stopPropagation();\r\n        } else {\r\n          event.cancelBubble = true;\r\n        }\r\n      }\r\n    };','2017-10-26 05:12:56','2017-10-26 05:12:56','senior-javascript-programming-chapter-13-event-a'),(438,3,3,'去远方，在路上','我因为无聊而读书，读了一些，但并不是说，我就能写字了。在感觉上，我总是认为“日光之下，并无新事”，再加上每日上下班和规律的生活作息，内心很少有情感波澜。所以我很苦恼，可我必须要写。于是，在昨天，我决定骑车回家（如果我住的地方，能叫“家”的话），希望有些情感波澜。\r\n\r\n给共享单车充了20块钱，我就出发了。我是这样想的，我住在南京东路，从金科路出发到那，得4块钱。我骑车，总么着也不会要4块吧，刚开始的行程我就是抱着这样的小情感开始的。\r\n\r\n我从金科中路到金科西路，然后拐进锦绣路，一路直行，从上海科技馆直插世纪广场，上世纪大道，世纪大道好长，到环球金融中心还没结束，因为不能再向前骑了，我只能上天桥从陆家嘴地铁站站回去。原来想坐轮渡过江，但想到晚上可能停运。\r\n\r\n上海的绿化非常好，公园和路两边的草地和树都很好看。我从下班高峰期骑到下班高峰期结束，终于感受到在地铁上感受不到的事情。\r\n\r\n天空颜色深沉，云朵色彩绚烂，有客机和喷气式战斗机在飞，群鸟像一个整体在慢慢移动。在桥上压腿的大妈、在臭水沟边草皮上翻墙的男孩们、在荒凉站牌前等车的情侣、挽手陪妈妈走路说话的女孩、跑步的人、体态丰盈的女子、公园草地上练习平板支撑的人、高得像插在地上的建筑、破烂的路、平整的路、长长的上坡和下坡、玩滑板的人、与周围环境有点违和的广场舞歌曲、在这里工作的老外……有那么一瞬间，我突然感觉现代生活没想象中那么糟，但又想一下，那是因为我在路上。\r\n\r\n“生活不止眼前的苟且，还有诗和远方的田野，你赤手空拳来到人世间，为找到那片海不顾一切”——海里都是水，但这不是说要做一个有水分的人，海很空旷，极目远眺，水天相接没有尽头——那仿佛在说，不要被局限在生活里的那几十平方。','2017-10-26 05:15:59','2017-10-26 05:15:59','go-the-distance-on-the-road'),(439,3,3,'切斯瓦夫·米沃什的《礼物》','[波兰]切斯瓦夫·米沃什 | 西川 译\r\n\r\n如此幸福的一天。\r\n\r\n雾一早就散了，我在花园里干活，蜂鸟停在忍冬花上。\r\n\r\n这世上没有一样东西我想占有。\r\n\r\n我知道没有一个人值得我羡慕。\r\n\r\n任何我曾遭受的不幸，我都已忘记。\r\n\r\n想到故我今我同为一人并不使我难为情。\r\n\r\n在我身上没有痛苦。\r\n\r\n直起腰来，我望见蓝色的大海和帆影。\r\n\r\n*作者：切斯瓦夫·米沃什（Czeslaw Milosz，1911-2004），美籍波兰诗人、散文家、文学史家。*','2017-10-26 05:18:15','2017-10-26 05:18:15','chase-wagh-miloszs-gift'),(440,3,3,'名著导读','1. 《鲁滨孙漂流记》[英国]丹尼尔·笛福\r\n\r\n于1719年4月25日出版。出身于商人之家的鲁滨孙，不想平庸地生活，一心向往着充满冒险与挑战的海外生活，于是毅然舍弃安逸舒适的生活，离家出海航行，去实现遨游世界的梦想，但每次都历尽艰险。有一次，风暴将船只打翻，鲁滨孙一个人被海浪抛到一座荒无人烟的海岛上，在那里度过了28年孤独的时光。\r\n\r\n> 可见，我们一般人，非要亲眼看见更恶劣的环境，就无法理解原有环境的好处；非要落到山穷水尽的地步，就不懂得珍视自己原来享受到的东西。\r\n\r\n2.《钢铁是怎样炼成的》[苏联]尼古拉·阿列克谢耶维奇·奥斯特洛夫斯基\r\n\r\n长篇小说，于1933年写成。小说通过记叙保尔·柯察金的成长道路，告诉人们，一个人只有在革命的艰难困苦中战胜敌人也战胜自己，只有在把自己的追求和祖国、人民的利益联系在一起的时候，才会创造出奇迹，才会成长为钢铁战士。\r\n\r\n> 人最宝贵的是生命，生命每个人只有一次。人的一生应该这样度过：当他回首往事的时候，不因虚度年华而悔恨，也不因碌碌无为而羞愧。','2017-10-26 05:19:43','2017-10-26 05:19:43','tutor'),(441,3,3,'世界历史','### 罗马帝国\r\n\r\n罗马帝国——公元前27年—公元395年。\r\n\r\n### 西罗马帝国\r\n\r\n西罗马帝国灭亡后，欧洲进入了近一千年的中世纪（公元476年—公元1453年）\r\n\r\n### 中世纪（Middle Ages）\r\n\r\n中世纪（约公元476年~公元1453年），是欧洲历史上的一个时代（主要是西欧），自西罗马帝国灭亡（公元476年）到文艺复兴和大航海时代（15世纪末到17世纪）之前的这段时期。\r\n\r\n封建割据带来频繁战争，基督教禁锢人民思想。科技和生产力发展停滞。Dark Ages。\r\n\r\n### 东罗马帝国\r\n\r\n又称拜占庭帝国（公元395年—公元1204年，公元1261年—公元1453年）\r\n\r\n注：中间一段空白统计时期是由于[第四次十字军东征](https://wapbaike.baidu.com/item/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B8%9D%E5%9B%BD/475514)。\r\n\r\n### 奥斯曼帝国\r\n\r\n1453年，21岁的穆罕默德二世继位不到两年，亲率八万大军进攻君士坦丁堡，鏖战53天，终于5月29日攻克，并迁都于此，拜占庭帝国灭亡。穆罕默德二世将君士坦丁堡改名为伊斯坦布尔，土耳其语意为“上城去”。\r\n\r\n苏莱曼一世，是奥斯曼帝国第10位，也是在位时间最长的苏丹（1520年—1566年在位）\r\n\r\n1566—1808年 奥斯曼帝国衰落。\r\n\r\n### 第一次工业革命\r\n\r\n第一次工业革命（The first industrial revolution），18世纪60年代~19世纪40年代。英国、蒸汽机\r\n\r\n### 第二次工业革命\r\n\r\n第二次工业革命（Second Industrial Revolution），19世纪60年代后期。电力的发现和应用。\r\n\r\n### 清朝\r\n\r\n清朝（1636年—1912年）是中国历史最后一个封建王朝，共传十一帝（不包括后金），享国二百六十八年。\r\n\r\n### 第一次世界大战\r\n\r\n第一次世界大战（英语：World War I、First World War或Great War，简称WWI或WW1）。1914年7月28日-1918年11月11日\r\n\r\n### 第二次世界大战\r\n\r\n第二次世界大战（World War II，简称二战，亦可称世界反法西斯战争）。1939年9月1日—1945年9月2日。61个国家和地区、20亿以上的人口被卷入战争，战争中军民共伤亡9000余万人。\r\n\r\n### 抗日战争\r\n\r\n抗日战争（War of Resistance Against Japan），国际上称作第二次中日战争（Second Sino-Japanese War）、 日本侵华战争（Japanese War of aggression against China）。从1937年七七事变国民政府发表《告全体将士书》至1945年日本宣布投降结束，历时八年，被称为八年抗战；另一说法抗战的时间应从1931年9月18日九一八事变开始算起，至1945年结束，共十四年抗战。\r\n\r\n### 国共内战\r\n\r\n第一次：1927年至1937年。\r\n第二次：1945年8月至1949年9月。共产党方面统计共计歼灭国民党军军约807万。\r\n\r\n### 太平洋战争\r\n\r\n1941年12月7日，之后美国的罗斯福政府正式对日宣战。\r\n\r\n（完）','2017-10-26 05:21:49','2017-10-26 05:21:49','the-history-of-the-world'),(442,3,3,'滚动条距离获取：scrollTop 和 scrollLeft','获取滚动条距离有两种 API 可供使用：DOM 的和 BOM 的。下面分别来说：\r\n\r\n## DOM\r\n\r\n在混杂模式下，可以通过 `<body>` 元素的 `scrollTop` 和 `scrollLeft` 来监测这一变化；而在标准模式下，除 Safari 之外的浏览器都会通过 `<html>` 元素来反映这一变化（Safari 仍然基于 `<body>` 跟踪滚动位置）。\r\n\r\n分混杂模式和标准模式。\r\n\r\n### 标准模式\r\n\r\n1. `document.documentElememt.scrollTop`：获取滚动条距离顶部的距离。\r\n2. `document.documentElememt.scrollLeft`：获取滚动条距离左边的距离。\r\n\r\n### 混杂模式\r\n\r\n1.  `document.body.scrollTop`：获取滚动条距离顶部的距离。\r\n2.  `document.body.scrollLeft`：获取滚动条距离左边的距离。\r\n\r\n下面是封装的一个工具对象：\r\n\r\n	var ScrollUtil = {\r\n	  scrollTop: function () {\r\n		if (document.compatMode === \'CSS1Compat\') {\r\n		  return document.documentElement.scrollTop;\r\n		}\r\n		return document.body.scrollTop;\r\n	  },\r\n	  scrollLeft: function () {\r\n		if (document.compatMode === \'CSS1Compat\') {\r\n		  return document.documentElement.scrollLeft;\r\n		}\r\n		return document.body.scrollLeft;\r\n	  }\r\n	};\r\n\r\n这样使用：\r\n\r\n	window.onscroll = function (ev) {\r\n	  console.log(ScrollUtil.scrollTop());\r\n	};\r\n\r\n## BOM\r\n\r\n下面两个属性的兼容性是 IE9+。\r\n\r\n1. `window.pageYOffset`：获取滚动条距离顶部的距离。\r\n2. `window.pageXOffset`：获取滚动条距离左边的距离。\r\n\r\n设置滚动条的距离使用 `window.scrollTo(scrollLeft, scrollTop)` 方法，这个方法 **全兼容** 的。\r\n\r\n	window.scrollTo( 0, 1000 );','2017-10-26 09:21:57','2017-11-05 05:55:48','scroll-bar-distance-access-scrolltop-and-scrollleft'),(443,3,3,'userAgent 和 location','获得用户代理：`window.navigator.userAgent`。\r\n\r\n`window.location.href`：URL 地址中。\r\n\r\n`window.location.search`：URL 地址中，`?` 和 `#`（有的话） 之间的内容。下面是使用这个属性封装的一个查询 URL 参数变量的方法：\r\n\r\n	function queryString(query) {\r\n		var search = window.location.search.substr(1);\r\n		var pairs = search.split(\'&\');\r\n		var pair;\r\n		for (var i = 0; i < pairs.length; i++) {\r\n			pair = pairs[i].split(\'=\');\r\n			if (pair[0] === query) {\r\n				return pair[1];\r\n			}\r\n		}\r\n\r\n		return \'\';\r\n	}\r\n\r\n`window.location.hash`：URL 地址中，`#` 后面的内容，即锚点信息。','2017-10-26 09:25:18','2017-10-26 09:25:18','useragent-and-location'),(444,3,3,'Git 日常使用命令','## 安装\r\n\r\n下载在 https://git-scm.com/ 。\r\n\r\nGit 根目录 = 安装目录：`C:\\Program Files\\Git`。\r\n\r\n用户目录（`cd ~`）：`C:\\Users\\Administrator`。\r\n\r\n清屏：`Ctrl` + `L`。\r\n\r\n## 配置\r\n\r\n全局（一台电脑中的一个用户）配置用户和 Email。\r\n\r\n```\r\n$ git config --global user.name \"your-name\"\r\n$ git config --global user.email \"your-email\"\r\n\r\ngit config --global core.editor \"\'E:/Program Files/Notepad++/notepad++.exe\' -multiInst -nosession\"\r\n```\r\n\r\n可在 `C:\\Users\\用户名\\.gitconfig` 中看到。\r\n\r\n配置项查看\r\n\r\n```\r\ngit config --list\r\n```\r\n\r\n## 工作流\r\n\r\n```\r\n$ mkdir how-to-use-git && cd how-to-use-git && git init\r\nInitialized empty Git repository in C:/Users/Administrator/how-to-use-git/how-to-use-git/.git/\r\n```\r\n\r\n```\r\n$ echo \"<?php phpinfo(); ?>\" >> index.php\r\n$ git add index.php\r\n$ git status\r\n$ git commit -m \"first commmit\"\r\n```\r\n\r\n删除 add （缓存中）后的文件夹。\r\n\r\n```\r\n$ git rm -r --cached .idea/\r\n```\r\n\r\n查看提交日志\r\n\r\n```\r\n$ git log\r\n\r\n$ git log\r\ncommit 5652c7e52cc5e9acf8818434395b5fc41986d6e2\r\nAuthor: zhangbao <3183442656@qq.com>\r\nDate:   Sun Jun 4 12:00:55 2017 +0800\r\n\r\n    fix typo\r\n\r\ncommit a890772bf8b0153c246cb4a1013a49affd2251c7\r\nAuthor: zhangbao <3183442656@qq.com>\r\nDate:   Sun Jun 4 11:58:34 2017 +0800\r\n\r\n    First Commit\r\n```\r\n\r\n## 修正错误\r\n\r\n软重置——最新提交的文件内容不变。\r\n\r\n```\r\n$ git reset --soft a890772bf8b0153c246cb4a1013a49affd2251c7\r\n```\r\n\r\n硬重置——最新提交的文件内容**回退到当前设置的提交时候的样子**。\r\n\r\n```\r\n$ git reset --hard a890772bf8b0153c246cb4a1013a49affd2251c7\r\nHEAD is now at a890772 First Commit\r\n```\r\n\r\n## 忽略文件 `.gitignore`\r\n\r\n```\r\n/node_modules\r\n/public/storage\r\n/storage/*.key\r\n/vendor\r\n/.idea\r\nHomestead.json\r\nHomestead.yaml\r\n.env\r\n```\r\n\r\n## 分支管理\r\n\r\n创建分支 `about-feature`。\r\n\r\n```\r\n$ git branch about-feature\r\n```\r\n\r\n查看分支\r\n\r\n```\r\n$ git branch\r\n  about-feature\r\n* master\r\n```\r\n\r\n进入分支 `about-feature`。\r\n\r\n```\r\n$ git checkout about-feature\r\n```\r\n\r\n创建并进入分支 `about-feature`。\r\n\r\n```\r\ngit checkout -b about-feature\r\n```\r\n\r\n合并分支\r\n\r\n```\r\n$ git merge about-feature\r\nUpdating 1eba5aa..e90272c\r\nFast-forward\r\n routes/web.php | 5 +++++\r\n 1 file changed, 5 insertions(+)\r\n```\r\n\r\n删除分支\r\n\r\n```\r\n$ git branch -d about-feature\r\nDeleted branch about-feature (was e90272c).\r\n```\r\n\r\n## 处理冲突\r\n\r\n```\r\n$ git merge feature/new-design\r\nAuto-merging resources/views/welcome.blade.php\r\nCONFLICT (content): Merge conflict in resources/views/welcome.blade.php\r\nAutomatic merge failed; fix conflicts and then commit the result.\r\n```\r\n\r\n手动修改合并后的内容后\r\n\r\n```\r\n$ git add .\r\n$ git commit\r\n```\r\n\r\n## 快捷方式\r\n\r\n```\r\n$ git config --global alias.s status\r\n\r\n$ git s\r\nOn branch master\r\nnothing to commit, working tree clean\r\n\r\n$ git config --global --unset alias.s\r\n```\r\n\r\n更加详细的可以参见阮一峰的 [Git 命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html) 这篇文章。','2017-10-27 07:10:27','2018-01-12 06:44:45','daily-use-the-command-git'),(445,3,3,'input 元素的 input 和 change 事件','input 元素的 `input` 和 `change` 事件都会在元素值改变时触发，但 `change` 事件比 `input` 事件少一些。下面详细介绍。\r\n\r\n## input 事件\r\n\r\n当 `<input>`、`<select>` 和 `<textarea>` 元素值改变时，会触发 `input` 事件（对于 `type=\"checkbox\"` 和 `type=\"radio\"` 类型的 input 元素不会触发该事件，因为元素的 `value` 值没改变）。\r\n\r\n## change 事件\r\n\r\n当 `<input>`、`<select>` 和 `<textarea>` 元素可以触发 `change` 事件，但不是在元素 `value` 值改变之后立即触发的。\r\n\r\n下面来描述 `change` 事件触发的时机：\r\n\r\n1. 当 `<input type=\"radio\">` 和 `<input type=\"checkbox\">` 元素被点击或者用键盘激活时。\r\n2. 当改变后的值被显示提交时：用鼠标点击 `<select>` 下拉框的一个值、选择了 `<input type=\"date\">` 的一个日期值、用 `<input type=\"file\">` 选择了一个文件等情况。\r\n3. 在值改变后，元素失去焦点时。比如编辑 `textarea` 和 `<input type=\"text\">` 的值时。\r\n\r\n下面是一个例子：\r\n	\r\n	// HTML\r\n	<label>Choose an ice cream flavor:\r\n		<select id=\"ice-cream\" name=\"ice-cream\">\r\n			<option value=\"\">Select One …</option>\r\n			<option value=\"chocolate\">Chocolate</option>\r\n			<option value=\"strawberry\">Strawberry</option>\r\n			<option value=\"vanilla\">Vanilla</option>\r\n		</select>\r\n	</label>\r\n\r\n	// JS\r\n	document.addEventListener(\'DOMContentLoaded\',function() {\r\n		document.querySelector(\'select[name=\"ice-cream\"]\').onchange=changeEventHandler;\r\n	},false);\r\n	function changeEventHandler(event) {\r\n		// You can use “this” to refer to the selected element.\r\n		if(!event.target.value) alert(\'Please Select One\');\r\n		else alert(\'You like \' + event.target.value + \' ice cream.\'); \r\n	}\r\n\r\n## 参考链接\r\n\r\n1. https://developer.mozilla.org/en-US/docs/Web/Events/input\r\n2. https://developer.mozilla.org/en-US/docs/Web/Events/change','2017-10-27 08:35:52','2017-10-27 08:36:16','the-input-element-input-and-change-events'),(446,3,3,'最近的日志','今天宿舍停水了，我到公司里来了。早上风和日丽，阳光还有些刺眼，算是一个不错的好天气。\r\n\r\n我中午吃了拌面，不好吃。现在快到下午五点了，已经没有了阳光，这一天又要入夜了。我看了几首诗经里的诗，整理了出来，只感觉《卷耳》好些。\r\n\r\n待会我就要回去了。\r\n\r\n---\r\n\r\n今天降温了，最高 15 度，但是有太阳。早上我在楼下想安排一场偶遇，等李若楠，阿姨说她七点多出来，现在快到七点四十了，我有点冻腿，十多分就下来了。我不知道天气怎么这么巧…我旁边的五金杂货店开门了，门口的电动车也骑走了一些，又看了几个家长在路上送小孩上学…八点了，我要去上班了…我没有走运过，到也没倒了血霉，明天再行观望……没有观望\r\n\r\n---\r\n\r\n徐燕的一番话，让我有些惊异，但还是有些明白了。我的心情有些受影响，也不能说感受到了人性的黑暗面，我不争辩。我还是信我自己的。?\r\n\r\n---\r\n\r\n路上树叶被风卷起，天上白云飞逝的速度变慢了。我在跑步回去的路上，没有碰上那个跑步的她。\r\n\r\n脑袋里总是想到哥哥面前一条弯弯的河，感觉歌词写得好。有水、有歌、有哥有妹，像诗经里的诗。今天农历九月十五，月亮圆月光晴朗，霾被风吹走了。\r\n\r\n11.03','2017-10-28 08:57:33','2017-11-03 23:55:12','on-october-28-2017'),(447,3,3,'《JavaScript 高级程序设计》第10章：DOM','DOM 是针对 HTML 文档的一个 API，它描述了一个层次化的节点树，允许开发人员添加、删除和修改页面的某一部分。\r\n\r\n本章讨论的是 DOM1 级的特性和应用，它得到了非常完善的实现。\r\n\r\n## 节点层次\r\n\r\nHTML 文档中的标签根据家族关系被 DOM 描绘成一个树形结构。以下面的 HTML 为例：\r\n\r\n    <html>\r\n        <head>\r\n            <meta charset=\"utf-8\">\r\n            <title>简单页面</title>\r\n        </head>\r\n        <body>\r\n            <p>你好，世界！</p>\r\n        </body>\r\n    </html>\r\n    \r\n这个简单的 HTML 页面描绘出来的树形结构是这样的：\r\n\r\n    Document\r\n        Element meta\r\n        Element html\r\n            Element head\r\n            Element title\r\n                Text 简单页面\r\n        Element body\r\n            Element p\r\n                Text 你好，世界！\r\n\r\n文档节点（`Document`）是每个 HTML 文档的根节点，它只有一个子节点，即 `<html>` 元素。\r\n\r\n### Node 类型\r\n\r\nDOM1 级定义了一个 `Node` 接口，这个接口被所有节点类型实现。每个节点都有一个 `nodeType` 属性，表示节点类型，一共有 12 个节点类型，对应到 `Node` 类型的 12 个数值常量属性。这里列举出常用的 4 个。\r\n\r\n- `Node.ELEMENT_NODE`。值为 `1`，表示元素节点。\r\n- `Node.ATTRIBUTE_NODE`。值为 `2`，表示元素的特性节点。\r\n- `Node.TEXT_NODE`。值为 `3`，表示文本节点。\r\n- `Node.COMMENT_NODE`。值为 `8`，表示注释节点。\r\n\r\n由此，我们可以很容易的根据这些常量判断节点类型。\r\n\r\n    if (someNode.nodeType === Node.ELEMENT_NODE) { // 在 IE 中无效\r\n        alert(\'这是一个元素节点\');\r\n    }\r\n\r\n由于 IE 并没有公开 `Node` 类型的构造函数，因此上面的代码在 IE 中会报错。**为了确保跨浏览器兼容，最好还是将 `nodeType` 与数字值进行比较**。\r\n\r\n    if (someNode.nodeType === 1) { // 适用于所有浏览器\r\n        alert(\'这是一个元素节点\');\r\n    }\r\n\r\n#### `nodeName` 和 `nodeValue` 属性\r\n\r\n每个节点还具有`nodeName` 和 `nodeValue` 属性，分别表示节点名和节点值。对于元素节点，`nodeName` 取得的是标签名的大写形式，`nodeValue` 的值始终为 `null`。\r\n\r\n    if (someNode.nodeType === 1) {\r\n        value = someNode.nodeName; // nodeName 取得的是元素标签名的大写形式\r\n    }\r\n    \r\n#### 节点关系\r\n\r\n每个节点都有一个 `childNodes` 属性，值是一个 `NodeList` 对象。`NodeList` 是一个类数组对象——具有数字索引和 `length` 属性，但并不是 Array 实例，所以不具备数组方法。\r\n\r\n`NodeList` 对象独特之处在于，它是基于 DOM 结构动态查询的，DOM 结构的变化能自动反映在 `NodeList` 对象上，而不是我们第一次的访问快照。\r\n\r\n我们可以使用 `Array.prototype.slice()` 方法将 `NodeList` 对象转变为数组。\r\n\r\n    // 在 IE8- 版本中无效\r\n    var arrayOfNodes = Array.prototype.slice(someNode.childNodes, 0);\r\n\r\n之所以在 IE8- 版本中无效，是因为 IE8- 版本中 `NodeList` 对象被解析为一个 COM 对象。所以下面给出一个解决方案。\r\n\r\n    function convertToArray(nodes) {\r\n        var array = [];\r\n        try {\r\n            array = Array.prototype.slice(someNode.childNodes, 0);\r\n        } catch (ex) {\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                array.push(nodes[i]);\r\n            }\r\n        }\r\n        return array;\r\n    }\r\n\r\n每个节点都有一个 `parentNode` 属性，指向文档中的父节点。`childNodes` 列表中的每个节点相互之间都是兄弟节点，使用 `previousSibling` 和 `nextSibling` 获得一个元素的前一个和后一个兄弟节点\r\n\r\n节点间的关系，可以形象的用下面这张图来表示。\r\n\r\n![节点关系图](http://www.baooab.com/wp/wp-content/uploads/2017/10/nodes-relations-methods.jpg)\r\n\r\n#### 操作节点\r\n\r\n**最常用的方法是 `appendChild()`**，向父节点末尾添加一个子节点，然后返回新增的节点。\r\n\r\n    var returnNode = parent.appendChild(newNode);\r\n\r\n    returnNode === newNode; // true\r\n\r\n如果传给 `appendChild()` 的节点已经存在于文档中，那执行结果就是原来的节点转移到了现在的位置。\r\n    \r\n    var returnNode = parent.appendChild(parent.firstChild);\r\n    \r\n    returnNode === parent.firstChild; // false\r\n    returnNode === parent.lastChild; // true\r\n\r\n**如果添加的子节点需要放在特定的位置上，而不是放在末尾，可以使用 `insertBefore()` 方法**：\r\n\r\n    parent.insertBefore(newNode, parentSomeChild);\r\n\r\n这个方法可以形象的解释为：在父节点（`parent`）的某个子节点（`parentSomeChild`）之前，插入新的子节点（`newNode`）。\r\n\r\n当 `parentSomeChild` 为 `null` 时，`insertBefore()` 方法等同于 `appendChild()`。\r\n\r\n**替换节点使用 `replaceChild()` 方法，返回被替换节点**。与 `insertBefore()` 方法的 **第二个参数** 意义不同的是，它不是表示插入元素的参考节点，而是 **表示被替换节点**。\r\n\r\n    parent.replaceChild(newNode, parentSomeChild);\r\n\r\n下面是它的使用例子：\r\n\r\n    // 替换第一个子节点\r\n    parent.replaceChild(newNode, parent.firstChild);\r\n    \r\n    // 替换最后一个子节点\r\n    parent.replaceChild(newNode, parent.lastChild);\r\n\r\n移除节点使用 `removeChild()` 方法，这个方法只接受一个参数，就是要被移除的节点，并且最终被方法返回。\r\n\r\n    // 移除第一个子节点\r\n    parent.removeChild(parent.firstChild);\r\n    \r\n    // 移除最后一个子节点\r\n    parent.removeChild(parent.lastChild);\r\n\r\n### Document 类型\r\n\r\n在浏览器中，`document` 对象是 `HTMLDocument`（继承自 `Document` 类型）的一个实例，表示整个页面。而且 `document` 对象是 `window` 对象的一个属性，因此可以作为全局属性来访问。 \r\n\r\n#### 文档的子节点\r\n\r\n`document` 对象的 `documentElement` 属性指向 `<html>` 元素；`document` 对象的 `body` 属性指向 `<body>` 元素。\r\n\r\n    document.documentElement; // <html>\r\n    \r\n    document.body; // <body>\r\n\r\n所有的浏览器都支持 `document.documentElement` 和 `document.body` 属性。\r\n\r\n多数情况下，用不着在 `document` 对象上调用 `appenChild()`、`removeChild()` 和 `repalceChild()` 方法，因为文档类型是只读的，而且只能有一个元素子节点。\r\n\r\n#### 文档信息\r\n\r\n`document` 对象的 `title` 属性包含着 `<title>` 元素中的文本。通过它，你可以取得或者修改当前的页面标题。\r\n\r\n    // 取得文档标题\r\n    var originTitle = document.title;\r\n    \r\n    // 设置文档标题\r\n    document.title = \'新的文档标题\';\r\n    \r\n还有 3 个与网页请求有关的属性：`URL`、`domain` 和 `referrer`。\r\n\r\n    // 取得完整的 URL\r\n    var url = document.URL;\r\n    \r\n    // 取得域名\r\n    var domain = document.domain;\r\n    \r\n    // 取得来源页面的 URL\r\n    var referrer = document.referrer;\r\n    \r\n#### 查找元素\r\n\r\n`Document` 类型为此提供了两个方法：`getElementById()` 和 `getElementsByTagName()`。\r\n\r\n`getElementsByTagName()` 方法返回的结果是 `HTMLCollection` 对象，取得是动态查询的结果，与 `NodeList` 对象非常类似，但前者代表的是 HTML 元素集合，后者表示的是文档节点集合。\r\n\r\n### `Element` 类型\r\n\r\n`Element` 类型是 Web 编程中最常用的类型了。`Element` 节点具有以下特征：\r\n\r\n- `nodeType` 的值为 `1`。\r\n- `nodeName` 的值为元素标签名。\r\n- `nodeValue`的值为 `null`。\r\n- `parentNode` 为 `Document` 或者 `Element`。\r\n\r\n访问元素的标签名，可以使用 `nodeName` 属性，也可以使用 `tagName` 属性，这两个属性返回相同的值。\r\n\r\n在 HTML 中，标签名始终都会以全部大写的形式表示；在 XML 中（有时也包括 XHTML）中，标签名始终始终与源代码中的保持一致。\r\n\r\n    if (element.tagName === \'div\') {} // 这样比，容易出错。\r\n    \r\n    if (element.tagName.toLowerCase() === \'div\') {} // 这样最好（适用于任何文档）\r\n    \r\n#### HTML 元素\r\n\r\nHTML 元素由 `HTMLElement` 元素表示，直接继承自 `Element` 元素并添加了一些属性：`id`、`title` 和 `className`。\r\n\r\n#### 取得属性\r\n\r\n操作特性的 DOM 方法主要有三个：`getAttribute()`、`setAttribute()` 和 `removeAttribute()`。\r\n\r\n为 DOM 元素对象添加的自定义属性，不会成为元素特性，反之亦然。\r\n\r\n#### `attributes` 属性\r\n\r\n`attributes` 属性用来取得元素属性列表，也是一个「动态」的集合。\r\n\r\n    function outoutAttributes(element) {\r\n        var pairs = [],\r\n            attrs = element.attributes,\r\n            attrName,\r\n            attrValue,\r\n            i;\r\n            \r\n        for (i = 0; i < attrs.length; i++) {\r\n            attrName = attrs[i].nodeName;\r\n            attrValue = attrs[i].nodeValue;\r\n            \r\n            pairs.push(attrName + \'=\"\' + attrValue + \'\"\');\r\n        }\r\n        \r\n        return pairs.join(\' \');\r\n    }\r\n\r\n#### 元素的子节点\r\n\r\n元素的 `childNodes` 属性包含了元素的所有子节点，可能是元素、文本、注释等。如果要单纯取得元素类型子节点，需要使用 `nodeType` 属性过滤下。\r\n\r\n    for (var i = 0; i < element.childNodes.length; i++) {\r\n        if (element.childNodes[i].nodeType === 1) {\r\n            // ...\r\n        }\r\n    }\r\n\r\n#### `DocumentFragment` 类型\r\n\r\n所有节点类型中，只有 `DocumentFragment` 在文档中没有对应的标记。文档片段永远不会成为文档树的一部分，但可以作为一个「仓库」使用。 看下面的代码；\r\n\r\n    <ul id=\"list\"></ul>\r\n\r\n假设为这个 `<ul>` 添加 3 个列表项，如果逐个添加，会导致浏览器反复渲染。为了避免这个问题，可以使用文档片段来暂存列表项，然后一次性添加到文档中。\r\n\r\n    var fragment = document.createDocumentFragment();\r\n    var ul = document.getElementById(\'list\');\r\n    var li = null;\r\n    \r\n    for (var i = 0; i < 3; i++) {\r\n        li = document.createElement(\'li\');\r\n        li.appendChild(document.createTextNode(\'Item\' + (i + 1)));\r\n        fragment.appendChild(li);\r\n    }\r\n    \r\n    ul.appendChild(fragment);\r\n        \r\n\r\n## DOM 操作技术\r\n\r\n### 动态脚本\r\n\r\n这里讨论的动态脚本是指页面加载时不存在，但将来的某一个时刻通过修改 DOM 动态添加的脚本。\r\n\r\n比如下面的 `<script>` 元素：\r\n\r\n    <script type=\"text/javascript\" src=\"client.js\"></script>\r\n\r\n使用 DOM 创建这个元素的代码如下：\r\n\r\n    var script = document.createElement(\'script\');\r\n    script.type = \'text/javascript\';\r\n    script.src = \'client.js\';\r\n    document.body.appendChild(script);\r\n\r\n或者把这个元素添加到 `<head>` 元素中，效果相同。下面我们把这些代码给封装起来：\r\n\r\n    function loadScript(url) {\r\n        var script = document.createElement(\'script\');\r\n        script.type = \'text/javascript\';\r\n        script.src = url;\r\n        document.body.appendChild(script); \r\n    }\r\n\r\n然后，我们就可以这样加载外部 JavaScript 文件了：\r\n\r\n    loadScript(\'client.js\');\r\n\r\n### 动态样式\r\n\r\n所谓的动态样式是指页面加载时不存在，在页面加载完成后动态添加到页面中的。\r\n\r\n我们以下面这个典型的 `<link>` 元素为例：\r\n\r\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\r\n\r\n使用 DOM 创建这个元素的代码如下：\r\n\r\n    var link = document.createElement(\'link\');\r\n    link.rel = \'stylesheet\';\r\n    link.type = \'text/css\';\r\n    link.href = \'styles.css\';\r\n    var head = document.getElementsByTagName(\'head\')[0];\r\n    head.appendChild(link);\r\n\r\n需要注意的是，**需要把 `<link>` 元素添加到 `<head>` 而不是 `<body>` 元素，才能保证在所有浏览器中的行为一致**。下面我们把这些代码给封装起来：\r\n\r\n    function loadStyles(url) {\r\n        var link = document.createElement(\'link\');\r\n        link.rel = \'stylesheet\';\r\n        link.type = \'text/css\';\r\n        link.href = url;\r\n        var head = document.getElementsByTagName(\'head\')[0];\r\n        head.appendChild(link);\r\n    }\r\n\r\n### 操作表格\r\n\r\n下面只介绍取得表格结构的方法。\r\n\r\n    var table = document.querySelector(\'table\');\r\n    \r\n    // 取得表格头\r\n    var tHead = table.tHead;\r\n    \r\n    // 取得表格主体，是一个 HTMLCollection 对象\r\n    // 因为一个 `<table>` 元素可包含多个 `<tbody>`。\r\n    var tBodies = table.tBodies;\r\n    \r\n    // 取得表格尾部\r\n    var tFoot = table.tFoot;\r\n    \r\n    // 取得表格行\r\n    table.rows;\r\n    tHead.rows;\r\n    tBodies[0].rows;\r\n    tFoot.rows;\r\n\r\n    // 取得表格行单元格\r\n    table.rows[0].cells;\r\n    // 只能对单个单元格进行操作\r\n    table.rows[0].cells[0].style.fontSize = \'24px\';','2017-10-29 05:25:33','2017-10-29 05:25:33','senior-javascript-programming-chapter-10-the-dom'),(448,3,3,'介绍 Eloquent 关联中的多对多多态关联','在 [上一篇][1] 里，讲到一张评论表（comments）可以给文章表（posts）用，也可以给视频表（videos）用。如果你足够细心就会发现，文章和评论、视频和评论都是一对多的，这其实就是**一对多多态关系**。\r\n\r\n[1]: https://laravel-china.org/articles/5375/describes-the-polymorphic-association-polymorphic-relations-in-the-eloquent-association\r\n\r\n但是有没有多对多的多态关联呢？这是废话，题目中就已经暴露了——确实有的，比如：标签。一篇文章的标签是 `JavaScript`，但是一个视频的标签也可能是 `JavaScript` 啊。\r\n\r\n文章和标签、视频和标签都是多对多的，这就是**多对多多态关系**，定义在它们 Model 中的关联就是**多对多多态关联**。\r\n\r\n下面就来实现。\r\n\r\n## 创建表\r\n\r\n创建 `tags` 表和 `taggables` 表。\r\n\r\n```\r\nphp artisan make:model Models/Tag -m -c\r\n```\r\n\r\n```\r\n/**\r\n * Run the migrations.\r\n *\r\n * @return void\r\n */\r\npublic function up()\r\n{\r\n    Schema::create(\'tags\', function (Blueprint $table) {\r\n        $table->increments(\'id\');\r\n        $table->string(\'name\')->unique();\r\n        $table->string(\'slug\')->unique();\r\n    });\r\n\r\n    DB::table(\'tags\')->insert([\r\n        [\'name\' => \'Laravel\', \'slug\' => \'laravel\'],\r\n        [\'name\' => \'Lumen\', \'slug\' => \'lumen\'],\r\n        [\'name\' => \'Spark\', \'slug\' => \'spark\'],\r\n        [\'name\' => \'Forge\', \'slug\' => \'Forge\'],\r\n        [\'name\' => \'Envoyer\', \'slug\' => \'envoyer\'],\r\n        [\'name\' => \'Homestead\', \'slug\' => \'homestead\'],\r\n        [\'name\' => \'Valet\', \'slug\' => \'valet\'],\r\n        [\'name\' => \'Socialite\', \'slug\' => \'socialite\'],\r\n        [\'name\' => \'Mix\', \'slug\' => \'mix\'],\r\n        [\'name\' => \'Dusk\', \'slug\' => \'dusk\'],\r\n    ]);\r\n}\r\n```\r\n\r\n```\r\nphp artisan make:migration create_taggables_table --create=taggables\r\n```\r\n\r\n```\r\nSchema::create(\'taggables\', function (Blueprint $table) {\r\n    $table->increments(\'id\');\r\n    $table->unsignedInteger(\'taggable_id\');\r\n    $table->string(\'taggable_type\');\r\n    $table->timestamps();\r\n});\r\n```\r\n\r\n`taggables` 是多对多关系中的中间表/关系表。`taggable_id`、`taggable_type` 和 [上一篇][1] 中的 `commentable_id`、`commentable_type` 两个字段的作用是一样一样的。\r\n\r\n```\r\nphp artisan migrate\r\n```\r\n\r\n## 设定关联\r\n\r\nTag Model\r\n\r\n```\r\nclass Tag extends Model\r\n{\r\n    protected $fillable = [\'name\', \'slug\'];\r\n\r\n    public $timestamps = false;\r\n\r\n    /**\r\n     * 获取该标签下的文章\r\n     *\r\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\MorphToMany\r\n     */\r\n    public function posts()\r\n    {\r\n        return $this->morphedByMany(Post::class, \'taggable\');\r\n    }\r\n\r\n    /**\r\n     * 获取该标签下的视频\r\n     *\r\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\MorphToMany\r\n     */\r\n    public function videos()\r\n    {\r\n        return $this->morphedByMany(Video::class, \'taggable\');\r\n    }\r\n}\r\n```\r\n\r\nPost Model\r\n\r\n```\r\n/**\r\n * 取得文章标签\r\n *\r\n * @return \\Illuminate\\Database\\Eloquent\\Relations\\MorphToMany\r\n */\r\npublic function tags()\r\n{\r\n    return $this->morphToMany(Tag::class, \'taggable\');\r\n}\r\n```\r\n\r\nVideo Model\r\n\r\n```\r\n/**\r\n * 取得视频标签\r\n *\r\n * @return \\Illuminate\\Database\\Eloquent\\Relations\\MorphToMany\r\n */\r\npublic function tags()\r\n{\r\n    return $this->morphToMany(Tag::class, \'taggable\');\r\n}\r\n```\r\n\r\n你会发现 Post Model 和 Video Model 中定义的 `tags` 方法是一样的，没错，包括后来的内容类型，在其 Model 中定义这个方法都是一样的。\r\n\r\n所以，我们就把这个方法写成一个 trait。\r\n\r\n```\r\n<?php\r\n\r\nnamespace App\\Helpers;\r\n\r\nuse App\\Models\\Tag;\r\n\r\ntrait HasTags\r\n{\r\n    /**\r\n     * 取得爱谁谁的标签\r\n     *\r\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\MorphToMany\r\n     */\r\n    public function tags()\r\n    {\r\n        return $this->morphToMany(Tag::class, \'taggable\');\r\n    }\r\n}\r\n```\r\n\r\n然后改写前面 Post Model 和 Video Model 的写法。\r\n\r\n```\r\nuse App\\Helpers\\HasTags;\r\n\r\nclass Post extends Model\r\n{\r\n    use HasTags;\r\n    \r\n    ...\r\n}\r\n\r\nclass Video extends Model\r\n{\r\n    use HasTags;\r\n    \r\n    ...\r\n}\r\n```\r\n\r\n## 使用\r\n\r\n```\r\nphp artisan tinker\r\n\r\n>>> namespace App\\Models;\r\n>>> Post::find(1)->tags()->sync([1,2,3]);\r\n=> [\r\n     \"attached\" => [\r\n       1,\r\n       2,\r\n       3,\r\n     ],\r\n     \"detached\" => [],\r\n     \"updated\" => [],\r\n   ]\r\n>>> Post::find(1)->tags;\r\n=> Illuminate\\Database\\Eloquent\\Collection {#784\r\n     all: [\r\n       App\\Models\\Tag {#785\r\n         id: 1,\r\n         name: \"Laravel\",\r\n         slug: \"laravel\",\r\n         pivot: Illuminate\\Database\\Eloquent\\Relations\\MorphPivot {#782\r\n           taggable_id: 1,\r\n           tag_id: 1,\r\n         },\r\n       },\r\n       App\\Models\\Tag {#786\r\n         id: 2,\r\n         name: \"Lumen\",\r\n         slug: \"lumen\",\r\n         pivot: Illuminate\\Database\\Eloquent\\Relations\\MorphPivot {#783\r\n           taggable_id: 1,\r\n           tag_id: 2,\r\n         },\r\n       },\r\n       App\\Models\\Tag {#789\r\n         id: 3,\r\n         name: \"Spark\",\r\n         slug: \"spark\",\r\n         pivot: Illuminate\\Database\\Eloquent\\Relations\\MorphPivot {#778\r\n           taggable_id: 1,\r\n           tag_id: 3,\r\n         },\r\n       },\r\n     ],\r\n   }\r\n```','2017-10-29 07:25:38','2017-10-29 07:25:38','introduction-to-state-a-lot-more-relevance-in-eloquent-association'),(449,3,3,'介绍 Eloquent 关联中的多态关联','## 简介\r\n\r\n你可能会这样设计你的博客系统：一张文章表（posts）和一张评论表（comments）。\r\n\r\n```\r\nposts\r\n    id - integer\r\n    title - string\r\n    body - text\r\n    \r\ncomments\r\n    id - integer\r\n    body - text\r\n    post_id - integer\r\n```\r\n\r\n突然有一天，你开始录播视频教程了，那么就会多一个张视频表（videos）。\r\n\r\n```\r\nvideos\r\n    id - integer\r\n    title - string\r\n    url - string\r\n```\r\n\r\n此时，为了能够重用之前的评论表，就要对评论表修改了。怎么改才好呢？用冗余字段？\r\n\r\n```\r\ncomments\r\n    id - integer\r\n    body - text\r\n    post_id - integer\r\n    video_id - integer\r\n```\r\n\r\n这当然没问题！但是，如果以后又多了什么图片、音频、名人名言之类的内容，它们也都可以评论，那是否就意味着评论表又变了？\r\n\r\n```\r\ncomments\r\n    id - integer\r\n    body - text\r\n    post_id - integer\r\n    video_id - integer\r\n    image_id - integer\r\n    audio_id - integer\r\n    quote_id - integer\r\n```\r\n\r\n这让人抓狂，因为冗余字段实在太多了，对于后台逻辑判断也是负担。Laravel 提供的解决方案是这样的：\r\n\r\n```\r\ncomments\r\n    id - integer\r\n    body - text\r\n    commentable_id - integer\r\n    commentable_type - string\r\n```\r\n\r\n使用 `commentable_id` 和 `commentable_type` 两个字段替代冗余字段的方式。`comments` 表的内容类似于这样：\r\n\r\n| id | body | commentable_id | commentable_type |\r\n| -------- | -------- | -------- | -------- |\r\n| 1     | 这是文章 1 的评论     | 1     | posts     |\r\n| 2     | 这是文章 2 的评论     | 2     | posts     |\r\n| 3     | 这是视频 1 的评论     | 1     | videos    |\r\n| 4     | 这是视频 2 的评论     | 2     | videos    |\r\n| 5     | 这是音频 1 的评论     | 1     | audios    |\r\n| 6     | 这是音频 2 的评论     | 2     | audios    |\r\n\r\n\r\n这样即使日后增加新的内容类型，只要定义一个新的 `commentable_type` 值就可以了。\r\n\r\n我们称 Comment Model 与 Post Model、Video Model 的关系是**多态关系**，而在它们的 Model 中定义的关联称为**多态关联**。\r\n\r\n## 实现\r\n\r\n### 创建表\r\n\r\n```\r\nphp artisan make:model Models/Post -m -c\r\n\r\nphp artisan make:model Models/Video -m -c\r\n\r\nphp artisan make:model Models/Comment -m -c\r\n```\r\n\r\n```\r\nSchema::create(\'posts\', function (Blueprint $table) {\r\n    $table->increments(\'id\');\r\n    $table->string(\'title\')->unique();\r\n    $table->text(\'body\');\r\n    $table->timestamps();\r\n});\r\n\r\n\r\nSchema::create(\'videos\', function (Blueprint $table) {\r\n    $table->increments(\'id\');\r\n    $table->string(\'title\');\r\n    $table->string(\'url\')->unique();\r\n    $table->timestamps();\r\n});\r\n\r\nSchema::create(\'comments\', function (Blueprint $table) {\r\n    $table->increments(\'id\');\r\n    $table->text(\'body\');\r\n    $table->unsignedInteger(\'commentable_id\');\r\n    $table->string(\'commentable_type\');\r\n    $table->timestamps();\r\n});\r\n```\r\n\r\n```\r\nphp artisan migrate\r\n```\r\n\r\n### 定义关联关系\r\n\r\n```\r\nclass Comment extends Model\r\n{\r\n\r\n    /**\r\n     * 取得评论的文章/视频。\r\n     *\r\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\MorphTo\r\n     */\r\n    public function commentable()\r\n    {\r\n        return $this->morphTo();\r\n    }\r\n}\r\n\r\nclass Post extends Model\r\n{\r\n    const TABLE = \'posts\';\r\n\r\n    protected $table = self::TABLE;\r\n\r\n    /**\r\n     * 取得文章评论\r\n     *\r\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\MorphMany\r\n     */\r\n    public function comments()\r\n    {\r\n        return $this->morphMany(Comment::class, \'commentable\');\r\n    }\r\n}\r\n\r\nclass Video extends Model\r\n{\r\n    const TABLE = \'videos\';\r\n\r\n    protected $table = self::TABLE;\r\n\r\n    /**\r\n     * 取得视频评论\r\n     *\r\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\MorphMany\r\n     */\r\n    public function comments()\r\n    {\r\n        return $this->morphMany(Comment::class, \'commentable\');\r\n    }\r\n}\r\n```\r\n\r\n在 `AppServiceProvider` `boot` 方法中自定义多态关联的类型字段。\r\n\r\n```\r\nuse App\\Models\\Post;\r\nuse App\\Models\\Video;\r\nuse Illuminate\\Database\\Eloquent\\Relations\\Relation;\r\n\r\npublic function boot()\r\n{\r\n    $this->bootEloquentMorphs();\r\n}\r\n\r\n/**\r\n * 自定义多态关联的类型字段\r\n */\r\nprivate function bootEloquentMorphs()\r\n{\r\n    Relation::morphMap([\r\n        Post::TABLE => Post::class,\r\n        Video::TABLE => Video::class,\r\n    ]);\r\n}\r\n```\r\n\r\n### 插入数据\r\n\r\n在 ModelFactory 中定义 Model 的工厂方法。\r\n\r\n```\r\nuse App\\Models\\Post;\r\nuse App\\Models\\Video;\r\nuse App\\Models\\Comment;\r\n\r\n$factory->define(Post::class, function (Faker\\Generator $faker) {\r\n    return [\r\n        \'title\' => $faker->sentence,\r\n        \'body\' => $faker->text,\r\n    ];\r\n});\r\n\r\n$factory->define(Video::class, function (Faker\\Generator $faker) {\r\n\r\n    return [\r\n        \'title\' => $faker->sentence,\r\n        \'url\' => $faker->url,\r\n    ];\r\n});\r\n\r\n$factory->define(Comment::class, function (Faker\\Generator $faker) {\r\n    return [\r\n        \'body\' => $faker->text,\r\n        \'commentable_id\' => factory(Post::class)->create()->id,\r\n        \'commentable_type\' => Post::TABLE,\r\n    ];\r\n\r\n//    return [\r\n//        \'body\' => $faker->text,\r\n//        \'commentable_id\' => factory(Video::class)->create()->id,\r\n//        \'commentable_type\' => Video::TABLE,\r\n//    ];\r\n});\r\n```\r\n\r\n插入伪数据。\r\n\r\n```\r\nphp artisan tinker\r\n\r\n>> namespace App;\r\n>> factory(Models\\Comment::class, 10)->create();\r\n```\r\n\r\n## 使用 \r\n\r\n```\r\nphp artisan tinker\r\n\r\n>> namespace App\\Models;\r\n>> $post = Post::find(1);\r\n>> $post->comments\r\n=> Illuminate\\Database\\Eloquent\\Collection {#733\r\n     all: [\r\n       App\\Models\\Comment {#691\r\n         id: 1,\r\n         body: \"Ut omnis voluptatem esse mollitia nisi saepe vero. Est sed et eius pariatur hic harum sed. Laboriosam autem quis vel optio fugiat tota\r\nm laboriosam.\",\r\n         commentable_id: 1,\r\n         commentable_type: \"posts\",\r\n         created_at: \"2017-07-21 02:42:17\",\r\n         updated_at: \"2017-07-21 02:42:17\",\r\n       },\r\n     ],\r\n   }\r\n```','2017-10-29 07:26:34','2017-10-29 07:26:34','describes-the-polymorphic-associations-in-eloquent-association'),(450,3,3,'《JavaScript 高级程序设计》第13章：事件（二）','## 事件类型\r\n\r\n这里只讲“DOM3 级事件”中常用的几类事件。\r\n\r\n- UI 事件\r\n- 鼠标事件\r\n- 滚轮事件\r\n- 文本事件\r\n- 键盘事件\r\n\r\n### UI 事件\r\n\r\nUI 事件是指哪些不一定与用户操作有关的事件，多数事件都与 `window` 对象有关，主要包括：\r\n\r\n- `load`：当页面加载完毕后在 `window` 对象上触发。\r\n- `select`：当用户选择文本框（`<input>` 和 `<textarea>`）中的一个或者多个字符时触发。\r\n- `resize`：当窗口大小改变时在 `window` 对象上触发。\r\n- `scroll`：在包含滚动条的元素上滚动滚动条时，在元素上触发。页面中的滚动条包含在 `<body>` 元素上。\r\n\r\n1. `load` 事件\r\n\r\nJavaScript 中最常用的一个事件就是 `load`。当页面加载完毕后（包括图片、JS 文件、CSS 文件等外部资源），就会触发 `window` 上面的 `load` 事件。\r\n\r\n为 `window` 对象绑定 `load` 事件处理函数方式，除了 DOM0 级和 DOM2 级事件绑定方式，还可以使用 HTML 标签特性的方式、为 `<body>` 标签添加一个 `onload` 特性实现。\r\n\r\n2. `resize` 事件\r\n\r\n当窗口大小（指宽或者高）改变时会在 `window` 对象上触发 `resize` 事件。**关于何时触发 `resize` 事件，不同浏览器有不同的机制，分 FireFox 阵营和非 FireFox 阵营**。\r\n\r\nFireFox 阵营：当用户停止调整窗口大小时才触发。\r\n\r\n非 FireFox 阵营：窗口变化了 1px 就会触发 `resize` 事件，然后随着变化不断触发。\r\n\r\n3. `scroll` 事件\r\n\r\n`scroll` 事件是在 `window` 对象上触发的。在混杂模式下，可以通过 `<body>` 元素的 `scrollLeft` 和 `scrollTop` 来监控这一变化；**在标准模式下，除了 Safari 之外的所有浏览器都会通过 `<html>` 元素（`document.documentElement`）来反映这一变化**（Safari 仍然是基于 `<body>` 跟踪滚动位置）。\r\n\r\n    window.onscroll = function () {\r\n        if (document.compatMode === \'CSS1Compat\') {\r\n            alter(document.documentElement.scrollTop);\r\n        } else {\r\n            alter(document.body.scrollTop);\r\n        }\r\n    };\r\n\r\n上面的代码会输出页面滚动条垂直滚动距离。Safari 3.1 之前的浏览器不支持 `document.compatMode`，因此旧版本浏览器都会满足第二个条件。\r\n\r\n`scroll` 事件会在页面滚动时重复被触发，所以尽量保持事件处理程序代码简单。\r\n\r\n### 鼠标与滚轮事件\r\n\r\nWeb 开发中，鼠标还是最主要的定位设备。DOM3 级事件中定义了 9 个鼠标事件：\r\n\r\n1. `click`：鼠标单击。\r\n2. `dbclick`：鼠标双击。\r\n3. `mousedown`：按下鼠标按钮。\r\n4. `mouseup`：释放鼠标按钮。\r\n5. `mouseover`：移入一个元素边界时触发。\r\n6. `mouseout`：移出一个元素边界时触发。\r\n7. `mouseenter`：移入一个元素边界时触发（不冒泡）。\r\n8. `mouseleave`：移出一个元素边界时触发（不冒泡）。\r\n9. `mousemove`：在元素内部移动时重复地触发。\r\n\r\n`click`、`dbclick`、`mousedown` 和 `mouseup` 事件触发的顺序如下：\r\n\r\n1. `mousedown`\r\n2. `mouseup`\r\n3. `click`\r\n4. `mousedown`\r\n5. `mouseup`\r\n6. `click`\r\n7. `dbclick`\r\n\r\n`click` 和 `dbclick` 事件都会依赖其他先行事件的触发；而 `mousedown` 和 `mouseup` 则不受其他事件的影响。\r\n\r\n#### 鼠标视口坐标\r\n\r\n鼠标事件对象上有两个属性 `clientX` 和 `clientY`，分别表示鼠标事件发生时，鼠标指针在视口中的水平和垂直坐标。\r\n\r\n#### 鼠标页面坐标\r\n\r\n鼠标事件对象上有两个属性 `pageX` 和 `pageY`，分别表示鼠标事件发生时，鼠标指针在页面中的水平和垂直坐标。因此，在页面没有滚动的情况下，`clientX` 和 `clientY` 的值与 `pageX` 和 `pageY` 的值相等。\r\n\r\n**IE8- 不支持这两个属性**，但是我们可以通过鼠标视口坐标和滚动信息来计算出来。这是要用到 `document.body`（混杂模式）或者 `document.documentElement`（标准模式）中的 `scrollTop` 和 `scrollLeft` 属性来实现。\r\n\r\n    document.onclick = function (event) {\r\n      var pageX = event.pageX,\r\n          pageY = event.pageY;\r\n\r\n      if (pageX === undefined) {\r\n        pageX = event.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft);\r\n      }\r\n\r\n      if (pageY === undefined) {\r\n        pageY = event.clientY + (document.body.scrollTop || document.documentElement.scrollTop);\r\n      }\r\n\r\n      alert(\'pageX：\' + pageX + \' pageY：\' + pageY);\r\n    };\r\n\r\n#### 鼠标屏幕坐标\r\n\r\n鼠标事件对象上有两个属性 `screenX` 和 `screenY`，分别表示鼠标事件发生时，鼠标指针在整个屏幕中的水平和垂直坐标。\r\n\r\n#### 鼠标滚轮事件\r\n\r\n分 FireFox 阵营和非 FireFox 阵营。\r\n\r\n1. 非 FireFox 阵营\r\n\r\nIE6.0 首先实现了 `mousewheel` 事件，然后 Chrome 和 Safari 也实现了这个事件。该事件可以在任何元素上触发，最终会冒泡到 `document`（IE8）或 `window`（IE9、Safari 和 Chrome） 对象上。\r\n\r\n`mousewheel` 事件有一个 `wheelDelta` 属性，它是一个数字。**鼠标上滑时，是 120 的倍数；鼠标下滑时，是 -120 的倍数**。\r\n\r\n    document.onmousewheel = function (event) {\r\n      console.log(event.wheelDelta);\r\n    };\r\n\r\n2. FireFox 阵营\r\n\r\n鼠标滚轮滚动时，触发的是一个名为 `DOMMouseScroll` 的事件，与 `mousewheel` 事件类似。鼠标滚轮的信息保存在 `detail` 属性中。**鼠标上滑时，是 -3 的倍数；鼠标下滑时，是 3 的倍数**。该事件最终会冒泡到 `window` 对象上。\r\n\r\n    document.addEventListener(\'DOMMouseScroll\', function (event) {\r\n      console.log(event.detail);\r\n    });\r\n\r\n咱们下面给出跨浏览器的解决方案。\r\n\r\n    var EventUtil = {\r\n      ...\r\n      ,\r\n      getWheelDelta: function (event) {\r\n        if (event.wheelDelta) {\r\n          return event.wheelDelta;\r\n        }\r\n        return -event.detail * 40;\r\n      }\r\n    };\r\n\r\n有了这个方法之后，就可以将相同的事件处理程序指定给 `mousewheel` 和 `DOMMouseScroll` 事件了。\r\n\r\n    (function() {\r\n      function handleMouseWheel(event) {\r\n        event = EventUtil.getEvent(event);\r\n        var delta = EventUtil.getWheelDelta(event);\r\n        console.log(delta);\r\n      }\r\n\r\n      EventUtil.addHandler(document, \'mousewheel\', handleMouseWheel);\r\n      EventUtil.addHandler(document, \'DOMMouseScroll\', handleMouseWheel);\r\n    })();\r\n\r\n### 键盘与文本事件\r\n\r\n“DOM3 级事件”为键盘事件指定了规范，IE9 率先完全实现了该规范。有 3 个键盘事件：\r\n\r\n1. `keydown`：**按下任意键时触发**。按住不放，会重复触发此事件。\r\n2. `keypress`：**按下字符键时触发**。按住不放，会重复触发此事件。\r\n3. `keyup`：释放键盘上的键时触发。\r\n\r\n当按了字符键时：首先触发 `keydown` 事件，然后是 `keypress` 事件，最后是 `keyup` 事件。`keydown` 和 `keypress` 在文本框变化之前触发，`keyup` 在文本框发生变化之后触发。\r\n\r\n当按了非字符键时：首先触发 `keydown` 事件，最后触发 `keyup` 事件。\r\n\r\n#### 键码\r\n\r\n键盘事件对象拥有一个 `keyCode` 属性，这就是键码。对于数字、字母按键，`keyCode` 属性值与 [ASCII 码](http://tool.oschina.net/commons?type=4)（非字符键键码参见 p380） 中对应的大写字母与数字的编码一样。**DOM 和 IE 的事件对象都支持 `keyCode` 属性**。\r\n\r\n### HTML5 事件\r\n\r\nHTML5  详尽列出了浏览器应该支持的所有事件，这里讨论其中得到浏览器完善支持的事件。\r\n\r\n#### `contextmenu` 事件\r\n\r\n为了解决屏蔽与鼠标右键关联的默认上下文菜单的问题，引入了 `contextmenu` 事件。\r\n\r\n`contextmenu` 事件是冒泡的，因此可以为 `document` 对象指定一个事件处理程序，来处理默认上下文菜单事件。取消这个事件的默认行为：在兼容 DOM 的浏览器中，使用 `event.preventDefault()`；在 IE 中，将 `event.returnValue` 的值设置为 `false`。\r\n\r\n#### `DOMContentLoaded` 事件\r\n\r\n`window` 的 `load` 事件会在页面中的一切资源加载完毕时触发。而 `DOMContentLoaded` 事件则在形成完整的 DOM 树后就会触发，不理会图片、JS 文件、CSS 文件或者其他资源是否已经加载完毕。IE9+ 的支持。\r\n\r\n与 `load` 事件不同的是，**`DOMContentLoaded` 支持在页面下载的早期添加事件处理程序，意味着用户能够尽早地与页面进行交互**。\r\n\r\n### 设备事件\r\n\r\n### 触摸与手势事件','2017-10-30 01:25:44','2017-10-30 01:25:44','senior-javascript-programming-chapter-13-events-2'),(451,3,3,'《JavaScript 高级程序设计》第11章：DOM扩展','对 DOM 的主要扩展是选择符 API 和 HTML5。\r\n\r\n## 选择符 API\r\n\r\n选择符 API Level 1 的核心是两个方法：`querySelector()` 和 `querySelectorAll()`。在支持的浏览器中，可以通过 `Document` 和 `Element` 类型实例调用它们。IE8+ 的支持。\r\n\r\n### `querySeletor()` 方法\r\n\r\n`querySeletor()` 方法接受一个 CSS 选择符，返回与选择符匹配的第一个元素，如果没有找到返回 `null`。\r\n\r\n### `querySelectorAll()` 方法\r\n\r\n`querySelectorAll()` 方法接受的参数和 `querySeletor()` 一样，都是一个 CSS 选择符，返回的是所有匹配的元素集合，是一个 `NodeList` 对象。\r\n\r\n不管找到多少匹配的元素，`querySelectorAll()` 方法都会返回一个 `NodeList` 对象。如果没有找到匹配的元素，`NodeList` 对象就是空的。\r\n\r\n## 元素遍历\r\n\r\n对于元素的空格，IE9 及之前版本不会返回文本结点，而其他浏览器都会返回文本节点。这样，就导致了在使用 `childNodes` 和 `firstChild` 等属性时的行为不一致。为了弥补这一差异，同是保持 DOM 规范不变，Element Traversal 规范新定义了一组属性。\r\n\r\nElement Traversal API 为 DOM 元素添加了以下 5 个属性：\r\n\r\n- `childElementCount`：返回子元素的个数（不包括文本节点和注释）。\r\n- `firstElementChild`：指向第一个子元素；`firstChild` 的元素版。\r\n- `lastElementChild`：指向最后一个子元素；`lastChild` 的元素版。\r\n- `previousElementSibling`：指向前一个兄弟元素；`previousSibling` 的元素版。\r\n- `nextElementSibling`：指向后一个兄弟元素；`nextSibling` 的元素版。\r\n\r\n使用这些方法就不必担心空白文本结点了。\r\n\r\n## HTML5\r\n\r\nHTML5 规范围绕如果使用新增标记定义了大量 JavaScript API。\r\n\r\n### 与类相关的扩充\r\n\r\n#### `getElementsByClassName()` 方法\r\n\r\n`getElementsByClassName()` 方法接受一个参数，即包含一个或者多个类名的字符串，返回带有指定类的所有元素的 `NodeList` 对象，类名的先后顺序不重要。\r\n    \r\n    // 取得类名包含“username”和“current”的元素，类名的先后顺序无所谓\r\n    var currUsernames = document.getElementsByClassName(\'username current\');\r\n\r\nIE9+ 的支持。\r\n\r\n#### `classList` 属性\r\n\r\nHTML 为所有元素添加了 `classList` 属性，实现更方便地操作类名，返回的是 `DOMTokenList` 类型实例，提供了如下的新方法。\r\n\r\n- `add(value)`：将给定的字符串添加到列表中。如果值已经存在了，就不添加。\r\n- `contains(value)`：表示列表中是否存在给定的值，如果存在，返回 `true`，否则返回 `false`。\r\n- `remove(value)`：从列表中删除给定的字符串\r\n- `toggle(value)`：如果列表中存在给定的值，删除它；如果列表中不存在给定的值，添加它。\r\n\r\nIE11 的支持。\r\n\r\n### 自定义数据属性\r\n\r\nHTML5 规定可以为元素添加非标准的属性，但要添加前缀 `data-`，目的是为元素添加与渲染无关的信息。自定义属性可以通过 `dataset` 属性访问。`dataset` 属性的值 `DOMStringMap` 的实例，包含一个键值对映射。在这个映射中，键名一一对应元素自定义特性，只是没有 `data-` 前缀（比如：自定义属性是 `data-name`，那映射中对应的属性就是 `name`）。\r\n\r\n但直到 IE11 才支持 `dataset` 属性。对于 IE8 到 IE10 浏览器，我们可以在标签里使用 `data-` 属性，获得属性的话就用 `getAttribute()` 方法。\r\n\r\n## 插入标记\r\n\r\n### `innerHTML` 属性\r\n\r\n在写模式下，元素 `innerHTML` 的值会被解析为 DOM 子树，替换调用元素原来所有的子节点。\r\n\r\n并不是所有的元素都支持 `innerHTML` 属性。不支持 `innerHTML` 的元素有：`<col>`、`<colgroup>`、`<frameset>`、`<head>`、`<html>`、`<style>`、`<table>`、`<tbody>`、`<thead>`、`<tfoot>` 和 `<tr>`。 \r\n\r\n## 专有扩展\r\n\r\n表面上看，开发商往 DOM 中添加专有扩展的各行其是的做法似乎不太好，但实际上有些专有扩展中重要的，最终都在 HTML5 规范中得到了标准化。\r\n\r\n### 文档模式\r\n\r\n从 IE8 开始，引入了文档模式（document mode）的概念。强制浏览器以某种模式渲染页面，可以使用 HTTP 头部信息 `X-UA-Compatible`，或通过等价的 `<meta>` 标签来设置：\r\n\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\">\r\n\r\n`Edge` 表示始终以最新的文档模式来渲染页面。通过 `document.documentMode` 属性可以知道给定页面使用的是什么文档模式，是 IE8 中新增的。\r\n\r\n### `children` 属性\r\n\r\n元素的 `children` 属性返回的是 `HTMLCollection` 实例，只包含元素中同样还是元素的子节点。\r\n\r\n主要注意的是：IE8- 版本中 `children` 属性返回值中也包含注释节点，但 IE9+ 之后的版本则只返回元素结点。\r\n\r\n## 滚动\r\n\r\n### `scrollIntoView()` 方法\r\n\r\n`elem.scrollIntoView()`：将元素滚动到可视区域，元素顶部（默认情况）与可视区顶部对齐；`elem.scrollIntoView(false)`表示将元素滚动到可视区域，元素底部与可视区顶部对齐。','2017-10-30 05:44:54','2017-10-30 05:44:54','senior-javascript-programming-chapter-11-the-dom-extension'),(452,3,3,'何谓 jQuery Slim？','3.0 版本的 jQuery 除了提供了一个普通的 `jquery.js` 版本，还提供了一个特别版----`jquery.slim.js` 的 [下载](http://jquery.com/download/)。\r\n\r\n何谓 jQuery Slim 呢？，这在发布博文了有 [说明](http://blog.jquery.com/2017/03/20/jquery-3-2-1-now-available/)，总结下来是这样的：\r\n\r\n> jQuery Slim 版本是普通的发行版本的阉割版，剔除了 ajax 和动画效果模块。\r\n\r\n## 为什么要这么做呢？\r\n\r\n1. 为什么要剔除  ajax 模块？\r\n\r\n有许多专注于 ajax 通信的第三方库（比如 [axios](https://github.com/axios/axios) ）可供选择。\r\n\r\n2. 为什么要剔除动画效果？\r\n\r\n因为现代浏览器的更新换代，使用「类名 + CSS3 动画」能实现很多丰富的动画效果了。\r\n\r\n## 注意\r\n\r\n3.0 版本兼容的 IE9+ 上的浏览器，如果需要支持 IE6-8 版本的浏览器，建议使用 [jQuery 1.12](https://code.jquery.com/jquery/#jquery-all-1.x)。','2017-11-03 09:24:34','2017-11-03 09:24:34','what-is-a-jquery-slim'),(453,3,3,'2017年11月5号的日志','我们常常会忘记我们在一直呼吸，从呼吸里滋润血液，氧化自己，小孩成长为大人，大人衰老成老人，这是新陈代谢，也是斗转星移。\r\n\r\n在我认为我存在于世界的时候，我觉得很神奇，你有一个身体做为载体用来体验，可以以我为中心思考身边世界，我身边的世界就是整个世界了，这是一项很大的权利。现在的年纪，我想不到死，渴望着爱与被爱，充满精力和热情，我非常开心。人应该尽可能的让自己开心，健康的开心。不应该考虑孤独和胆怯，因为他们如此自然，不是考虑重点，但白天让我们想到它，让我们变得忧虑忡忡。应该要认识到这件事情的存在，并避免它。\r\n\r\n我想到和广西北路上那个5点半就起来出摊卖煎饼的女子（我偏不叫阿姨），她绝对找不到有人在念着她，是生活成就了她。我想到年底清早天蒙蒙黑的时候骑电动三轮车去土山赶集，现在没有了这个感觉，工作本是个辛苦而又容易迷失的过程，我们庸庸碌碌、平平淡淡的过去，庆幸按时下班并拿到工资，并没有想到时间在流失，我们还湮没在物质与迷失中。这让我没有秘密，练习表达，心情敞亮。\r\n\r\n我为一天中有片刻的冷静思考而喜悦。','2017-11-05 05:59:09','2017-11-05 05:59:09','on-november-5-2017'),(454,3,3,'JavaScript 实战：使用方向键控制方块的运动','我们完成的效果是实现页面中的方块根据方向键的按下情况，可以在 8 个方向上自由做直线运动。这是最终的实战效果：https://codepen.io/zhangbao/full/pdbEvx 。下面分析是怎么做的。\r\n\r\n## HTML\r\n\r\n首先定义好我们的方块。\r\n\r\n	<div class=\"square\"></div>\r\n	\r\n	.square {\r\n		width: 80px;\r\n		height: 80px;\r\n		background: darkred;\r\n		position: absolute;\r\n		left: 0;\r\n		top: 0;\r\n	}\r\n	\r\n这是一个使用了绝对定位的方块。方块的运动时通过修改其 `left`、`top` 值实现的。\r\n\r\n## JavaScript\r\n\r\n接下来写 JavaScript 代码。\r\n\r\n首先获得咱们的方块。\r\n	\r\n	var square = document.querySelector(\'.square\');\r\n\r\n然后声明一个存储按键按下状态的对象 `states`\r\n	\r\n	var states = {\r\n		37: false,\r\n		38: false,\r\n		39: false,\r\n		40: false\r\n	};\r\n	\r\n	Object.seal(states);\r\n\r\n`states` 对象的属性名对应左、上、右、下方向键的 `keyCode`，属性值表示是否被按下：`false` 表示没按下（默认），`true` 表示按下。\r\n\r\n我们还是用 `Object.seal()` 方法「密封」了这个对象，是为了保证对象不能添加属性也不能删除属性，但是可以修改现有的属性值。\r\n\r\n接下来为 `document` 对象添加 `keydown` 和 `keyup` 事件，实现在页面中按下方向键的时候，`states` 对象中的状态值跟着改变。\r\n	\r\n	document.addEventListener(\'keydown\', function (event) {\r\n		states[event.keyCode] = true;\r\n	});\r\n	document.addEventListener(\'keyup\', function (event) {\r\n		states[event.keyCode] = false;\r\n	});\r\n	\r\n现在状态值改变了，我们还需要定义在按下某个方向键时，方块的运动方向是怎样的。我们把这个逻辑封装在一个函数 `move` 里。\r\n	\r\n	function move() {\r\n		if (states[37]) {\r\n			square.style.left = square.getBoundingClientRect().left - 5 + \'px\';\r\n		}\r\n\r\n		if (states[38]) {\r\n			square.style.top = square.getBoundingClientRect().top - 5 + \'px\';\r\n		}\r\n\r\n		if (states[39]) {\r\n			square.style.left = square.getBoundingClientRect().left + 5 + \'px\';\r\n		}\r\n\r\n		if (states[40]) {\r\n			square.style.top = square.getBoundingClientRect().top + 5 + \'px\';\r\n		}\r\n	}\r\n\r\n现在一切都准备好了，需要实现的是怎样将 `states` 对象与 `move` 函数联系在一起，实现滑块根据状态实时运动（运动状态的实时改变我们已经通过给 `document` 对象添加事件监听实现了）。答案就是使用 `setInterval` 定时器函数：\r\n\r\n	setInterval(function () {\r\n		move();\r\n	}, 16);\r\n\r\nOK，完成。','2017-11-06 01:18:42','2017-11-06 01:18:42','javascript-combat-use-the-direction-key-control-the-movement-of-the-block'),(455,3,3,'JavaScript 实战：使用方向键控制轮播图切换','我们这里要实现的效果是：按下左、上、右、下按键，实现轮播图在特定方向上的切换效果。这是最终的代码实现：https://codepen.io/zhangbao/full/eezdrY 。下面来讲解是怎么实现的。\r\n\r\n## 页面结构\r\n\r\n先敬上咱们使用的 HTML 和 CSS 代码。\r\n\r\n**HTML**\r\n\r\n	<div class=\"container\">\r\n		<div class=\"screen\">\r\n			<ul class=\"ppt\">\r\n				<li>1</li>\r\n				<li>2</li>\r\n				<li>3</li>\r\n				<li>4</li>\r\n			</ul>\r\n		</div>\r\n	</div>\r\n\r\n怎们这里有四个幻灯片，一张 PPT。\r\n\r\n**CSS**\r\n\r\n	html, body {\r\n		font-family: Georgia, STXihei;\r\n		height: 100%;\r\n	}\r\n\r\n	ul {\r\n		margin: 0;\r\n		padding: 0;\r\n		list-style: none;\r\n	}\r\n\r\n	.container {\r\n		display: flex;\r\n		height: 100%;\r\n		align-items: center;\r\n		justify-content: center;\r\n	}\r\n\r\n	.screen {\r\n		position: relative;\r\n		width: 100px;\r\n		height: 100px;\r\n		overflow: hidden;\r\n	}\r\n\r\n	.ppt {\r\n		position: absolute;\r\n		top: 0;\r\n		left: 0;\r\n	}\r\n\r\n	.ppt li {\r\n		float: left;\r\n		width: 100px;\r\n		line-height: 100px;\r\n		background: linear-gradient(to right, #90c4ee 0%, #f1caf2 100%);\r\n		text-align: center;\r\n		font-size: 48px;\r\n		color: #fff;\r\n	}\r\n\r\n咱们实现轮播图切换效果的原理是：改变 `.ppt` 在 `.screen` 中的 top 和 left 值，因为  `.screen` 的宽高和一张幻灯片（`.ppt` 下的 `li` 标签）的宽高是一样的（宽高都是 `100px`），所以在水平/垂直方向上改变的一个宽度/高度大小，给我们产生的表象是幻灯片切换，而实际上是整个 `.ppt` 在动的。\r\n\r\n注意，默认 `.ppt` 的宽度和 `.screen` 是一样的（`100px`），也就是说 `.ppt` 默认是垂直排列的，所以当我们在垂直方向上移动 `.ppt` 时能实现无缝切换；但是**当  `.ppt` 在水平方向上移动时，为了能实现无缝切换，需要将 `.ppt` 的宽度设置为全部幻灯片总宽度才行**，在这个例子里是 `400px`（一张幻灯片宽度是 `100px`，共 4 张，所以是 `400px`）。\r\n\r\n分析好后，写咱们的 JavaScript 代码。\r\n\r\n## JavaScript\r\n\r\n首先我们需要获取一些必要的文档元素和要使用的幻灯片的大小的变量。\r\n\r\n	var ppt = document.querySelector(\'.ppt\');\r\n	var slides = ppt.getElementsByTagName(\'li\');\r\n	var slideSize = slides[0].offsetWidth;\r\n\r\n咱们的幻灯片的宽高都是一样的 `100px`，所以 `slideSize` 即表示幻灯片高，也表示幻灯片宽。\r\n\r\n接下来为 `document` 对象添加 `keydown` 事件，处理按下方向键时，`.ppt` 的运动逻辑。**先以按下左方向键为例**：\r\n\r\n	document.addEventListener(\'keydown\', function (event) {\r\n		switch (event.keyCode) {\r\n			case 37:\r\n				ppt.style.width = slideSize * slides.length + \'px\';\r\n\r\n				$(ppt).animate(\r\n					{\r\n						left: -slideSize\r\n					},\r\n					500,\r\n					function () {\r\n						ppt.appendChild(slides[0]);\r\n						ppt.style.left = 0;\r\n					}\r\n				);\r\n\r\n				break;\r\n		}\r\n	});\r\n\r\n注意，这里的动画效果使用 jQuery 的 `.animate()` 方法实现的。咱们分析下这里的逻辑：\r\n\r\n1. 因为是水平轮播的，先把 `.ppt` 设置为横排，也就是它的宽度设置为全部幻灯片总宽度。\r\n2. 使用运动方法 `.animate()`，将 `.ppt` 的 `left` 值设置为 `-100px`，运动时间 500 毫秒。\r\n3. 动画结束后，还需要在结构上做改变，否则下次轮播没有效果（因为始终是 `-100px` 的 left 值）----将第一张幻灯片移动到 `.ppt` 的最后一个位置。这时还需要修复 `.ppt` 和 `left` 值为 `0`，这样第二张幻灯片就能看到了，也就实现了无缝的滚动效果。\r\n\r\n**按下上方向键的处理逻辑是这样的**：\r\n\r\n	case 38: \r\n		ppt.style.width = \'\';\r\n\r\n		$(ppt).animate(\r\n			{\r\n				top: -slideSize\r\n			},\r\n			500,\r\n			function () {\r\n				ppt.appendChild(slides[0]);\r\n				ppt.style.top = 0;\r\n			}\r\n		);\r\n\r\n		break;\r\n\r\n因为是垂直方向上的轮播切换，所以先把 `.ppt` 设置为竖排。与左切换稍有不同的是，这里改变的是 `top` 值。\r\n\r\n再看 **按下右方向键的处理逻辑**：\r\n\r\n	case 39:\r\n		ppt.style.width = slideSize * slides.length + \'px\';\r\n		ppt.insertBefore(slides[slides.length - 1], slides[0]);\r\n		ppt.style.left = -slideSize + \'px\';\r\n\r\n		$(ppt).animate(\r\n			{\r\n				left: 0\r\n			},\r\n			500\r\n		);\r\n\r\n		break;\r\n\r\n与按下左方向键不同的是，除了需要先设置 `.ppt` 宽度，我们其次要考虑的情况是：第一张幻灯片在右切换的时候，左边是没有幻灯片的，所以需要先把最后一张幻灯片转移到第一个位置上来，同时将 `.ppt` 的 `left` 值设置为 `-100px`，这样在初始状态下，我们看到的还是我们要切换的那张幻灯片，那么最后要做的无非是将 `.ppt` 右移，即 left 值从 `-100px` 变为 `0`。\r\n\r\n这样最后 **按下下方向键的处理逻辑** 就不难理解了：\r\n\r\n	case 40:\r\n		ppt.style.width = \'\';\r\n\r\n		ppt.insertBefore(slides[slides.length - 1], slides[0]);\r\n		ppt.style.top = -slideSize + \'px\';\r\n\r\n		$(ppt).animate(\r\n			{\r\n				top: 0\r\n			},\r\n			500\r\n		);\r\n\r\n		break;\r\n\r\n转移最后一张幻灯片的位置到第一个位置，然后改变其 `top` 值为 `-100px`，然后动画运动到 `top` 值为 `0` 的位置，就是说幻灯片在下移。\r\n\r\n## 注意\r\n\r\n因为 `keydown` 事件会在我们按下按键不放时连续触发，所以为了避免切换效果受影响。我们可以引入一个状态变量，当正在切换幻灯时，不执行后来的 `keydown` 请求。\r\n\r\n	var moving = false;\r\n\r\n	document.addEventListener(\'keydown\', function (event) {\r\n		 \r\n		// 如果正在进行幻灯片切换，则直接返回\r\n		if (moving) {\r\n			return ;\r\n		}\r\n	\r\n		// 如果当前没有正在切换的幻灯片，并且按下了方向键的话\r\n		// 则将 moving 变量设置为 true，表示现在有正在切换的幻灯片\r\n		if (event.keyCode <= 40 && event.keyCode >= 37) {\r\n			moving = true;\r\n		}\r\n\r\n		switch (event.keyCode) {\r\n			case 37:\r\n				ppt.style.width = slideSize * slides.length + \'px\';\r\n\r\n				$(ppt).animate(\r\n					{\r\n						left: -slideSize\r\n					},\r\n					500,\r\n					function () {\r\n						ppt.appendChild(slides[0]);\r\n						ppt.style.left = 0;\r\n\r\n						// 在每次运动结束后，将 moving 变量设置为 false，表示当前没有正在切换的幻灯片\r\n						moving = false;\r\n					}\r\n				);\r\n\r\n				break;\r\n\r\n			...','2017-11-06 02:53:48','2017-11-06 03:06:58','javascript-combat-use-the-direction-key-control-by-switch'),(456,3,3,'JavaScript 实战：搜索框','我们实现的搜索框效果是：\r\n\r\n1. 点击搜索框显示词条列表。\r\n2. 点击点击搜索框之外的地方隐藏词条列表。\r\n3. 点击词条：\r\n	- 点击的是新词条：词条内容填入搜索框，并将词条置为 `.selected` 状态。\r\n	- 重复点击同一个词条：搜索框内容置空，词条取消 `.selected` 状态。\r\n4. 搜索词条。\r\n5. 按回车键显示、隐藏词条。\r\n6. 按上、下方向键切换选中词条，并且将选中词条的内容同步更新到搜索框中。\r\n\r\n我们就按照这样的步骤去实现效果（最终效果可在这里看到→ https://codepen.io/zhangbao/full/zPBNeX ）。\r\n\r\n## 页面结构\r\n\r\n**HTML**\r\n\r\n	<div class=\"search-engine\">\r\n		<div class=\"search-box\">\r\n			<input type=\"text\" name=\"search\" autocomplete=\"off\">\r\n			<span class=\"search-btn\"></span>\r\n		</div>\r\n		<ul class=\"search-res\"></ul>\r\n	</div>\r\n\r\n我们的搜索结果就放在 `.search-res` 中，这是词条列表。\r\n\r\n**CSS**\r\n\r\nCSS 内容较多，咱们这里只列出重要的，具体看 [源码](https://codepen.io/zhangbao/full/zPBNeX)。\r\n\r\n	.search-res {\r\n		position: absolute;\r\n		top: 39px;\r\n		left: 0;\r\n		right: 0;\r\n		border: 1px solid #ebebeb;\r\n		display: none;\r\n	}\r\n\r\n	.search-res.show {\r\n		display: block;\r\n	}\r\n\r\n`.search-res` 默认是 `display: none` 的，在我们的实现里用到 `.search-res` 的隐藏和显示的地方很多，所以我们这里添加了 `.show` 辅助类，控制 `.search-res` 的隐藏和显示。\r\n\r\n## JavaScript\r\n\r\n首先我们先准备好的我们的词条伪数据：\r\n\r\n	var entries = [\r\n		\'《健康日历2018》\',\r\n		\'《我不》\',\r\n		\'《我在未来等你》\',\r\n		\'《摆渡人》\',\r\n		\'《摆渡人2：重返荒原》\',\r\n		\'《决定你上限的不是能力，而是格局》\',\r\n		\'《习近平的七年知青岁月》\',\r\n		\'《愿你历尽千帆，归来仍是少年》\'\r\n	];\r\n\r\n然后，保存我们需要使用的文档元素\r\n\r\n	var searchInput = document.querySelector(\'input[name=\"search\"]\'); \r\n	var searchRes = document.querySelector(\'.search-res\');\r\n	var lis = searchRes.getElementsByTagName(\'li\');\r\n\r\n注意，这里的 ` lis` 是使用 `getElementsByTagName` 获取的，这个查询结果是动态的，这样就不用每次 `searchRes.innerHTML = ...` 的时候，再用 `querySelectorAll` 获得最新结果了。\r\n\r\n接下来我们渲染内容到 `searchRes` 中：\r\n\r\n	renderEntries(entries);\r\n	\r\n	function renderEntries(data) {\r\n		var fragment = \'\';\r\n\r\n		data.forEach(function (entry) {\r\n			fragment += \'<li>\' + entry + \'</li>\';\r\n		});\r\n\r\n		searchRes.innerHTML = fragment;\r\n	}\r\n\r\n现在我们默认就把所有词条渲染达到页面了。接下来实现「点击搜索框显示词条列表」和「点击点击搜索框之外的地方隐藏词条列表」：\r\n\r\n	// 1. 点击搜索框显示词条列表\r\n	searchInput.onclick = function (event) {\r\n		searchRes.classList.add(\'show\');\r\n\r\n		// 阻止事件冒泡\r\n		event.cancelBubble = true;\r\n	};\r\n\r\n	// 2. 点击页面空白处，隐藏词条列表\r\n	document.onclick = function (event) {\r\n		searchRes.classList.remove(\'show\');\r\n	}\r\n\r\n`searchInput` 的 `click` 事件中	，我们写了一个组织事件冒泡的语句 `event.cancelBubble = true`----这是为了避免发生在搜索框上的 `click`  事件会冒泡到 `document` 对象上，从而导致咱们的词条列表始终不显示的问题。\r\n\r\n还有一个 **点击词条** 的功能，这个应该在 `renderEntries` 的时候就完成的，所以我们这里对 `renderEntries` 方法修改下。\r\n\r\n	var prevSelEntryIndex = -1;\r\n\r\n	function renderEntries(data) {\r\n		...\r\n\r\n		// 3. 点击词条\r\n		for (var i = 0; i < lis.length; i++) {\r\n			lis[i].index = i;\r\n			lis[i].onclick = function () {\r\n				searchInput.focus();\r\n\r\n				if (prevSelEntryIndex !== -1) {\r\n					lis[prevSelEntryIndex].classList.remove(\'selected\');\r\n				}\r\n\r\n				// 重复点击同一个词条。此时要做的是：\r\n				// 1). 取消本条目选中状态（上一步已做）\r\n				// 2). 将选中词条索引置为初始值 -1\r\n				// 3). 搜索框内容置为空\r\n				// 4). 直接返回，不执行后面的代码\r\n				if (this.index === prevSelEntryIndex) {\r\n					prevSelEntryIndex = -1;\r\n					searchInput.value = \'\';\r\n					return ;\r\n				}\r\n\r\n				// 点击新词条\r\n				this.classList.add(\'selected\');\r\n				searchInput.value = this.innerHTML;\r\n				prevSelEntryIndex = this.index;\r\n			}\r\n		}\r\n\r\n		prevSelEntryIndex = -1;\r\n	}\r\n\r\n注意，我们这里引入了一个全局变量 `prevSelEntryIndex`---表示前一个选中的词条索引值。这是为了把当前条目标识为选中的同时（`this.classList.add(\'selected\')`），把上一个选中词条的选中样式去掉（`lis[prevSelEntryIndex].classList.remove(\'selected\')`）。\r\n\r\n当然，每次调用渲染函数 `renderEntries` 时（后面要讲的搜索条目功能就需要调用这个函数），也不要忘记把 `prevSelEntryIndex ` 的值设置为 `-1`。\r\n\r\n接下来实现「搜索词条」的功能。\r\n\r\n	// 4. 搜索词条\r\n	searchInput.oninput = function (event) {\r\n		var filterEntries = [];\r\n		entries.forEach(function (entry) {\r\n			if (entry.indexOf(searchInput.value) !== -1) {\r\n				filterEntries.push(entry);\r\n			}\r\n		});\r\n\r\n		renderEntries(filterEntries);\r\n\r\n		searchRes.classList.add(\'show\');\r\n	};\r\n\r\n注意，搜索词条的时候，不要忘记显示词条列表。\r\n\r\n最后要实现的功能都发在搜索框中----「按下回车键显示、隐藏词条列表」和「按上、下键切换选中词条」。这都放在了搜索框的 `keydown` 事件中实现。\r\n\r\n	searchInput.onkeydown = function (event) {\r\n		switch (event.keyCode) {\r\n\r\n			// 5. 按下回车键显示、隐藏词条列表\r\n			case 13:\r\n				searchRes.classList.contains(\'show\') ? searchRes.classList.remove(\'show\') : searchRes.classList.add(\'show\');\r\n\r\n				break;\r\n\r\n			// 6. 按上、下键切换选中词条\r\n			case 38:\r\n				if (prevSelEntryIndex !== -1) {\r\n					lis[prevSelEntryIndex].classList.remove(\'selected\');\r\n				}\r\n\r\n				prevSelEntryIndex--;\r\n				if (prevSelEntryIndex < 0) {\r\n					prevSelEntryIndex = lis.length - 1;\r\n				}\r\n\r\n				lis[prevSelEntryIndex].classList.add(\'selected\');\r\n				searchInput.value = lis[prevSelEntryIndex].innerHTML;\r\n\r\n				searchRes.classList.add(\'show\');\r\n\r\n				break;\r\n\r\n			case 40: \r\n				if (prevSelEntryIndex !== -1) {\r\n					lis[prevSelEntryIndex].classList.remove(\'selected\');\r\n				}\r\n\r\n				prevSelEntryIndex++;\r\n				if (prevSelEntryIndex > (lis.length - 1)) {\r\n					prevSelEntryIndex = 0;\r\n				}\r\n\r\n				lis[prevSelEntryIndex].classList.add(\'selected\');\r\n				searchInput.value = lis[prevSelEntryIndex].innerHTML;\r\n\r\n				searchRes.classList.add(\'show\');\r\n\r\n				break;\r\n		}\r\n	};\r\n\r\n注意，按下上下方向键切换选中词条的时候，也不要忘记显示词条列表。','2017-11-06 06:59:39','2017-11-06 07:29:17','javascript-combat-search-box'),(457,3,3,'Ajax 同源策略和 JSONP','一般， Ajax 请求是不允许跨域的。例如，从 example1.com 加载的页面中向 example2.com 这个域名发送 Ajax 请求是不可以的，因为这违反了同源策略（Same-Origin Policy）。作为替代方案，使用 JSONP（JSON with Padding）来获得数据，JSONP 并不是 Ajax，它利用了 `<script>` 标签 `src` 属性引用的地址不受同源策略限制的特点，来加载来自另一个域的数据，这些数据可以是任意的 JavaScript 内容，也可以是 JSON 数据。\r\n\r\n当然还有一种解除 Ajax 同源策略的方案称为「跨域资源共享」（CORS，IE9- 不支持），但这需要 XMLHttpRequest Level 2 级 API 和后台服务器端的支持才行。\r\n\r\n## 同源策略和 JSONP\r\n\r\n一般，页面中的 Ajax 请求被限制在相同的协议（http 或者 https）、端口和域名中，这被称为「同源策略」。但是这个限制对使用 `<script>` 标签引用的脚本是无效的，这就引出了 JSONP。\r\n\r\nJSON 技术的本质是，通过页面的 `<script>` 标签的 `src` 属性向服务器端请求脚本数据，这就避免了同源限制。而请求过来的数据内容是包装在你提供的回调函数名中的。\r\n\r\n## JSONP 请求实例\r\n\r\n我向百度搜索发送一个 JSONP 请求，请求地址是\r\n	\r\n	https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=z&cb=jQuery1102025238744678233105_1510018595565&_=1510018595569\r\n\r\n这个请求地址里包含 3 个参数：\r\n\r\n1. `wd`：这是查询关键字，此处是 `z`。\r\n2. `cb`：是「callback」的缩写，这个变量的值会传递到后台，后台在返回的脚本数据会使用它作为回调函数名，将我们请求的数据作为参数传递到这个回调函数里。\r\n3. `_`：这是个时间戳字段，避免数据缓存，让我们实时得到最新数据。\r\n\r\n最终这个请求地址的返回的数据是这样的。\r\n\r\n	jQuery1102025238744678233105_1510018595565({\r\n		\"q\": \"z\", \r\n		\"p\": false, \r\n		\"s\": [\r\n			\"知乎\", \r\n			\"在线翻译\", \r\n			\"智联招聘\", \r\n			\"中国有嘻哈\", \r\n			\"中国新歌声\", \r\n			\"醉玲珑\", \r\n			\"支付宝\", \r\n			\"中国银行\", \r\n			\"招商银行\", \r\n			\"中国地图\"\r\n		]\r\n	})\r\n\r\n注意，当我们以\r\n\r\n	<script src=\"https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=z&cb=jQuery1102025238744678233105_1510018595565&_=1510018595569\"></script>\r\n\r\n的形式请求得到这段脚本时，**得到的是一段函数执行代码，而且参数就是我们请求的数据**！理解这一点非常重要，因为接下来我们就知道怎么调用它了。\r\n\r\n	<script>\r\n		function jQuery1102025238744678233105_1510018595565(response) {\r\n			console.log(response);\r\n		} \r\n	</script>\r\n	<script src=\"https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=z&cb=jQuery1102025238744678233105_1510018595565&_=1510018595569\"></script>\r\n\r\n在页面里放入这段代码，然后我们就可以在控制台看到输出的返回数据了。\r\n	\r\n![JSONP 请求数据](http://www.baooab.com/wp/wp-content/uploads/2017/11/jsonp_request.png)。\r\n\r\n## 参考链接\r\n\r\n1. [Ajax](https://learn.jquery.com/ajax/)，from jQuery.com\r\n2. [Same-Origin Policy and JSONP](https://learn.jquery.com/ajax/key-concepts/)，from jQuery.com','2017-11-06 07:59:35','2017-11-07 02:00:18','ajax-same-origin-policy-and-json'),(458,3,3,'? 自己封装一个 JSONP 请求函数?','接下来封装一个调用 JSONP 请求辅助函数。核心的步骤是：\r\n\r\n1. merge 初始化参数。\r\n2. 拼接查询字符串。\r\n3. 拼接 `<script>` 标签 `src` 属性使用的请求地址。\r\n3. 声明脚本中调用的回调函数，接收返回数据。\r\n\r\n下面来实现。\r\n\r\n## 实现\r\n\r\n### 第一步\r\n\r\n声明函数 `jsonp`，它包含一个 `settings` 属性，包含默认参数值。\r\n\r\n	function jsonp() {\r\n		var settings = {\r\n			url: \'\',\r\n			data: {},\r\n			callBack: \'callback\',\r\n			fnName: \'jsonp_\' + new Date().getTime(),\r\n			succ: function () {}\r\n		};\r\n	}\r\n\r\n一共接收 5 个参数：\r\n\r\n1. `url`：请求地址。\r\n2. `data`：请求数据。\r\n3. `callBack`：URL 中存储回调函数名的变量。\r\n4. `fnName`：回调函数名。\r\n5. `succ`：成功返回数据时的回调函数。\r\n\r\n当然这些参数允许我们自定义的 `jsonp` 函数添加 `options` 自定义参数变量，这个变量需要与默认变量 `settings` merge。\r\n\r\n	function jsonp(options) {\r\n		var settings = {\r\n			url: \'\',\r\n			data: {},\r\n			callBack: \'callback\',\r\n			fnName: \'jsonp_\' + new Date().getTime(),\r\n			succ: function () {}\r\n		};\r\n	}\r\n\r\n	if (typeof Object.assign === \'function\') {\r\n		Object.assign(settings, options);\r\n	} else {\r\n		for (var attr in options) {\r\n			if (options.hasOwnProperty(attr)) {\r\n				settings[attr] = options[attr];\r\n			}\r\n		}\r\n	}\r\n	settings.data[settings.callBack] = settings.fnName;\r\n\r\n我们这里加了一句 \r\n\r\n	settings.data[settings.callBack] = settings.fnName;\r\n\r\n这是为了补全 `settings.data` 变量属性用的，因为之后 **JSONP 请求地址里的查询字符串全部来自于 `settings.data` 变量**。\r\n\r\n### 第二步\r\n\r\n拼接查询字符串。\r\n\r\n	var pairs = [];\r\n	for (var attr in settings.data) {\r\n		pairs.push(encodeURIComponent(attr) + \'=\' + encodeURIComponent(settings.data[attr]));\r\n	}\r\n	var queryString = pairs.join(\'&\');\r\n\r\n### 第三步\r\n\r\n新建、设置 `script` 标签的 `src` 属性：\r\n\r\n	var script = document.createElement(\'script\');\r\n	script.className = \'sc\';\r\n	script.src = settings.url + \'?\' + queryString;\r\n	\r\n	var head = document.head || document.getElementsByTagName(\'head\')[0];\r\n	head.appendChild(script);\r\n\r\n### 第三步\r\n\r\n声明脚本中调用的回调函数。\r\n\r\n	window[settings.fnName] = function (data) {\r\n\r\n		// 先删除咱们的 <script> 标签，就像什么都没发生……\r\n		var scripts = head.getElementsByTagName(\'script\');\r\n		for (var i = 0; i < scripts.length; i++) {\r\n			if (scripts[i].className === \'sc\') {\r\n				head.removeChild(scripts[i]);\r\n			}\r\n		}\r\n\r\n		// 调用成功时的处理函数\r\n		settings.succ(data);	\r\n	};\r\n\r\n### 全部代码\r\n\r\n	function jsonp(options) {\r\n		var settings = {\r\n			url: \'\',\r\n			data: {},\r\n			callBack: \'callback\', // URL 中存储回调函数名的变量\r\n			fnName: \'jsonp_\' + new Date().getTime(), // 回调函数名\r\n			succ: function () {}\r\n		};\r\n\r\n		// 1. merge 参数\r\n		if (typeof Object.assign === \'function\') {\r\n			Object.assign(settings, options);\r\n		} else {\r\n			for (var attr in options) {\r\n				if (options.hasOwnProperty(attr)) {\r\n					settings[attr] = options[attr];\r\n				}\r\n			}\r\n		}\r\n\r\n		// 2. 补全 data，添加回调函数参数数据\r\n		settings.data[settings.callBack] = settings.fnName;\r\n\r\n		// 3. 拼接查询字符串\r\n		var pairs = [];\r\n		for (var attr in settings.data) {\r\n			pairs.push(encodeURIComponent(attr) + \'=\' + encodeURIComponent(settings.data[attr]));\r\n		}\r\n		var queryString = pairs.join(\'&\');\r\n\r\n		// 4. 新建、设置 script 标签的 src 属性\r\n		var script = document.createElement(\'script\');\r\n		script.className = \'sc\';\r\n		script.src = settings.url + \'?\' + queryString;\r\n\r\n		// 5. 将 script 标签添加到 <head> 头部\r\n		var head = document.head || document.getElementsByTagName(\'head\')[0];\r\n		head.appendChild(script);\r\n\r\n		// 6. 声明脚本中调用的回调函数\r\n		window[settings.fnName] = function (data) {\r\n\r\n			// 删除咱们的 <script> 标签\r\n			var scripts = head.getElementsByTagName(\'script\');\r\n			for (var i = 0; i < scripts.length; i++) {\r\n				if (scripts[i].className === \'sc\') {\r\n					head.removeChild(scripts[i]);\r\n				}\r\n			}\r\n\r\n			// 调用成功时的处理函数\r\n			settings.succ(data);	\r\n		};\r\n	}\r\n\r\n## 使用\r\n\r\n下面以百度搜索的 JSONP 请求地址 https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su  为例，他接受两个参数：\r\n\r\n1. `wd`：这是查询关键字。\r\n2. `cb`：URL 中存储回调函数名的变量。\r\n\r\n### HTML\r\n\r\n	<input type=\"type\" name=\"search\">\r\n\r\n	<ul class=\"res\"></ul>\r\n\r\n### JavaScript\r\n\r\n	var searchInput = document.querySelector(\'input[name=\"search\"]\');\r\n	var res = document.querySelector(\'.res\');\r\n\r\n	searchInput.oninput = function () {\r\n		search(searchInput.value);\r\n	};\r\n\r\n	function search(q) {\r\n		jsonp({\r\n			url: \'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su\',\r\n			callBack: \'cb\',\r\n			data: {\r\n				wd: q\r\n			},\r\n			succ: succHandler\r\n		});\r\n	}\r\n\r\n	function succHandler(data) {\r\n		var tempHtml = \'\';\r\n		for (var i = 0; i < data.s.length; i++) {\r\n			tempHtml += \'<li>\' + data.s[i] + \'</li>\';\r\n		}\r\n		res.innerHTML = tempHtml;\r\n	}\r\n\r\nOK，就这么多了。\r\n\r\n## 2017.12.16 更新\r\n\r\n对封装的 jsonp 函数做了一个升级----在调用成功回调函数中，删除 `<script>` 标签的代码放在 `onload` 事件之中。\r\n\r\n```javascript\r\nfunction jsonp(options) {\r\n    var settings = {\r\n        url: \'\',\r\n        data: {},\r\n        callBack: \'callback\', // URL 中存储回调函数名的变量\r\n        fnName: \'jsonp_\' + new Date().getTime(), // 回调函数名\r\n        succ: function () {}\r\n    };\r\n\r\n    // 1. merge 参数\r\n    for (var attr in options) {\r\n		if (options.hasOwnProperty(attr)) {\r\n			settings[attr] = options[attr];\r\n		}\r\n	}\r\n\r\n    // 2. 补全 data，添加回调函数参数数据\r\n    settings.data[settings.callBack] = settings.fnName;\r\n\r\n    // 3. 拼接查询字符串\r\n    var pairs = [];\r\n    for (var attr in settings.data) {\r\n        pairs.push(encodeURIComponent(attr) + \'=\' + encodeURIComponent(settings.data[attr]));\r\n    }\r\n    var queryString = pairs.join(\'&\');\r\n\r\n    // 4. 新建、设置 script 标签的 src 属性\r\n    var script = document.createElement(\'script\');\r\n    script.className = \'sc\';\r\n    script.src = settings.url + \'?\' + queryString;\r\n\r\n    // 5. 调用脚本中的回调函数\r\n    window[settings.fnName] = function (data) {\r\n        settings.succ(data);    \r\n    };\r\n	// 6. 脚本加载完毕后删除 script 标签\r\n	script.onload = script.onreadystatechange = function() {\r\n		if (!this.readyState ||\r\n						this.readyState === \"loaded\" || this.readyState === \"complete\") {\r\n			// Handle memory leak in IE\r\n			script.onload = script.onreadystatechange = null;\r\n			if ( head && script.parentNode ) {\r\n					head.removeChild( script );\r\n			}\r\n		}\r\n	};\r\n		\r\n	// 7. 将 script 标签添加到 <head> 头部\r\n	var head = document.getElementsByTagName(\'head\')[0] || document.documentElement;\r\n    head.insertBefore( script, head.firstChild );\r\n}\r\n```\r\n\r\n为了更好的兼容性，`<script>` 插入 head 的时机，安排在了最后。','2017-11-07 03:00:25','2017-12-16 14:07:52','packaging-function-called-the-json-request-and-process-the-data'),(459,3,3,'XMLHttpRequest 对象上的 readystatechange 与 load 事件','这两个事件都发生在 XMLHttpRequest 对象上的，也就是 Ajax 请求过程中。`load` 事件是 XMLHttpRequest Level 2 级别的 API，不兼容 IE6/7/8；而 `readystatechange` 事件兼容 IE6/7/8。\r\n\r\n`xhr.readyState` 属性表示请求/响应的活动阶段，我们可以使用 `onreadystatechange` 事件实时监听这个属性值的变化。其可取的值如下：\r\n\r\n* `0`。初始化。还没有调用 `open()` 方法。\r\n* `1`。启动。已经调用 `open()` 方法，还没有调用 `send` 方法。\r\n* `2`。发送。已经调用 `send` 方法，但还没有接收到响应。\r\n* `3`。接收。已经接收到部分响应数据，正在解析。\r\n* `4`。完成。已经接收到全部响应数据，解析完成，客户端可以使用了。\r\n\r\n需要注意的是，必须在调用 `open()` 方法之前指定 `onreadystatechange` 事件处理程序才能确保跨浏览器兼容性。 \r\n\r\n`xhr.status` 属性表示 HTTP 响应码。常见的像 200（成功）、404（未找到） 等。\r\n\r\n`xhr.onload` 属性设定请求完成后（即发生 `load` 事件时 ）调用的回调函数，此时 `readyState` 属性值为 4。但 IE6/7/8 不支持这个属性。\r\n\r\n新的 XMLHttpRequest 不推荐使用 `onreadystatechange`，而是使用作为替代的 `onload` 属性作为监听 XMLHttpRequest 对象请求状态。','2017-11-07 04:30:42','2017-11-07 04:30:42','the-xmlhttprequest-object-readystatechange-and-the-load-on-the-event'),(460,3,3,'封装函数：调用 Ajax 请求','接下来我们来封装一个 Ajax 请求的辅助函数，核心步骤包括以下 5 个：\r\n\r\n1. merge 默认参数。\r\n2. 拼接查询字符串。\r\n3. 生成一个 XMLHttpRequest 对象。\r\n4. 根据请求方式发送请求。\r\n5. 处理请求返回的数据。\r\n\r\n首先，我们声明一个函数 `ajax`，带有配置对象 `options`。\r\n\r\n	function ajax(options) {\r\n		var settings = {\r\n			url: \'\',\r\n			method: \'get\',\r\n			dataType: \'json\',\r\n			data: null,\r\n			succ: function () {},\r\n			fail: function () {}\r\n		};\r\n	}\r\n\r\n## 实现\r\n\r\n### 第一步\r\n\r\nmerge 默认参数。\r\n\r\n	if (typeof Object.assign === \'function\') {\r\n		Object.assign(settings, options);\r\n	} else {\r\n		for (var attr in options) {\r\n			if (options.hasOwnProperty(attr)) {\r\n				settings[attr] = options[attr];\r\n			}\r\n		}\r\n	}\r\n\r\n### 第二步\r\n\r\n拼接查询字符串。\r\n\r\n	var pairs = [];\r\n	for (var attr in settings.data) {\r\n		pairs.push(attr + \'=\' + encodeURIComponent(settings.data[attr]));\r\n	}\r\n	var queryString = pairs.join(\'&\');\r\n\r\n### 第三步\r\n\r\n生成一个 XMLHttpRequest 对象。\r\n\r\n	var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\'Microsoft.XMLHTTP\');\r\n\r\n`new ActiveXObject` 兼容 IE6- 的浏览器。\r\n\r\n### 第四步\r\n\r\n根据请求方式发送请求。\r\n\r\n	// get 请求\r\n	if (settings.method.toLowerCase() === \'get\') {\r\n		xhr.open(settings.method, settings.url + \'?\' + queryString + \'&_\' + new Date().getTime());\r\n		xhr.send();\r\n		\r\n	// post 请求\r\n	} else if (settings.method.toLowerCase() === \'post\') {\r\n		xhr.open(settings.method, settings.url);\r\n		xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\');\r\n		xhr.send(queryString);\r\n	} else {\r\n		console.log(\'Not support request method \"\' + settings.method + \'\"!\');\r\n		return ;\r\n	}\r\n\r\n### 第五步\r\n\r\n处理请求返回数据。\r\n\r\n	if (typeof xhr.onload === \'undefined\') {\r\n		xhr.onreadystatechange = ready;\r\n	} else {\r\n		xhr.onload = ready;\r\n	}\r\n\r\n	function ready() {\r\n		if (xhr.readyState === 4) {\r\n			if (xhr.status === 200) {\r\n				switch (settings.dataType.toLowerCase()) {\r\n					case \'text\':\r\n						settings.succ(xhr.responseText);\r\n						break;\r\n					case \'json\': \r\n						settings.succ(JSON.parse(xhr.responseText));\r\n						break;\r\n					case \'xml\':\r\n						settings.succ(xhr.responseXML);\r\n						break;\r\n					default:\r\n						console.log(\'Not support data type \"\' + settings.dataType + \'\"!\');\r\n				}\r\n			} else {\r\n				settings.fail(\'error >>> \' + xhr.status);\r\n			}\r\n		}\r\n	}\r\n\r\n### 完整代码\r\n\r\n	/*\r\n		url 请求地址\r\n		method 请求方式 get/post\r\n		dataType 返回的数据类型 text/json/xml\r\n		data 请求时附带的数据\r\n		succ 请求成功后的回调函数\r\n		fail 请求失败后的回到函数\r\n	*/\r\n	function ajax(options) {\r\n		var settings = {\r\n			url: \'\',\r\n			method: \'get\',\r\n			dataType: \'json\',\r\n			data: null,\r\n			succ: function () {},\r\n			fail: function () {}\r\n		};\r\n\r\n		// 1. merge 参数\r\n		if (typeof Object.assign === \'function\') {\r\n			Object.assign(settings, options);\r\n		} else {\r\n			for (var attr in options) {\r\n				if (options.hasOwnProperty(attr)) {\r\n					settings[attr] = options[attr];\r\n				}\r\n			}\r\n		}\r\n\r\n		// 2. 拼接查询字符串\r\n		var pairs = [];\r\n		for (var attr in settings.data) {\r\n			pairs.push(attr + \'=\' + encodeURIComponent(settings.data[attr]));\r\n		}\r\n		var queryString = pairs.join(\'&\');\r\n\r\n		// 3. 生成一个 XMLHttpRequest 对象\r\n		var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\'Microsoft.XMLHTTP\');\r\n\r\n		// 5. 处理请求返回数据\r\n		if (typeof xhr.onload === \'undefined\') {\r\n			xhr.onreadystatechange = ready;\r\n		} else {\r\n			xhr.onload = ready;\r\n		}\r\n\r\n		function ready() {\r\n			if (xhr.readyState === 4) {\r\n				if (xhr.status === 200) {\r\n					switch (settings.dataType.toLowerCase()) {\r\n						case \'text\':\r\n							settings.succ(xhr.responseText);\r\n							break;\r\n\r\n						case \'json\': \r\n							settings.succ(JSON.parse(xhr.responseText));\r\n							break;\r\n\r\n						case \'xml\':\r\n							settings.succ(xhr.responseXML);\r\n							break;\r\n\r\n						default:\r\n							console.log(\'Not support data type \"\' + settings.dataType + \'\"!\');\r\n					}\r\n				} else {\r\n					settings.fail(\'error >>> \' + xhr.status);\r\n				}\r\n			}\r\n		}\r\n\r\n		// 4. 根据请求方式发送请求\r\n		// get 请求\r\n		if (settings.method.toLowerCase() === \'get\') {\r\n			xhr.open(settings.method, settings.url + \'?\' + queryString + \'&_\' + new Date().getTime());\r\n			xhr.send();\r\n		// post 请求\r\n		} else if (settings.method.toLowerCase() === \'post\') {\r\n			xhr.open(settings.method, settings.url);\r\n			xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\');\r\n			xhr.send(queryString);\r\n		} else {\r\n			console.log(\'Not support request method \"\' + settings.method + \'\"!\');\r\n			return ;\r\n		}\r\n	}\r\n\r\n## 使用\r\n\r\n	<script type=\"text/javascript\" src=\"ajax.js\"></script>\r\n	<script type=\"text/javascript\">\r\n		ajax({\r\n			url: \'https://api.github.com/search/repositories\',\r\n			data: {\r\n				q: \'微信\',\r\n				sort: \'stars\',\r\n				per_page: 10\r\n			},\r\n			succ: function (data) {\r\n				console.log(data);\r\n			}\r\n		});\r\n	</script>','2017-11-07 06:43:54','2017-11-07 06:43:54','packaging-functions-call-ajax-requests'),(461,3,3,'Ajax 技术简介','Ajax 即异步 JavaScript + XML，它本身并不是一项技术，它是由 Jesse James Garrett 在 2005 年创造的术语，它描述了一种将大量现有技术结合在一起的“新”方法。包括 HTML 或 XHTML，层叠样式表，JavaScript，文档对象模型，XML，XSLT，**最重要的是 XMLHttpRequest 对象**。当这些技术结合在 Ajax 模型中，web 应用程序都能够做出快速、增量式更新浏览器的用户界面，而**不用重新加载整个页面**。这使得应用程序更快和更响应用户操作。\r\n\r\n**尽管 Ajax 中的 X 代表 XML**，但由于 JSON 的轻量化和作为 JavaScript 的一部分等诸多优点，**JSON 现在使用的频率比 XML 要多**。 JSON 和 XML 都用于在 Ajax 模型中打包信息。\r\n\r\n1. 起步\r\n\r\n本文将指导您完成 Ajax 基础，并从给你两个简单实际的例子开始。','2017-11-08 00:46:17','2017-11-08 00:46:17','ajax-technology-introduction'),(462,3,3,'Ajax 技术简介：起步','### 什么是 Ajax?\r\n\r\nAjax 表示 **A**synchronous **J**avaScript **A**nd **X**ML，即异步的 JavaScript 和 XML。简而言之，就是使用 [`XMLHttpRequest`][1] 对象与服务器进行通信。它可以发送和接收各种格式的信息，包括 JSON，XML，HTML 和文本文件。AJAX 最吸引人的特点是它的“异步”性质，这意味着它 **可以与服务器进行通信、交换数据、更新页面而不必刷新整个页面**。\r\n\r\nAJAX 的两个主要功能如下：\r\n\r\n1. 在不重新加载页面的情况下向服务器发出请求。\r\n2. 接收和处理来自服务器的数据。\r\n\r\n### 步骤 1：怎样发出一个 Http 请求\r\n \r\n为了使用 JavaScript 向服务器发出 HTTP 请求，您需要一个具有必要功能的对象实例。 这就是 `XMLHttpRequest` 的来源。它的前身是一个名为 `XMLHTTP` 的 ActiveX 对象，它起源于 Internet Explorer。 然后，Mozilla，Safari 和其他浏览器跟随、实现了支持 Microsoft 原始 ActiveX 对象的方法和属性的 `XMLHttpRequest` 对象。 同时，微软也实现了 `XMLHttpRequest` 对象。\r\n	\r\n	if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ...\r\n		xhr = new XMLHttpRequest();\r\n	} else if (window.ActiveXObject) {\r\n		xhr = new ActiveXObject(\'Microsoft.XMLHTTP\');\r\n	}\r\n\r\n*注意：为了说明的目的，以上是用于创建 `XMLHttp` 实例的代码的某种简化版本。 有关更现实的示例，请参阅本文的步骤 3。*\r\n\r\n发出请求后，您将收到回复。在这个阶段，你需要告诉 `XMLHttp` 请求对象哪个 JavaScript 函数将用于处理响应，这可以通过设置对象的 `onreadystatechange` 属性实现，这个属性会请求对象状态改变时调用其后的函数，如下所示：\r\n\r\n	xhr.onreadystatechange = nameOfTheFunction;\r\n	\r\n请注意，函数名称后面没有括号或参数，因为您正在使用一个函数引用，而不是实际调用它。 或者，您可以使用匿名函数来处理响应，而不是提供函数名称，如下所示：\r\n\r\n	xhr.onreadystatechange = function () {\r\n		// 在这里处理服务器响应\r\n	};\r\n\r\n接下来，在声明接收到响应后的处理函数后，您需要通过调用 HTTP 请求对象的 `open()` 和 `send()`方法来实际发出请求，如下所示：\r\n\r\n	xhr.open(\'GET\', \'http://www.example.org/some.file\', true);\r\n	xhr.send();\r\n\r\n- `open()` 方法的第一个参数是 HTTP 请求方法 - GET、POST、HEAD 或服务器支持的其他方法。**按照 HTTP 标准保持方法全部大写，否则某些浏览器（如 Firefox）可能无法处理请求**。有关可能的 HTTP 请求方法的更多信息，请查看 [W3C规范][2]。\r\n\r\n- 第二个参数是您要发送请求的 URL。 为了安全，默认情况下，您无法调用第三方域网址。所以，请务必在所有页面上使用确切的域名，否则当您调用 `open()` 时将会出现“permission denied”（权限被拒绝）的错误。 一个常见的错误是在 `domain.tld` 这个域名下的网页中，试图调用 www.domain.tld 页面的内容。如果您确实需要将请求发送到其他域，请参阅 [HTTP 访问控制][3]。\r\n\r\n- 可选的第三个参数设置 **请求是否是异步的**。 如果为 `true`（默认值），则当前 JavaScript 对象请求不会阻塞后续代码的执行，后续代码会继续执行，这样用户可以在服务器响应尚未到达时与页面继续做交互。**这就是 AJAX 中的第一个 A 的意思**。\r\n\r\n`send()` 方法的参数可以是要发送到服务器的任何数据（这针对的是 POST 请求）。表单数据应该以服务器可以解析的格式发送，如查询字符串：\r\n\r\n	\"name=value&anothername=\"+encodeURIComponent(myVar)+\"&so=on\"\r\n\r\n或其他格式，如 `multipart/form-data`、JSON 和 XML 等等。\r\n\r\n请注意，如果您 **想要 POST 数据，则必须设置请求的 MIME 类型**。 例如，在使用查询字符串调用 `send()` 方法发送表单数据之前，请设置如下内容：\r\n\r\n	xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\');\r\n\r\n### 步骤 2：处理服务器响应\r\n\r\n发送请求时，您提供了 JavaScript 函数的名称来处理响应：\r\n\r\n	xhr.onreadystatechange = nameOfTheFunction;\r\n\r\n这个函数应该做什么？ 首先，该功能需要检查请求的状态。 如果状态的值为 `XMLHttpRequest.DONE`（对应到数值 4），则表示已收到完整的服务器响应，您可以继续处理它。\r\n\r\n	if (xhr.readyState === XMLHttpRequest.DONE) {\r\n		// 已收到完整的服务器响应\r\n	} else {\r\n		// 还没接收到完整服务器响应\r\n	}\r\n\r\n`readyState` 值的完整列表记录在 [XMLHTTPRequest.readyState[4] 中，如下所示：\r\n\r\n| 值 | 状态 | 描述 |\r\n| -------- | -------- | -------- |\r\n| `0`     | `UNSET`     | 客户端（`XMLHttpRequest` 对象）已创建，但还没有调用 `open()` 方法     |\r\n| `1`     | `OPENED`     | 已经调用了 `open()` 方法     |\r\n| `2`     | `HEADERS_RECEIVED`     | 调用了 `send()` 方法，可以得到头部和状态信息了     |\r\n| `3`     | `LOADING`     | 下载中，`responseText` 中已经接收到了部分数据     |\r\n| `4`     | `DONE`     | 请求完成     |\r\n\r\n接下来，检查HTTP响应的响应代码。 所有可能的响应吗 [在 W3C 列出][5]。在以下示例中，我们通过检查 `200 OK` 响应代码来区分成功和失败的 AJAX 调用。\r\n\r\n	if (xhr.status === 200) {\r\n		// 200 响应码，请求得到得到正确数据\r\n	} else {\r\n		// 请求出现了问题\r\n		// 例如，如果请求码返回 404（Not Found）或者 500（Internal Server Error）\r\n	}\r\n\r\n在检查请求状态和 HTTP 响应代码之后，可以对服务器发送的数据做任何你想做的事情。你有 **两种选择来访问服务器发送过来的数据**：\r\n\r\n- `xhr.responseText` - 以一串文本形式返回服务器响应。\r\n- `xhr.responseXML` - 以 JavaScriptDOM 函数可以遍历的 `XMLDocument` 对象的形式返回响应。\r\n\r\n请注意，仅当您使用异步请求（`open()` 的第三个参数未指定或设置为 `true`）时，上述步骤才有效。 如果你使用了一个同步请求，你不需要指定一个函数（译者：这里指在 `send()` 后面直接使用 `xhr.responseText` / `xhr.responseXML`），但是这是非常不鼓励的，因为它会导致一个糟糕的用户体验。\r\n\r\n### 步骤 3：一个简单的例子\r\n\r\n我们制作一个简单的 HTTP 请求把上面所有的东西放在一起。 我们的 JavaScript 将请求一个 HTML 文档 `test.html`，其中包含文本“我是一个测试”。 然后我们使用 `alert()` 方法弹出响应内容。 请注意，这个例子使用了原生 JavaScript - 不涉及 jQuery。 另外，HTML、XML 和 PHP 文件应该放在同一个目录下。\r\n\r\n	<button id=\"ajaxButton\" type=\"button\">Make a request</button>\r\n\r\n	<script type=\"text/javascript\">\r\n		(function () {\r\n			var xhr;\r\n			document.getElementById(\'ajaxButton\').addEventListener(\'click\', makeRequest);\r\n\r\n			function makeRequest() {\r\n				xhr = new XMLHttpRequest();\r\n\r\n				if (!xhr) {\r\n					alert(\'Giving up :( Cannot create an XMLHTTP instance\');\r\n					return false;\r\n				}\r\n\r\n				xhr.onreadystatechange = alertContents;\r\n				xhr.open(\'GET\', \'test.html\');\r\n				xhr.send();\r\n			}\r\n\r\n			function alertContents() {\r\n				if (xhr.readyState === XMLHttpRequest.DONE) {\r\n					if (xhr.status === 200) {\r\n						alert(xhr.responseText);\r\n					} else {\r\n						alert(\'There was a problem with the request.\');\r\n					}\r\n				}\r\n			}\r\n		})();\r\n	</script>\r\n\r\n在这个例子里：\r\n\r\n- 用户点击「Make a request」按钮。\r\n- 事件处理器调用 `makeRequest` 函数。\r\n- 发出请求，并将请求结果（通过 `onreadystatechange` 属性监听）传递给 `alertContents` 函数处理。\r\n- `alertContents` 函数检查响应是否接受 OK 了，是的话就会使用 `alert()` 方法弹出 `test.html` 文件里的内容。\r\n\r\n*注1：如果您要发送请求到一段将返回 XML 的代码，而不是一个静态的 XML 文件，那么您必须设置响应头才能在 Internet Explorer 中工作。 如果您没有设置 `Content-Type: application/xml `头，IE 会在您尝试访问 XML 元素的行后面引发 JavaScript“Object Expected”错误。*\r\n\r\n*注2：如果你没有设置 `Cache-Control: no-cache` 头部信息：浏览器将缓存响应，永不重新提交请求，使调试不方便。这时您还可以添加一个总是不同的 GET 参数，如时间戳或随机数（请 [参阅绕过缓存][6]）。*\r\n\r\n*注3：如果全局使用 `xhr` 变量，则调用 `makeRequest()` 的竞争函数可能会相互覆盖，从而导致争用条件。 将 `xhr` 变量局部声明在包含 AJAX 函数的闭包中可以避免这种问题发生。*\r\n\r\n**如果发生通信错误（如服务器关闭），则在访问响应状态时，将在 `onreadystatechange` 方法上引发异常**。为了缓解这个问题，你可以把你的 `if ... else` 语句包装在 `try ... catch` 中：\r\n\r\n	function alertContents() {\r\n	  try {\r\n		if (httpRequest.readyState === XMLHttpRequest.DONE) {\r\n		  if (httpRequest.status === 200) {\r\n			alert(httpRequest.responseText);\r\n		  } else {\r\n			alert(\'There was a problem with the request.\');\r\n		  }\r\n		}\r\n	  }\r\n	  catch( e ) {\r\n		alert(\'Caught Exception: \' + e.description);\r\n	  }\r\n	}\r\n\r\n### 步骤 4：处理 XML 响应\r\n\r\n在前面的例子中，在接收到对 HTTP 请求的响应之后，我们使用请求对象的 `responseText` 属性，它包含了`test.html` 文件的内容。 现在我们来试试 `responseXML` 属性。\r\n\r\n首先，让我们创建一个有效的 XML 文档，稍后我们会请求它。文档（`test.xml`）包含如下内容：\r\n\r\n	<?xml version=\"1.0\" ?>\r\n	<root>\r\n		I\'m a test.\r\n	</root>\r\n\r\n在脚本中，我们只需要将请求行更改为：\r\n\r\n	...\r\n	onclick=\"makeRequest(\'test.xml\')\">\r\n	...\r\n\r\n然后在 `alertContents()` 中，将 `alert(httpRequest.responseText)` 替换为：\r\n\r\n	var xmldoc = httpRequest.responseXML;\r\n	var root_node = xmldoc.getElementsByTagName(\'root\').item(0);\r\n	alert(root_node.firstChild.data);\r\n\r\n此代码采用 `responseXML` 提供的 `XMLDocument` 对象，并使用 DOM 方法访问 XML 文档中包含的一些数据。\r\n\r\n### 步骤 5：处理数据\r\n\r\n最后，让我们发送一些数据到服务器，并接受响应。 这次我们的 JavaScript 会请求一个动态的页面 `test.php`，它将接收我们发送的数据并返回一个计算后的字符串 -“Hello，[user data]！” - 我们会给它弹出来。\r\n\r\n首先，我们将在我们的 HTML 中添加一个文本框，以便用户输入他们的名字：\r\n\r\n	<label>Your name: \r\n	  <input type=\"text\" id=\"ajaxTextbox\" />\r\n	</label>\r\n	<span id=\"ajaxButton\" style=\"cursor: pointer; text-decoration: underline\">\r\n	  Make a request\r\n	</span>\r\n\r\n我们需要修改 `makeRequest()` 方法来接受用户数据并将其传递给服务器。 我们将请求方法从 GET 更改为POST，并在调用 `httpRequest.send()` 时将我们的数据作为参数包含在内：\r\n\r\n	function makeRequest(url, userName) {\r\n		xhr = new XMLHttpRequest();\r\n\r\n		if (!xhr) {\r\n			alert(\'Giving up :( Cannot create an XMLHTTP instance\');\r\n  			return false;\r\n		}\r\n\r\n		xhr.onreadystatechange = alertContents;\r\n		xhr.open(\'POST\', url);\r\n		xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\');\r\n		xhr.send(\'userName=\' + encodeURIComponent(userName));\r\n	}\r\n\r\n函数 `alertContents()` 可以用与步骤 3 中相同的方式编写，以提醒计算出的字符串，如果这是所有的服务器返回。 但是，假设服务器将返回计算的字符串和原始用户数据。 所以如果我们的用户在文本框中键入“Jane”，那么服务器的响应如下所示：\r\n\r\n	{\"userData\":\"Jane\",\"computedString\":\"Hi, Jane!\"}\r\n\r\n为了使用上面的数据，我们不能简单在 \r\n\r\n要在 `alertContents()` 中使用上面的数据，我们不能简单弹出 `responseText` 的内容 ，我们必须先解析它，并提弹出属性 `computeString` 的值：\r\n\r\n	function alertContents() {\r\n	  if (httpRequest.readyState === XMLHttpRequest.DONE) {\r\n		if (httpRequest.status === 200) {\r\n		  var response = JSON.parse(httpRequest.responseText);\r\n		  alert(response.computedString);\r\n		} else {\r\n		  alert(\'There was a problem with the request.\');\r\n		}\r\n	  }\r\n	}\r\n\r\n`test.php` 文件的内容如下：\r\n\r\n	<?php \r\n		$name = (isset($_POST[\'userName\'])) ? $_POST[\'userName\'] : \'no name\';\r\n		$computedString = \"Hi, \" . $name;\r\n		$array = [\'userName\' => $name, \'computedString\' => $computedString];\r\n		echo json_encode($array);\r\n	?>\r\n\r\n有关 DOM 方法的更多信息，请务必查看 [Mozilla 的 DOM 实现文档][7]。\r\n\r\n[1]: https://developer.mozilla.org/en/DOM/XMLHttpRequest\r\n[2]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\r\n[3]: https://developer.mozilla.org/En/HTTP_access_control\r\n[4]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#Properties\r\n[5]: https://developer.mozilla.org/en/HTTP#HTTP_Response_Codes\r\n[6]: https://developer.mozilla.org/en/DOM/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\r\n[7]: http://www.mozilla.org/docs/dom/','2017-11-08 01:24:29','2017-11-08 02:53:53','ajax-technology-introduction-start'),(463,3,3,'Ajax 技术简介：使用 XMLHttpRequest（待续）','> 原文链接：https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\r\n\r\n要发送HTTP请求，请创建一个 `XMLHttpRequest` 对象，打开一个 URL 并发送请求。 事务完成后，对象将包含有用的信息，如响应正文和结果的 HTTP 状态。 本页概述了 `XMLHttpRequest` 对象的一些常见甚至稍微模糊的用例。\r\n\r\n	function reqListener () {\r\n	  console.log(this.responseText);\r\n	}\r\n\r\n	var xhr = new XMLHttpRequest();\r\n	xhr.addEventListener(\"load\", reqListener);\r\n	xhr.open(\"GET\", \"http://www.example.org/example.txt\");\r\n	xhr.send();\r\n\r\n## 请求类型\r\n\r\n通过 XMLHttpRequest 发出的请求可以以两种方式之一（异步或同步）来获取数据。 请求的类型由 `XMLHttpRequest.open()` 方法上设置的可选的第三个参数指定。 如果此参数为 `true` 或未指定，则 `XMLHttpRequest` 将异步处理，否则将同步处理请求过程。这两种不同类型请求的详细讨论和演示可以在 [同步和异步请求][1] 页面上找到。一般来说，你应该很少使用同步请求。\r\n\r\n*注：从 Gecko 30.0（Firefox 30.0 / Thunderbird 30.0 / SeaMonkey 2.27）开始，由于对用户体验的负面影响，主线程上的同步请求已被弃用。*\r\n\r\n## 处理响应\r\n\r\nLive 标准规范对 XMLHttpRequest 构造函数定义了几种类型的 [响应属性][2]。这些告诉了客户在 XMLHttpRequest 对象上有关响应状态的重要信息。在下面的章节中概述了处理非文本响应类型的一些情况可能涉及一些操作和分析。\r\n\r\n### 分析和操作 `responseXML` 属性\r\n\r\n（从略）\r\n\r\n### 分析和操作 `responseText` 属性（包含 HTML 文档）\r\n\r\n（从略）\r\n\r\n## 处理二进制数据\r\n\r\n（从略）\r\n\r\n## 监听进度\r\n\r\n`XMLHttpRequest` 提供了监听处理请求时可能发生的各种事件的能力。这包括定期进度通知、错误通知等等。\r\n\r\n支持 `XMLHttpRequest` 传输的 DOM 进度事件监视遵循 [进度事件规范][3]：这些事件实现了 `ProgressEvent` 接口。\r\n\r\n	var xhr = new XMLHttpRequest();\r\n\r\n	xhr.addEventListener(\"progress\", updateProgress);\r\n	xhr.addEventListener(\"load\", transferComplete);\r\n	xhr.addEventListener(\"error\", transferFailed);\r\n	xhr.addEventListener(\"abort\", transferCanceled);\r\n\r\n	xhr.open();\r\n	\r\n	// ...\r\n	\r\n	// 从服务器到客户端的传输进度（下载）\r\n	function updateProgress(event) {\r\n		if (event.lengthComputable) {\r\n			var percentComplete = event.loaded / event.total;\r\n			\r\n			// ...\r\n		} else {\r\n			// 由于总大小未知，无法计算进度信息\r\n		}\r\n	}\r\n	\r\n	funtion transferComplete(event) {\r\n		console.log(\'传输完成。\');\r\n	}\r\n	\r\n	function transferFailed() {\r\n		console.log(\'传输文件时发生错误。\');\r\n	}\r\n	\r\n	function transferCanceled(event) {\r\n		console.log(\'用户取消了传输。\')\r\n	}\r\n	\r\n第 3-6 行为使用 `XMLHttpRequest` 执行数据传输时发生的各种事件添加事件侦听器。\r\n\r\n*注意：必须在调用 `open()` 方法之前，添加请求的事件侦听器。否则进度事件不会触发。*\r\n\r\n由本例中的 `updateProgress` 函数指定的进度事件处理程序，会接收要传输的总字节数以及到目前为止传输了多少字节数，这分别可以通过事件对象的 `total` 和 `loaded` 属性获得。但是，如果 `lengthComputable` 字段为false，则总长度是未知的，将为零。\r\n\r\n下载和上传传输都存在进度事件。下载事件在 `XMLHttpRequest` 对象上触发，如上例所示。 上传事件则在 `XMLHttpRequest.upload` 对象上触发，如下所示：\r\n\r\n	var xhr = new XMLHttpRequest();\r\n\r\n	xhr.upload.addEventListener(\"progress\", updateProgress);\r\n	xhr.upload.addEventListener(\"load\", transferComplete);\r\n	xhr.upload.addEventListener(\"error\", transferFailed);\r\n	xhr.upload.addEventListener(\"abort\", transferCanceled);\r\n\r\n	xhr.open();\r\n\r\n*注意：进度事件不可用于 `file:` （本地文件）协议。*\r\n\r\n*注意：从 Gecko 9.0 开始，现在可以依赖进度事件来处理接收到的每一个数据块，包括最后一个数据包被接收的情况下的最后一个数据块，并且在进度事件触发之前连接关闭。 在这种情况下，进程事件会在发生该数据包的加载事件时自动触发。 这使您现在可以通过只监视“进度”事件来可靠地监视进度。*\r\n\r\n*注意：从 Gecko 12.0 开始，如果你调用的进度事件的 `responseType ` 为“moz-blob”，那么响应的值是一个 [`Blob`][4]，包含到目前为止收到的数据。*\r\n\r\n也可以使用 `loadend` 事件检测所有三种 load-ending 条件（`abort`、`load` 和 `error`）：\r\n\r\n	xhr.addEventListener(\"loadend\", loadEnd);\r\n\r\n	function loadEnd(e) {\r\n	  console.log(\"传输已经结束了（虽然我们不知道是否成功了）。\");\r\n	}\r\n\r\n请注意，根据加载事件所收到的信息，无法确定导致操作终止的条件。但是，您 **可以使用它来处理需要在所有传输结束后中执行的任务**。\r\n\r\n## 提交表单和上传文件\r\n\r\n`XMLHttpRequest` 实例可以用两种方式提交表单：\r\n\r\n1. 只用 AJAX。\r\n2. 使用 [`FormData`][5] API。\r\n\r\n使用 `FormDat`a API是最简单和最快的，但是它的缺点是收集的数据不能字符串化。仅使用 AJAX 更复杂，但通常更灵活，更强大。\r\n\r\n### 只用 `XMLHttpRequest`\r\n\r\n在不使用 `FormData` API 的情况下提交表单不需要其他 API，这适用于大多数情况下。唯一需要额外 API 的情况是，如果您想要上传一个或多个文件，请使用 [FileReader][6] API。\r\n\r\n### 提交方法简介\r\n\r\n`<form>` 可以以 4 种方式发送：\r\n\r\n1. 使用 `POST` 方法，将 `enctype` 特性设置为 `application/x-www-form-urlencoded`（默认）；\r\n2. 使用 `POST` 方法，将 `enctype` 特性设置为 `text/plain`；\r\n3. 使用 `POST` 方法，将 `enctype` 特性设置为 `multipart/form-data`；\r\n4. 使用 `GET` 方法（这时会忽略 `enctype` 特性）。\r\n\r\n现在，考虑提交一个只包含两个字段的表单，名为 `foo` 和 `baz`。 如果使用 `POST` 方法，则服务器将接收到类似于下面 3 个例子之一的字符串，具体取决于所使用的编码类型：\r\n\r\n- 方法：`POST`；编码类型：`application/x-www-form-urlencoded`（默认）\r\n\r\n		Content-Type: application/x-www-form-urlencoded\r\n\r\n		foo=bar&baz=The+first+line.%0D%0AThe+second+line.%0D%0A\r\n\r\n- 方法：`POST`；编码类型：`text/plain`\r\n\r\n		Content-Type: text/plain\r\n\r\n		foo=bar\r\n		baz=The first line.\r\n		The second line.\r\n\r\n- 方法：`POST`；编码类型：`multipart/form-data`\r\n\r\n		Content-Type: multipart/form-data; boundary=---------------------------314911788813839\r\n\r\n		-----------------------------314911788813839\r\n		Content-Disposition: form-data; name=\"foo\"\r\n\r\n		bar\r\n		-----------------------------314911788813839\r\n		Content-Disposition: form-data; name=\"baz\"\r\n\r\n		The first line.\r\n		The second line.\r\n\r\n		-----------------------------314911788813839--\r\n\r\n但是，如果您使用的是 GET 方法，则会将以下字符串简单地添加到 URL 中：\r\n\r\n	?foo=bar&baz=The%20first%20line.%0AThe%20second%20line.\r\n\r\n### 一个小的原生框架\r\n\r\n所有这些效果都是在您提交 `<form>` 时由网络浏览器自动完成的。 如果你想使用 JavaScript 执行相同的效果，你必须指导解释器的一切。因此，如何在纯 AJAX 中发送表单太复杂了，这里不能详细解释。出于这个原因，在这里我们放置一个完整的（也是教学）框架，能够使用所有四种方式提交，并上传文件：\r\n\r\n（从略）\r\n\r\n[1]: https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Synchronous_and_Asynchronous_Requests\r\n[2]: https://xhr.spec.whatwg.org/\r\n[3]: https://xhr.spec.whatwg.org/#interface-progressevent\r\n[4]: https://developer.mozilla.org/en-US/docs/Web/API/Blob\r\n[5]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/FormData\r\n[6]: https://developer.mozilla.org/en-US/docs/Web/API/FileReader','2017-11-08 03:07:33','2017-11-08 05:04:23','introduction-of-ajax-technology-using-xmlhttprequest'),(464,3,3,'《JavaScript 高级程序设计》第21章：Ajax 和 Comet（待续）','Ajax 技术的核心是 XMLHttpRequest 对象（简称 XHR），这是由微软最先引入的一个特性，其它浏览器厂商后来都提供了相同的实现。\r\n\r\n## XMLHttpRequest 对象\r\n\r\nIE7+ 、FireFox、Opera、Chrome 和 Safari 浏览器都原生支持 XHR 对象，所以我们可以只用原生 XHR 对象即可使用 Ajax 了。\r\n\r\n	function createXHR() {\r\n		return new XMLHttpReuqest();\r\n	}\r\n\r\n### XHR 的用法\r\n\r\n使用 XHR 对象，要调用的第一个方法是 `open()`，接收三个参数：请求类型（“GET”、“POST”等，为了向规范靠近最好都用大写形式）、请求的 URL 和是否异步发送（可选，一个布尔值。取值 `true`（默认）或 `false`）。\r\n\r\n	xhr.open(\'GET\', \'example.php\');\r\n\r\n`open()` 方法不会真正发送请求，而是启动一个以请求以备发送。发送请求，使用 `send()` 方法：\r\n\r\n	xhr.open(\'get\', \'example.txt\');\r\n	xhr.send(null);\r\n\r\n`send()` 方法接收一个参数，表示请求发送主体。如果不需要（比如 GET 请求），为了兼容最好填入 `null`。\r\n\r\n我们发送异步请求的时候，会经历几个阶段，可以通过 XHR 对象的 `readyState` 属性监测到，而每一次 `readyState` 属性值的改变都会触发一次 `readystatechange` 事件。我们只对 `readyState` 值为 4 的阶段感兴趣，这时候所有数据都已经就绪了。\r\n\r\n	var xhr = new XMLHttpRequest();\r\n	\r\n	xhr.onreadystatechange = function () {\r\n		if (xhr.readyState === 4) {\r\n			if ((xhr.status >= 200 && xhr.status) < 300 || xhr.status === 304) {\r\n				alert(xhr.responseText);\r\n			} else {\r\n				alert(\'请求未成功：\' + xhr.status);\r\n			}\r\n		}\r\n	};\r\n	\r\n	xhr.open(\'GET\', \'example.txt\');\r\n	xhr.send(null);\r\n\r\n### 头部信息\r\n\r\n我们可以使用 XHR 对象的 `setRequestHeader()` 方法设置给服务器发送的请求头部信息。这个方法接收两个参数----头部字段名和头部字段值，而且 `setRequestHeader()` 方法必须在 `open()` 方法之后、`send()` 方法之前调用。\r\n\r\n	...\r\n\r\n	xhr.open(\'GET\', \'example.txt\');\r\n	xhr.setRequestHeader(\'MyHeader\', \'MyValue\');\r\n	xhr.send(null);\r\n\r\n### GET 请求\r\n\r\nGET 是常见的请求类型，如果请求包含查询字符串，对于 XHR 而言，要把查询字符串传入 `open()` 方法的 URL 末尾的地方，而且查询字符串必须要经过正确编码才行。\r\n\r\n	xhr.open(\'GET\', \'example.php?username=\' + encodeURIComponent(value));\r\n\r\n### POST 请求\r\n\r\n与 GET 请求方式不同的是，POST 请求时提供的数据必须在请求的主体里进行提交。\r\n\r\n其次，服务器对 XHR POST 请求和表单 POST 请求并不会一视同仁。我们可以使用 XHR 模仿表单提交：将 `Content-Type` 头部字段值设置为 `application/x-www-form-urlencoded`，也就是表单提交时的内容类型。\r\n\r\n	xhr.open(\'GET\', \'example.txt\');\r\n	xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\');\r\n	xhr.send(username=\' + encodeURIComponent(value));\r\n\r\n## XMLHttpRequest 2 级','2017-11-08 06:18:39','2017-11-08 06:35:01','chapter-21-senior-javascript-programming-ajax-and-comet'),(466,3,3,'使用 jQuery 实现懒加载图片功能','原理：当滚动鼠标时，如果当前图片在可视区范围内，则加载。\r\n\r\n## 代码实现\r\n\r\nHTML\r\n\r\n	<img class=\"lazy\" data-src=\"images/p2.jpg\">\r\n\r\n	<img class=\"lazy\" data-src=\"images/p3.jpg\">\r\n\r\n	<img class=\"lazy\" data-src=\"images/p4.jpg\">\r\n\r\n	<img class=\"lazy\" data-src=\"images/p5.jpg\">\r\n\r\nJavaScript\r\n\r\n	<script type=\"text/javascript\" src=\"js/jquery-3.2.1.min.js\"></script>\r\n	<script type=\"text/javascript\">\r\n		$(function () {\r\n			var $images = $(\'.lazy\');\r\n\r\n			lazyImageHandler();\r\n\r\n			$(document).on(\'scroll\', function () {\r\n				lazyImageHandler();\r\n			});\r\n\r\n			function lazyImageHandler() {\r\n				var scrollTop = $(document).scrollTop();\r\n				var viewHeight = $(window).height();\r\n				\r\n				$images.each(function (index, image) {\r\n					if ($(image).offset().top < (viewHeight + scrollTop)) {\r\n						console.log($(image).offset().top);\r\n						$(image).attr(\'src\', $(image).attr(\'data-src\'));\r\n					}\r\n				});\r\n			}\r\n		});\r\n	</script>\r\n	\r\n实现的步骤如下：\r\n\r\n1. 先获得所有的懒加载图片。\r\n2. 滚动滚轮时，设置监听事件。\r\n3. 如果当前图片出现在视口中（即图片相对于视口的向上偏移量小于视口高度和滚动条滚动的距离），则将 `data-src` 特性的值作为 `src` 特性的值，用来加载图片。','2017-11-09 04:15:29','2017-11-09 04:15:29','using-jquery-function-to-implement-lazy-loading-pictures'),(467,3,3,'相对定位元素不会创建一个 BFC','今天看到了 [一篇文章](http://layout.imweb.io/article/formatting-context.html)。里面讲到了块级格式化上下文（block formating context，简称 BFC）。\r\n\r\n我注意到，**相对定位元素不会创建一个 BFC**。下面是可以创建一个新 BFC 的元素。\r\n\r\n- 浮动元素 (元素的 `float` 不是 `none`)\r\n- 绝对定位元素 (元素具有 `position` 为 `absolute` 或 `fixed`)\r\n- 内联块 (元素具有 `display: inline-block`)\r\n- 表格单元格 (元素具有 `display: table-cell`，HTML表格单元格默认属性)\r\n- 表格标题 (元素具有 `display: table-caption`, HTML表格标题默认属性)\r\n- 具有 `overflow` 且值不是 `visible` 的块元素，\r\n- `display: flow-root`\r\n- `column-span: all` 应当总是会创建一个新的格式化上下文，即便具有 `column-span: all` 的元素并不被包裹在一个多列容器中。\r\n- `flex item` 和 `grid item`。\r\n\r\n而 BFC 规定的是其块级子元素的排列方式如下：\r\n\r\n- 块级盒会在垂直方向，一个接一个地放置，每个盒子水平占满整个容器空间；\r\n- 块级盒的垂直方向距离由上下 `margin` 决定，同属于一个 BFC 中的两个或以上块级盒的相接的 `margin` 会发生重叠；\r\n- **BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素**。反之也如此；\r\n- **计算 BFC 的高度时，浮动元素也参与计算**。\r\n\r\n由「相对定位元素不会创建一个 BFC」和「计算 BFC 的高度时，浮动元素也参与计算」我想到，**在一个相对元素里面设置浮动元素时，父级元素（即这个相对元素）的高度会塌陷的**。\r\n\r\n而且又想到，**为一个行内元素设置 `position: relative`  之后，对其设置宽高也是无效的**（详情见 [这里](http://baooab.com/forum/discussion/by-doing-a-job-understand-the-floating-and-relative-positioning)）。','2017-11-09 04:33:30','2017-11-10 04:53:12','relative-positioning-element-does-not-create-a-landing'),(468,3,3,'Flexbox 布局教程图解','https://codepen.io/zhangbao/full/OOXjOv/','2017-11-09 09:36:08','2017-11-10 02:28:32','flexbox-layout-diagram-of-the-tutorial'),(469,3,3,'JS脚本：检测浏览器是否支持 Webp 格式图片','检测浏览器是否支持 Webp 格式图片原理是这样的：使用 JS 的 `Image` 函数加载一张 base64 的 webp 格式图片，待加载完成后，检测图片宽高是否和图片格式一致----如果一致，则支持；不一致（宽高都为 `0`）则不支持。\r\n\r\n下面的例子中使用了一张 2x2 的图片作为检测依据（源码地址看 [这里](https://codepen.io/zhangbao/pen/jarLjj)）：\r\n\r\n	(function (w) {\r\n\r\n		if (w.Webp) { return ; }\r\n\r\n		w.Webp = {};\r\n\r\n		w.Webp.isSupport = function () {\r\n			var e = false;\r\n			if (window.chrome || window.opera && window.localStorage && window.localStorage.getItem(\"webpsupport\") !== null) {\r\n				e = (window.localStorage.getItem(\'webpsupport\') === \'true\');\r\n			}\r\n			return e;\r\n		};\r\n\r\n		var n = new Image();\r\n		n.src = \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\";\r\n		n.onload = n.onerror = function () {\r\n			var e = false;\r\n			if (window.chrome || window.opera && window.localStorage) {\r\n				e = true;\r\n			}\r\n			window.localStorage.setItem(\'webpsupport\', e);\r\n		}\r\n	})(window);\r\n\r\n\r\n执行完上面这个脚本后，就有一个全局对象属性 `Webp`，里面有一个 `isSupport` 方法属性，调用它就可知道当前浏览器是否支持 webp 格式图片了---- `true` 表示支持，`false` 表示不支持。\r\n\r\n	Webp.isSupport(); // true 或者 false.','2017-11-10 07:56:22','2017-11-10 07:57:32','to-test-whether-the-browser-support-webp-images'),(470,3,3,'jQuery 入门：关于 jQuery','开始使用 jQuery 可能很容易或具有挑战性，这取决于您对 JavaScript、HTML、CSS 和编程概念的使用经验。除了这些文章之外，您还可以阅读 [jQuery 的历史][1] 和 [许可条款][2]。 你也可以 [捐赠][3] 来帮助 [jQuery团队][4] 继续改进 jQuery。\r\n\r\n一个重要的事情要知道，jQuery 只是一个 __JavaScript库___ 。 jQuery 的所有功能都是通过 JavaScript 来访问的，所以掌握 JavaScript 是理解、构造和调试代码的关键。 定期使用 jQuery 可以随着时间的推移提高对 JavaScript 的熟练程度，如果不熟悉 JavaScript 的内置结构和语法，就很难开始编写 jQuery。 因此，如果您不熟悉 JavaScript ，建议您在 Mozilla 开发人员网络（MDN）上查看 [JavaScript 基础教程][5]。\r\n\r\n1. [jQuery 是怎么工作的？][6]\r\n2. [额外的 jQuery 支持][7]\r\n\r\n[1]: https://jquery.org/history/\r\n[2]: https://jquery.org/license/\r\n[3]: https://jquery.org/donate/\r\n[4]: https://jquery.org/team/\r\n[5]: https://developer.mozilla.org/en-US/Learn/Getting_started_with_the_web/JavaScript_basics\r\n[6]: http://www.baooab.com/forum/discussion/introduction-to-the-jquery-about-jquery-jquery-based\r\n[7]: http://www.baooab.com/forum/discussion/introduction-to-the-jquery-about-jquery-additional-jquery-support','2017-11-10 08:39:28','2017-11-10 09:40:21','introduction-to-the-jquery-about-jquery'),(471,3,3,'jQuery 入门：关于 jQuery - jQuery 基础','这是一个基本的教程，旨在帮助您开始使用 jQuery。 如果您还没有测试页面，请从创建以下 HTML 页面开始：\r\n\r\n```\r\n<!doctype html>\r\n<html>\r\n<head>\r\n	<meta charset=\"utf-8\">\r\n	<title>Demo</title>\r\n</head>\r\n<body>\r\n	<a href=\"http://jquery.com/\">jQuery</a>\r\n	<script src=\"jquery.js\"></script>\r\n	<script>\r\n\r\n	// Your code goes here.\r\n\r\n	</script>\r\n</body>\r\n</html>\r\n```\r\n\r\n`<script>` 元素中的 `src` 属性必须指向 jQuery 的副本。 从 [下载 jQuery][1] 页面下载 jQuery 的副本，并将 `jquery.js` 文件存储在与您的 HTML 文件相同的目录中。\r\n\r\n<div class=\"warning\">**注意**：当你下载 jQuery 时，文件名可能包含一个版本号，例如 `jquery-x.y.z.js`。 确保将该文件重命名为 `jquery.js` 或更新 `<srcipt>` 元素的 `src` 属性以匹配文件名。</div>\r\n\r\n### 文档就绪时启动代码\r\n\r\n为了确保在浏览器完成加载文档后运行代码，许多 JavaScript 程序员将其代码封装在一个 `onload` 函数中：\r\n\r\n```\r\nwindow.onload = function() {\r\n\r\n	alert( \"welcome\" );\r\n\r\n};\r\n```\r\n\r\n不幸的是，非得到所有的图像完成下载，包括横幅广告，否则代码不会运行。 为了在文档准备好被操作的时候运行代码，jQuery 有一个名为 [ready event][2] 的语句：\r\n\r\n```\r\n\r\n$( document ).ready(function() {\r\n\r\n	// Your code here.\r\n\r\n});\r\n```\r\n\r\n<div class=\"warning\">**注意**：jQuery 库通过 `window` 对象的 jQuery 和 `$` 两个属性公开了它的方法和属性。 `$` 仅仅是 `jQuery` 的别名。经常使用 `$`，因为它更短写得更快。</div>\r\n\r\n例如，在 `ready` 事件里面，你可以为链接添加一个点击处理程序：\r\n\r\n```\r\n$( document ).ready(function() {\r\n\r\n	$( \"a\" ).click(function( event ) {\r\n\r\n		alert( \"Thanks for visiting!\" );\r\n\r\n	});\r\n\r\n});\r\n```\r\n\r\n将上面的 jQuery 代码复制到你之前 HTML 文件中 `// Your code goes here` 的位置。 然后，保存您的 HTML 文件，并在浏览器中重新加载测试页面。 现在，点击链接应该首先显示一个警报弹出窗口，然后继续默认行为、导航到 `http://jquery.com` 这个地址。\r\n\r\n对于 `click` 和大多数其他 [事件][3]，你可以通过在事件处理程序中调用 `event.preventDefault()` 来防止默认行为：\r\n\r\n```\r\n$( document ).ready(function() {\r\n\r\n	$( \"a\" ).click(function( event ) {\r\n\r\n		alert( \"As you can see, the link no longer took you to jquery.com\" );\r\n\r\n		event.preventDefault();\r\n\r\n	});\r\n\r\n});\r\n```\r\n\r\n尝试用上面的代码替换您之前复制到 HTML 文件中的第一个 jQuery 代码片段。 再次保存 HTML 文件并重新加载以进行尝试。\r\n\r\n### 完整的例子\r\n\r\n下面的例子说明了上面讨论的点击处理代码，直接嵌入到 HTML 的 `<body>` 中。 请注意，在实践中，将代码放置在单独的 JS 文件中并使用 `<script>` 元素的 `src` 属性将其加载到页面上通常会更好。\r\n\r\n```\r\n<!doctype html>\r\n<html>\r\n<head>\r\n	<meta charset=\"utf-8\">\r\n	<title>Demo</title>\r\n</head>\r\n<body>\r\n	<a href=\"http://jquery.com/\">jQuery</a>\r\n	<script src=\"jquery.js\"></script>\r\n	<script>\r\n\r\n	$( document ).ready(function() {\r\n		$( \"a\" ).click(function( event ) {\r\n			alert( \"The link will no longer take you to jquery.com\" );\r\n			event.preventDefault();\r\n		});\r\n	});\r\n\r\n	</script>\r\n</body>\r\n</html>\r\n```\r\n\r\n### 添加和删除 HTML 类\r\n\r\n<div class=\"warning\">**重要：** 您必须将其余的 jQuery 示例放置在 `ready` 事件中，以便在文档准备就绪时执行代码。</div>\r\n\r\n另一个常见的任务是添加或删除一个类。\r\n\r\n首先，将一些样式信息添加到文档的 `<head>` 中，如下所示：\r\n\r\n```\r\n<style>\r\na.test {\r\n	font-weight: bold;\r\n}\r\n</style>\r\n```\r\n\r\n接下来，将 [.addClass()][4] 调用添加到脚本中：\r\n\r\n```\r\n$( \"a\" ).addClass( \"test\" );\r\n```\r\n\r\n所有的 `<a>` 元素现在都加粗了。\r\n\r\n要移除现有类，请使用 [.removeClass()][5]：\r\n\r\n```\r\n$( \"a\" ).removeClass( \"test\" );\r\n```\r\n\r\n### 特殊效果\r\n\r\njQuery 还提供了一些方便的 [效果][6] 来帮助您使您的网站脱颖而出。例如，如果您创建一个点击处理程序：\r\n\r\n```\r\n$( \"a\" ).click(function( event ) {\r\n\r\n	event.preventDefault();\r\n\r\n	$( this ).hide( \"slow\" );\r\n\r\n});\r\n```\r\n\r\n然后点击链接时，链接缓慢消失。\r\n\r\n## 回调和函数\r\n\r\n与许多其他编程语言不同，JavaScript 使您可以自由传递函数以便稍后执行。*callback* 是一个函数，作为参数传递给另一个函数，并在其父函数完成后执行。 回调是特殊的，因为他们耐心地等待，直到他们的父函数执行完毕后才执行。 同时，浏览器可以执行其他函数或做各种其他工作。\r\n\r\n要使用回调函数，知道如何将它们传递给父函数是很重要的。\r\n\r\n### 回调 *无* 参数\r\n\r\n如果一个回调没有参数，你可以像这样传入它：\r\n\r\n```\r\n$.get( \"myhtmlpage.html\", myCallBack );\r\n```\r\n\r\nWhen [$.get()](http://api.jquery.com/jQuery.get/) finishes getting the page `myhtmlpage.html`, it executes the `myCallBack()` function.\r\n\r\n当 [$.get()][7] 完成页面 `myhtmlpage.html` 的获取时，就会执行 `myCallBack()` 函数。\r\n\r\n**注意：** 这里的第二个参数只是函数的名称（*不* 是字符串，也没有括号）。\r\n\r\n### 回调 *有* 参数\r\n\r\n有参数的回调执行起来可能会很棘手。\r\n\r\n#### 错误的\r\n\r\n这个代码示例将 ***不会*** 工作：\r\n\r\n```\r\n$.get( \"myhtmlpage.html\", myCallBack( param1, param2 ) );\r\n```\r\n\r\n这个失败的原因是代码立即执行 `myCallBack(param1, param2)`，然后把 `myCallBack()` 的返回值作为第二个参数传递给了 `$.get()`。我们实际上想传递函数 `myCallBack()`，而不是 `myCallBack(param1, param2)` 的返回值（可能是函数，也可能不是函数）。 那么，如何传递 `myCallBack() ` *和* 它包含的参数呢？\r\n\r\n#### 正确的\r\n\r\n为了延迟执行带有参数的 `myCallBack()`，你可以使用一个匿名函数作为包装器。 注意使用 `function() {`。 匿名函数只为了完成一件事：使用 `param1` 和 `param2` 的值调用 `myCallBack()`。\r\n\r\n```\r\n$.get( \"myhtmlpage.html\", function() {\r\n\r\n	myCallBack( param1, param2 );\r\n\r\n});\r\n```\r\n\r\n当 `$ .get()` 完成页面 `myhtmlpage.html` 的获取后，才去执行匿名函数，再执行 `myCallBack(param1, param2)`。\r\n\r\n[1]: http://jquery.com/download/\r\n[2]: http://api.jquery.com/ready/\r\n[3]: http://api.jquery.com/category/events/\r\n[4]: http://api.jquery.com/addClass/\r\n[5]: http://api.jquery.com/removeClass/\r\n[6]: http://api.jquery.com/category/effects/\r\n[7]: http://api.jquery.com/jQuery.get/','2017-11-10 09:17:57','2017-11-10 09:17:57','introduction-to-the-jquery-about-jquery-jquery-based'),(472,3,3,'jQuery 入门：关于 jQuery - 额外的 jQuery 支持','虽然我们希望本网站涵盖上大多数与 jQuery 相关的主题，但您可能需要额外的或更多的即时支持。 以下资源可以证明是有用的。\r\n\r\n### 官方论坛\r\n\r\nhttp://forum.jquery.com/\r\n\r\n有许多子模块可以讨论 jQuery，提问题，讨论 JavaScript，或者发布你的插件。\r\n\r\n* [Getting Started](http://forum.jquery.com/getting-started)\r\n	* 如果你是 jQuery 和 JavaScript 的新手，这是最好的地方。\r\n* [Using jQuery](http://forum.jquery.com/using-jquery)\r\n	* 如果您有一般问题或疑虑，这是最好的地方。\r\n	* 如果你已经建立了一个使用 jQuery 的网站，或者想发布一个新的插件，这是做这件事的地方。\r\n* [Using jQuery Plugins](http://forum.jquery.com/using-jquery-plugins)\r\n	* 如果您是插件作者或用户，并且希望讨论特定插件，插件 Bug，新功能或新插件。\r\n* [Using jQuery UI](http://forum.jquery.com/using-jquery-ui)\r\n	* 这是讨论使用[jQuery UI](http://jqueryui.com/) 交互，小工具和效果的地方。\r\n* [jQuery Mobile](http://forum.jquery.com/jquery-mobile)\r\n	* 这里是讨论 jQuery Mobile 的地方。\r\n* [Developing jQuery Core](http://forum.jquery.com/developing-jquery-core)\r\n	* 这个子模块围绕着 jQuery 库本身的开发。\r\n	* 如果您对某些错误，使用 jQuery 进行开发，功能或 Bug 跟踪器或 Git 中的任何内容有疑问，请点击此处。\r\n* [Developing jQuery Plugins](http://forum.jquery.com/developing-jquery-plugins)\r\n	* 这个子模块涵盖了 jQuery 插件的开发。\r\n* [Developing jQuery UI](http://forum.jquery.com/developing-jquery-ui)\r\n	* 这是讨论 [jQuery UI](http://jqueryui.com/) 本身开发的地方 - 包括 Bug，新插件以及如何提供帮助。\r\n	* 所有的 jQuery UI svn 提交都被发布到这个列表中以方便反馈，讨论和评论。\r\n	* 另外请注意，jQuery UI 的开发和规划大部分发生在 [jQuery UI开发和规划维基][http://wiki.jqueryui.com/] 上。\r\n* [Developing jQuery Mobile](http://forum.jquery.com/developing-jquery-mobile)\r\n	* 本论坛涵盖了与 jQuery Mobile 开发相关的问题。\r\n* [QUnit and Testing](http://forum.jquery.com/qunit-and-testing)\r\n	* 这是讨论 JavaScript 测试的地方，特别是 QUnit。\r\n\r\n在每个论坛的底部是一个 RSS 订阅，你可以订阅。\r\n\r\n为确保您能及时得到有用的答案，请考虑以下建议：\r\n\r\n* 确保你的标记是有效的。\r\n* 使用 Firebug / Developer Tools 查看是否有异常。\r\n* 使用 Firebug / Developer Tools 来检查 HTML 类，CSS 等。\r\n* 尝试在没有 没有 JavaScript / jQuery 的情况下，预期产生的 HTML 和 CSS ，看看问题是不是出在 HTML 和 CSS 本身。\r\n* 减少到一个最小的测试案例（不断删除的东西，直到问题消失等）。\r\n* 提供该测试用例作为您的邮件的一部分。请将其上传到 [jsbin.com](http://jsbin.com/)。\r\n\r\n一般来说，保持简短和专注的问题，只提供必要的细节 - 其他可以在需要时添加。\r\n\r\n### 邮件列表档案\r\n\r\n邮件列表在论坛创建之前就已存在，并在 2010 年初关闭。\r\n\r\n浏览邮件列表档案有两种不同的方式。\r\n\r\n1. 官方邮件列表档案可以在这里找到：\r\n	* [jQuery 常规讨论存档](http://groups.google.com/group/jquery-en)\r\n		* [jQuery 开发列表存档](http://groups.google.com/group/jquery-dev)\r\n		* [jQuery UI 一般讨论存档](http://groups.google.com/group/jquery-ui)\r\n	* [jQuery UI 开发列表存档](http://groups.google.com/group/jquery-ui-dev)\r\n	* [jQuery 插件列表存档](http://groups.google.com/group/jquery-plugins)\r\n\r\n2. 此外，可以在[Nabble](http://jquery.10927.n7.nabble.com/jQuery-General-Discussion-f3.html) 上找到一个交互式的可浏览的通用讨论邮件列表版本（类似论坛邮件列表镜像）。\r\n\r\n### 聊天 / IRC 频道\r\n\r\njQuery 还有一个非常活跃的 IRC频道 `＃jquery`，由 [freenode](http://freenode.net/) 托管。\r\n\r\nIRC 频道是最好的，如果你需要快速帮助下面的任何一个：\r\n\r\n* JavaScript\r\n* jQuery语法\r\n* 解决问题\r\n* 奇怪的错误\r\n\r\n如果您的问题更深入，我们可能会要求您发送到邮件列表或错误跟踪器，以便我们可以在更合适的环境中为您提供帮助。\r\n\r\n#### 连接信息\r\n\r\n**服务器：** irc.freenode.net\r\n\r\n**房间：** `＃jquery`\r\n\r\n您也可以通过 http://webchat.freenode.net/?channels=#jquery 进行连接。\r\n\r\n如果您希望将代码片段发布到频道，则应使用粘贴网站，如 [jsfiddle.net](http://jsfiddle.net/) 或 [jsbin.com](http://jsbin.com/)。\r\n\r\n有关使用 jQuery IRC 的更多信息可以在 [irc.jquery.org](http://irc.jquery.org) 上找到。\r\n\r\n### StackOverflow\r\n\r\n在 [StackOverflow](http://stackoverflow.com/questions/tagged/jquery) 上有一个主动的，消息灵通的支持社区。 无论您遇到什么问题，您都可以找到答案。 如果你的问题没有解决，你可以问一个新的问题，并经常收到一个快速的回应。','2017-11-10 09:40:03','2017-11-10 09:40:03','introduction-to-the-jquery-about-jquery-additional-jquery-support'),(473,3,3,'jQuery 入门：jQuery 核心功能','1. [$ vs $()][1]\r\n\r\n[1]: #','2017-11-10 09:42:42','2017-11-10 09:42:53','introduction-to-the-jquery-use-the-jquery-core-function'),(474,3,3,'jQuery 入门：jQuery 核心功能  - $ vs $()','到目前为止，我们已经完全处理了在 jQuery 对象上调用的方法。 例如：\r\n\r\n```\r\n$( \"h1\" ).remove();\r\n```\r\n\r\n如上所示，大多数 jQuery 方法都是在 jQuery 对象上调用的；这些方法被认为是 `$ .fn` 命名空间或「jQuery 原型」的一部分，并且被认为是 jQuery 对象方法。\r\n\r\n但是，有几种方法不会对选集（selection）起作用；这些方法被认为是 jQuery 命名空间的一部分，最好被认为是核心 jQuery 方法。\r\n\r\n新的 jQuery 用户对于这种区别可以令人难以置信的混淆。 以下是您需要记住的内容：\r\n\r\n* 在 jQuery 选集上调用的方法位于 `$.fn` 命名空间中，而且自动接收并将作为 `this` 返回选集。\r\n* `$` 命名空间中的方法通常是工具类型方法，不适用于选集；它们不会自动传递任何参数，它们的返回值会有所不同。\r\n\r\n有些情况下，对象方法和核心方法有相同的名字，比如`.each()`和`.each()`。 在这些情况下，在阅读文档寻求正确方法的时要特别小心。\r\n\r\n在本指南中，如果可以在 jQuery 选集上调用某个方法，我们将仅以其名称引用它：`.each()`。 如果它是一个 [工具方法](https://learn.jquery.com/using-jquery-core/utility-methods/) ----也就是说，不是在选集上调用的方法----我们将明确提到它的方法是在 jQuery 命名空间的：`$.each()`。','2017-11-10 12:55:13','2017-11-10 12:55:13','introduction-to-the-jquery-jquery-core-functions-vs'),(475,3,3,'jQuery 入门：jQuery 核心功能 - $( document ).ready()','在文档「准备就绪」之前，页面操作都不能安全地进行。 jQuery 为您检测到这种状态。 包含在 `$(document).ready()` 中的代码只有在页面文档对象模型（DOM）准备好执行 JavaScript 代码时才会运行。而包含在 `$(window).on（\'load\', function() {...})` 中的代码将在整个页面都加载完毕后（包含图像或 iframe）才执行，而不仅仅是 DOM。\r\n\r\n```\r\n// 一个 $( document ).ready() 块\r\n$( document ).ready(function() {\r\n	console.log( \"ready!\" );\r\n});\r\n```\r\n\r\nExperienced developers sometimes use the shorthand `$()` for `$( document ).ready()`. If you are writing code that people who aren\'t experienced with jQuery may see, it\'s best to use the long form.\r\n\r\n经验丰富的开发人员有时使用 `$()`作为 `$(document).ready()`的简写。 如果你正在编写的代码可能会给那些没有经验的人看到，最好使用长的形式。\r\n\r\n```\r\n// $( document ).ready() 的简写形式\r\n$(function() {\r\n	console.log( \"ready!\" );\r\n});\r\n```\r\n\r\n你也可以为 `$( document ).ready()` 传递一个命名函数，而不是匿名函数。\r\n\r\n```\r\n// 传递一个命名函数，而不是匿名函数。\r\n\r\nfunction readyFn( jQuery ) {\r\n	// Code to run when the document is ready.\r\n}\r\n\r\n$( document ).ready( readyFn );\r\n// or:\r\n$( window ).on( \"load\", readyFn );\r\n```\r\n\r\n下面的例子显示了 `$(document).ready()` 和 `$(window).on(\'load\')` 的作用。代码尝试在一个 `<iframe>` 中加载一个网站 URL，并检查两个事件：\r\n\r\n```\r\n<html>\r\n<head>\r\n	<script src=\"https://code.jquery.com/jquery-1.9.1.min.js\"></script>\r\n	<script>\r\n	$( document ).ready(function() {\r\n		console.log( \"document loaded\" );\r\n	});\r\n\r\n	$( window ).on( \"load\", function() {\r\n		console.log( \"window loaded\" );\r\n	});\r\n	</script>\r\n</head>\r\n<body>\r\n	<iframe src=\"http://techcrunch.com\"></iframe>\r\n</body>\r\n</html>\r\n```','2017-11-10 13:09:47','2017-11-10 13:09:47','jquery-introduction-jquery-core-functions-document-ready'),(476,3,3,'jQuery 入门：jQuery 核心功能 - 避免与其他库冲突','jQuery 库和几乎所有的插件都包含在 `jQuery` 命名空间中。作为一般规则，全局对象也存储在 jQuery 名称空间内，所以不应该在 jQuery 和任何其他库（如 prototype.js ，MooTools 或 YUI）之间发生冲突。\r\n\r\n也就是说，有一点需要注意：*默认情况下，jQuery 使用 `$` 作为 `jQuery` 的快捷方式。* 因此，如果您用了另一个使用 `$` 变量的 JavaScript 库，您可能会遇到与 jQuery 的冲突。 为了避免这些冲突，你需要把 jQuery 加载到页面之后，在页面中使用 jQuery 之前，将它们置于非冲突模式。\r\n\r\n## 将 jQuery 置于非冲突模式\r\n\r\n当将 jQuery 置于非冲突模式后，你可以选择一个新的变量名来代替 `$` 别名。\r\n\r\n```\r\n<!-- Putting jQuery into no-conflict mode. -->\r\n<script src=\"prototype.js\"></script>\r\n<script src=\"jquery.js\"></script>\r\n<script>\r\n\r\nvar $j = jQuery.noConflict();\r\n// $j 现在是 jQuery 函数的别名了； 创建新的别名是可选的。\r\n\r\n$j(document).ready(function() {\r\n	$j( \"div\" ).hide();\r\n});\r\n\r\n// 这里的 $ 变量现在是 prototype.js 里的了，是\r\n// document.getElementById() 的简写形式。 下面的 mainDiv 是一个 DOM 元素，而不是一个 jQuery 对象。\r\nwindow.onload = function() {\r\n	var mainDiv = $( \"main\" );\r\n}\r\n\r\n</script>\r\n```\r\n\r\n在上面的代码中，`$` 将恢复到原始库中的含义。 您仍然可以在应用程序的其余部分使用全功能名称 `jQuery` 以及新的别名 `$j`。新的别名可以命名为任何你想要的，比如：`jq`、`$J`、`awesomeQuery` 等。\r\n\r\n最后，如果你不想为完整的 `jQuery` 函数名称定义另外一个选择（你真的喜欢使用 `$` 而不关心使用其他库的 `$` 方法），那么还有另一种方法您可以尝试：只需将 `$` 作为传递给您的 `jQuery(document).ready()`函数作为参数。 这是最经常使用的场景，你仍然可以真正享受简洁 jQuery 写法的好处，又不会与其他库造成冲突。\r\n\r\n```\r\n<!-- Another way to put jQuery into no-conflict mode. -->\r\n<script src=\"prototype.js\"></script>\r\n<script src=\"jquery.js\"></script>\r\n<script>\r\n\r\njQuery.noConflict();\r\n\r\njQuery( document ).ready(function( $ ) {\r\n	// You can use the locally-scoped $ in here as an alias to jQuery.\r\n	$( \"div\" ).hide();\r\n});\r\n\r\n// 全局 $ 变量现在是 prototype.js 里的了\r\nwindow.onload = function(){\r\n	var mainDiv = $( \"main\" );\r\n}\r\n\r\n</script>\r\n```\r\n\r\n对于大多数代码来说，这可能是最理想的解决方案，考虑到为了实现完全的兼容性，将只需修改更少的代码。\r\n\r\n## 在引入其他库之前引入 jQuery\r\n\r\n上面的代码片断依赖于在加载 prototype.js 之后加载的 jQuery。如果在其他库之前包含 jQuery，那么当您使用 jQuery 进行一些工作时，可以使用`jQuery`，但 `$` 将具有在另一个库中定义的含义。 没有必要通过调用 `jQuery.noConflict()`来放弃 `$` 别名。\r\n\r\n```\r\n<!-- Loading jQuery before other libraries. -->\r\n<script src=\"jquery.js\"></script>\r\n<script src=\"prototype.js\"></script>\r\n<script>\r\n\r\n// Use full jQuery function name to reference jQuery.\r\njQuery( document ).ready(function() {\r\n	jQuery( \"div\" ).hide();\r\n});\r\n\r\n// Use the $ variable as defined in prototype.js\r\nwindow.onload = function() {\r\n	var mainDiv = $( \"main\" );\r\n};\r\n\r\n</script>\r\n```\r\n\r\n## 总结引用 jQuery 函数的方法\r\n\r\n下面简要介绍一下当另一个库的存在与 `$` 变量的使用相冲突时，可以引用 jQuery 函数的方法：\r\n\r\n### 创建新的别名\r\n\r\n`jQuery.noConflict()` 方法返回一个对 jQuery 函数的引用，所以你可以在任何你想要的变量中捕获它：\r\n\r\n```\r\n<script src=\"prototype.js\"></script>\r\n<script src=\"jquery.js\"></script>\r\n<script>\r\n\r\n// Give $ back to prototype.js; create new alias to jQuery.\r\nvar $jq = jQuery.noConflict();\r\n\r\n</script>\r\n```\r\n\r\n### 使用了立即执行函数表达式\r\n\r\n你可以继续使用标准的 `$`，把你的代码包装在一个立即调用的函数表达式中；这也是 jQuery 插件创作的标准模式，作者无法知道另一个库是否会使用 `$`。 有关编写插件的更多信息，请参阅 [插件](https://learn.jquery.com/plugins/) 部分。\r\n\r\n```\r\n<!-- Using the $ inside an immediately-invoked function expression. -->\r\n<script src=\"prototype.js\"></script>\r\n<script src=\"jquery.js\"></script>\r\n<script>\r\n\r\njQuery.noConflict();\r\n\r\n(function( $ ) {\r\n	// Your jQuery code here, using the $\r\n})( jQuery );\r\n\r\n</script>\r\n```\r\n\r\n请注意，如果使用这种技术，您将无法在立即调用的函数内使用 prototype.js 方法。 `$` 将是对 jQuery的 引用，而不是 prototype.js 的。\r\n\r\n### 使用传递给`jQuery(document).ready()` 函数的参数\r\n\r\n```\r\n<script src=\"jquery.js\"></script>\r\n<script src=\"prototype.js\"></script>\r\n<script>\r\n\r\njQuery(document).ready(function( $ ) {\r\n	// Your jQuery code here, using $ to refer to jQuery.\r\n});\r\n\r\n</script>\r\n```\r\n\r\n或者使用 DOM ready 函数的更简洁的语法：\r\n\r\n```\r\n<script src=\"jquery.js\"></script>\r\n<script src=\"prototype.js\"></script>\r\n<script>\r\n\r\njQuery(function($){\r\n	// Your jQuery code here, using the $\r\n});\r\n\r\n</script>\r\n```','2017-11-11 06:15:12','2017-11-11 06:15:12','introduction-to-the-jquery-jquery-core-function-to-avoid-conflict-with-other-libraries'),(477,3,3,'jQuery 入门：jQuery 核心功能 - 特性','元素的属性可以包含应用程序的有用信息，所以能够获取和设置它们是非常重要的。\r\n\r\n## `.attr()` 方法\r\n\r\n`.attr()` 方法既是一个 getter 也是一个 setter。 作为一个setter，`.attr()` 可以接受一个键和一个值，或者接受一个包含一个或多个键/值对的对象。\r\n\r\n`.attr()` 作为 setter:\r\n\r\n```\r\n$( \"a\" ).attr( \"href\", \"allMyHrefsAreTheSameNow.html\" );\r\n\r\n$( \"a\" ).attr({\r\n	title: \"所有 a 的 title 也都一样了！\",\r\n	href: \"somethingNew.html\"\r\n});\r\n```\r\n\r\n`.attr()` 作为 getter:\r\n\r\n```\r\n$( \"a\" ).attr( \"href\" ); //  返回文档中匹配得第一个元素的 href 属性\r\n```','2017-11-11 06:21:33','2017-11-11 06:21:33','jquery-introduction-jquery-core-functions-features'),(478,3,3,'jQuery 入门：jQuery 核心功能 - 选择元素','jQuery 的最基本的概念是“选择一些元素，并用他们做些什么”。 jQuery 支持大多数的 CSS3 选择器，以及一些非标准的选择器。 要获得完整的选择器列表，请访问 [api.jquery.com 上的选择器文档](http://api.jquery.com/category/selectors/)。\r\n\r\n## 通过 ID 选择元素\r\n\r\n```\r\n$( \"#myId\" ); // Note IDs must be unique per page.\r\n```\r\n\r\n## 通过类名选择元素\r\n\r\n```\r\n$( \".myClass\" );\r\n```\r\n\r\n## 通过属性选择元素\r\n\r\n```\r\n$( \"input[name=\'first_name\']\" );\r\n```\r\n\r\n## 通过复合 CSS 选择器选择元素\r\n\r\n```\r\n$( \"#contents ul.people li\" );\r\n```\r\n\r\n## 使用逗号分隔的选择器列表选择元素\r\n\r\n```\r\n$( \"div.myClass, ul.people\" );\r\n```\r\n\r\n## 伪选择器\r\n\r\n```\r\n$( \"a.external:first\" );\r\n$( \"tr:odd\" );\r\n\r\n// Select all input-like elements in a form (more on this below).\r\n$( \"#myForm :input\" );\r\n$( \"div:visible\" );\r\n\r\n// All except the first three divs.\r\n$( \"div:gt(2)\" );\r\n\r\n// All currently animated divs.\r\n$( \"div:animated\" );\r\n```\r\n\r\n**注意：** 当使用 `:visible` 和 `:hidden` 伪选择器时，jQuery 测试元素的实际可见性，而不是CSS的 `visibility `或 `display` 属性。 jQuery 会查看元素在页面上的物理高度和宽度是否都大于零。\r\n\r\n但是，这个测试不适用于 `<tr>` 元素。 jQuery 测试 `<tr>` 元素实际可见性，是通过检查 CSS 的 `display` 属性，如果其 `display` 属性设置为 `none`，则认为这个元素是隐藏的。\r\n\r\n没有添加到 DOM 中的元素将始终被视为隐藏，即使它们身上的 CSS 属性是使其可见的。 请参阅 [操作元素](https://learn.jquery.com/manipulating-elements) 部分，了解如何创建元素并将其添加到 DOM 中。\r\n\r\n## 选择选择器\r\n\r\n选择好的选择器是提高 JavaScript 性能的一种方法。太多的特异性可能是一件坏事。如果选择器如 `#myTable th.special` 将完成工作，那么诸如 `#myTable thead tr th.special` 这样的选择器是过度的。\r\n\r\n### 我的选择是否包含任何元素？\r\n\r\n一旦你做出选择，你会经常想知道我的选择是否包含任何元素。 常见的错误是使用：\r\n\r\n```\r\n// Doesn\'t work!\r\nif ( $( \"div.foo\" ) ) {\r\n	...\r\n}\r\n```\r\n\r\n这是行不通的。 当使用 `$()` 进行选择时，总是返回一个对象，并且对象始终判断为 `true`。 即使选择不包含任何元素，`if` 语句中的代码仍将运行。\r\n\r\n确定是否有任何元素的最好方法是测试选集的 `.length` 属性，它告诉你选择了多少个元素。 如果答案是 0，当作为布尔值使用时，它将被判断为 `false`：\r\n\r\n```\r\n// Testing whether a selection contains elements.\r\nif ( $( \"div.foo\" ).length ) {\r\n	...\r\n}\r\n```\r\n\r\n### 保存选集\r\n\r\njQuery 不会为你缓存元素。 如果你已经做了一个选择，你可能需要重新做，你应该将选集保存在一个变量中，而不是重复选择。\r\n\r\n```\r\nvar divs = $( \"div\" );\r\n```\r\n\r\n一旦选集被存储在一个变量中，就可以调用变量上的 jQuery 方法，就像在原始选集中调用它们一样。\r\n\r\n选择只会在选择时提取页面上的元素。 如果稍后将元素添加到页面中，则必须重复选择或将其添加到存储在变量中的选择中。 当 DOM 改变时，存储的选集不会神奇地更新。\r\n\r\n### 精炼和过滤选集\r\n\r\n有时选集中包含比你以后要用到的要多。对于这种情况， jQuery 提供了几种精炼和筛选选集的方法。\r\n\r\n```\r\n// Refining selections.\r\n$( \"div.foo\" ).has( \"p\" );         // div.foo elements that contain <p> tags\r\n$( \"h1\" ).not( \".bar\" );           // h1 elements that don\'t have a class of bar\r\n$( \"ul li\" ).filter( \".current\" ); // unordered list items with class of current\r\n$( \"ul li\" ).first();              // just the first unordered list item\r\n$( \"ul li\" ).eq( 5 );              // 获得第六个 li 元素\r\n```\r\n\r\n### 选择表单元素\r\n\r\njQuery 提供了几个伪选择器来帮助查找表单中的元素。这些特别有用，因为使用标准的 CSS 选择器可以很难区分基于状态或类型的表单元素。\r\n\r\n#### :checked\r\n\r\n不要与 *:checkbox * 混淆了，`:checked` 命中 *checked* 的复选框元素，但是同时请记住，这个选择器也可以用于 *checked* 单选按钮和 `<select>` 元素（如果只选择 `<select>` 元素，请使用 `:selected` 选择器）：\r\n\r\n```\r\n$( \"form :checked\" );\r\n```\r\n\r\n`:checked` 伪选择器可以用于 **复选框**、**单选按钮** 和 **`<select>`** 上面。\r\n\r\n#### :disabled\r\n\r\n使用`:disabled` 伪选择器将 `input` 元素设置 `disabled` 属性：\r\n\r\n```\r\n$( \"form :disabled\" );\r\n```\r\n\r\n为了在使用 `:disabled` 时获得最好的性能，首先使用标准 jQuery 选择器选择元素，然后使用 `.filter(\':disabled\')`，或者在伪选择器之前加上标签名称或其他选择器。\r\n\r\n#### :enabled\r\n\r\n基本上是 *:disabled* 伪选择符的反转，`:enabled` 伪选择器的目标是那些 *不* 设置 `disabled`属性的元素：\r\n\r\n```\r\n$( \"form :enabled\" );\r\n```\r\n\r\n为了使用 `:enabled` 时能获得最佳性能，首先使用标准 jQuery 选择器选择元素，然后使用 `.filter(\':disabled\')`，或者在伪选择器之前加上标签名称或其他选择器。\r\n\r\n#### :input\r\n\r\n使用 `:input` 选择器将选择所有的 `<input>`、`<textarea>`、`<select>` 和 `<button>` 元素：\r\n\r\n```\r\n$( \"form :input\" );\r\n```\r\n\r\n#### :selected\r\n\r\n使用 `:selected` 伪选择器来定位 `<option>` 元素中的所有选择项：\r\n\r\n```\r\n$( \"form :selected\" );\r\n```\r\n\r\n为了使用在 `:selected` 时获得最佳性能，首先使用标准 jQuery 选择器选择元素，然后使用`.filter(\':selected\')`，或者在伪选择器之前加上标签名称或其他选择器。\r\n\r\n#### 通过类型选择\r\n\r\njQuery 提供伪选择器来根据类型选择特定的表单元素：\r\n\r\n* [`:password`](http://api.jquery.com/password-selector/)\r\n* [`:reset`](http://api.jquery.com/reset-selector/)\r\n* [`:radio`](http://api.jquery.com/radio-selector/)\r\n* [`:text`](http://api.jquery.com/text-selector/)\r\n* [`:submit`](http://api.jquery.com/submit-selector/)\r\n* [`:checkbox`](http://api.jquery.com/checkbox-selector/)\r\n* [`:button`](http://api.jquery.com/button-selector/)\r\n* [`:image`](http://api.jquery.com/image-selector/)\r\n* [`:file`](http://api.jquery.com/file-selector/)\r\n\r\n对于所有这些都有关于性能的旁注，请务必查看 [API 文档](http://api.jquery.com/category/selectors/form-selectors/) 以获取更深入的信息。','2017-11-11 08:21:36','2017-11-11 08:21:36','introduction-to-the-jquery-jquery-core-functions-select-elements'),(479,3,3,'2017年11月11号的日志','今天天气好、心情好，我晴天了。晴天之后，我来到图书馆看书，准备看一会，然后出去走走，做什么不知道，就走走。平淡的陈述和抒情。\r\n\r\n**《红楼梦》第八回**\r\n\r\n- 宝钗看毕，又从新翻过来细看。\r\n- 宝玉央道：“我只喝一钟。”\r\n- （薛姨妈）一面令小丫鬟:“来，让你奶奶们去，也吃一杯搪搪雪气。”\r\n\r\n喝酒为何要暖呢？我读到了原因。\r\n\r\n> 宝钗笑道：“宝兄弟，亏你每日家杂学旁收的，难道就不知道酒性最热，若热吃下去，发散的就快；若冷吃下去，便凝结在内，以五脏去暖他，岂不受害？从此还不快不要吃那冷的了。”宝玉听这话有情理，便放下冷酒，令人暖来方饮。\r\n\r\n我没有读懂黛玉说得话，丫鬟拿来手炉，黛玉奚落外丫鬟。到底是借此奚落宝玉，还是避免薛姨妈难堪的。\r\n\r\n- 林黛玉冷笑道：“我为什么助着他?我也不犯着劝他。你这妈妈太小心了，往常老太太又给他酒吃，如今在姨妈这里多吃了一口，料也不妨事。必定姨妈这里是外人，不当在这里的，也未可定。”\r\n\r\n黛玉说话确实是“叫人恨也不是，喜欢又不是”。\r\n\r\n- 晴雯向里间炕上努嘴。\r\n\r\n宝玉乳母吃包子吃茶，宝玉怒了。\r\n\r\n> 将手中茶杯顺手往地下一掷，豁琅一声，打\r\n了个粉碎，泼了茜雪一裙子的茶。又跳起来问着茜雪道：“他是你那一门子的奶奶，你们这么孝敬他？不过是仗着我小时候儿吃过他几日奶罢了，如今逞的他比祖宗还大了！撵了出去，大家干净！”\r\n\r\n**《红楼梦》第九回**\r\n\r\n袭人疼人，见宝玉就要去上学了，准备停当后，坐在床沿上发闷。\r\n\r\n> 这是那里话？读书是极好的事，不然就潦倒一辈子，终久怎么样呢。但只一件：只是念书的时节想着书，不念的时节想着家些。别和他们一处顽闹，碰见老爷不是顽的。虽说是奋志要强，那工课宁可少些，一则贪多嚼不烂，二则身子也要保重。这就是我的意思，你可要体谅。\r\n\r\n说得句句让人心疼。\r\n\r\n- 吓的李贵忙双膝跪下，摘了帽子碰头，连连答应“是”，又回说：“哥儿已念到第三本《诗经》，什么‘呦呦鹿鸣，荷叶浮萍’，小的不敢撒谎。”\r\n\r\n宝玉小心。\r\n\r\n- 黛玉忙又叫住，问道：“你怎么不去辞辞你宝姐姐呢？”宝玉笑而不答，一径同秦钟上学去了。\r\n\r\n原来薛蟠自来王夫人处住后，便知有一家学，学中广有青年子弟，不免偶动了龙阳之兴，因此也假来上学读书，不过是三日打鱼，两日晒网。','2017-11-11 22:27:00','2017-11-15 14:38:15','november-11-2017'),(480,3,3,'jQuery 入门：jQuery 核心功能 - 使用选集','### Getters & Setters\r\n\r\n一些 jQuery 方法可以用来分配或读取选集的某个值。当这个方法调用时使用了参数，它被称为 Setter，因为它设置（或分配）了该值。 当方法被调用时没有使用参数，它用来获取（或读取）元素的值。 Setters 影响选择中的所有元素，而 Getters 仅返回所选值中第一个元素的请求值，当然有一个里外，就是 [`.text()`](http://api.jquery.com/text/) 方法，作为 Getter 时， 它会检索回所有元素的值。\r\n\r\n```\r\n// .html() 方法将所有 h1 元素的 html 内容设置为「hello world」：\r\n$( \"h1\" ).html( \"hello world\" );\r\n```\r\n\r\n```\r\n// .html() 方法返回第一个 h1 元素的 html 内容：\r\n$( \"h1\" ).html();\r\n// > \"hello world\"\r\n\r\n```\r\n\r\nSetters 返回一个 jQuery 对象，允许你继续在你的选集上调用 jQuery 方法。 Getters 返回所要求的东西，所以你不能继续期望在 Getter 上调用 jQuery 对象的方法了。\r\n\r\n```\r\n// 尝试在 Getter 上调用 jQuery 对象的方法。\r\n// 这是无效的：\r\n$( \"h1\" ).html().addClass( \"test\" );\r\n```\r\n\r\n### 链式调用\r\n\r\n如果您在选集上调用方法，并且该方法返回一个 jQuery 对象，则可以继续在该对象上调用 jQuery 方法，而不必使用分号，再起一行调用 jQuery 对象的方法。 这种做法被称为「链式调用」：\r\n\r\n```\r\n$( \"#content\" ).find( \"h3\" ).eq( 2 ).html( \"第三个 h3 元素的内容变成这个了！\" );\r\n```\r\n\r\n将链式调用分拆成几行更有助于代码的可读性：\r\n\r\n```\r\n$( \"#content\" )\r\n	.find( \"h3\" )\r\n	.eq( 2 )\r\n	.html( \"第三个 h3 元素的内容变成这个了！\" );\r\n```\r\n\r\njQuery 还提供了 `.end()` 方法，以便在链式调用的中间更改选集至上一个选集：\r\n\r\n```\r\n$( \"#content\" )\r\n	.find( \"h3\" )\r\n	.eq( 2 )\r\n		.html( \"new text for the third h3!\" )\r\n		.end() // Restores the selection to all h3s in #content\r\n	.eq( 0 )\r\n		.html( \"new text for the first h3!\" );\r\n```\r\n\r\n链接是非常强大的，这是许多库里都已经使用了，因为它是由 jQuery 流行的功能。 但是，必须谨慎使用----大量的链式调用会使代码极难修改或调试。对于一个链式调用应该有多长时间没有硬性规定----只要知道它很容易使人冲昏头脑。','2017-11-12 04:49:17','2017-11-12 04:49:17','jquery-introduction-jquery-core-functions-use-selection'),(481,3,3,'2017年11月12号的日志','图书馆的检索系统慢而且不支持分词搜索，我按照索书号也没有找到书。\r\n\r\n**《红楼梦》第十一回**\r\n\r\n- 凤姐儿听了，哼了一声，说道：“这畜生合该作死，看他来了怎么样！”\r\n\r\n我想到在家的青麦苗田里站着。\r\n\r\n我想到春林、阿娟、佩佩，我感觉非常可惜。我还在活着，需要用力，需要希望和爱。\r\n\r\n要保持开心，忧愁总比快乐多。\r\n\r\n我什么都不想，我只有自己在这边，这不是生活，我要自由快乐。','2017-11-12 23:39:15','2017-11-12 23:39:42','on-november-12-2017'),(482,3,3,'JavaScript 实战：自定义滚动条','自定义滚动条需要完成以下功能：\r\n\r\n1. 鼠标拖动 slide bar 时，实现 slide bar 和内容同时滚动的效果。\r\n2. 滚动鼠标滚轮时，实现 slide bar 和内容同时滚动的效果。\r\n3. 点击 slide bar 上下两个箭头时，实现 slide bar 和内容同时滚动的效果。\r\n4. 点击 bar 条的空白处时，实现 slide bar 和内容同时滚动的效果。\r\n5. 按照内容的高度，计算出 slide bar 的高度。\r\n\r\n下面我们就按照这个步骤，实现自定义滚动条（完整源码看 [这里](https://codepen.io/zhangbao/pen/RjVYez)）。\r\n\r\n## 页面结构\r\n\r\nHTML\r\n\r\n	<div id=\"app\">\r\n		<div class=\"con-wrap\">\r\n			<div class=\"con\">\r\n				<h3>那个年代，物资都很匮乏 - 杨怡倩</h3>\r\n				<p>很多年以前有一群农村的孩子，他们捡到一个乒乓球，因为从来没见过这种东西，视若珍宝，坐了很长时间的火车，带上了半个月的干粮，要去北京把它献给毛主席。这个故事似乎有个同样情节的电影，但是我很小的时候外公给我讲过这样的事儿，真事儿。</p>\r\n				<p>...</p>\r\n				<p>（完）</p>\r\n			</div>\r\n		</div>\r\n		<div class=\"bar-wrap\">\r\n			<div class=\"arrow up-arrow\"><span>︿</span></div>\r\n			<div class=\"bar\">\r\n				<div class=\"slide\"></div>\r\n			</div>\r\n			<div class=\"arrow down-arrow\"><span>﹀</span></div>\r\n		</div>\r\n	</div>\r\n\r\nCSS\r\n\r\n	body {\r\n		margin: 10px;\r\n		color: #333;\r\n		font: 14px/1.4286 STXihei, Georgia, serif;\r\n		height: 2000px;\r\n	}\r\n\r\n	h3 {\r\n		margin: 0;\r\n	}\r\n\r\n	.con-wrap {\r\n		width: 350px;\r\n		height: 500px;\r\n		border: 1px solid #eee;\r\n		overflow: hidden;\r\n		float: left;\r\n		position: relative;\r\n	}\r\n\r\n	.con-wrap .con {\r\n		padding: 1em;\r\n		text-align: justify;\r\n		position: absolute;\r\n	}\r\n\r\n	.bar-wrap {\r\n		width: 16px;\r\n		height: 500px;\r\n		float: left;\r\n		border: 1px solid #eee;\r\n		border-left: none;\r\n	}\r\n\r\n	.bar-wrap .arrow {\r\n		width: inherit;\r\n		height: 3%;\r\n		background: #f9f9f9;\r\n		cursor: pointer;\r\n		text-align: center;\r\n		color: #999;\r\n	}\r\n\r\n	.bar-wrap .arrow:hover {\r\n		background: #eee;\r\n	}\r\n\r\n	.bar-wrap .up-arrow {\r\n		line-height: 8px;\r\n	}\r\n\r\n	.bar-wrap .bar {\r\n		width: inherit;\r\n		height: 94%;\r\n		position: relative;\r\n	}\r\n\r\n	.bar-wrap .bar .slide {\r\n		width: inherit;\r\n		height: 100px;\r\n		background: #efefef;\r\n		position: absolute;\r\n	}\r\n\r\n	.bar-wrap .bar .slide:hover {\r\n		background: #e3e1e1;\r\n	}\r\n\r\n	.bar-wrap .bar .slide.active {\r\n		background: #bcbbbb;\r\n	}\r\n\r\n## 实现过程\r\n\r\n### 第一步\r\n\r\n拖动 slide bar 实现 slide bar 和内容同步滚动的效果。\r\n\r\n	var app = document.querySelector(\'#app\'),\r\n		conWrap = app.querySelector(\'.con-wrap\'),\r\n		con = conWrap.children[0],\r\n		// 内容区能滚动的最长距离\r\n		maxConHeight = con.offsetHeight - conWrap.clientHeight,\r\n		barWrap = app.querySelector(\'.bar-wrap\'),\r\n		bar = barWrap.querySelector(\'.bar\'),\r\n		slide = bar.children[0],\r\n		// slide bar 在 bar 中能滚动的最长距离\r\n		maxSlideHeight = bar.clientHeight - slide.offsetHeight,\r\n		scrollTop = 0;\r\n	\r\n	slide.onmousedown = function (ev) {\r\n		// 这是为了避免在下面 mousemove 的时候，选中内容区文字内容的默认行为。\r\n		ev.preventDefault();\r\n		// 阻止事件冒泡，这样就不能触发 bar 上的 mousedown 事件了，\r\n		// 因为之后要实现点击 bar 条滚动的效果\r\n		ev.stopPropagation();\r\n\r\n		slide.classList.add(\'active\');\r\n\r\n		var initTop = ev.clientY - slide.offsetTop;\r\n\r\n		document.onmousemove = function (ev) {\r\n			// mousemove 时实时监听 slide bar 的 top 值\r\n			scrollTop = ev.clientY - initTop;\r\n			// 同步滚动 slider bar 和内容区\r\n			scroll();\r\n		};\r\n\r\n		document.onmouseup = function () {\r\n			slide.classList.remove(\'active\');\r\n			document.onmousemove = null;\r\n		}\r\n	};\r\n\r\n	function scroll() {\r\n		// 修正 top 值，避免越界\r\n		if (scrollTop < 0) {\r\n			scrollTop = 0;\r\n		} else if (scrollTop > maxSlideHeight) {\r\n			scrollTop = maxSlideHeight;\r\n		}\r\n		slide.style.top = scrollTop + \'px\';\r\n	\r\n		// 计算出内容区应该滚动的距离\r\n		var percentage = scrollTop / maxSlideHeight;\r\n		con.style.top = -(maxConHeight * percentage) + \'px\';\r\n	}\r\n\r\n\r\n### 第二步\r\n\r\n滚动滚轮。\r\n\r\n	mouseWheel(app, function () {\r\n		scrollTop -= 8;\r\n		scroll();\r\n	}, function () {\r\n		scrollTop += 8;\r\n		scroll();\r\n	});\r\n\r\n	// 这里封装了鼠标滚轮滚动时的兼容函数，兼容 Firefox 和其他浏览器\r\n	// 这里可以分别为滚轮上滚和下滚提供了回调函数\r\n	function mouseWheel(target, fnUp, fnDown) {\r\n		target.onmousewheel = wheel;\r\n		target.addEventListener(\'DOMMouseScroll\', wheel);\r\n\r\n		function wheel(event) {\r\n			event.preventDefault();\r\n\r\n			if (getWheelDelta(event) > 0) {\r\n				fnUp.call(target);\r\n			} else {\r\n				fnDown.call(target);\r\n			}\r\n		}\r\n\r\n		function getWheelDelta (event) {\r\n			if (event.wheelDelta) {\r\n				return event.wheelDelta;\r\n			}\r\n			return -event.detail * 40;\r\n		}\r\n	}\r\n\r\n### 第三步\r\n\r\n实现点击上下键滚动效果。\r\n\r\n	var upArrow = app.querySelector(\'.up-arrow\'),\r\n		downArrow = app.querySelector(\'.down-arrow\'),\r\n		timer;\r\n	\r\n	upArrow.onmousedown = function (ev) {\r\n		// 这是为了避免当连续点击 div 时，出现的（默认）选中效果。\r\n		ev.preventDefault();\r\n\r\n		timer = setInterval(function () {\r\n			scrollTop -= 5;\r\n			scroll();\r\n		}, 16);\r\n\r\n		document.onmouseup = function () {\r\n			clearInterval(timer);\r\n		}; \r\n	};\r\n	downArrow.onmousedown = function (ev) {\r\n		ev.preventDefault();\r\n\r\n		timer = setInterval(function () {\r\n			scrollTop += 5;\r\n			scroll();\r\n		}, 16);\r\n\r\n		document.onmouseup = function () {\r\n			clearInterval(timer);\r\n		};\r\n	};\r\n\r\n这里启用了定时器，实现长按上下键时的连续滚动效果。\r\n\r\n## 第四步\r\n\r\n点击 bar 条时的滚动效果。\r\n\r\n	bar.onmousedown = function (ev) {\r\n		// 如果不需要连续、流畅的上下滚动的效果，可以直接计算出滚动距离即可\r\n		// scrollTop = ev.clientY - bar.getBoundingClientRect().top - slide.offsetHeight / 2;\r\n		\r\n		// 这是为了避免当连续点击 div 时，出现的（默认）选中效果。\r\n		ev.preventDefault();\r\n\r\n		timer = setInterval(function () {\r\n			var compareTop = getPos(slide).top + (slide.offsetHeight / 2);\r\n\r\n			// 避免抖动\r\n			if (Math.abs(ev.clientY - compareTop) <= 5) {\r\n				returnv ;\r\n			}\r\n\r\n			if (ev.clientY < compareTop) {\r\n				scrollTop -= 5;\r\n			} else {\r\n				scrollTop += 5;\r\n			}\r\n\r\n			scroll();\r\n		}, 16);\r\n\r\n		document.onmouseup = function () {\r\n			clearInterval(timer);\r\n		}; \r\n	};\r\n\r\n## 第五步\r\n\r\n确定 slide bar 的高度。**注意这一步放在所有步骤之前执行**。\r\n\r\n	(function () {\r\n		var beishu = con.offsetHeight / conWrap.clientHeight;\r\n\r\n		if (beishu <= 1) {\r\n			barWrap.style.display = \'none\';\r\n			return ;\r\n		} else if (beishu > 20) {\r\n			beishu = 20;\r\n		}\r\n\r\n		// 为 slide 给予高度\r\n		slide.style.height = bar.offsetHeight / beishu + \'px\';\r\n\r\n		// 计算出 slide 可滑动的最高距离\r\n		maxSlideHeight = bar.clientHeight - slide.offsetHeight;\r\n	})();\r\n\r\n这么一来，`slide` 的高度和 `maxSlideHeight` 都是依据内容区高度自动计算出来的了。','2017-11-13 06:21:41','2017-11-13 06:21:41','javascript-combat-custom-scroll-bar'),(483,3,3,'JavaScript 实战：可变大小框','功能类型 Windows 文件系统窗口，当鼠标在有效区域内移动时，出现可拖拽大小的样式，然后当按下鼠标即可在相应方向进行大小可改变的变化了。\r\n\r\n主要实现的步骤如下：\r\n\r\n1. 在 box 上 `mousedown` 的时候，记录 box 的位置信息，以及鼠标是否被按下的信息。\r\n2. 一切功能都是在 box 上 `mousmove` 时发生的：\r\n	- 当鼠标未按下时，我们需要改变鼠标的 `cursor` 样式。\r\n	- 当鼠标按下时，我们根据 cursor 情况改变 `box` 框相应方向上的大小和位置信息。\r\n\r\n实现的源码可在 [这里](https://codepen.io/zhangbao/pen/gXWZRJ) 看到。\r\n\r\n## 页面结构\r\n\r\nHTML \r\n\r\n	<div class=\"box\"></div>\r\n\r\nCSS\r\n\r\n	.box {\r\n		width: 100px;\r\n		height: 100px;\r\n		background: pink;\r\n		position: absolute;\r\n		top: calc(50% - 50px);\r\n		left: calc(50% - 50px);\r\n	}\r\n\r\n## 实现过程\r\n\r\n### 第一步\r\n\r\n在 box 上 `mousedown` 的时候，记录 box 的位置信息，以及鼠标是否被按下的信息。\r\n\r\n	var box = document.querySelector(\'.box\'),\r\n		isDown = false,\r\n		mes = null;\r\n	\r\n	box.onmousedown = function (ev) {\r\n		var pos = getPos(box);\r\n\r\n		isDown = true;\r\n\r\n		mes = {\r\n			x: ev.clientX,\r\n			y: ev.clientY,\r\n			w: box.offsetWidth,\r\n			h: box.offsetHeight,\r\n			t: pos.top,\r\n			l: pos.left,\r\n			r: pos.right,\r\n			b: pos.bottom\r\n		};\r\n	};\r\n\r\n	document.onmouseup = function () {\r\n		isDown = false;\r\n	};\r\n	\r\n### 第二步\r\n\r\n一切功能都是在 box 上 `mousmove` 时发生的：\r\n\r\n- 当鼠标未按下时，我们需要改变鼠标的 `cursor` 样式。\r\n- 当鼠标按下时，我们根据 cursor 情况改变 `box` 框相应方向上的大小和位置信息。\r\n\r\n下面是代码实现：\r\n	\r\n	var xResize = \'\';\r\n\r\n	box.onmousemove = function (ev) {\r\n		ev.preventDefault();\r\n\r\n		// 鼠标未按下\r\n		if (! isDown) {\r\n			xResize = \'\';\r\n\r\n			if (ev.clientY < (getPos(this).top + 10)) {\r\n				xResize = \'n\';\r\n			}\r\n\r\n			if (ev.clientY > (getPos(this).bottom - 10)) {\r\n				xResize = \'s\';\r\n			}\r\n\r\n			if (ev.clientX < (getPos(this).left + 10)) {\r\n				xResize += \'w\';\r\n			}\r\n\r\n			if (ev.clientX > (getPos(this).right - 10)) {\r\n				xResize += \'e\';\r\n			}\r\n\r\n			if (xResize) {\r\n				box.style.cursor = xResize + \'-resize\';\r\n			} else {\r\n				box.style.cursor = \'auto\';\r\n			}\r\n\r\n		// 鼠标已经按下，改变 .box 的大小和位置。 \r\n		} else {\r\n			document.onmousemove = function (ev) {\r\n				var w, h, l, t;\r\n\r\n				// 向右拖动 \r\n				if (xResize.indexOf(\'e\') !== -1) {\r\n					w = mes.w + (ev.clientX - mes.x);\r\n\r\n					if (w < 100) {\r\n						w = 100;\r\n					}\r\n\r\n					box.style.width = w + \'px\';\r\n				}\r\n\r\n				// 向下拖动\r\n				if (xResize.indexOf(\'s\') !== -1) {\r\n					h = mes.h + (ev.clientY - mes.y);\r\n\r\n					if (h < 100) {\r\n						h = 100;	\r\n					}\r\n\r\n					box.style.height = h + \'px\';\r\n				}\r\n\r\n				// 向左拖动\r\n				if (xResize.indexOf(\'w\') !== -1) {\r\n					w = mes.w + (mes.x - ev.clientX);\r\n					l = mes.l - (mes.x - ev.clientX);\r\n\r\n					if (w < 100) {\r\n						w = 100;\r\n						l = mes.r - 100;\r\n					}\r\n\r\n					box.style.width = w + \'px\';\r\n					box.style.left = l + \'px\';\r\n				}\r\n\r\n				// 向上拖动\r\n				if (xResize.indexOf(\'n\') !== -1) {\r\n					h = mes.h + (mes.y - ev.clientY);\r\n					t = mes.t - (mes.y - ev.clientY);\r\n\r\n					if (h < 100) {\r\n						h = 100;\r\n						t = mes.b - 100;\r\n					}\r\n\r\n					box.style.height = h + \'px\';\r\n					box.style.top = t + \'px\';\r\n				}\r\n			}\r\n		}\r\n	};\r\n\r\n这事还需要修改之前在 `document` 上的 `mouseup` 事件。\r\n\r\n	document.onmouseup = function () {\r\n		// 拖动结束松开鼠标后，将 document 身上的 momusemove 事件去掉。\r\n		document.onmousemove = null;\r\n		isDown = false;\r\n	};','2017-11-13 08:05:39','2017-11-13 08:19:58','javascript-combat-variable-size-box'),(484,3,3,'ES6：函数的 rest 参数和数组的扩展运算符','数组的扩展运算符（spread）是三个点（...），在数组前使用；rest 参数在函数声明时使用，只能作为最后一个参数，其值是一个数组。\r\n\r\n可以说，rest 参数与扩展运算符互为逆运算。\r\n\r\n下面详细介绍。\r\n\r\n## 数组的扩展运算符\r\n\r\n扩展运算符（spread）是三个点（...），在数组前面使用，它会 **将一个数组转为用逗号分隔的参数序列**。\r\n\r\n例如：\r\n\r\n	 console.log(...[1, 2, 3])\r\n	 // 等同于\r\n	 console.log(1, 2, 3)\r\n\r\n	 [\'zhangb\', ...[1, 2, 3], \'baooab\'] // [\"zhangb\", 1, 2, 3, \"baooab\"]\r\n	\r\n## 函数的 rest 参数\r\n\r\n函数的 rest 参数，形式如 `...变量名`，是在声明函数时使用的，**用来获取函数的多余参数，参数值是一个数组，而且只能作为函数的最后一个参数使用**。\r\n\r\n	function foo(first, ...values) {\r\n	    // values 是一个数组，用来获取函数的多余参数。\r\n		console.log(values);\r\n	}\r\n\r\n	foo(2, 5, 3); // [5, 3]\r\n\r\n这样一来，我们就不需要使用 `arguments` 这个类数组对象了。','2017-11-16 07:53:42','2017-12-18 07:32:55','es6-rest-parameters-of-the-function-and-the-expansion-of-the-array-operators'),(551,3,3,'ES6：export default 命令','指定模块的默认输出使用 `export default` 命令：\r\n\r\n```javascript\r\n// export-default.js\r\nexport default function () {\r\n  console.log(\'foo\');\r\n}\r\n```\r\n\r\n上面的模块默认输出是一个匿名函数。\r\n\r\n现在使用 `import` 命令加载这个模块。加载时，可以为加载模块输出的默认匿名函数指定任意名字，然后使用。\r\n\r\n```javascript\r\n// import-default.js\r\nimport customName from \'./export-default\';\r\ncustomName();\r\n```','2017-12-19 02:00:52','2017-12-19 02:00:52','es6-export-the-default-command'),(485,3,3,'2017 年 11 月 16 号日志','今天小雨，晚上跑步去了，不过比较晚了九点才开始。还好，路上雨点似下非下，跑完了也没感觉到什么。我刚才去接水喝，发现外面雨下大了，还是挺幸运的。\r\n\r\n还有…所谓伊人，在水一方。','2017-11-16 15:09:18','2017-11-16 15:09:18','log-on-november-16th-2017'),(486,3,3,'JS 移动端基础事件','## 移动端基础事件\r\n\r\n	<meta name=\"viewport\" content=\"width=device-width,user-scalable=no\">\r\n\r\ntouch 事件。\r\n\r\n1. `touchstart`：手指按下事件。\r\n2. `touchmove`：手指移动事件。\r\n3. `touchend`：手指离开事件。\r\n\r\n下面是例子说明：\r\n\r\n	<style type=\"text/css\">\r\n		.box {\r\n			width: 100px;\r\n			height: 100px;\r\n			background: pink;\r\n		}\r\n	</style>\r\n	\r\n	<div class=\"box\"></div>\r\n	\r\n	<script>\r\n		var box = document.querySelector(\'.box\');\r\n\r\n		box.addEventListener(\'touchstart\', function (ev) {\r\n			console.log(\'touchstart\');\r\n		});\r\n\r\n		box.addEventListener(\'touchmove\', function (ev) {\r\n			console.log(\'touchmove\');\r\n		});\r\n\r\n		box.addEventListener(\'touchend\', function (ev) {\r\n			console.log(\'touchend\');\r\n		});\r\n	</script>\r\n\r\n需要注意的是：\r\n\r\n1. 只能通过 `addEventListener` 添加 touch 事件。\r\n2. 在移动端中不用再用鼠标事件了。\r\n\r\n## 事件对象\r\n\r\ntouch 事件触发的事件对象是 `TouchEvent`。里面包含的主要属性如下：\r\n\r\n1. `touches`：当前屏幕中的手指列表。\r\n2. `targetTouches`：当前元素上的手指列表。\r\n3. `changedTouches`：触发当前事件的手指列表（以后就用这个）。\r\n4. `Touch.pageX`：触摸点相对于页面左边的距离。\r\n5. `Touch.pageY`：触摸点相对于页面上边的距离。\r\n\r\n## 重力加速度事件\r\n\r\n`devicemotion`：重力加速度事件。注意，这个事件只能放在 `window` 身上。重力加速度对象是通过事件对象上的 `accelerationIncludingGravity` 属性获得的。\r\n\r\n`accelerationIncludingGravity` 是一个包括三轴（x、y、z）加速度信息的对象，每个轴都有自己的属性：\r\n\r\n1. `x`：表示 x 轴（西到东）上的加速度。\r\n2. `y`：表示 y 轴（南到北）上的加速度。\r\n3. `z`：表示 z 轴（下到上）上的加速度。\r\n\r\n下面是个例子：\r\n\r\n	window.addEventListener(\'devicemotion\', function (ev) {\r\n		var motion = ev.accelerationIncludingGravity;\r\n\r\n		box.innerHTML = `x:{motion.x}<br>y:{motion.y}<br>z:{motion.z}`;\r\n	});\r\n\r\n## 手机倾斜事件\r\n\r\n`deviceorientation`：手机倾斜事件。手机倾斜事件产生的事件对象包含如下 3 个属性：\r\n\r\n1. `alpha`：X 轴的倾斜度。\r\n2. `beta`：Y 轴的倾斜度。\r\n3. `gamma`：Z 轴的倾斜度。\r\n\r\n## 手机摇一摇\r\n\r\n	var lastRange = 0;\r\n	var isShake = false;\r\n\r\n	var box = document.querySelector(\'.box\');\r\n\r\n	window.addEventListener(\'devicemotion\', function (ev) {\r\n		var motion = ev.accelerationIncludingGravity;\r\n		var x = Math.abs(motion.x);\r\n		var y = Math.abs(motion.y);\r\n		var z = Math.abs(motion.z);\r\n\r\n		var range = x + y + z;\r\n\r\n		if (range - lastRange > 100) { // 用户大幅度摇晃了\r\n			isShake = true;	\r\n		}\r\n\r\n		if (isShake && range < 50) { // 说民用户摇晃（几乎）停止，开始处理业务逻辑\r\n			alert(\'摇一摇了!\');\r\n			isShake = false;\r\n		}\r\n	});\r\n\r\n## 多指旋转\r\n\r\n*仅是 Safari 浏览器支持此事件类型*。\r\n\r\n手势事件 `gesturestart` ---- 表示两个或者两个以上的手指按于屏幕上时，发生的事件。\r\n\r\n手势事件 `gesturechange` ---- 表示两个或者两个以上的手指在屏幕上的手势发生变化时，发生的事件。\r\n\r\n手势事件 `gestureend` ---- 表示两个或者两个以上的手指的手势离开屏幕时，发生的事件。\r\n\r\n	<div class=\"box\"></div>\r\n\r\n	<style>\r\n		.box {\r\n			width: 300px;\r\n			height: 300px;\r\n			background: coral;\r\n		}\r\n	</style>\r\n\r\n	<script>\r\n	var box = document.querySelector(\'.box\');\r\n\r\n	var startDeg = 0;\r\n\r\n	box.addEventListener(\'gesturestart\', function (ev) {\r\n		this.style.background = \'blue\';\r\n\r\n		if (this.style.transform) {\r\n			startDeg = parseFloat(this.style.transform.split(\'(\')[1]);\r\n		}\r\n	});\r\n\r\n	box.addEventListener(\'gesturechange\', function (ev) {\r\n		this.style.background = \'black\';\r\n\r\n		// ev.rotation 表示旋转角度\r\n		this.style.transform = \'rotate(\' + (ev.rotation + startDeg) + \'deg)\';\r\n	});\r\n\r\n	box.addEventListener(\'gestureend\', function (ev) {\r\n		this.style.background = \'coral\';\r\n	});\r\n	</script>\r\n	\r\n## 多指缩放\r\n\r\n	<script>\r\n	var box = document.querySelector(\'.box\');\r\n\r\n	var startScale = 0;\r\n\r\n	box.addEventListener(\'gesturestart\', function (ev) {\r\n		this.style.background = \'blue\';\r\n\r\n		if (this.style.transform) {\r\n			startScale = parseFloat(this.style.transform.split(\'(\')[1]);\r\n		}\r\n	});\r\n\r\n	box.addEventListener(\'gesturechange\', function (ev) {\r\n		this.style.background = \'black\';\r\n\r\n		var sc = ev.scale * startScale;\r\n		// 限制最小缩小比例\r\n		sc = (sc < 0.5) ? 0.5 : sc;\r\n	\r\n		// ev.rotation 表示旋转角度\r\n		this.style.transform = \'scale(\' +  sc + \')\';\r\n	});\r\n\r\n	box.addEventListener(\'gestureend\', function (ev) {\r\n		this.style.background = \'coral\';\r\n	});\r\n	</script>','2017-11-17 01:49:48','2017-11-17 05:55:17','js-mobile-client-base-events'),(487,3,3,'2017年11月17号的日志','- 上午写了代码后，发现下午完全没有心思学习了。人的一天可以集中的精力有限，所以上午还是看理论知识或者读书比较好。\r\n- 我竭尽努力写东西，发现也不过写了 400  多篇，其中丑陋、不堪的篇幅又甚多。但希望能依靠这种笨拙的展示提高自己的文笔和写作技巧、继续坚持----这毕竟不是一朝一夕的事情。','2017-11-18 01:37:42','2017-11-18 01:37:42','on-november-17-2017'),(488,3,3,'2017 年 11 月 18 号日志','今天降温了，还刮着风，一早知冬。我八点半起来，九点十多分就出来了。\r\n\r\n红楼梦第二十回\r\n\r\n- 我家里烧得滚热的野鸡，快来跟我吃酒去。一面说，一面拉着走，又叫：丰儿，替你李奶奶拿着拐棍子，擦眼泪的手帕子。\r\n- 他便料定，原来天生人为万物之灵，凡山川日月之精秀，只钟于女儿，须眉男子不过是些渣滓浊沫而已。\r\n\r\n风卷起一片树叶，然后又松开落下了。\r\n\r\n---\r\n\r\n跑完步刚回来，感觉很费劲。路上我想到了人生可以多么的轻盈，也感觉到了跑前没做拉伸运动带来的苦楚。\r\n\r\n如果实在想不到该干什么，我就不去跑步了。在宿舍里也是没事，想学习但是没有心思，没心思。','2017-11-18 14:21:43','2017-11-18 14:21:43','on-18-november-2017-logs'),(489,3,3,'樊小纯：借我（小诗）','> 解释参见这里的：https://www.zhihu.com/question/28536070\r\n\r\n借我一个暮年，\r\n\r\n借我碎片，\r\n\r\n借我瞻前与顾后，\r\n\r\n借我执拗如少年。\r\n\r\n借我后天长成的先天，\r\n\r\n借我变如不曾改变。\r\n\r\n借我素淡的世故和明白的愚，\r\n\r\n借我可预知的脸。\r\n\r\n借我悲怆的磊落，\r\n\r\n借我温软的鲁莽和玩笑的庄严。\r\n\r\n借我最初与最终的不敢，借我不言而喻的不见。\r\n\r\n借我一场秋啊，可你说这已是冬天。','2017-11-19 03:13:25','2017-11-19 03:13:25','fanxiaochun-lend-me-poem'),(490,3,3,'漫谈实现网页分割线方法 2 种','最近再做一个网页项目，遇到做分割线样式的地方 2 处，根据环境不同，对应实现了 2 种分割线。下面进行说明。\r\n\r\n![](http://www.baooab.com/wp/wp-content/uploads/2017/11/split.png)\r\n\r\n1. 头部导航\r\n\r\n头部导航的核心代码如下：\r\n\r\n```\r\n<div class=\"siteNavItemHd pipe\">\r\n	<a href=\"javascript: void(0);\">企业采购</a>\r\n</div>\r\n```\r\n\r\n```\r\n.siteNavItemHd a {\r\n    display: inline-block;\r\n    color: #ccc;\r\n}\r\n\r\n.siteNavItemHd.pipe:before {\r\n    content: \"\";\r\n    display: inline-block;\r\n    height: 16px;\r\n    margin-right: 10px;\r\n    border-left: 1px solid #5c5c5c;\r\n    vertical-align: middle;\r\n}\r\n```\r\n\r\n`a` 标签是 inline-block，`:before` 伪类的内容也是 inline-block 的。为了实现 16px 高的 border-left 线条与 `a` 标签垂直居中对齐显示，使用 ` vertical-align: middle` 即可。\r\n\r\n2. 主导航\r\n\r\n下部主导航的核心代码如下：\r\n\r\n```\r\n<ul class=\"navBar clearfix\">\r\n	...\r\n	<li><a href=\"#\">志趣</a></li>\r\n	<li class=\"split\"></li>\r\n	<li><a href=\"#\">为你严选</a></li>\r\n	...\r\n</ul>\r\n```\r\n\r\n```\r\n.nav .navBar li {\r\n    float: left;\r\n}\r\n\r\n.nav .navBar li.split {\r\n    padding: 0;\r\n    border-left: 1px solid #ccc;\r\n    height: 20px;\r\n    margin-top: 8px;\r\n}\r\n```\r\n\r\n这里所有的 li 标签都是浮动的，`.split` 这个 li 也是浮动的。也就是说这里实现的是浮动元素对齐----是通过调整 `margin-top`  的大小实现的----`margin-top: 8px`。\r\n\r\n## 总结\r\n\r\n1. 行内元素对齐通过使用 `vertical-align: middle` 的方式实现。\r\n2. 浮动元素对齐通过调整外边距 `margin` 大小实现。','2017-11-21 09:25:46','2017-11-21 09:25:46','two-kinds-of-rambling-realize-web-line-method'),(491,3,3,'2017年11月21号日志','我想了一下，半天也没想到可以有什么独创性的东西可以贡献出来，不过一直是在拾人牙慧。可见，还是我资历尚浅，经验不足，没有膂力。还是安心跐在路人的肩膀子上吧。我感觉还是时机不够成熟。\r\n\r\n但我又感觉我拿到了去往这条道路上的钥匙。不管断断续续，总是在坚持，希望有所回报。','2017-11-21 10:22:13','2017-11-21 10:22:13','in-november-2017-21-log'),(492,3,3,'Window.getComputedStyle() 和 Element.getBoundingClientRect()','`getComputedStyle` 和 `getBoundingClientRect` 都是用来获得元素的样式信息的。但 `getComputedStyle` 用来获得元素的所有计算出来的样式（结果都是带单位的）；`getBoundingClientRect` 用来返回元素的大小及其相对于视口的位置（结果都无单位）。\r\n\r\n下面是一个例子：\r\n\r\n```\r\n<div class=\"box\"></div>\r\n```\r\n\r\n```\r\nbody {\r\n	margin: 8px;\r\n}\r\n\r\n.box {\r\n	margin-top: 120px;\r\n	width: 100px;\r\n	height: 100px;\r\n	padding: 10px;\r\n	background: lightblue;\r\n	border: 5px solid #ececec;\r\n}\r\n```\r\n\r\n```\r\nvar box = document.querySelector(\'.box\');\r\n```\r\n\r\n## 使用 `getComputedStyle`\r\n\r\n```\r\nvar styles = getComputedStyle(box); \r\n\r\nstyles.width; // \"100px\"\r\nstyles.height; // \"100px\"\r\n```\r\n\r\n注意到：\r\n\r\n1. 这里的结果都是带单位的。\r\n2. `width` 和 `height` 属性求取的是元素的 CSS 属性 `width` 和 `height` 值，并不是元素实际大小（实际大小跟 `padding`、`border`、`box-sizing` 的设置有关）。\r\n\r\n## 使用 `getBoundingClientRect`\r\n\r\n```\r\nbox.getBoundingClientRect();\r\n\r\n// [object ClientRect] {\r\n//   bottom: 250,\r\n//   height: 130,\r\n//   left: 8,\r\n//   right: 138,\r\n//   top: 120,\r\n//   width: 130\r\n// }\r\n```\r\n\r\n已经说过，`Element.getBoundingClientRect()` 方法返回元素的大小及其相对于视口的位置。\r\n\r\n需要注意的是：\r\n\r\n1. 这里的结果不带单位。\r\n2.  `width` 和 `height` 属性值是指元素的实际大小。又分：\r\n	1). `box-sizing: content-box`（即默认情况）：`width` 和 `height` 的值是包含 `padding` 和 `border` 的。\r\n	2). `box-sizing: border-box`：`width` 和 `height` 即元素的 CSS 属性 `width` 和 `height` 值。\r\n3. 相对于视口的位置的属性 `top`、`left`、`right` 和 `bottom` 的计算方式如下图所示。\r\n\r\n![相对于视口的位置属性图解](https://mdn.mozillademos.org/files/15087/rect.png)\r\n\r\n## 兼容性\r\n\r\n- `getComputedStyle`：IE9+\r\n\r\n- `getBoundingClientRect`：IE9+','2017-11-22 03:26:36','2017-11-22 03:26:36','windowgetcomputedstyleelementgetboundingclientrect'),(493,3,3,'Sass 学习笔记之 Mixins','Sass 的文件后缀名有两种：`.sass` 和 `.scss`。先有 `.sass`，后有 `.scss`，`.scss` 能让我们以更接近 CSS 语法的方式去编写 Sass 脚本。\r\n\r\n```\r\n// .sass\r\n$font-stack:    Helvetica, sans-serif\r\n$primary-color: #333\r\n\r\nbody\r\n  font: 100% $font-stack\r\n  color: $primary-color\r\n\r\n// 等同于的 .scss\r\n$font-stack:    Helvetica, sans-serif;\r\n$primary-color: #333;\r\n\r\nbody {\r\n  font: 100% $font-stack;\r\n  color: $primary-color;\r\n}\r\n```\r\n\r\n可以看到，以 `.sass` 为后缀名的文件语法 **以空格区分层次关系，不带分号**；以 `.scss` 为后缀名的文件语法 **每个声明之后以分号结尾，用花括号区分层次关系**。\r\n\r\n## Mixins\r\n\r\nMixin 相当于「函数」，不过调用（更准确地说「包含」）这个函数后，不是简单返回一个值，而是返回一整块 CSS 声明样式----这是为了重用代码。在调用函数后，通过给予不同函数变量，即可改变返回的可重用代码块中不同的那部分。\r\n\r\n下面我们在 `.scss` 文件中定义一个 Mixin `border-radius` 来生成兼容版的边框圆角样式。\r\n\r\n```\r\n@mixin border-radius($radius) {\r\n	-webkit-border-radius: $radius;\r\n	-moz-border-radius: $radius;\r\n	-ms-border-radius: $radius;\r\n	border-radius: $radius;\r\n}\r\n```\r\n\r\n下面就可以将我们之前这样写的代码\r\n\r\n```\r\n.box {\r\n	border-radius: 10px;\r\n}\r\n```\r\n\r\n改成兼容版的了\r\n\r\n```\r\n.box {\r\n	@include border-radius(10px);\r\n}\r\n```\r\n\r\n最终深生成出来的 CSS 代码如下：\r\n\r\n```\r\n.box {\r\n  -webkit-border-radius: 10px;\r\n  -moz-border-radius: 10px;\r\n  -ms-border-radius: 10px;\r\n  border-radius: 10px;\r\n}\r\n```\r\n\r\n当然，同样的功能用 `.sass` 文件后缀语法会显得更加简洁\r\n\r\n```\r\n=border-radius($radius)\r\n  -webkit-border-radius: $radius\r\n  -moz-border-radius: $radius\r\n  -ms-border-radius: $radius\r\n  border-radius: $radius\r\n\r\n.box\r\n  +border-radius(10px)\r\n```\r\n\r\n其实这种语法更能符合直觉---- Minxin `border-radius` 其实是被 **插入** 到 `.box` 中，而不是以「调用」的方式返回的。\r\n\r\n## 实战\r\n\r\n下面我们以定义一个清除浮动的辅助类来是说明 Mixins 的实际使用：\r\n\r\n```\r\n=clearfix\r\n  &:after\r\n    clear: both\r\n    content: \"\"\r\n    display: table\r\n\r\n.is-clearfix\r\n  +clearfix\r\n```\r\n\r\n得到的结果如下：\r\n\r\n```\r\n.is-clearfix:after {\r\n  clear: both;\r\n  content: \"\";\r\n  display: table;\r\n}\r\n```\r\n\r\n我们定义了一个辅助类 `is-clearfix` 用于在父元素上清除浮动影响。\r\n\r\n## `@content`\r\n\r\n定义 Mixin 时，还可以使用一个特殊的指令 `@content`----用来在后面 **使用 Mixin 时，向 Mixin 中插入代码块**。\r\n\r\n这在定义基于媒体查询的 CSS 样式时，非常有用，有例为证：\r\n\r\n```\r\n$tablet: 769px !default;\r\n\r\n@mixin mobile {\r\n	@media screen and (max-width: $tablet - 1px) {\r\n		@content;\r\n	}\r\n}\r\n	\r\n@include mobile {\r\n	.is-block-mobile {\r\n		display: block;\r\n	}\r\n}\r\n```\r\n\r\n最终生成出来的 CSS 样式如下：\r\n\r\n```\r\n@media screen and (max-width: 768px) {\r\n  .is-block-mobile {\r\n    display: block;\r\n  }\r\n}\r\n```\r\n\r\n上面的代码写成 `.sass` 语法会更加简洁。 \r\n\r\n```\r\n$tablet: 769px !default\r\n\r\n=mobile\r\n  @media screen and (max-width: $tablet - 1px)\r\n    @content\r\n\r\n+mobile\r\n  .is-block-mobile\r\n    display: block\r\n```\r\n\r\n我们定义了一个 Mixin `mobile` 用于配置在移动端上的样式----在使用这个 Mixin 时，我们向其 `@content` 中插入的内容是 `.is-block-mobile` 的样式。\r\n\r\n## 总结\r\n\r\n1. 不带 `@content` 指令的 Mixin 可以认为定义的是布局的代码块。\r\n2. 带 `@content` 指令的 Mixin 可以作为独立的代码块在 Sass 文件最高层级定义的。\r\n\r\n当然，要依据具体情况去使用了。','2017-11-24 02:28:46','2017-11-24 03:03:51','mixins-sass-study-notes'),(494,3,3,'Sass 学习笔记之变量类型-----值的列表。','在 Sass 文件中使用 `$var: value` 声明变量。可以声明的数据类型有：\r\n\r\n- numbers (e.g. 1.2, 13, 10px)\r\n- strings of text, with and without quotes (e.g. \"foo\", \'bar\', baz)\r\n- colors (e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5))\r\n- booleans (e.g. true, false)\r\n- nulls (e.g. null)\r\n- lists of values, separated by spaces or commas (e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif)\r\n- maps from one value to another (e.g. (key1: value1, key2: value2))\r\n- function references\r\n\r\n其中有一个就是「值的列表」（lists of values），用空格或者逗号分隔的。\r\n\r\n```\r\n$displays: \'block\', \'flex\', \'inline\', \'inline-block\', \'inline-flex\'\r\n\r\n// 或者\r\n$displays: \'block\' \'flex\' \'inline\' \'inline-block\' \'inline-flex\'\r\n```\r\n\r\n我们可以使用 `@each...in` 指令来遍历这个值的列表的每个项。\r\n\r\n```\r\n$displays: \'block\', \'flex\', \'inline\', \'inline-block\', \'inline-flex\'\r\n\r\n@each $display in $displays\r\n  .is-#{$display}\r\n    display: #{$display} !important\r\n```\r\n\r\n生成的最终样式结果如下：\r\n\r\n```\r\n.is-block {\r\n  display: block !important;\r\n}\r\n\r\n.is-flex {\r\n  display: flex !important;\r\n}\r\n\r\n.is-inline {\r\n  display: inline !important;\r\n}\r\n\r\n.is-inline-block {\r\n  display: inline-block !important;\r\n}\r\n\r\n.is-inline-flex {\r\n  display: inline-flex !important;\r\n}\r\n```\r\n\r\n是不是很方便呢？','2017-11-24 04:25:09','2017-11-24 04:25:09','sass-variable-types-of-learning-notes-the-list-of-values'),(495,3,3,'Sass 学习笔记之变量类型----Map','变量类型 Map 其实就是用 `()` 括起来的键值对的集合，键值之间用 `:` 分隔，每个集合元素之间使用 `,` 分隔。形如：\r\n\r\n```\r\n$map: (key1: value1, key2: value2, key3: value3);\r\n```\r\n\r\n我们使用 `@each...in` 指令来遍历下面这个 Map，来说明其使用的正确方式：\r\n\r\n```\r\n$alignments: (\'centered\': \'center\', \'justified\': \'justify\', \'left\': \'left\', \'right\': \'right\')\r\n\r\n@each $alignment, $text-align in $alignments\r\n  .has-text-#{$alignment}\r\n    text-align: $text-align\r\n```\r\n\r\n上面我们定义了文本对齐方式的辅助类。用到了 Map 类型变量 `$alignments`。每次循环的跌代理， `$alignment` 变量对应键值对里的 `key`，`$text-align` 变量对应键值对里的 `$value`，脚本执行完毕后，会得到如下的 CSS 样式代码：\r\n\r\n```\r\n.has-text-centered {\r\n  text-align: \"center\";\r\n}\r\n\r\n.has-text-justified {\r\n  text-align: \"justify\";\r\n}\r\n\r\n.has-text-left {\r\n  text-align: \"left\";\r\n}\r\n\r\n.has-text-right {\r\n  text-align: \"right\";\r\n}\r\n```\r\n\r\n是不是很方便呢？','2017-11-24 04:37:44','2017-11-30 02:13:36','sass-learning-notes-of-the-variable-types-the-map'),(496,3,3,'今天，我读木心了','上午我去图书馆了看了一会《红楼梦》，是第二遍，可是完全不像是读过的，但感觉上比第一次清晰了一些，也更有兴趣去读了。\r\n\r\n然后将尽中午，没去吃饭，就去书店找木心看了。我原想看的是《诗经演》，但没有，就看了《西班牙三棵树》----几乎没读懂，但还是会看。草草翻了个大概，暂且记录下令我印象深刻的片段。\r\n\r\n1. 《十四年前的一些夜》\r\n\r\n```\r\n自己的毒汁毒不死自己\r\n好难的终于呀\r\n你的毒汁能毒死我\r\n反之，亦然\r\n说了等于不说的话才是情话\r\n\r\n白天走在纯青的钢索上\r\n夜晚宴饮在\r\n软得不能再软的床上\r\n满满一床希腊神话\r\n门外站着百匹木马\r\n那珍珠项链的水灰的线\r\n英国师兄叫它永恒\r\n证之，亦然\r\n干了等于不干的杯才是圣杯\r\n\r\n太古，就是一个人也没有\r\n静得山崩地坼\r\n今夜，太古又来\r\n思之，亦然\r\n静了等于不静的夜才是良夜\r\n```\r\n\r\n「说了等于不说的话才是情话」----我是因为看到了这句才注意这首诗。这样的情话不就是「废话」吗？不是，因为说了，虽然「等于不说」，但聊胜与不说。\r\n\r\n「静了等于不静的夜才是良夜」----安静极了，仿佛回到太古，但内心的思绪泛滥，这样的夜显得格外汹涌。\r\n\r\n2. 《论拥抱》\r\n\r\n```\r\n人体\r\n相互\r\n接触时\r\n\r\n血液中\r\n含氧的血红素\r\n快速\r\n增加\r\n\r\n血红素\r\n使肉身诸因子\r\n均衡\r\n持平\r\n\r\n病者早康复\r\n健者\r\n更毋庸议\r\n\r\n亲爱的\r\n拥抱你\r\n我紧紧拥\r\n抱你\r\n\r\n绝不是\r\n上述的\r\n原因\r\n```\r\n\r\n原因不是血红素，化学生物机理都解释不了，也不是情欲。那是什么？借用《奇怪的她》电影里最后老头的话说：「那是男人的真情」。\r\n\r\n3. 《如歌的岁月》\r\n\r\n```\r\n我是\r\n鋸子\r\n上行\r\n\r\n你是鋸子\r\n下行\r\n合把那樹鋸斷\r\n\r\n兩邊都可\r\n見年輪\r\n一堆清香的屑\r\n\r\n鋸斷了才知\r\n愛情是棵樹\r\n樹已很大了\r\n```\r\n\r\n两人积蓄的爱情多少不知道，而后又慢慢消磨爱情很多年，中间缓慢而又不断的锯屑留香。竟然都这么多了，我们积蓄的爱情居然这样多，没了也没感到可惜，留下来尚可会为的年代记忆，食之如饴。\r\n\r\n4. 《涉及爱情的十个单行》\r\n\r\n```\r\n说纯洁不是说素未曾爱而是说已懂了爱 \r\n无限是还勿知其限的意思没有别的意思 \r\n誓言是那种懒洋洋侧身接过来的小礼物 \r\n现代人是（目夾）（目夾）眼睑就算一首十四行诗了 \r\n何必艳羡硬边之吻几缕不肯绕梁的余韵 \r\n情场上到处可见侥幸者鞋子穿在袜子里 \r\n别人的滂沱快乐滴在我肩上是不快乐的 \r\n到头来彼此负心又濒死难忘的褴褛神话 \r\n没有你时感到寂寞有了你代你感到寂寞 \r\n清晓疯人院里修剪得整整齐齐的冬青树 \r\n```\r\n\r\n「说纯洁不是说素未曾爱而是说已懂了爱」，「没有你时感到寂寞有了你代你感到寂寞」。\r\n\r\n5. 《甜刺猬》\r\n\r\n```\r\n你是船我是车\r\n你是车时我是船\r\n船要和车挤在一起\r\n不是船裂便是车折\r\n及至船载车车曳船\r\n不外乎去修理去卖掉\r\n\r\n初识你呀是个夜\r\n楼梯转角的一瞥\r\n唇涡或眉梢\r\n极微的某点特征\r\n我针刺似的感到\r\n可能酿生什么\r\n\r\n疯人院的铁门口\r\n用脚扫落叶\r\n去年秋天谁知世上有你\r\n喘不过气来的瞬间\r\n心中喝一声懦夫\r\n喘过来便轩昂而笑\r\n\r\n好了 不再劳瘁于思念\r\n虽然啊虽然\r\n我是临街橱窗中的刺猬\r\n巧克力刺猬\r\n视之可怕 食之还不坏\r\n```','2017-11-25 06:02:08','2017-11-25 06:26:29','today-i-read-the-wood-heart'),(497,3,3,'《豆腐匠的哲学》文摘','父母大概深感失望，但我只关心自己做的事，其余皆置之度外。\r\n\r\n所以，我没有称得上是师父的人，只是靠自己的力量坚持了下来。\r\n\r\n五十部作品中，没有一部作品是抱着“要拍部失败作品”的初衷拍成的，所以你问我“得意之作”是哪一部，我也没法回答。今后只要身体健康，我就还会喝着喜欢的酒，继续拍“小津调”的电影吧。\r\n\r\n三十年连续入选十佳第一名的时候，我心里很想找个地洞钻进去。因为在公司，我被说成“尽拍些想要当选第一名的艺术品，却都是些不赚钱的电影”。\r\n\r\n我由衷觉得人也是可以干着、干着、继续干下去的，五十五、六十岁就退休太早了。\r\n\r\n这本书（《电影制作法》）翻译后，引起了很大的轰动，但不过是些“电影中有文学要素、绘画要素和音乐要素，所以电影是艺术”之类平淡无奇的本质论。现在想来，这书只是把不值一提的事故意往深奥里写而已。\r\n\r\n不是单纯的悲伤，是笑中带泪的、复杂而微妙的情感。\r\n\r\n但是在这里不要搞错：电影的文法毕竟是常识，沿袭常识更稳妥，所以也没有必要特意去打破常识。我之所以故意违背，最初是因为日式房间中人物与背景的关联。\r\n\r\n比如有一部优秀的小说，令我深受感动。对我来说，这感动并不会成为我将小说改编成电影的动机。那完全是另外一回事。试着将感动在头脑中置换为电影，那么文学作品与电影的差别会将这种感动变成另一种东西。若会变成另一种东西，那么小说不改编也罢。\r\n\r\n---\r\n\r\n我在看上个世纪日本电影导演小津安二郎的自传性随笔《豆腐匠的哲学》，他曾参加过侵华战争，足迹经过大半个中国，参加过徐州会战争，也来过我们宿州。这本书里的有一节收录了这段时期的战地信笺，读起来能让人感受与以往不同的战地生活印象，看了让人很动容。\r\n\r\n你看，其中一段：\r\n\r\n我点上了台灯，泡了茶，还可以写信。\r\n在大阪请你买的防护面具，虽隔云烟万里，据说效用大矣……星星很美，这就去床前的槐树下长长的小个便回来就睡了。\r\n愿多保重。我也健康安好。','2017-11-25 18:48:03','2017-11-25 18:48:03','bean-curd-goldsmiths-philosophy-abstract'),(498,3,3,'学习 Vue.js：组件之非 prop 特性','所谓非 prop 特性，就是指它可以直接传入组件的根元素上，而不需要在子组件的 props 中显式接收它 。\r\n\r\n## prop 特性\r\n\r\n现在我们就要明白，什么才是 prop 特性呢？它分两种情况：\r\n\r\n1. 静态 prop\r\n\r\n	1) 向子组件中传递数据时，使用的是普通特性的形式：\r\n\r\n		<child my-message=\"hello!\"></child>\r\n\r\n	借助特性 my-message，传给子组件的实际上是一个普通的字符串「hello!」。\r\n\r\n	2) 子组件中显式地用 props 选项声明它\r\n\r\n		props: [\'myMessage\'],\r\n\r\n2. 动态 prop\r\n\r\n	1) 向子组件中传递数据时，使用了 v-bind 指令将特性的值绑定给了父组件的一个数据\r\n\r\n		<child :my-message=\"parentMsg \"></child>\r\n\r\n	借助特性 my-message，传给子组件的实际上是一个动态值。因为特性 my-message 绑定给了父组件数据 parentMsg 了，这样父组件中 parentMsg 的更新会同步到子组件中\r\n\r\n	2) 子组件中显式地用 props 选项声明它\r\n\r\n		 props: [\'myMessage\'],\r\n\r\n## 非 prop 特性\r\n      \r\n下面来讲「非 prop 特性」，其实这是「**静态 prop」的阉割版**，去掉第二步----也就是我们传递给子组件的普通特性如果没有被子组件显式使用 props 属性接收的话，那么这些**普通特性会直接传入到组件的根元素上**！','2017-11-29 08:25:47','2017-11-29 08:27:56','the-prop-learning-vue-js-component-properties'),(499,3,3,'学习 Vue.js： v-model 指令的本质','> `v-model` 指令是为表单元素定制的指令，可以简单理解为可替换为 `v-bind:value` 和 `v-on:input` 的写法。 \r\n\r\n我们知道 `v-model` 指令用于将表单里的值与 Vue 应用的某条数据进行绑定的\r\n\r\n但本质上，**`v-model` 只是一个语法糖**而已：\r\n\r\n	<input type=\"text\" v-model=\"msg\">\r\n\r\n等同于\r\n\r\n	<input type=\"text\" v-bind:value=\"msg\" v-on:input=\"msg = $event.target.value\">\r\n\r\n解释如下：\r\n\r\n1. 将表单框的 `value` 特性绑定给了数据 `msg`，这样 `msg` 的更新就会触发表单框 `value` 的更新。那么 `msg` 值有由谁更新呢，请看第二步。\r\n2. 在表单框里输入内容时，**触发 `input` 事件，从事件对象里获得最新的表单框数据，然后给 `msg`**。msg 更新了，表单框的 value 值就跟着更新了。\r\n\r\n注意：这里 **表单框的 `value` 值一直在依赖绑定数据 `msg`，表单框中输入的内容并没有直接作用在 `value` 上**，这一点一定要注意！这也就是为什么使用了 `v-model` 的表单框的初始 `value` 特性（或者复选框的 `checked` 特性、select 元素的 `selected` 特性）无效的原因，因为此时表单框与 `value` 值毛关系都没有，只与绑定的那个数据值才有关系！\r\n\r\n下面是个例子：\r\n\r\n	<div id=\"app\">\r\n		<p>数据<code>msg</code>的值：{{ msg }}</p>\r\n		<p><input type=\"text\" class=\"input\"  v-model=\"msg\" placeholder=\"使用v-model指令\"></p>\r\n		<p><input type=\"text\" class=\"input\"  :value=\"msg\" @input=\"msg = $event.target.value\" placeholder=\"模拟v-model指令\"></p>\r\n	</div>\r\n	\r\n	<script type=\"text/javascript\">\r\n      new Vue({\r\n        el: \'#app\',\r\n        data: {\r\n          msg: \'\'\r\n        }\r\n      });\r\n    </script>','2017-11-30 02:24:47','2017-12-02 07:17:46','learning-vue-js-v-the-essence-of-the-model-orders'),(500,3,3,'JS PEN：页面&可视区大小、屏幕分辨率','查阅地址：https://codepen.io/zhangbao/full/dZwRWr','2017-12-01 05:46:15','2017-12-01 05:46:15','js-pen-page'),(501,3,3,'Vue.js 学习笔记：Vue 实例、挂载元素和应用数据','在 Vue.js 的世界里，一个应用就是一个 Vue 实例。\r\n\r\n```html\r\n<script src=\"https://unpkg.com/vue\"></script>\r\n<script>\r\n  let app = new Vue();\r\n</script>\r\n```\r\n\r\n有了 Vue 实例，我们还需要为它指定一个 DOM 元素挂载上去，这样就能以 Vue 的方式操作 DOM 了。 \r\n\r\n```html\r\n<div id=\"app\">\r\n  <p>欢迎学习 Vue.js！</p>\r\n</div>\r\n\r\n<script>\r\n  let app = new Vue({\r\n    el: \'#app\'  \r\n  });\r\n</script>\r\n```\r\n\r\n如此一来，挂载元素中的内容也可以用 Vue 管理了。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p>{{ msg }}</p>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    msg: \'欢迎学习 Vue.js！\'\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n`data` 指定应用数据，挂载元素本质上是咱们应用的模板，我们可以在模板中直接使用 `{{ }}` 解析 `data` 中的属性值。\r\n\r\n上面例子中，最终渲染出来的 HTML 结构如下：\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p>欢迎学习 Vue.js！</p>\r\n</div>\r\n```','2017-12-01 07:53:15','2017-12-01 08:02:24','vue-js-learning-notes-first'),(502,3,3,'Vue.js 学习笔记：访问 Vue 实例的属性和方法','Vue 实例中，`data` 定义应用数据----是用户定义的数据，除了可以在模板中使用 `{{ }}` 访问，还可以作为 Vue 实例的属性直接访问。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p>{{ msg }}</p>\r\n</div>\r\n\r\n<script src=\"https://unpkg.com/vue\"></script>\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    msg: \'欢迎学习 Vue.js！\'\r\n  }\r\n});\r\n\r\napp.msg; // \"欢迎学习 Vue.js！\"\r\n</script>\r\n```\r\n\r\n为了与用户定义的数据区分开来，访问 Vue 实例对象上原本的属性与方法，都需要跟上前缀 `$`。\r\n\r\n```javascript\r\nvar data = {\r\n  msg: \'欢迎学习 Vue.js！\'\r\n};\r\n\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: data\r\n});\r\n\r\napp.$el === document.querySelector(\'#app\'); // true\r\napp.$data === data; // true\r\n\r\n// $watch 是一个实例方法\r\napp.$watch(\'msg\', function (newV, oldV) {\r\n  // 这个回调将在 `app.msg` 改变后调用\r\n  console.log(\'新值: \', newV, \', 旧值: \', oldV);\r\n});\r\n```','2017-12-01 08:18:13','2017-12-01 08:18:13','vue-js-learning-notes-access-properties-and-methods-of-the-vue-instance'),(503,3,3,'Vue.js 学习笔记：Vue 实例的生命周期','每个 Vue 实例在被创建之前都要经过一系列的初始化过程，在这个过程中也会运行一些 **钩子函数**。\r\n\r\n常用的钩子函数包括：\r\n\r\n- `created`：到这一阶段，可以访问用户自定义数据（`data`）。\r\n- `mounted`：到这一阶段，可以访问 Vue 实例上的属性和方法（如：`$el`、`$watch` 等）。\r\n- `destroyed`：实例被销毁后，调用此钩子（我们可以使用 Vue 实例的 `$destroy` 方法手动销毁 Vue 实例以便触发此钩子）。\r\n\r\n下面提供例子代码（[源码](https://codepen.io/zhangbao/pen/NwewBp)）：\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p><input type=\"text\" v-model=\"msg\"></p>\r\n  <p><button @click=\"del\">销毁 Vue 实例</button></p>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    msg: \'欢迎学习 Vue.js！\'\r\n  },\r\n  created: function () {\r\n    console.log(\'进入声明周期 created\');\r\n  },\r\n  mounted: function () {\r\n    console.log(\'进入声明周期 mounted\');\r\n    console.log(\'此时可以访问 Vue 实例的属性和方法了：\');\r\n    console.log(\'比如访问 msg，得 \"\' + this.msg + \'\"\');\r\n    console.log(\'比如访问 $data，得 \"\' + this.$data + \'\"\');\r\n    console.log(\'访问 $el，得 \"\' + this.$el + \'\"\');\r\n  },\r\n  updated: function () {\r\n    console.log(\'应用中每当有数据更新时，你就会看到我。\');\r\n  },\r\n  destroyed: function () {\r\n    console.log(\'Vue 实例已被销毁了。\');\r\n  },\r\n  methods: {\r\n    del: function () {\r\n      this.$destroy();\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n完整的声明周期图如下所示：\r\n\r\n![Vue 实例声明周期图](https://cn.vuejs.org/images/lifecycle.png \'Vue 实例声明周期图\')','2017-12-01 09:00:54','2017-12-01 09:02:43','vue-js-learning-notes-vue-instance-statement-cycle'),(504,3,3,'被誉为神器的 requestAnimationFrame','> 原文地址：https://www.w3cplus.com/javascript/requestAnimationFrame.html\r\n\r\n1. IE9- 浏览器不支持该方法。\r\n2. `requestAnimationFrame` 是 HTML5 新增的定时器方法，属于处理动画的 API。\r\n3. `requestAnimationFrame` 的用法与 `setTimeout` 作用一样，只是不需要设置时间间隔而已。\r\n\r\n并且，**`requestAnimationFrame` 采用系统时间间隔**，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。\r\n\r\n所以其兼容函数可以写：\r\n\r\n```\r\nif (!window.requestAnimationFrame) { \r\n	requestAnimationFrame = function(fn) { \r\n		setTimeout(fn, 17); \r\n	}; \r\n}\r\n```\r\n\r\n这里的 17 是这样计算出来的----大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60 次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是 1000ms/60，约等于 16.6ms。\r\n\r\n下面附上 `requestAnimationFrame` polyfill：\r\n\r\n```\r\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\r\n\r\n// requestAnimationFrame polyfill by Erik Möller\r\n// fixes from Paul Irish and Tino Zijdel\r\n\r\n(function() {\r\n    var lastTime = 0;\r\n    var vendors = [\'ms\', \'moz\', \'webkit\', \'o\'];\r\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n        window.requestAnimationFrame = window[vendors[x]+\'RequestAnimationFrame\'];\r\n        window.cancelAnimationFrame = window[vendors[x]+\'CancelAnimationFrame\'] \r\n                                   || window[vendors[x]+\'CancelRequestAnimationFrame\'];\r\n    }\r\n \r\n    if (!window.requestAnimationFrame)\r\n        window.requestAnimationFrame = function(callback, element) {\r\n            var currTime = new Date().getTime();\r\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, \r\n              timeToCall);\r\n            lastTime = currTime + timeToCall;\r\n            return id;\r\n        };\r\n \r\n    if (!window.cancelAnimationFrame)\r\n        window.cancelAnimationFrame = function(id) {\r\n            clearTimeout(id);\r\n        };\r\n}());\r\n```','2017-12-01 09:28:48','2017-12-01 09:36:19','transfer-is-regarded-as-a-requestanimationframe-artifact'),(505,3,3,'Vue.js 学习笔记：文本插值和输出原始 HTML','文本插值是 Vue 中数据绑定最常见的形式，也就是在 Vue 模板中插入咱们 Vue 实例中提供的数据（`data`），使用双大括号（`{{ }}`）语法；文本插值也是绑定数据，当绑定的数据改变时，对应文本插值的地方也会同步改变，这就是数据绑定（[源码](https://codepen.io/zhangbao/pen/RjvPoQ)）。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <!-- 输出结果\"<p>欢迎学习 &lt;strong&gt;Vue.js&lt;/strong&gt;！&lt;/p&gt;\"-->\r\n  <p>{{ msg }}</p>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    msg: \'欢迎学习 <strong>Vue.js</strong>！\'\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n如果插入文本的地方只是为了初始化内容，数据只用一次，也就是不需要绑定数据，那就要用到 `v-once` 指令----这称为一次性文本插值，数据插入后就不在同步改变了。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p v-once>{{ msg }}</p>\r\n</div>\r\n```\r\n\r\n你可能发现了，数据中的 HTML 标签在输出时被转移为对应的实体字符了，这是因为 `{{ }}` 中的变量内容默认是当做纯文本输出的。如果输出的是原始 HTML 内容怎么办呢？答案是使用 `v-html` 指令。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <!-- 输出结果\"<p>欢迎学习 <strong>Vue.js</strong>！</p>\" -->\r\n  <p v-html=\"msg\"></p>\r\n</div>\r\n```\r\n\r\n这里我们不再使用 `{{ }}`，而是使用 `v-html` 指令绑定数据。','2017-12-02 01:43:26','2017-12-02 01:43:26','vue-js-learning-notes-raw-html-text-interpolation-and-output'),(506,3,3,'JavaScript 中的真值（Truthy）和假值（falsy）','在 JavaScript 中，Truthy（真值）指的是经 Boolean 函数转换后的值为 `true` 的值；对应地，假值（falsy）指的是经 Boolean 函数转换后的值为 `false` 的值。\r\n\r\n除假值之外的值都是真值。\r\n\r\n假值范围包括：`false`，`0`，`\'\'`，`null`，`undefined` 和 `NaN`。\r\n\r\n所以真值是除 `false`，`0`，`\"\"`，`null`，`undefined` 和 `NaN` 之外的值。\r\n\r\n参考链接：\r\n\r\n- [Truthy](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)，MDN','2017-12-02 02:14:14','2017-12-02 02:14:14','the-true-value-of-javascript-truthy-and-false-value-falsy'),(507,3,3,'Vue.js 学习笔记：绑定 HTML 特性','我们已经学习过使用双大括号语法（`{{ }}`）插值了，这是操作标签内容，如果需要我们操作标签特性，我们怎么做呢----使用 `v-bind` 指令。\r\n\r\n`v-bind` 指令后头用 `:` 跟着咱们的要绑定的特性，然后在使用 `=\"xxx\"` 的形式绑定数据 `xxx`---- `xxx` 是指一个表达式。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p v-bind=\"dynamicId\">这里有一个按钮：<button v-bind:disabled=\"isButtonDisabled\">我是按钮</button></p>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    dynamicId: 22\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n上面案例中最终渲染出来的 HTML 结构如下：\r\n\r\n```html\r\n<p id=\"22\">这里有一个按钮：<button disabled=\"disabled\">我是按钮</button></p>\r\n```\r\n\r\n需要注意的是，这里的 `id` 和 `disabled` 特性都是动态渲染出来的，如果 Vue 中对应数据发生改变，HTML 结构也会重新渲染。所以这儿的 `id` 和 `disabled` 特性不是固定不变的。\r\n\r\n还有需要注意的是，在 Vue 中，`disabled` 这种开关属性是通过 [真值/假值](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy) 来控制效果的，比如 true 就是真值，所以渲染出来的 button 是 disable 的状态。\r\n\r\n在 Vue 中适用此方式的开关特性还有单个复选框的 `checked` 特性，其他就没有了。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p v-bind=\"dynamicId\">这里有一个按钮：<button v-bind:disabled=\"isButtonDisabled\">我是按钮</button></p>\r\n  <p><input type=\"checkbox\" v-bind:checked=\"isOptionChecked\"></p>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    dynamicId: 22,\r\n    isButtonDisabled: true\r\n  }\r\n});\r\n</script>\r\n```','2017-12-02 02:18:58','2017-12-02 02:19:52','vue-js-learning-notes-binding-html-features'),(508,3,3,'Vue.js 学习笔记：在文本插值时使用 JavaScript 表达式','在我们之前学习过得文本插值的地方----`v-bind:attr=\"xxx\"` 和 `{{ }}` 中我们绑定的都是简单的数据值，其实 **文本插值从本质上说是输出了表达式的返回值**。\r\n\r\n```\r\n{{ msg }}\r\n```\r\n\r\n等同于控制台上的\r\n\r\n```javascript\r\nvar msg = \'I am a message!\';\r\nmsg; // 这一句。表达式返回了结果值 \"I am a message!\"\r\n```\r\n\r\n所以在文本插值的地方我们可以使用表达式来简单处理数据后输出：\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p>{{ num = 22 }}</p><!-- 此处会输出 2，但没有什么意义，在此只是为了说明，文本插值输出的内容是表达式返回值这一本质 -->\r\n  <p>{{ number + 1 }}</p>\r\n  <p>{{ ok ? \'YES\' : \'NO\' }}</p>\r\n  <p>{{ message.split(\'\').reverse().join(\'\') }}</p>\r\n  <p v-bind:id=\"\'list-\' + id\">{{ message }}</p>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\nel: \'#app\',\r\n  data: {\r\n    number: 1,\r\n    ok: false,\r\n    message: \'I am a message!\',\r\n    id: \'zhangb\'\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n所以，在文本插值时，「使用语句是没有实际意义的、使用流控制更是无效、会报错的」。\r\n\r\n```html\r\n<!-- 这是语句，不会报错，但输出 undefined，没有什么使用意义 -->\r\n{{ var a = 1 }}\r\n\r\n<!-- 这是流控制，不会生效会报错，此种情况请使用三元表达式 -->\r\n{{ if (ok) { return message; } }}\r\n```','2017-12-02 02:45:21','2017-12-02 02:45:21','vue-js-learning-notes-when-the-text-interpolation-using-javascript-expression'),(509,3,3,'Vue.js 学习笔记：指令 (Directives) 是带有 v- 前缀的特殊属性','## 什么是指令？\r\n\r\n在 Vue.js 上，指令（Directives）是指带有 `v-` 前缀的特殊属性，是为了方便操作应用而引入的。\r\n\r\n比如，我们用 `v-if` 指令指定标签元素的渲染与否。\r\n\r\n```html\r\n<p v-if=\"seen\">如果 v-if 为 true 的话，你就能看到我；否则是看不见我的。</p>\r\n```\r\n\r\n指令也能接收参数，在指令后以冒号（`:`）给出，然后再指定绑定的数据值。以 `v-bind` 指令为例。\r\n\r\n```html\r\n<a v-bind:href=\"url\">数据 url 被绑定给了 href 特性</a>\r\n```\r\n\r\n另一个例子是 `v-on` 指令，它用于监听 DOM 事件：\r\n\r\n```html\r\n<a v-on:click.prevent=\"doSomething\">当点击这个链接时，会调用 doSomething 这个方法处理一些事情</a>\r\n```\r\n\r\n*`.prevent` 是事件修饰符，用来阻止默认行为，之后会讲到。*\r\n\r\n下面我们使用指令来完成一个可以切换搜索引擎的搜索功能框（[在线源码](https://codepen.io/zhangbao/pen/XzOmma)）。其中用到 [Bulma CSS](https://bulma.io/) 的样式。\r\n\r\n## 一个例子\r\n\r\n```html\r\n<link rel=\"stylesheet\" href=\"https://unpkg.com/bulma@0.6.1/css/bulma.css\">\r\n<script src=\"https://unpkg.com/vue@2.5.9/dist/vue.js\"></script>\r\n\r\n<div id=\"app\">\r\n  <div class=\"section\">\r\n    <form method=\"get\" v-bind:action=\"url\" target=\"_blank\">\r\n      <div class=\"field has-addons\">\r\n        <p class=\"control\">\r\n          <span class=\"select\">\r\n            <select v-model=\"selected\">\r\n              <option disabled value=\"\">--- 请选择 ---</option>\r\n              <option v-for=\"(enginee, name) in enginees\">{{ name }}</option>\r\n            </select>\r\n          </span>\r\n        </p>\r\n        <p class=\"control\">\r\n          <input class=\"input\" type=\"text\" v-bind:name=\"query\">\r\n        </p>\r\n        <p class=\"control\">\r\n          <input type=\"submit\" value=\"搜索\" class=\"button\">\r\n        </p>\r\n      </div>\r\n    </form>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    enginees: {\r\n      \'百度\': {\r\n        url: \'https://www.baidu.com/s\',\r\n        query: \'wd\'\r\n      },\r\n      \'必应\': {\r\n        url: \'http://cn.bing.com/\',\r\n        query: \'q\'\r\n      },\r\n      \'Google\': {\r\n        url: \'https://www.google.com.hk/search\',\r\n        query: \'q\'\r\n      }\r\n    },\r\n    selected: \'必应\',\r\n    url: \'\',\r\n    query: \'\'\r\n  },\r\n  created: function () {\r\n    for (name in this.enginees) {\r\n      if (name === this.selected) {\r\n        this.url = this.enginees[name].url;\r\n        this.query = this.enginees[name].query;\r\n        break;\r\n      }\r\n    }\r\n  },\r\n  updated: function () {\r\n    var name = this.selected;\r\n    this.url = this.enginees[name].url;\r\n    this.query = this.enginees[name].query;\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n1. 用`v-bind` 指令绑定了 form 的 `action`、input 的 `name` 特性；\r\n2. 用 `v-for` 指令遍历所有搜索引擎，完成 option 的初始化；\r\n3. 用 `v-model` 指令监听 select 被选择的值，每当 select 选项值发生改变时，都会触发生命周期钩子函数 `updated`，我们在这里更新 `v-bind` 指令绑定的 `url` 和 `q` 数据值。\r\n\r\n## 指令修饰符\r\n\r\n指令修饰符就是在指令后头、`=\"xxx\"` 前头的那部分内容（是可选择的），用半角句号（`.`）开头以示区分。\r\n\r\n比如我们要自定义 form 表单提交逻辑，那么就可以用 `.prevent` 这个指令修饰符来阻止默认表单的提交行为，而使用自己定义的提交逻辑。\r\n\r\n```html\r\n<form v-on:submit.prevent=\"onSubmit\"></form>\r\n```\r\n\r\n现在我们就可以使用 `onSubmit` 方法中的逻辑来处理表单请求了。','2017-12-02 04:41:07','2017-12-02 04:51:59','vue-js-learning-notes-instruction-directives-is-a-special-attribute-with-v-prefix'),(510,3,3,'Vue.js 学习笔记：v-bind 和 v-on 指令的简写形式','Vue 中的指令使用 `v-` 前缀作为一种视觉提示，标记 Vue 提供的特殊属性。但是有如下缺点：\r\n\r\n1. 对于一些频繁用到的指令来说，写起来繁琐。\r\n2. 构建 Vue.js 单页面应用程序时，用 `v-` 前缀标记是 Vue 引用也显得没那么重要了。\r\n\r\n所以，针对常用的 `v-on` 和 `v-bind` 指令，Vue 提供了特定的简写形式\r\n\r\n- `v-bind` 简写为 `:`。\r\n\r\n```html\r\n<!-- 完整语法  -->\r\n<a v-bind:href=\"url\">...</a>\r\n\r\n<!-- 缩写 -->\r\n<a :href=\"url\">...</a>\r\n```\r\n\r\n- `v-on` 简写为 `@`。\r\n\r\n```html\r\n<!-- 完整语法 -->\r\n<a v-on:click=\"doSomething\">...</a>\r\n\r\n<!-- 缩写 -->\r\n<a @click=\"doSomething\">...</a>\r\n```\r\n\r\n下面举一个例子：我们在输入框中输入按钮主题，然后下面的按钮就会按照对应主题来显示（[在线演示](https://codepen.io/zhangbao/pen/WXPQYp)）。同样用到了 [Bulma CSS](https://bulma.io/) 这个样式库。\r\n\r\n```html\r\n<link rel=\"stylesheet\" href=\"https://unpkg.com/bulma@0.6.1/css/bulma.css\">\r\n<script src=\"https://unpkg.com/vue@2.5.9/dist/vue.js\"></script>\r\n\r\n<div id=\"app\">\r\n  <div class=\"section\">\r\n    <div class=\"field\">\r\n      <div class=\"control\">\r\n        <input class=\"input\" type=\"text\" name=\"btnType\" :value=\"inputText\" @input=\"inputText = $event.target.value.trim()\">\r\n      </div>\r\n      <p class=\"help\">\r\n        输入<code>primary</code>、<code>link</code>、<code>info</code>、<code>success</code>、<code>danger</code>和<code>warning</code>中的任意一个，既能看到对应的主题的按钮效果了（不区分大小写）。\r\n      </p>\r\n    </div>\r\n    <div class=\"field\">\r\n      <div class=\"control\">\r\n        <button :class=\"[\'button\', buttonThemeClass]\">{{ buttonText }} Button</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    inputText: \'\',\r\n    buttonThemeClass: \'\',\r\n    buttonText: \'Default\'\r\n  }, \r\n  watch: {\r\n    inputText: function (newText) {\r\n      var newText = newText.toLowerCase();\r\n      \r\n      if ([\'primary\', \'link\', \'info\', \'success\', \'warning\', \'danger\'].indexOf(newText) > -1) {\r\n        this.buttonText = newText.charAt(0).toUpperCase() + newText.substr(1);\r\n        this.buttonThemeClass = \'is-\' + newText; \r\n        return ;\r\n      }\r\n\r\n      this.buttonText = \'Default\';\r\n      this.buttonThemeClass = \'\';\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n两个指令简写我们都用在了 input 上，`:value=\"inputText\"` 将 value 特性绑定到了 `inputText`，这样每当 `inputText` 值改变就同步更新在 input 上了；`@input=\"inputText = $event.target.value.trim()\"` 保证在输入框里输入内容时，更新`inputText` 的值，这样的话 input 的 `value` 也跟着更新了。\r\n\r\n这里使用了 Vue 实例的 `watch` 方法来监听数据 `inputText` 的变化，每当 `inputText` 的值发生改变就会调用回调函数，把最新的值（`newText`）作为参数传递进去，然后处理 `buttonText` 和 `buttonThemeClass` 数据的值，它们都会作用在最终的按钮显示效果上。\r\n\r\n可以把 `watch` 方法当做一种面向切面编程---在观察的数据发生改变时做些事情，不必去修改主线任务的代码。\r\n\r\n当然，以后学习过 `v-model` 之后就知道\r\n\r\n```html\r\n<input class=\"input\" type=\"text\" name=\"btnType\" :value=\"inputText\" @input=\"inputText = $event.target.value.trim()\">\r\n\r\n<!-- 基本可以简写为 -->\r\n<input class=\"input\" type=\"text\" name=\"btnType\" v-model.trim=\"inputText\">\r\n```','2017-12-02 07:14:09','2017-12-02 07:14:39','vue-js-learning-notes-v-bind-and-v-on-the-instructions-of-shorthand'),(511,3,3,'罗密欧和朱丽叶的情话','看过朱丽叶在阳台上对罗密欧说过的情话，朱丽叶说：亲爱的，如果你觉得我是那么容易就接受了你的爱，让你觉得很廉价，那么我可以学着不愿意的样子，拒绝你，让你追求我，再拒绝你，然后你再追求我，还拒绝你，然后你接二连三地追求我。慢慢地，我在这些追求中，给你被我接受的假象，可我不愿意。罗密欧说，我也不愿意。','2017-12-02 08:50:42','2017-12-13 01:16:51','romeo-and-juliets-prattle'),(512,3,3,'Vue.js 学习笔记：计算属性','为什么要有计算属性呢？因为在模板中放入太多的逻辑会让模板过重且难以维护。下面的例子里：\r\n\r\n```html\r\n<div id=\"example\">\r\n  {{ message.split(\'\').reverse().join(\'\') }}\r\n</div>  \r\n```\r\n\r\n上例中实现的功能是把 `message` 这条信息反转显示。但它有下面的缺点：\r\n\r\n1. 你必须看一段时间才能意识到是这个功能。\r\n2. 如果在模板中有多次引用此处的翻转字符串时，就要写好几个，这样就不好维护了。\r\n\r\n所以，**对于任何复杂逻辑，你都应当使用计算属性，而且，你可以像绑定普通属性一样在模板中绑定计算属性**。\r\n\r\n## 计算属性\r\n\r\n计算属性在 `computed` 属性中声明。\r\n\r\n```html\r\n<div id=\"#app\">\r\n  <!-- <p>计算后的翻转字符串：!sj.euV olleH。</p> -->\r\n  <p>计算后的翻转字符串：{{ reverseMsg }}。</p>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'app\',\r\n  data: {\r\n    msg: \'Hello Vue.js!\'\r\n  },\r\n  computed: {\r\n    reverseMsg: function () {\r\n      return this.msg.split(\'\').reverse.join(\'\');   \r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n需要注意的是，**计算属性会基于它们的依赖进行缓存**。如果依赖变量没有更新，则计算属性也不会更新，后续使用到的这个计算属性值都是之前缓存下来的；如果依赖变量更新了，计算属性就会同步更新。\r\n\r\n所以下面这个情况，自页面打开后，时间不再改变。\r\n\r\n```html\r\n<p>页面打开时间：<time>{{ now }}</time></p>\r\n\r\n<script>\r\nnew Vue({\r\n  ...\r\n  computed: {\r\n    ...\r\n    now: function () {\r\n      return (new Date).toLocaleString();\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## 计算属性的 setter\r\n\r\n上面对计算属性 `reverseMsg` 的声明只等于声明了计算属性的 getter，所以你无法设置计算属性 `reverseMsg` 的值。\r\n\r\n```javascript\r\nnew Vue({\r\n  ...\r\n  computed: {\r\n    reverseMsg: function () {\r\n        return this.msg.split(\'\').reverse().join(\'\');\r\n    }\r\n  }\r\n});\r\n\r\n// 等同于\r\nnew Vue({\r\n  ...\r\n  computed: {\r\n    reverseMsg: {\r\n      get: function () {\r\n        return this.msg.split(\'\').reverse().join(\'\');\r\n      }\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n如果需要设置计算属性的值，就需要定义计算属性的 setter。\r\n\r\n```html\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    msg: \'Hello Vue.js!\'\r\n  },\r\n  computed: {\r\n    reverseMsg: {\r\n      get: function () {\r\n        return this.msg.split(\'\').reverse().join(\'\');\r\n      },\r\n      set: function (newMsg) {\r\n        this.msg = newMsg.split(\'\').reverse().join(\'\');\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\napp.reverseMsg2 = \'你好，世界！\';\r\n```\r\n\r\n因为 `reverseMsg` 的值是依赖于 `msg` 的，所以设置计算属性的值就是设置所依赖的那个数据的值，对应到此例中，设置计算属性 `reverseMsg` 的值就是设置所依赖的数据 `msg` 的值。依赖的数据值改变之后，计算属性值自然就改变了。\r\n\r\n所以，**可以看出来，同一个计算属性的 setter 和 getter 其实是互逆运算**！\r\n\r\n## 一个例子\r\n\r\n```html\r\n<p>您的全名：{{ fullName }}</p>\r\n<p><input type=\"text\" v-model=\"firstName\"><input type=\"text\" v-model=\"lastName\"></p>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    firstName: \'\',\r\n    lastName: \'\'\r\n  },\r\n  computed: {\r\n    fullName: {\r\n      get: function () {\r\n        return this.firstName + \' \' + this.lastName;\r\n      },\r\n      set: function (newFullName) {\r\n        var names = newFullName.split(\' \');\r\n        this.firstName = names[0];\r\n        this.lastName = names[names.length - 1];\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\napp.fullName = \'zhang bao\';\r\n</script>\r\n```\r\n\r\n这个例子有两个功能点：\r\n\r\n1. 修改 `firstName` 和 `lastName` 的值后，计算属性 `fullName` 会同步更新。\r\n2. 直接设置计算属性 `fullName` 的值时，会对应设置到 `firstName` 和 `lastName` 上。\r\n\r\n可查看：[在线源码](https://codepen.io/zhangbao/pen/BmMYRO)。','2017-12-03 03:36:37','2017-12-03 03:36:37','vue-js-learning-notes-calculate-attribute'),(513,3,3,'Vue.js 学习笔记：自定义 watch 侦听器','虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。\r\n\r\n自定义侦听器用来侦听数据的改变，在 `watch` 属性中声明侦听的数据并提供回调处理函数。这听起来和计算属性很像，但区别是：\r\n\r\n1. 侦听数据在依赖数据变化时通常执行「异步」或「开销较大」的操作，而不是计算属性中简单的数据处理。\r\n2. 侦听数据和依赖的数据的结构可能很不同。\r\n\r\n下面我们举一个查询 Github 上热门仓库的例子（[在线源码](https://codepen.io/zhangbao/full/jadZKg)）。其中会使用 [axios](https://github.com/axios/axios) 和 [lodash](https://github.com/lodash/lodash)。axios 发送异步请求，lodash 做防抖动处理。\r\n\r\n```html\r\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.17.4/lodash.min.js\"></script>\r\n<script src=\"https://unpkg.com/axios@0.17.1/dist/axios.min.js\"></script>\r\n<script src=\"https://unpkg.com/vue@2.5.9/dist/vue.js\"></script>\r\n\r\n<div id=\"app\">\r\n  <p><input type=\"text\" v-model.trim=\"q\"><span>{{ tip }}</span></p>\r\n  <ul>\r\n    <li v-for=\"item in items\">\r\n      <a :href=\"item.html_url\" target=\"_blank\">{{ item.full_name }}</a>\r\n    </li>\r\n  </ul>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    q: \'\',\r\n    tip: \'输入内容才可搜索哦~\',\r\n    items: []\r\n  },\r\n  watch: {\r\n    q: function (newV) {\r\n      if (!newV) {\r\n        this.tip = \'输入内容才可搜索哦~\';\r\n        this.items = [];\r\n        return ;\r\n      }\r\n      this.tip = \'等待您结束输入……\';\r\n      this.getAnswer();\r\n    }\r\n  },\r\n  methods: {\r\n    getAnswer: _.debounce(function () {\r\n      this.tip = \'正在用力搜索中，请稍后……\';\r\n      var vm = this; \r\n      axios.get(\'https://api.github.com/search/repositories?q=\' + encodeURIComponent(vm.q) + \'&sort=stars\')\r\n        .then(function (response) {\r\n          if (response.data.total_count > 0) {\r\n            vm.tip = \'OK，搜索成功！\';\r\n            vm.items = response.data.items;\r\n            return ;\r\n          }\r\n\r\n          vm.items = [];\r\n          vm.tip = \'无结果\';\r\n        })\r\n        .catch(function (error) {\r\n          console.log(\'Error! Could not reach the API. \', error);\r\n        });\r\n    }, 500)\r\n  }\r\n});\r\n</script>\r\n```','2017-12-03 04:25:32','2017-12-03 04:25:32','vue-js-learning-notes-custom-watch'),(514,3,3,'Vue.js 学习笔记：操作元素的 class 特性','可以使用 `v-bind` 指令对 HTML 标签的 `class` 和 `style` 特性进行字符串拼接。不过，字符串拼接麻烦且易错。因此，**在将 `v-bind` 用于 `class` 和 `style` 时，Vue.js 做了专门的增强----表达式返回结果除了字符串类型之外，还可以是对象或数组**。\r\n\r\n## 对象语法\r\n\r\n```\r\nv-bind:class=\"{ \'className1\': Truthy|falsy, \'className2\': Truthy|falsy }\"\r\n```\r\n\r\n如你所见，提供给 `class` 特性的对象由一个个键值对组成----键代表类名；值代表该类名是否显示的真值/假值，为真值时显示类名，为假值时不显示类名。\r\n\r\n*补充：Truthy（真值）指的是经 `Boolean` 函数转换后的值为 `true` 的值。除了 `false`、`0`、`\"\"`、`null`、`undefined` 和 `NaN` 外，其他所有值都是真值。*\r\n\r\n### 与 `class` 特性共存\r\n\r\n此外，`v-bind:class` 还可与普通的 `class` 特性共存。有如下的模板结构和 `data`：\r\n\r\n```html\r\n<div class=\"static\" v-bind:class=\"{ \'active\': isActive, \'text-danger\': hasError }\">\r\n```\r\n\r\n```javascript\r\ndata: {\r\n  isActive: true,\r\n  hasError: false\r\n}\r\n```\r\n\r\n最终渲染出来的结果如下：\r\n\r\n```html\r\n<div class=\"static active\"></div>\r\n```\r\n\r\n### 绑定单独的类对象\r\n\r\n`v-bind:class` 绑定的类对象还可以单独拿出来定义。\r\n\r\n```html\r\n<div class=\"box\" v-bind:class=\"classObject\"></div>\r\n```\r\n\r\n```javascript\r\ndata: {\r\n  classObject: {\r\n    \'active\': false,\r\n    \'text-danger\': true\r\n  }\r\n}\r\n```\r\n\r\n甚至可以把计算属性算出来对象作为绑定类对象使用。\r\n\r\n```html\r\n<div class=\"box\" v-bind:class=\"classObject\"></div>\r\n```\r\n\r\n```javascript\r\ndata: {\r\n  isActive: true,\r\n  hasError: true,\r\n  error: null\r\n},\r\ncomputed: {\r\n  classObject: {\r\n    \'active\': this.isActive && !this.error,\r\n    \'text-danger\': this.error && this.error.type === \'fatal\'\r\n  }  \r\n}\r\n```\r\n\r\n### 一个例子\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p><button class=\"button\" v-bind:class=\"{ \'is-active\': isActive, \'is-danger\': hasError }\">Button</button></p>\r\n  <p><button class=\"button\" v-bind:class=\"classObject\">Button</button></p>\r\n  <p><button class=\"button\" v-bind:class=\"classObject2\">Button</button></p>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    isActive: true,\r\n    hasError: true,\r\n    error: null,\r\n    classObject: {\r\n      \'is-active\': false,\r\n      \'is-danger\': true\r\n    }\r\n  },\r\n  computed: {\r\n    classObject2: function () {\r\n      return {\r\n        \'is-active\': this.isActive && !this.error,\r\n        \'is-danger\': this.error && this.error.type === \'fatal\'\r\n      };\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n最终渲染出来的结构如下。\r\n\r\n```html\r\n<p><button class=\"button is-active is-danger\">Button</button></p>\r\n<p><button class=\"button is-danger\">Button</button></p>\r\n<p><button class=\"button is-active\">Button</button></p>\r\n```\r\n\r\n## 数组语法\r\n\r\n如果 `v-bind:class` 绑定的是一个数组，那么 **数组里列出的元素的值都会出现在最终的渲染 class 特性中**。\r\n\r\n```html\r\n<div class=\"box\" v-bind:class=\"[activeClass, errorClass]\"></div>\r\n<div class=\"box\" v-bind:class=\"[\'custom-class\', activeClass, errorClass]\"></div>\r\n```\r\n\r\n```javascript\r\ndata: {\r\n  activeClass: \'is-active\',\r\n  errorClass: \'is-danger\'\r\n}\r\n```\r\n\r\n最终渲染出来的结构如下：\r\n\r\n```html\r\n<div class=\"box is-active is-danger\"></div>\r\n<div class=\"box custom-class is-active is-danger\"></div>\r\n```\r\n\r\n还可以在数组中做判断。\r\n\r\n```html\r\n<div class=\"box\" v-bind:class=\"[isActive ? activeClass : \'\', errorClass]\"></div>\r\n```\r\n\r\n```javascript\r\ndata: {\r\n  isActive: false,\r\n  activeClass: \'is-active\',\r\n  errorClass: \'is-danger\'\r\n}\r\n```\r\n\r\n最终渲染出的效果如下：\r\n\r\n```html\r\n<div class=\"box\" v-bind:class=\"box is-danger\"></div>\r\n```\r\n\r\n但当有多个判断时，写起来会很不方便，所以也可以在数组语法其中使用对象语法：\r\n\r\n```html\r\n<div v-bind:class=\"[{ \'active\': isActive }, errorClass]\"></div>\r\n```\r\n\r\n可以看出，当 `isActive` 为 `true` 时，等同于\r\n\r\n```html\r\n<div v-bind:class=\"[\'active\', errorClass]\"></div>\r\n```\r\n\r\n当 `isActive` 为 `false` 时，等同于\r\n\r\n```html\r\n<div v-bind:class=\"[errorClass]\"></div>\r\n```\r\n\r\n## 在自定义组件上使用 class 特性\r\n\r\n当在自定义组件上使用 `class` 特性时，这个类会被添加到该组件的根元素上面。并且，根元素上已经存在的类不会被覆盖。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <my-component class=\"baz boo\"></my-component>\r\n</div>\r\n\r\n<script type=\"text/javascript\">\r\n  Vue.component(\'my-component\', {\r\n    template: \'<p class=\"foo bar\">Hi</p>\'\r\n  });\r\n\r\n  new Vue({\r\n    el: \'#app\'\r\n  });\r\n</script>\r\n```\r\n\r\n最终渲染出来的结果如下：\r\n\r\n```html\r\n<p class=\"foo bar baz boo\">Hi</p>\r\n```','2017-12-03 05:13:37','2017-12-03 05:17:40','vue-js-learning-notes-class-features-of-the-operating-elements'),(515,3,3,'Vue.js 学习笔记：操作元素的 style 特性/内联样式','现在要讲的是，操作元素的内联样式，也就是 `style` 特性的方式。同样也提供了对象语法和数组语法两种方式。但操作元素的内联样式比操作元素的 `class` 特性更容易理解。\r\n\r\n下面两个例子中的在线源码在 [这里](https://codepen.io/zhangbao/full/pdGLPN)。\r\n\r\n## 对象语法\r\n\r\n`v-bind:style` 的对象语法看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式也可以用短横线分隔（需要用 **单引号** 括起来）来命名：\r\n\r\n```html\r\n<div id=\"app\">\r\n  <div class=\"box\" \r\n    v-bind:style=\"{ \'color\': activeColor, \'font-size\': fontSize + \'px\' }\">\r\n    你好，世界！\r\n  </div>\r\n</div>\r\n \r\n<script type=\"text/javascript\">\r\n  new Vue({\r\n    el: \'#app\',\r\n    data: {\r\n      activeColor: \'red\',\r\n      fontSize: 32\r\n    }\r\n  });\r\n</script>\r\n```\r\n\r\n## 数组语法\r\n\r\n`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：\r\n\r\n```html\r\n<div id=\"app\">\r\n  <div class=\"box\" \r\n    v-bind:style=\"[baseStyles, overridingStyles]\">\r\n    Nice to meet you!\r\n  </div>\r\n</div>\r\n\r\n<script type=\"text/javascript\">\r\n  new Vue({\r\n    el: \'#app\',\r\n    data: {\r\n      baseStyles: {\r\n        \'color\': \'red\',\r\n        \'font-size\': \'28px\'\r\n      },\r\n      overridingStyles: {\r\n        \'color\': \'#1e1e1e\',\r\n        \'font-size\': \'32px\',\r\n        \'background\': \'pink\'\r\n      }\r\n    }\r\n  });\r\n</script>\r\n```\r\n\r\n对于同一个样式，后面的样式会覆盖掉前面的样式。所以上例中的最终得到的渲染结果如下：\r\n\r\n```html\r\n<div class=\"box\" style=\"color: gray; font-size: 32px; background: pink;\">\r\n  你好，世界！\r\n</div>\r\n```','2017-12-03 05:31:45','2017-12-03 05:31:45','vue-js-learning-notes-operating-elementsinline-style-style-characteristics'),(516,3,3,'Vue.js 学习笔记：<template> 元素','`<template>` 元素当做不可见的包裹元素，当我们同时渲染多个同级标签元素（没有父级元素可供使用）的时候，可以用它。在最终的渲染结果将不包含 `<template>` 元素。\r\n\r\n以下面的代码为例：\r\n\r\n```html\r\n<template v-if=\"ok\">\r\n  <h1>Title</h1>\r\n  <p>Paragraph 1</p>\r\n  <p>Paragraph 2</p>\r\n</template>\r\n```\r\n\r\n当 `ok` 的值为 `true` 时，最终渲染出来的结果是这样的。\r\n\r\n```html\r\n<h1>Title</h1>\r\n<p>Paragraph 1</p>\r\n<p>Paragraph 2</p>\r\n```','2017-12-03 08:10:08','2017-12-03 08:10:08','vue-js-learning-notes-the-template-element'),(517,3,3,'Bulma 学习笔记：表单域、表单控件和表单控制类','表单域是使用 `.field` 类的标签，表单控件是使用 `.control` 类的标签，表单控制类是使用 `.input`、`.textarea`、`.select`、`.checkbox`、`.radio`和 `.button` 类的标签。\r\n\r\n表单域直接包含控件，表单控件直接包含表单控制类。\r\n\r\n## 表单控件 `.control`\r\n\r\n使用 `.control` 类修饰的标签称为一个表单控件，表单控件标签可以是 `div`、`p` 或 `span`。\r\n\r\n```html\r\n<div class=\"control\"></div>\r\n<p class=\"control\"></p>\r\n<span class=\"control\"></span>\r\n```\r\n\r\n## 表单控制类\r\n\r\nBulma 没有选择在表单元素上直接设置样式，而是通过一系列的表单控制类来保证表单元素样式上的一致性。针对每一种类型的表单元素，Bulma 都引入了一个对应的表单控制类：\r\n\r\n* `.input`\r\n* `.textarea`\r\n* `.select`\r\n* `.checkbox`\r\n* `.radio`\r\n* `.button`\r\n\r\n```html\r\n<input class=\"input\" type=\"text\" placeholder=\"Text Input\">\r\n<input class=\"input\" type=\"password\" placeholder=\"Password Input\">\r\n\r\n<textarea class=\"textarea\" placeholder=\"Textarea Text\"></textarea>\r\n\r\n<div class=\"select\">\r\n  <select>\r\n    <option>北京</option>\r\n    <option>上海</option>\r\n    <option>广州</option>\r\n    <option>深圳</option>\r\n  </select>\r\n</div>\r\n\r\n<label class=\"checkbox\">\r\n  <input type=\"checkbox\" name=\"agree\">\r\n  I agree to the <a href=\"#\">terms and conditions</a>\r\n</label>\r\n\r\n<label class=\"radio\">\r\n  <input type=\"radio\" name=\"gender\" vlaue=\"male\">男\r\n</label>\r\n<label class=\"radio\">\r\n  <input type=\"radio\" name=\"gender\" vlaue=\"female\">女\r\n</label>\r\n\r\n<input class=\"button\" type=\"submit\" value=\"提交\">\r\n<button class=\"button\">提交</button>\r\n```\r\n\r\n可以看到，`.select`、`.checkbox` 和 `.radio` 类都没有直接使用在表单元素本身，而是用在包裹元素上了。\r\n\r\n* `<select>` 外层包裹元素是 `div.select` 或 `span.select`。\r\n* `<input type=\"checkbox\">` 外层包裹元素是 `label.checkbox`。\r\n* `<input type=\"radio\">` 外层包裹元素是 `label.radio`。\r\n\r\n## 在表单控件中使用表单控制类\r\n\r\n表单控制类直接包含在表单控件（`.control`）中：\r\n\r\n```html\r\n<div class=\"control\">\r\n  <input class=\"input\" type=\"text\" placeholder=\"Text Input\">\r\n</div>\r\n<div class=\"control\">\r\n  <input class=\"input\" type=\"password\" placeholder=\"Password Input\">\r\n</div>\r\n\r\n<div class=\"control\">\r\n  <textarea class=\"textarea\" placeholder=\"Textarea Text\"></textarea>	\r\n</div>\r\n\r\n<div class=\"control has-icons-left\">\r\n  <div class=\"select\">\r\n    <select>\r\n        <option>北京</option>\r\n        <option>上海</option>\r\n        <option>广州</option>\r\n        <option>深圳</option>\r\n    </select>\r\n  </div>\r\n  <span class=\"icon is-left\">\r\n    <i class=\"fa fa-globe\"></i>\r\n  </span>\r\n</div>\r\n\r\n<div class=\"control\">\r\n  <label class=\"checkbox\">\r\n    <input type=\"checkbox\">\r\n    I agree to the <a href=\"#\">terms and conditions</a>\r\n  </label>\r\n</div>\r\n\r\n<div class=\"control\">\r\n  <label class=\"radio\">\r\n    <input type=\"radio\" name=\"gender\" vlaue=\"male\">男\r\n  </label>\r\n  <label class=\"radio\">\r\n    <input type=\"radio\" name=\"gender\" vlaue=\"female\">女\r\n  </label>\r\n</div>\r\n\r\n<div class=\"control\">\r\n  <input class=\"button\" type=\"submit\" value=\"提交\">\r\n</div>\r\n<div class=\"control\">\r\n  <button class=\"button\">提交</button>\r\n</div>\r\n```\r\n\r\n除了这几个表单控制类\r\n\r\n* `.input`\r\n* `.textarea`\r\n* `.select`\r\n* `.checkbox`\r\n* `.radio`\r\n* `.button`\r\n\r\n另外控件还支持包含图标控制类\r\n\r\n* `.icon`（一般指 `span.icon`）\r\n\r\n## 表单域 `.field`\r\n\r\n使用 `.field` 类修饰的标签称为一个表单域/单元。它的样式很简单\r\n\r\n```css\r\n.field:not(:last-child) {\r\n  margin-bottom: 0.75rem;\r\n}\r\n```\r\n\r\n目的是为了保证每个表单单元在垂直方向上有一样的间距。在表单域中可以直接包含的类有：\r\n\r\n* `.label`\r\n* `.control`\r\n* `.help`\r\n* `.file`（新）\r\n\r\n```html\r\n<div class=\"field\">\r\n  <label class=\"label\">Label</label>\r\n  <div class=\"control\">\r\n    <input type=\"text\" class=\"input\">\r\n  </div>\r\n  <p class=\"help\">This is a help text.</p>\r\n</div>\r\n<div class=\"field\">\r\n  <label class=\"label\">Label</label>\r\n  <div class=\"control\">\r\n    <textarea class=\"textarea\"></textarea>\r\n  </div>\r\n</div>\r\n<div class=\"field\">\r\n  <div class=\"control\">\r\n    <label class=\"checkbox\">\r\n      <input type=\"checkbox\">\r\n      I agree to the <a href=\"#\">terms and conditions</a>\r\n    </label>\r\n  </div>\r\n</div>\r\n<div class=\"field\">\r\n  <div class=\"control\">\r\n    <label class=\"radio\">\r\n      <input type=\"radio\" name=\"gender\" value=\"male\" checked>女\r\n    </label>\r\n    <label class=\"radio\">\r\n      <input type=\"radio\" name=\"gender\" value=\"female\">男\r\n    </label>\r\n  </div>\r\n</div>\r\n<div class=\"field\">\r\n  <div class=\"control has-icons-left\">\r\n    <div class=\"select\">\r\n      <select>\r\n        <option>北京</option>\r\n        <option>上海</option>\r\n        <option>广州</option>\r\n        <option>深圳</option>\r\n      </select>\r\n    </div>\r\n    <span class=\"icon is-left\">\r\n      <i class=\"fa fa-globe\"></i>\r\n    </span>\r\n  </div>\r\n</div>\r\n```\r\n\r\n注意到，表单控件（`.control`）是直接包含在表单域（`.field`）中的。\r\n\r\n## 最后\r\n\r\n所有源码在 [这里](https://codepen.io/zhangbao/pen/BmMOmZ) 查看。','2017-12-04 02:07:19','2017-12-04 08:13:35','bulma-learning-notes-form-fields-controls-and-form-control-class'),(518,3,3,'Bulma 学习笔记：表单控件 .control 详解','表单域 `.field` 很简单，只直接包含下列 3 类元素。\r\n\r\n* `.label`\r\n* `.control`\r\n* `.help`\r\n\r\n```html\r\n<div class=\"field\">\r\n  <label class=\"label\">用户名</label>\r\n  <div class=\"control\">\r\n    <input type=\"text\" class=\"input\" placeholder=\"如：张三\">\r\n  </div>\r\n  <p class=\"help\">6 - 10 个字符。</p>\r\n</div>\r\n<div class=\"field\">\r\n  <label class=\"label\">邮箱号</label>\r\n  <div class=\"control\">\r\n    <input type=\"email\" class=\"input\" placeholder=\"如：zhangsan@gmail.com\">\r\n  </div>\r\n  <p class=\"help\">我信任你，不会填写无用的邮箱号。</p>\r\n</div>\r\n<div class=\"field\">\r\n  <div class=\"control\">\r\n    <button class=\"button is-link\">注册</button>\r\n  </div>\r\n</div>\r\n```\r\n\r\n可以看到，表单控件 `.control` 直接包含在表单域中。**下面详细讲表单控件**。\r\n\r\n表单控件中除了直接包含下列的表单控制类\r\n\r\n* `.input`\r\n* `.textarea`\r\n* `.select`\r\n* `.checkbox`\r\n* `.radio`\r\n* `.button`\r\n\r\n还可以包含图标控制类\r\n\r\n* `.icon`\r\n\r\n## 带图标\r\n\r\n在表单控件中，有时并不只是有一个简单的表单元素而已，可能表单元素还需哟图标修饰。这中应用场景下，需要给 `.control` 添加修饰符类\r\n\r\n* `.has-icons-left`\r\n* 和/或 `.has-icons-right`\r\n\r\n同时，还需要为 `.icon` 添加一个修饰符类\r\n\r\n* `.has-icons-left` 配合 `.is-left`\r\n* `.has-icons-right` 配合 `.is-right`\r\n\r\n```html\r\n<div class=\"field\">\r\n  <div class=\"control has-icons-left has-icons-right\">\r\n    <input type=\"email\" class=\"input\" placeholder=\"邮箱号\">\r\n    <span class=\"icon is-left\">\r\n      <i class=\"fa fa-envelope\"></i>\r\n    </span>\r\n    <span class=\"icon is-right\">\r\n      <i class=\"fa fa-check\"></i>\r\n    </span>\r\n  </div>\r\n</div>\r\n<div class=\"field\">\r\n  <div class=\"control has-icons-left\">\r\n    <input type=\"password\" class=\"input\" placeholder=\"密码\">\r\n    <span class=\"icon is-left\">\r\n      <i class=\"fa fa-lock\"></i>\r\n    </span>\r\n  </div>\r\n</div>\r\n<div class=\"field\">\r\n  <div class=\"control has-icons-left\">\r\n    <span class=\"select\">\r\n      <select>\r\n        <option>中国</option>\r\n        <option>美国</option>\r\n        <option>俄罗斯</option>\r\n      </select>\r\n    </span>\r\n    <span class=\"icon is-left\">\r\n      <i class=\"fa fa-globe\"></i>\r\n    </span>\r\n  </div>\r\n</div>\r\n<div class=\"field\">\r\n  <div class=\"control\">\r\n    <button class=\"button is-link\">注册</button>\r\n  </div>\r\n</div>\r\n```\r\n\r\n*需要注意的是，这里的 `.select` 最好用在 `<span>` 标签上，这样与 `.fa-globe` 图标不仅在显示上、在语义上也是一行的了。*','2017-12-04 03:58:36','2017-12-04 06:12:13','bulma-learning-notes-the-form-controls-rounding'),(519,3,3,'Bulma 学习笔记：表单域 .field 详解','在表单域 `.field` 上支持使用 3 种修饰符类：\r\n\r\n1. `.has-addons`：让多个表单控件 `.control` 附加在一块，控件之间没有间隔。\r\n2. `.is-grouped`：让多个表单控件作为一组排列，控件之间有适当的间隔。\r\n3. `.is-horizontal`：让多个表单控件水平排列，需要额外引入 `.field-label` 和 `.field-body` 类实现水平效果。\r\n\r\n## 表单控件附加排列\r\n\r\n为表单域添加 `.has-addons` 类后，表单域中的表单控件将按照附加形式排列在一起，之间没有间隔。\r\n\r\n```html\r\n<div class=\"field has-addons\">\r\n  <div class=\"control\">\r\n    <input type=\"text\" class=\"input\" placeholder=\"查找仓库\">\r\n  </div>\r\n  <div class=\"control\">\r\n    <button class=\"button is-link\">搜索</button>\r\n  </div>\r\n</div>\r\n<div class=\"field has-addons\">\r\n  <div class=\"control\">\r\n    <input type=\"email\" class=\"input\" placeholder=\"您的邮箱号\">\r\n  </div>\r\n  <div class=\"control\">\r\n    <button class=\"button is-static\">@gmail.com</button>\r\n  </div>\r\n</div>\r\n<div class=\"field has-addons\">\r\n  <div class=\"control\">\r\n    <div class=\"select\">\r\n      <select>\r\n        <option>$</option>\r\n        <option>£</option>\r\n        <option>€</option>\r\n      </select>\r\n    </div>\r\n  </div>\r\n  <div class=\"control\">\r\n    <input type=\"text\" class=\"input\" placeholder=\"多少钱\">\r\n  </div>\r\n  <div class=\"control\">\r\n    <div class=\"button\">转换</div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n`is-static` 修饰的 `<button>` 不能被点击，是个静态显示效果。当控件以附加的形式，排列在一起的时候，如果需要将一个控件的拉伸撑满水平方向上的剩余空间的话，可以为表单控件添加 `.is-expanded` 类实现。\r\n\r\n```html\r\n<div class=\"field has-addons\">\r\n  <div class=\"control\">\r\n    <div class=\"select\">\r\n      <select>\r\n        <option>$</option>\r\n        <option>£</option>\r\n        <option>€</option>\r\n      </select>\r\n    </div>\r\n  </div>\r\n  <div class=\"control is-expanded\">\r\n    <input type=\"text\" class=\"input\" placeholder=\"多少钱\">\r\n  </div>\r\n  <div class=\"control\">\r\n    <div class=\"button\">转换</div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n对于表单控件中包含选择下拉框的场景，只在表单控件上使用 `.is-expanded` 还不行，还要为 `.select` 添加 `.is-fullwidth` 才能让选择下拉框占满剩余的水平空间。\r\n\r\n```html\r\n<div class=\"field has-addons\">\r\n  <div class=\"control has-icons-left is-expanded\">\r\n    <div class=\"select is-fullwidth\">\r\n      <select name=\"country\">\r\n        <option value=\"Argentina\">Argentina</option>\r\n        <option value=\"Bolivia\">Bolivia</option>\r\n        <option value=\"Brazil\">Brazil</option>\r\n        <option value=\"Chile\">Chile</option>\r\n        <option value=\"Colombia\">Colombia</option>\r\n        <option value=\"Ecuador\">Ecuador</option>\r\n        <option value=\"Guyana\">Guyana</option>\r\n        <option value=\"Paraguay\">Paraguay</option>\r\n        <option value=\"Peru\">Peru</option>\r\n        <option value=\"Suriname\">Suriname</option>\r\n        <option value=\"Uruguay\">Uruguay</option>\r\n        <option value=\"Venezuela\">Venezuela</option>\r\n      </select>\r\n    </div>\r\n    <span class=\"icon is-left\">\r\n      <i class=\"fa fa-globe\"></i>\r\n    </span>\r\n  </div>\r\n  <div class=\"control\">\r\n    <button class=\"button is-link\">选择</button>\r\n  </div>\r\n</div>\r\n```\r\n\r\n## 表单控件分组排列\r\n\r\n为表单域添加 `.is-grouped` 类后，表单域中的表单控件将在一组排列，且控件之间会有适当的间隔。\r\n\r\n```\r\n<div class=\"field is-grouped\">\r\n  <div class=\"control\">\r\n    <button class=\"button is-link\">提交</button>\r\n  </div>\r\n  <div class=\"control\">\r\n    <button class=\"button\">取消</button>\r\n  </div>\r\n</div>\r\n<div class=\"field is-grouped\">\r\n  <div class=\"control\">\r\n    <input type=\"text\" class=\"input\" placeholder=\"查找仓库\">\r\n  </div>\r\n  <div class=\"control\">\r\n    <button class=\"button is-link\">搜索</button>\r\n  </div>\r\n</div>\r\n<div class=\"field is-grouped\">\r\n  <div class=\"control is-expanded\">\r\n    <input type=\"text\" class=\"input\" placeholder=\"查找仓库\">\r\n  </div>\r\n  <div class=\"control\">\r\n    <button class=\"button is-link\">搜索</button>\r\n  </div>\r\n</div>\r\n```\r\n\r\n如果是排列多行表单控件，还需要额外添加 `.is-grouped-multiline` 类。\r\n\r\n```html\r\n<div class=\"field is-grouped is-grouped-multiline\">\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    One\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Two\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Three\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Four\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Five\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Size\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Seven\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Eight\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Nine\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Ten\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Eleven\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Twelve\r\n  </a>\r\n</p>\r\n<p class=\"control\">\r\n  <a class=\"button\">\r\n    Thirteen\r\n  </a>\r\n</p>\r\n</div>\r\n```\r\n\r\n## 表单控件水平排列\r\n\r\n水平排列的表单控件需要先在 `.field` 容器上使用 `.is-horizontal` 修饰符类。然后再包含下列结构:\r\n\r\n1. `.field-label`：容纳侧边文本 `.label`。\r\n2. `.field-body`：容纳多个表单域 `.field`。\r\n\r\n```html\r\n<div class=\"field is-horizontal\">\r\n  <div class=\"field-label is-normal\">\r\n    <label class=\"label\">来自</label>\r\n  </div>\r\n  <div class=\"field-body\">\r\n    <div class=\"field\">\r\n      <div class=\"control has-icons-left\">\r\n        <input type=\"text\" class=\"input\" placeholder=\"姓名\">\r\n        <span class=\"icon is-left\">\r\n          <i class=\"fa fa-user\"></i>\r\n        </span>\r\n      </div>\r\n    </div>\r\n    <div class=\"field\">\r\n      <div class=\"control has-icons-left has-icons-right\">\r\n        <input type=\"text\" class=\"input\" placeholder=\"邮箱号\" value=\"zhangbao90s@qq.com\">\r\n        <span class=\"icon is-left\">\r\n          <i class=\"fa fa-envelope\"></i>\r\n        </span>\r\n        <span class=\"icon is-right\">\r\n          <i class=\"fa fa-check\"></i>\r\n        </span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n<div class=\"field is-horizontal\">\r\n  <div class=\"field-label\"></div>\r\n  <div class=\"field-body\">\r\n    <div class=\"field\">\r\n      <div class=\"field has-addons\">\r\n        <div class=\"control\">\r\n          <button class=\"button is-static\">+44</button>		\r\n        </div>\r\n        <div class=\"control is-expanded\">\r\n          <input type=\"text\" class=\"input\">\r\n        </div>\r\n      </div>\r\n      <p class=\"help\">Do not enter the first zero</p>\r\n    </div>\r\n  </div>\r\n</div>\r\n<div class=\"field is-horizontal\">\r\n  <div class=\"field-label is-normal\">\r\n    <label class=\"label\">部门</label>\r\n  </div>\r\n  <div class=\"field-body\">\r\n    <div class=\"field\">\r\n      <div class=\"control has-icons-left\">\r\n        <div class=\"select\">\r\n          <select>\r\n            <option>Business development</option>\r\n            <option>Marketing</option>\r\n            <option>Sales</option>\r\n          </select>\r\n        </div>\r\n        <span class=\"icon is-left\">\r\n          <i class=\"fa fa-users\"></i>\r\n        </span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n<div class=\"field is-horizontal\">\r\n  <div class=\"field-label\">\r\n    <label class=\"label\">是会员吗?</label>\r\n  </div>\r\n  <div class=\"field-body\">\r\n    <div class=\"field\">\r\n      <div class=\"control\">\r\n        <label class=\"radio\">\r\n          <input type=\"radio\" name=\"question\" value=\"yes\">\r\n          是\r\n        </label>\r\n        <label class=\"radio\">\r\n          <input type=\"radio\" name=\"question\" value=\"no\" checked>\r\n          不是\r\n        </label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n<div class=\"field is-horizontal\">\r\n  <div class=\"field-label is-normal\">\r\n    <label class=\"label\">Subject</label>\r\n  </div>\r\n  <div class=\"field-body\">\r\n    <div class=\"field\">\r\n      <div class=\"control\">\r\n        <input type=\"text\" class=\"input\" placeholder=\"合作机会\">\r\n      </div>\r\n      <p class=\"help\">This field is required</p>\r\n    </div>\r\n  </div>\r\n</div>\r\n<div class=\"field is-horizontal\">\r\n  <div class=\"field-label is-normal\">\r\n    <babel class=\"label\">问题</babel>\r\n  </div>\r\n  <div class=\"field-body\">\r\n    <div class=\"field\">\r\n      <div class=\"control\">\r\n        <textarea class=\"textarea\" placeholder=\"解释下我们怎么帮助你\"></textarea>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n注意到，这里有的 `.field-label` 采用了 `is-normal`，这是为了将文本下沉一段距离，其样式如下：\r\n\r\n```css\r\n.field-label.is-normal {\r\n  padding-top: 0.375em;\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n在线源码地址在 [这里](https://codepen.io/zhangbao/pen/POLYrX)。','2017-12-04 06:11:45','2017-12-04 06:11:45','bulma-learning-notes-form-fields-the-field-explanation'),(520,3,3,'Vue.js 学习笔记：条件渲染指令 v-if 和 v-show','条件渲染使用指令 `v-if` 和 `v-show`，但它们有不同。我们现分别讲，然后再将它们的区别。\r\n\r\n## `v-if`\r\n\r\n当 `v-if`指令后的表达式返回 `true` 时，就渲染当前条件下的 HTML 结构，否则渲染 `v-else-if`/`v-else` 指令下的 HTML 结构。\r\n\r\n### `v-else`\r\n\r\n例子 1：\r\n\r\n```html\r\n<div id=\"app\">\r\n  <div v-if=\"!danger\" class=\"info\">\r\n    This is a common info :)\r\n  </div>\r\n  <div v-else class=\"info is-danger\">\r\n    This is a danger info :(\r\n  </div>\r\n  <button @click=\"danger = !danger\">Toggle info</button>\r\n  <span>danger: {{ danger }}</span>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    danger: false\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n当 `danger` 的值为 `true` 时，模板渲染结果为 \r\n\r\n```html\r\n<div class=\"info\">\r\n  This is a common info :)\r\n</div>\r\n```\r\n\r\n当 `danger` 的值为 `false` 时，模板渲染结果则为\r\n\r\n```html\r\n<div class=\"info is-danger\">\r\n  This is a danger info :(\r\n</div>\r\n```\r\n\r\n### `v-else-if`\r\n\r\n例子 2：\r\n\r\n```html\r\n<div v-if=\"type === \'A\'\" class=\"card\">A</div>\r\n<div v-else-if=\"type === \'B\'\" class=\"card\">B</div>\r\n<div v-else-if=\"type === \'C\'\" class=\"card\">C</div>\r\n<div v-else class=\"card is-small\">Not A/B/C</div>\r\n<p>\r\n  <button @click=\"type = \'A\'\">Toggle to \'A\'</button>\r\n  <button @click=\"type = \'B\'\">Toggle to \'B\'</button>\r\n  <button @click=\"type = \'C\'\">Toggle to \'C\'</button>\r\n  <button @click=\"type = \'\'\">Toggle to \'\'</button>\r\n</p>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    type: \'\'\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n当 `type` 分别等于 `\'A\'`、`\'B\'`、`\'C\'` 和 `\'\'` 的时候，就会渲染对应条件下的那个 div 内容。\r\n\r\n需要的注意的是，`v-else` 元素必须紧跟在带 `v-if` 或者 `v-else-if` 的元素的后面，否则它将不会被识别。同样，`v-else-if` 也必须紧跟在带 `v-if` 或者 `v-else-if` 的元素之后，否则不会被识别。\r\n\r\n### 使用 `key` 特性阻止元素复用\r\n\r\nVue 会尽可能的重用可复用的元素。拿下面的例子来说：\r\n\r\n```html\r\n<template v-if=\"loginType === \'username\'\">\r\n  <label>Username</label>\r\n  <input placeholder=\"Enter your username\">\r\n</template>\r\n<template v-else>\r\n  <label>Email</label>\r\n  <input placeholder=\"Enter your email address\">\r\n</template>\r\n```\r\n\r\n切换 `loginType` 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，**`<input>` 不会被替换掉——仅仅是替换了它的 `placeholder`**。\r\n\r\n实际使用中，如果你希望这两个元素是完全独立的，不要复用它们。就要使用 `key` 特性了。\r\n\r\n```html\r\n<template v-if=\"loginType === \'username\'\">\r\n  <label>Username</label>\r\n  <input placeholder=\"Enter your username\" key=\"username-input\">\r\n</template>\r\n<template v-else>\r\n  <label>Email</label>\r\n  <input placeholder=\"Enter your email address\" key=\"email-input\">\r\n</template>\r\n```\r\n\r\n这样一来，之后的每一次切换，输入框元素都会重新渲染而不是复用之前的。\r\n\r\n## `v-show`\r\n\r\n另一个用于根据条件展示元素的选项是 `v-show` 指令。用法大致一样：\r\n\r\n```html\r\n<h1 v-show=\"ok\">Hello!</h1>\r\n```\r\n\r\n不同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。**`v-show` 只是简单地切换元素的 CSS 属性 `display`**。\r\n\r\n另外，需要注意的是 `v-show` 不支持 `<template>` 元素，也不支持 `v-else-if` 和 `v-else`。\r\n\r\n## `v-if` 和 `v-show` 的区别\r\n\r\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\r\n\r\n## 最后\r\n\r\n两个例子的在线源码在 [这里](https://codepen.io/zhangbao/pen/zPbxpe) 查看。','2017-12-04 07:16:20','2017-12-04 07:16:20','vue-js-learning-notes-conditions-for-rendering-instructions-v-if-and-v-show'),(521,3,3,'Vue.js 学习笔记：负责列表渲染的 v-for 指令','`v-for` 指令用来遍历数组和对象。\r\n\r\n1. 遍历数组的语法如下：\r\n\r\n```html\r\nv-for=\"elem in array\"\r\n\r\nv-for=\"(elem, index) in array\"\r\n```\r\n\r\n`array` 是我们要遍历的数组，`elem` 是每一次迭代到的数组元素，（可选的）`index` 是当前迭代元素的索引值。\r\n\r\n2. 遍历对象的语法如下：\r\n\r\n```html\r\nv-for=\"value in object\"\r\n\r\nv-for=\"(value, prop) in object\"\r\n\r\nv-for=\"(value, prop, index) in object\"\r\n```\r\n\r\n`object` 是我们要遍历的对象，`value` 是当前迭代的属性值，（可选的）`prop` 是当前迭代的属性名，（可选的）`index` 则是当前迭代属性的索引值。\r\n\r\n*需要注意的是：在遍历对象时，是按 `Object.keys()` 的结果遍历，但是不能保证它的遍历顺序在不同的 JavaScript 引擎下是一致的。*\r\n\r\n## 遍历数组\r\n\r\n```html\r\n<div id=\"app\">\r\n  <ul>\r\n    <li v-for=\"(item, index) in items\">{{ parentMessage }} - {{ item.message }}({{ index }})</li>\r\n  </ul>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\nel: \'#app\',\r\ndata: {\r\n  parentMessage: \'Parent\',\r\n  items: [\r\n    { message: \'Foo\' },\r\n    { message: \'Bar\' }\r\n  ]\r\n}\r\n</script>\r\n```\r\n\r\n打印结果如下：\r\n\r\n```\r\nParent - Foo(0)\r\nParent - Bar(1)\r\n```\r\n\r\n我们可以发现在 `v-for` 指令块中，拥有对父级作用域属性的完全访问权限（此例中，我们就访问了父级作用域中的数据 `parentMessage`）。\r\n\r\n你也可以用 `of` 替代 `in` 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：\r\n\r\n```html\r\n<div v-for=\"item of items\"></div>\r\n```\r\n\r\n## 遍历对象\r\n\r\n```html\r\n<div id=\"app\">\r\n  <ul>\r\n    <li v-for=\"(value, prop, index) in object\">{{ prop }}  - {{ value }} - {{ index }}</li>\r\n  </ul>\r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    parentMessage: \'Parent\',\r\n    items: [\r\n      { message: \'Foo\' },\r\n      { message: \'Bar\' }\r\n    ],\r\n    object: {\r\n      firstName: \'Zhang\',\r\n      lastName: \'Bao\',\r\n      age: 18\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n打印结果如下：\r\n\r\n```\r\nfirstName - Zhang - 0\r\nlastName - Bao - 1\r\nage - 18 - 2\r\n```\r\n\r\n## `key` 特性\r\n\r\nVue 建议在使用 `v-for` 指令时尽可能提供 `key` 特性，除非遍历输出的 DOM 内容非常简单，或者是想刻意依赖默认行为以获取性能上的提升。\r\n\r\n```html\r\n<div v-for=\"item in items\" :key=\"item.id\">\r\n  <!-- 内容 -->\r\n</div>\r\n```\r\n\r\n因为这个 `key` 特性是 Vue 识别节点的一个通用机制，`key` 并不与 `v-for` 特别关联，还具有其他用途。\r\n\r\n## 最后\r\n\r\n在线源码看 [这里](https://codepen.io/zhangbao/pen/OOqVvw) 的。','2017-12-04 07:47:50','2017-12-04 07:47:50','vue-js-learning-notes-responsible-for-rendering-of-v-for-instruction-list'),(522,3,3,'Bulma 学习笔记：容器 .container 详解','Bulma 中将设备分为 6 类，共有 5 个断点（breakpoint）：\r\n\r\n- 移动：到 768px。对应 `.mobile`。\r\n- 平板：从 769px 算起。对应 `.tablet`。\r\n- *触屏：到 1023px。对应 `.touch`*。\r\n- 桌面：从 1024px 算起。对应 `.desktop`。\r\n- 宽屏：从 1216px 算起。对应 `.widescreen`。\r\n- 高清屏：从 1408px 算起。对应 `.fullhd`。\r\n \r\n这里的 `.mobile` 和 `.touch` 都是一眼就能看到范围的；\r\n\r\n- `.mobile` 是指从 0 到 768px 宽度范围的设备。\r\n- `.touch` 是指从 0 到 1023px 宽度范围的设备（包含移动和平板）。\r\n\r\n而 `.tablet`、`.desktop`、`.widescreen` 和 `.fullhd` 都只提供从最小宽度起、没有最大宽度限制的侦测范围。所以\r\n\r\n1. 如果只指定了一个类，那它作用的范围是包括它自己在内的、包含后面的更大宽度设备的。\r\n\r\n比如，我指定了 `.mobile`（移动），那么其样式在平板、桌面、宽屏和高清屏下同样适应；我指定了 `.tablet`（平板），那么其样式在桌面、宽屏和高清屏下同样适应；我指定了 `.desktop`（桌面），那么其样式在宽屏和高清屏下同样适应；我指定了 `.widescreen`，那么其样式在高清屏下同样适应。\r\n\r\n2. 当同时使用时，后面的类在其宽度范围设置的样式总是会覆盖前面类在同样的宽度范围设置的样式。\r\n\r\n## 容器 `.container`\r\n\r\n`.container` 可以用在任何上下文中，但最经常做为下列元素的直接子元素使用：\r\n\r\n- `.navbar`\r\n- `.hero`\r\n- `.section`\r\n- `.footer`\r\n\r\n`.container` 分两类：\r\n\r\n1. `.container`：宽度固定容器。\r\n2. `.container.is-fluid`：宽度流动容器。\r\n\r\n### 宽度固定容器\r\n\r\n用 `.container` 修饰的容器称为「宽度固定容器」，该容器在视口宽度大于等于 1024px 时，宽度在不同断点范围总是固定的，比如 960px、1152px 和 1344px。\r\n\r\n其实这里的「固定宽度值」本质上是在某个断点范围下的最大宽度值，共 4 种情况，下面具体说明：\r\n\r\n1. 当视口宽度在 0~1023px 范围时（`.touch`），`.container` 的宽度是充满视口的（不包括纵向滚动条）。\r\n2. 当视口宽度在 1024px ~ 1215px 范围时（`.desktop-only`），`.container` 的宽度保持在 960px，且水平居中显示。\r\n3. 当视口宽度在 1216px ~ 1407px 范围时（`.widescreen-only`），`.container` 的宽度保持在 1152px，且水平居中显示。\r\n4. 当视口宽度大于等于 1408px 时（`.fullhd`），`.container` 的宽度保持在 1344px，且水平居中显示。\r\n\r\n### 宽度流动容器\r\n\r\n用 `.container.is-fluid` 修饰的容器称为「宽度流动容器」。所谓的「宽度流动」，是指 `.container.is-fluid` 比较 `.container` 而言，没有最大宽度限制。\r\n\r\n`.container.is-fluid` 的应用规则比 `.container` 稍简单些，只有两种情况：\r\n\r\n1. 视口宽度在 0~1023px 范围时，`.container` 的宽度是充满视口的（不包括纵向滚动条）。\r\n2. 视口宽度大于等于 1024px 时，`.container` 的宽度 auto、水平居中显示，且左右各保持 32px 的外边距值。\r\n\r\n```css\r\n@media screen and (min-width: 1024px)\r\n.container.is-fluid {\r\n    margin-left: 32px;\r\n    margin-right: 32px;\r\n    max-width: none;\r\n    width: auto;\r\n}\r\n```\r\n\r\n## `.is-widescreen` 和 `.is-fullhd`\r\n\r\n用 `.is-widescreen` 和 `.is-fullhd` 修饰的 `.container` 结合了宽度流动容器和宽度固定容器的特点。\r\n\r\n### `.container.is-widescreen`\r\n\r\n扩大视口宽度时。\r\n\r\n1. 当 `.container` 宽度在 0~1151px 时，`.container` 的宽度是充满视口的（不包括纵向滚动条）。\r\n2. 当 `.container` 宽度大于等于 1152px、视口宽度小于等于 1407px 时，`.container` 的宽度保持在 1152px，且水平居中显示。\r\n3. 当视口宽度大于等于 1408px 时（`.fullhd`），`.container` 的宽度保持在 1344px，且水平居中显示。\r\n\r\n### `.container.is-fullhd`\r\n\r\n扩大视口宽度时。\r\n\r\n1. 当 `.container` 宽度在 0~1343px 时，`.container` 的宽度是充满视口的（不包括纵向滚动条）。\r\n2. 当 `.container` 宽度大于等于 1344px，`.container` 的宽度保持在 1344px，且水平居中显示。\r\n\r\n## 最后\r\n\r\n在线源码地址在 [这里](https://codepen.io/zhangbao/pen/KyErOa)。','2017-12-05 02:13:19','2017-12-05 02:13:19','bulma-learning-notes-container-the-container-explanation'),(523,7,7,'SaltAdmin 安装部署','# 一、环境说明\r\n\r\n系统平台：Centos 7.0\r\nPython：2.7.5\r\nSaltAdmin：1.0-Beta\r\n\r\n# 二、安装\r\n## pip安装\r\n\r\n```\r\nyum -y install epel-release\r\nyum install python-pip\r\npip install --upgrade pip\r\n```\r\n\r\n## 1.Webpy\r\n\r\n```\r\nwget http://webpy.org/static/web.py-0.38.tar.gz\r\ntar zxf web.py-0.38.tar.gz\r\npython setup.py install\r\n```\r\n\r\n## 2.Mako\r\n\r\n```\r\npip install mako\r\n```\r\n\r\n## 3.MySQLdb\r\n\r\n```\r\nyum install MySQL-python\r\n```\r\n\r\n## 4.SaltStack\r\n\r\n```\r\nyum install salt-master\r\n```\r\n\r\n## 5.其他依赖\r\n\r\n依赖以下 python 模块\r\n\r\n```\r\nyum install python-dmidecode\r\n```\r\n	\r\n安装 psutil\r\n\r\n```\r\nwget https://pypi.python.org/packages/source/p/psutil/psutil-2.1.3.tar.gz\r\ntar zxvf psutil-2.1.3.tar.gz\r\ncd psutil-2.1.3/\r\nyum -y install python-devel.x86_64\r\npython setup.py install\r\n```\r\n\r\n## 6.数据库配置\r\n新建数据库saltadmin\r\n导入doc目录下的saltadmin.sql文件\r\n配置config/database.py\r\n\r\n```\r\n#!/usr/bin/env python\r\n#-*- coding:utf-8 -*-\r\n\r\ndbType = \'mysql\'\r\ndbHost = \'127.0.0.1\'\r\ndbPort = 3306\r\ndbName = \'saltadmin\'\r\ndbUser = \'test\'            ##数据库登入账号\r\ndbPass = \'test\'            ##数据库登入密码\r\ndbChar = \'utf8\'\r\n```\r\n\r\n## 7. mysql 安装\r\n\r\n```\r\n1. wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\r\n2. rpm -ivh mysql-community-release-el7-5.noarch.rpm\r\n3. yum install mysql-community-server\r\n4. service mysqld restart # 安装成功后重启mysql服务\r\n5. mysql -u root # 初次安装mysql，root账户没有密码\r\n6. set password for \'root\'@\'localhost\' =password(\'password\'); # 设置密码\r\n```\r\n\r\n# 三、启动SaltAdmin\r\n启动：python run.py\r\n访问端口：8080\r\n用户名/密码：admin/admin\r\n更换监听端口：python run.py IP:Port\r\n\r\n# 备注\r\n1. 关闭防火墙\r\n\r\n```\r\n	systemctl stop firewalld.service #停止firewall\r\n	systemctl disable firewalld.service #禁止firewall开机启动\r\n```\r\n\r\n2. 关闭selinux\r\n\r\n```\r\n	# 打开 /etc/selinux/config 文件后,修改\r\n	#SELINUX=enforcing\r\n	#SELINUXTYPE=targeted\r\n	SELINUX=disabled\r\n	# 保存后退出 gedit。接着再执行如下命令,注意 setenforce 后面有空格:\r\n	setenforce 0\r\n	# 设置 SELinux 状态\r\n	getenforce\r\n	# 获取 SELinux 状态\r\n	[root@localhost etc]# setenforce 0\r\n	[root@localhost etc]# getenforce\r\n	Permissive\r\n```\r\n\r\n# 参考链接\r\n\r\n1. [数据库安装连接](http://www.cnblogs.com/starof/p/4680083.html)\r\n2. [防火墙设置](http://www.jianshu.com/p/d6414b5295b8)\r\n3. [安装 PIP](http://www.jianshu.com/p/5220d12b15e3)\r\n4. [安装 psutil](http://www.linuxidc.com/Linux/2016-03/129558.htm)','2017-12-05 03:23:18','2018-01-12 09:29:19','saltadmin-installation-deployment'),(524,3,3,'Bulma 学习笔记：水平排版用 .level！','`.level` 用来处理水平排版。HTML 结构如下：\r\n\r\n- `.level`：容器\r\n  - `.level-left`：左边栏\r\n  - `.level-right`：右边栏\r\n    - `.level-item`：栏目项。\r\n\r\n`.level-item` 中，可以放置几乎所有元素：标题、按钮、输入框，设置是文本内容。\r\n\r\n`.level-item` 中的内容总是处置居中的，这得益于样式\r\n\r\n```css\r\n.level-item {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n```\r\n\r\n## 两侧分栏\r\n\r\n```html\r\n<div class=\"level\">\r\n  <div class=\"level-left\">\r\n    <div class=\"level-item\">\r\n      <p class=\"subtitle is-5\">\r\n        <strong>123</strong> posts\r\n      </p>\r\n    </div>\r\n    <div class=\"level-item\">\r\n      <div class=\"field has-addons\">\r\n        <p class=\"control\">\r\n          <input type=\"text\" class=\"input\">\r\n        </p>\r\n        <p class=\"control\">\r\n          <button class=\"button\">Search</button>\r\n        </p>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <div class=\"level-right\">\r\n    <p class=\"level-item\"><strong>All</strong></p>\r\n    <p class=\"level-item\"><a href=\"#\">Published</a></p>\r\n    <p class=\"level-item\"><a href=\"#\">Drafts</a></p>\r\n    <p class=\"level-item\"><a href=\"#\">Deleted</a></p>\r\n    <p class=\"level-item\"><a href=\"#\" class=\"button is-link\">New</a></p>\r\n  </div>\r\n</div>\r\n```\r\n\r\n其中 `.level` 是 flex 布局。\r\n\r\n```css\r\n.level {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n}\r\n```\r\n\r\n因为 `.level` 使用了 `justify-content: space-between`，所以在此例中，其直接子项 `.level-left`、`.level-right` 并没有给予特殊样式，即可分布到两段对齐了。`.level-left`、`.level-right` 样式里只是简单的设置了子项的对齐方式：\r\n\r\n```css\r\n.level-left {\r\n  justify-content: flex-start;\r\n}\r\n\r\n.level-right {\r\n  justify-content: flex-end;\r\n}\r\n```\r\n\r\n## 居中分栏\r\n\r\n如果 `.level` 不是两侧分栏，而是所有栏目居中排版。那么我们就无需使用 `.level-left` 和 `.level-right`，而是将 `.level-item` 直接作为 `.level` 的子项使用。即结构为\r\n\r\n- `.level`\r\n  - `.level-item`\r\n\r\n```html\r\n<nav class=\"level\">\r\n  <div class=\"level-item has-text-centered\">\r\n    <div>\r\n      <p class=\"heading\">Tweets</p>\r\n      <p class=\"title\">3,456</p>\r\n    </div>\r\n  </div>\r\n  <div class=\"level-item has-text-centered\">\r\n    <div>\r\n      <p class=\"heading\">Following</p>\r\n      <p class=\"title\">123</p>\r\n    </div>\r\n  </div>\r\n  <div class=\"level-item has-text-centered\">\r\n    <div>\r\n      <p class=\"heading\">Followers</p>\r\n      <p class=\"title\">456K</p>\r\n    </div>\r\n  </div>\r\n  <div class=\"level-item has-text-centered\">\r\n    <div>\r\n      <p class=\"heading\">Likes</p>\r\n      <p class=\"title\">789</p>\r\n    </div>\r\n  </div>\r\n</nav>\r\n```\r\n\r\n当 `.level-item` 作为 `.level` 直接子项使用时，其应用了一个样式：\r\n\r\n```css\r\n.level > .level-item {\r\n  flex-grow: 1;\r\n}\r\n```\r\n\r\n就是说所有的 `.level-item` 平均等分水平空间----即所有的 `.level-item` 都是一样宽的了（这里提供一个 [模仿 demo](https://codepen.io/zhangbao/pen/KyEEoV)）。\r\n\r\n还可以看到，每个 `.level-item` 的直接子元素都给了一个 `div`，这是为了让这个 `div` 水平居中显示。因为每个 `.level-item` 都应用了样式 `    justify-content: center;`，如果直接这样做\r\n\r\n```html\r\n<!-- Bad \r\n  两个 <p> 在一行水平居中显示了\r\n-->\r\n<div class=\"level-item has-text-centered\">\r\n  <p class=\"heading\">Likes</p>\r\n  <p class=\"title\">789</p>\r\n</div>\r\n\r\n<!-- Good \r\n  <div> 水平居中显示了。\r\n  两个 <p> 也在两行显示了。\r\n-->\r\n<div class=\"level-item has-text-centered\">\r\n  <div>\r\n    <p class=\"heading\">Likes</p>\r\n    <p class=\"title\">789</p>\r\n  </div>\r\n</div>\r\n```\r\n\r\n注意这里 `.level-item` 上的 `.has-text-centered` 是为了保证 `.heading` 和 `.title` 在 `<div>` 里水平居中显示。','2017-12-05 03:34:00','2017-12-05 03:34:00','bulma-learning-notes-horizontal-layout-with-level'),(525,3,3,'Vue.js 学习笔记：检测数组更新','## 变异方法\r\n\r\n数组的变异方法（mutation method）是指在调用之后，原数组会发生改变。而通过这些方法改变数组，会被 Vue 检测到。这些方法包括：\r\n\r\n1. `push()` 在数组的最后压入一个元素。\r\n2. `unshift()` 从数组的头部压入一个元素。\r\n3. `pop()` 弹出数组的最后一个元素。\r\n4. `shift()` 弹出数组的第一个元素。\r\n5. `splice()` 拼接数组（增、删、改）。\r\n6. `sort()` 对数组排序。\r\n7. `reverse()` 翻转数组元素。\r\n\r\n## 替换方法\r\n\r\n数组的替换方法，即非变异（non-mutating method）方法。替换方法与变异方法相对的，表示执行完这些方法后，不会对原数组造成改变，而是方法会返回处理后的新数组。这些方法包括：`filter()`、`concat()` 和 `slice()`。\r\n\r\n当使用这些方法时，最好用新数组来替换旧数组。实际上，Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以 **在 Vue 中，用一个含有相同元素的数组去替换原来的数组是「非常高效的操作」**。\r\n\r\n## 例子\r\n\r\n在线源码地址在 [这里](https://codepen.io/zhangbao/pen/qVvwJz) 可以看到。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p>数组的变异方法（mutation method）是指在调用之后，原数组会发生改变。而通过这些方法改变数组，会被 Vue 检测到。</p>\r\n  <dl>\r\n    <dt>操作</dt>\r\n    <dd>在数组的最后压入一个元素：<button @click=\"arr.push(count++)\">push(count)</button></dd>\r\n    <dd>从数组的头部压入一个元素：<button @click=\"arr.unshift(count++)\">unshift(count)</button></dd>\r\n    <dd>弹出数组的最后一个元素：<button @click=\"arr.pop()\">pop()</button></dd>\r\n    <dd>弹出数组的第一个元素：<button @click=\"arr.shift()\">shift()</button></dd>\r\n    <dd>拼接数组：<button @click=\"arr.splice(1, 2, \';)\')\">splice(1, 2, \';)\')</button></dd>\r\n    <dd>打乱数组：<button @click=\"randomArr\">randomArr</button></dd>\r\n    <dd>排序数组：<button @click=\"arr.sort((a, b) => a - b)\">sort()</button></dd>\r\n    <dd>翻转数组：<button @click=\"arr.reverse()\">reverse()</button></dd>\r\n  </dl>\r\n  <p>数组 arr 的值：{{ arr }}</p>\r\n\r\n  <hr>\r\n\r\n  <p>数组的替换方法</p>\r\n  <dl>\r\n    <dt>操作</dt>\r\n    <dd>保留数组中小于 10 的数字：<button @click=\"arr = arr.filter(v => v < 10)\">filter()</button></dd>\r\n    <dd>连接一个新数组：<button @click=\"arr = arr.concat([22, 33])\">concat([22, 33])</button></dd>\r\n    <dd>截取数组（截得索引 1、2 处的值）：<button @click=\"arr = arr.slice(1, 3)\">concat(slice(1, 3))</button></dd>\r\n  </dl>\r\n  <p>数组 arr 的值：{{ arr }}</p>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    count: 1,\r\n    arr: [100, -2]\r\n  },\r\n  methods: {\r\n    randomArr: function () {\r\n      this.arr.sort(function () {\r\n        return Math.random() - 0.5;\r\n      });\r\n    }\r\n  },\r\n  watch: {\r\n    arr: function (newV) {\r\n      console.log(\'数组 arr 更新了 → \', newV);\r\n    }\r\n  }\r\n});\r\n</script>\r\n```','2017-12-05 05:55:13','2017-12-05 06:13:55','bulma-learning-notes-detection-array-to-update'),(526,3,3,'Vue.js 学习笔记：添加响应式属性','## 添加响应式属性\r\n\r\n我们不能在 Vue 实例上添加根级别的响应式属性。但是，可以使用 `Vue.set(object, key, value)` 方法「向数据对象添加响应式属性」。\r\n\r\n```javascript\r\nvar vm = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    userProfile: {}\r\n  }\r\n});\r\n\r\n// vm.b 不会是响应式的\r\nvm.b = 2;\r\n\r\n// 通过 Vue.set 来添加响应式属性 name（userProfile 对象上的）\r\nVue.set(vm.userProfile, \'name\', \'zhangb\')\r\n// 上面 Vue.set(...) 的写法等同于\r\n// vm.$set(vm.userProfile, \'name\', \'zhangb\');\r\n```\r\n\r\n## 同时添加多个响应式属性\r\n\r\n有时你可能需要为已有对象赋予多个新属性，比如使用 `Object.assign()` 或 `_.extend()`。在这种情况下，你「应该用两个对象的属性创建一个新的对象」\r\n\r\n避免这样：\r\n\r\n```javascript\r\nObject.assign(vm.userProfile, {\r\n  name: \'zhangb\',\r\n  age: 18\r\n});\r\n```\r\n\r\n最好这样：\r\n\r\n```javascript\r\nvm.userProfile = Object.assign({}, vm.userProfile, {\r\n  name: \'zhangb\',\r\n  age: 18\r\n});\r\n```','2017-12-05 06:13:13','2017-12-05 11:56:33','bulma-learning-notes-add-the-response-type-attributes'),(528,3,3,'Bulma 学习笔记：媒体内容 .media 介绍','`.media` 样式在社交网站经常看到。一边是图片，一边是评论。在 Bulma 中，它的使用结构有如下几种：\r\n\r\n1. 单个评论\r\n\r\n```\r\n.media\r\n	.media-left\r\n		firgure.image\r\n			img\r\n	.media-content\r\n		.content\r\n			p\r\n		.level.is-mobile \r\n	.media-right\r\n		.delete\r\n```\r\n\r\n`.media-left` 是用户图片，基本上结构是死的；`.media-content` 是媒体内容主体，可以多变：`.content` 中存放当前用户的相关的内容（如用户名、账号名、评论时间和内容）；`.level.is-mobile` 存放对媒体内容的操作（如转发、分享、喜欢等），使用 `.is-mobile` 保证在移动设备中也水平显示操作文字，而不是上下堆积的样式。\r\n\r\n下面给出一个实际代码案例（全部在线案例源码在 [这里](https://codepen.io/zhangbao/pen/NwmOvY)）：\r\n\r\n```html\r\n<div class=\"media\">\r\n	<div class=\"media-left\">\r\n		<figure class=\"image is-64x64\">\r\n			<img src=\"https://bulma.io/images/placeholders/128x128.png\" alt=\"\">\r\n		</figure>\r\n	</div>\r\n	<div class=\"media-content\">\r\n		<div class=\"content\">\r\n			<p>\r\n				<strong>Zhang Bao</strong> <small>@baooab</small> <small>31m</small><br>\r\n				Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin ornare magna eros, eu pellentesque tortor vestibulum ut. Maecenas non massa sem. Etiam finibus odio quis feugiat facilisis.\r\n			</p>\r\n		</div> \r\n		<div class=\"level is-mobile\">\r\n			<div class=\"level-left\">\r\n				<a class=\"level-item\">\r\n					<span class=\"icon is-small\"><i class=\"fa fa-reply\"></i></span>\r\n				</a>\r\n				<a class=\"level-item\">\r\n					<span class=\"icon is-small\"><i class=\"fa fa-retweet\"></i></span>\r\n				</a>\r\n				<a class=\"level-item\">\r\n					<span class=\"icon is-small\"><i class=\"fa fa-heart\"></i></span>\r\n				</a>\r\n			</div>\r\n		</div>\r\n	</div>\r\n	<div class=\"media-right\">\r\n		<button class=\"delete\"></button>\r\n	</div>\r\n</div>\r\n```\r\n\r\n2. 提交评论框\r\n\r\n```\r\n.media\r\n	.media-left\r\n		firgure.image\r\n			img\r\n	.media-content\r\n		.field\r\n			.control\r\n				textaea.textartea\r\n		.level\r\n			.level-left\r\n				a.button\r\n			.level-right\r\n				label.checkbox\r\n					input[type=\"checkbox\"]\r\n```\r\n\r\n对于评论框，在 `.media-content` 下直接使用表单域 `.field` 即可。又使用了 `.level`，是因为用到了两端布局，否则直接使用 `.field` 包含 `a.button` 就可以了，即\r\n\r\n```\r\n.media\r\n	.media-left\r\n		firgure.image\r\n			img\r\n	.media-content\r\n		.field\r\n			.control\r\n				textaea.textartea\r\n		.field\r\n			.control\r\n				a.button\r\n```\r\n\r\n下面给出一个实际代码案例：\r\n\r\n```html\r\n<div class=\"media\">\r\n	<div class=\"media-left\">\r\n		<figure class=\"image is-64x64\">\r\n			<img src=\"https://bulma.io/images/placeholders/128x128.png\" alt=\"\">\r\n		</figure>\r\n	</div>\r\n	<div class=\"media-content\">\r\n		<div class=\"field\">\r\n			<div class=\"control\">\r\n				<textarea class=\"textarea\" placeholder=\"Add a comment...\"></textarea>\r\n			</div>\r\n		</div>\r\n		<nav class=\"level\">\r\n			<div class=\"level-left\">\r\n				<div class=\"level-item\">\r\n					<a href=\"#\" class=\"button is-link\">Submit</a>\r\n				</div>\r\n			</div>\r\n			<div class=\"level-right\">\r\n				<div class=\"level-item\">\r\n					<label class=\"checkbox\">\r\n						<input type=\"checkbox\">  Press enter to submit\r\n					</label>\r\n				</div>\r\n			</div>\r\n		</nav>\r\n	</div>\r\n</div>\r\n```\r\n\r\n2. 评论嵌套\r\n\r\n在 `.media-content` 中是可以嵌套 `.media` 的，这就属于嵌套评论了。\r\n\r\n```\r\n.media-content\r\n	.content\r\n	.media // 这就是嵌套的评论\r\n		.media-left\r\n		.media-content\r\n			.content\r\n			.media // 这就是嵌套评论的（简易）评论\r\n				评论文字\r\n			.media // 这就是嵌套评论的（简易）评论\r\n				评论文字\r\n```\r\n\r\n下面是一个实际案例：\r\n\r\n```html\r\n<article class=\"media\">\r\n	<div class=\"media-left\">\r\n		<figure class=\"image is-64x64\">\r\n			<img src=\"https://bulma.io/images/placeholders/128x128.png\" alt=\"\">\r\n		</figure>\r\n	</div>\r\n	<div class=\"media-content\">\r\n		<div class=\"content\">\r\n			<p>\r\n				<strong>Barbara Middleton </strong>\r\n				<br>\r\n				Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin ornare magna eros, eu pellentesque tortor vestibulum ut. Maecenas non massa sem. Etiam finibus odio quis feugiat facilisis.\r\n				<br>\r\n				<small><a href=\"#\">Like</a> · <a href=\"#\">Reply</a> · 2hr</small>\r\n			</p>\r\n		</div>\r\n\r\n		<div class=\"media\">\r\n			<div class=\"media-left\">\r\n				<figure class=\"image is-48x48\">\r\n					<img src=\"https://bulma.io/images/placeholders/128x128.png\" alt=\"\">\r\n				</figure>\r\n			</div>\r\n			<div class=\"media-content\">\r\n				<div class=\"content\">\r\n					<p>\r\n						<strong>Sean Brown</strong>\r\n						<br>\r\n						Donec sollicitudin urna eget eros malesuada sagittis. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam blandit nisl a nulla sagittis, a lobortis leo feugiat. \r\n						<br>\r\n						<small><a href=\"#\">Like</a> · <a href=\"#\">Reply</a> · 2hr</small>\r\n					</p>\r\n				</div>\r\n				<article class=\"media\">\r\n					Vivamus quis semper metus, non tincidunt dolor. Vivamus in mi eu lorem cursus ullamcorper sit amet nec massa.\r\n				</article>\r\n				<article class=\"media\">\r\n					Morbi vitae diam et purus tincidunt porttitor vel vitae augue. Praesent malesuada metus sed pharetra euismod. Cras tellus odio, tincidunt iaculis diam non, porta aliquet tortor.\r\n				</article>\r\n			</div>\r\n		</div>\r\n	</div>\r\n</article>\r\n<article class=\"media\">\r\n	<div class=\"media-left\">\r\n		<figure class=\"image is-64x64\">\r\n			<img src=\"https://bulma.io/images/placeholders/128x128.png\" alt=\"\">\r\n		</figure>\r\n	</div>\r\n	<div class=\"media-content\">\r\n		<div class=\"field\">\r\n			<div class=\"control\">\r\n				<textarea class=\"textarea\"></textarea>\r\n			</div>\r\n		</div>\r\n		<div class=\"field\">\r\n			<div class=\"control\">\r\n				<a href=\"#\" class=\"button is-link\">Post</a>\r\n			</div>\r\n		</div>\r\n	</div>\r\n</article>\r\n```\r\n\r\n## 总结\r\n\r\n1. 为了语义化，最好在 `<article>` 标签上使用 `.media`。\r\n2. `.media` 的直接子元素是 `.media-left`、`.media-content` 或 `.media-right`。`.media-left` 防止用户图片，结构基本固定；`.media-right` 防止关闭按钮；媒体主题内容放在 `.media-content`，结构样式是最多样的。\r\n3. `.media-content` 的直接子元素可以是 `.content`、`.level`、`.field` 和 `.media`（媒体嵌套）。','2017-12-06 03:01:23','2017-12-06 03:01:23','bulma-learning-notes-media-content-the-media-is-introduced'),(527,3,3,'Vue.js 学习笔记：显示过滤数据、使用有 v-for 的 <template>、v-for 指令的优先级高于 v-if','## 显示过滤或排序副本\r\n\r\n有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据，**这时就要用到计算属性了**。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <ul>\r\n    <li v-for=\"n in evenNumbers\">{{ n }}</li>\r\n  </ul>\r\n  <hr>\r\n  <ul>\r\n    <li v-for=\"n in 10\">{{ n }}</li>\r\n  </ul>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n  },\r\n  computed: {\r\n    evenNumbers: function () {\r\n      return this.numbers.filter(function (number) {\r\n        return number % 2 === 0;\r\n      });\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## 使用有 `v-for` 的 `<template>`\r\n\r\n类似于 `v-if`，你也可以利用带有 `v-for` 指令的 `<template>` 渲染多个元素。比如：\r\n\r\n```html\r\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.1/css/bulma.min.css\">\r\n\r\n<div id=\"app\">\r\n  <nav class=\"navbar\" role=\"navigation\" aria-label=\"dropdown navigation\">\r\n    <a class=\"navbar-item\">\r\n      <img src=\"https://bulma.io/images/bulma-logo.png\" alt=\"Bulma: a modern CSS framework based on Flexbox\" width=\"112\" height=\"28\">\r\n    </a>\r\n    <div class=\"navbar-item has-dropdown\">\r\n      <a class=\"navbar-link\">\r\n        Docs\r\n      </a>\r\n      <div class=\"navbar-dropdown\">\r\n        <template v-for=\"(item, index) in items\">\r\n          <hr class=\"navbar-divider\" v-if=\"index !== 0\">\r\n          <a class=\"navbar-item\">\r\n            {{ item }}\r\n          </a>\r\n        </template>\r\n      </div>\r\n    </div>\r\n  </nav>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    items: [\'Overview\', \'Elements\', \'Components\']\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## `v-if` 会在 `v-for` 循环的每个迭代中重复运行\r\n\r\n当同时处于同一节点时，`v-for` 指令的优先级要比 `v-if` 要高，这意味着 `v-if` 指令会在 `v-for` 循环的每次迭代中重复执行。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p><strong>{{ isDone ? \'已完成的\' : \'未完成的\' }}</strong></p>\r\n  <ul>\r\n    <li v-for=\"todo in todos\" v-if=\"todo.isDone === isDone\">{{ todo.con }}</li>\r\n  </ul>\r\n  <p><button @click=\"isDone = !isDone\">Toggle to  {{ isDone ? \'unDone\' : \'Done\' }}</button></p>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    isDone: true,\r\n    todos: [\r\n      { isDone: false, con: \'看《红楼梦》\' },\r\n      { isDone: false, con: \'看《莎士比亚》\' },\r\n      { isDone: false, con: \'看《云雀叫了一整天》\' },\r\n      { isDone: false, con: \'学习 Vue.js\' },\r\n      { isDone: true, con: \'扯淡\' }\r\n    ]\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## 最后，\r\n\r\n所有实例的在线源码可以在 [这个地址](https://codepen.io/zhangbao/pen/LOaowL) 里看到。','2017-12-05 06:54:40','2017-12-05 06:54:40','vue-js-learning-notes-according-to-filter-the-data-using-v-for-the-template-v-priority-than-v-if-the-for-instructions'),(529,3,3,'Bulma 学习笔记：导航栏 .navbar（上篇）','简易的导航栏用 [`.level`](http://baooab.com/forum/discussion/bulma-learning-notes-horizontal-layout-with-level) 也可以实现。但是用 `.navbar` 更专业，因为组件 `.navbar` 就是为组织导航栏编写的组件。\r\n\r\n## 简单导航栏\r\n\r\n用 `.navbar` 实现一个简单的导航栏的结构如下。\r\n\r\n```\r\n.navbar\r\n  .navbar-brand\r\n    a.navbar-item\r\n  .navbar-menu\r\n    .navbar-end\r\n      a.navbar-item\r\n```\r\n\r\n对应到代码类似（本文全部在线源码在 [这里](https://codepen.io/zhangbao/full/yPrZpQ)）\r\n\r\n```html\r\n<nav class=\"navbar is-light\">\r\n  <div class=\"navbar-brand\">\r\n    <a href=\"#\" class=\"navbar-item is-5\"><strong>乱炖社区</strong></a>\r\n</div>\r\n  <div class=\"navbar-menu\">\r\n    <div class=\"navbar-end\">\r\n        <a href=\"#\" class=\"navbar-item\">登录</a>\r\n        <a href=\"#\" class=\"navbar-item\">注册</a>\r\n    </div>\r\n  </div>\r\n</nav>\r\n```\r\n\r\n1. `.is-light` 表示导航栏使用浅色主题，这不是我们关注的重点。\r\n2. `.navbar` 的直接子元素就是 `.navbar-brand` 和 `.navbar-menu`。\r\n3. `.navbar-menu` 可包含两个直接子元素：`.navbar-start`（居左显示） 和 `.navbar-end`（居右显示）。此例中只使用了居右显示的菜单栏 `.navbar-end`。\r\n4. `.navbar-menu` 在 `< 1024px` 下是不显示的，如果要它一直显示需要添加 `.is-active`。\r\n\r\n```html\r\n<div class=\"navbar-menu is-active\">\r\n  <!-- ... -->\r\n</div>\r\n```\r\n5. `.navbar-menu` 一直显示的话会有问题，因为在 `< 1024px` 的视口宽度下，`.navbar-item` 是垂直堆积显示的，在有非常多 `.navbar-item` 的情况下，这种处理方式显然是不合理的，因此引入了 `.navbar-burger`。\r\n\r\n## 汉堡图标\r\n\r\n汉堡图标就是在 `>=1024px` 的视口宽度下不显示，在 `<1024px` 下显示为 3 个横线的结构。当你点击汉堡图标的时候，就会激活导航栏菜单，即为 `.navbar-menu` 添加 `.is-active`；再次点击，导航栏菜单消失，即删除 `.navbar-menu` 的 `is-active`。\r\n\r\n汉堡图标结构如下：\r\n\r\n```html\r\n<button class=\"button navbar-burger\">\r\n  <span></span>\r\n  <span></span>\r\n  <span></span>\r\n</button>\r\n```\r\n\r\n汉堡图标有一个激活状态 `is-active`，添加后汉堡图标显示为一个 `×`。\r\n\r\n加入汉堡图标后的导航栏结构如下：\r\n\r\n```\r\n.navbar\r\n  .navbar-brand\r\n    .navbar-item\r\n    .navbar-burger\r\n  .navbar-menu\r\n    .navbar-end\r\n      a.navbar-item\r\n```\r\n\r\n需要注意的是：\r\n\r\n1. `.navbar-brand` 中可添加多个 `.navbar-item`，但为了保持 brand 结构的简洁，在此处应该尽量避免写入过多的 `.navbar-item`。\r\n2. `.navbar-burger` 必须作为 `.navbar-brand` 最后一个直接子元素，才能保证正确呈现。\r\n\r\n因为 Bulma 是纯 CSS 框架，不包含任何 JavaScrit 代码，所以为了实现点击汉堡图标显示/隐藏导航栏菜单需要写一些简单的代码---在 `.navbar-burger` 和目标 `.navbar-menu` 上 toggle `.is-active`。\r\n\r\n```html\r\n<div class=\"navbar-brand\">\r\n  <a href=\"#\" class=\"navbar-item is-5\"><strong>乱炖社区</strong></a>\r\n  <!-- when clicked, toggle target #siteMenu\'s .is-active class -->\r\n  <button class=\"button is-light navbar-burger\" data-target=\"siteMenu\">\r\n    <span></span>\r\n    <span></span>\r\n    <span></span>\r\n  </button>\r\n</div>\r\n<!-- target #siteMenu -->\r\n<div id=\"siteMenu\" class=\"navbar-menu\">\r\n  <div class=\"navbar-end\">\r\n    <a href=\"#\" class=\"navbar-item\">登录</a>\r\n    <a href=\"#\" class=\"navbar-item\">注册</a>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\ndocument.addEventListener(\'DOMContentLoaded\', function () {\r\n	\r\n  // Get all \"navbar-burger\" elements\r\n  var navbarBurgers = [].slice.call(document.querySelectorAll(\'.navbar-burger\'), 0);\r\n\r\n  // Check if there are any navbar burgers\r\n  if (navbarBurgers.length > 0) {\r\n\r\n    // Add a click event on each of them\r\n    navbarBurgers.forEach(function (navbarBurger) {\r\n      navbarBurger.addEventListener(\'click\', function () {\r\n\r\n        // Get the target from the \"data-target\" attribute\r\n        var targetId = navbarBurger.dataset.target;\r\n        var target = document.getElementById(targetId);\r\n\r\n        // Toggle the class on both the \"navbar-burger\" and the \"navbar-menu\"\r\n        navbarBurger.classList.toggle(\'is-active\');\r\n        target.classList.toggle(\'is-active\');\r\n      });\r\n    });\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## `.navbar-item`\r\n\r\n`.navbar-item` 即导航项，它可不是只能包含简单的结构\r\n\r\n```html\r\n<a href=\"#\" class=\"navbar-item\">首页</a>\r\n```\r\n\r\n也可以是复杂的结构，一种是这样的。\r\n\r\n```html\r\n<!-- 一个结构复杂的按钮 -->\r\n<div class=\"navbar-item\">\r\n  <a href=\"#\" class=\"button\">\r\n    <span class=\"icon\">\r\n      <i class=\"fa fa-pencil\"></i>\r\n    </span>\r\n    <span>创作</span>\r\n  </a>\r\n</div>\r\n\r\n<!-- 按钮组（包含两个按钮） -->\r\n<div class=\"navbar-item\">\r\n  <div class=\"field is-grouped\">\r\n    <div class=\"control\">\r\n      <a href=\"#\" class=\"button is-light\">\r\n        <span class=\"icon\">\r\n          <i class=\"fa fa-qq\"></i>\r\n        </span>\r\n        <span>QQ</span>\r\n      </a>\r\n    </div>\r\n    <div class=\"control\">\r\n      <a href=\"#\" class=\"button is-light\">\r\n        <span class=\"icon\">\r\n          <i class=\"fa fa-github\"></i>\r\n        </span>\r\n        <span>Github</span>\r\n      </a>\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n还有一种是下拉框导航项：\r\n\r\n```html\r\n<div class=\"navbar-item has-dropdown is-hoverable\">\r\n  <a href=\"#\" class=\"navbar-link\">文档</a>\r\n  <div class=\"navbar-dropdown\">\r\n    <a href=\"#\" class=\"navbar-item\">JavaScript</a>\r\n    <a href=\"#\" class=\"navbar-item\">Vue.js</a>\r\n    <a href=\"#\" class=\"navbar-item\">Bulma</a>\r\n    <a href=\"#\" class=\"navbar-item\">Laravel</a>\r\n  </div>\r\n</div>\r\n```\r\n\r\n1. `.navbar-link` 是有一个（默认朝下）箭头图标的导航项。\r\n2. `.is-hoverable` 保证 `.navbar-item.has-dropdown` 在 hover 状态下，显示 `.navbar-dropdown` 的内容。\r\n3. `.navbar-dropdown` 中的直接子元素是 `.navbar-item`。\r\n\r\n下面是完整案例的代码。\r\n\r\n```html\r\n<nav class=\"navbar is-light\">\r\n  <div class=\"navbar-brand\">\r\n    <a href=\"#\" class=\"navbar-item\"><strong>乱炖社区</strong></a>\r\n    <button class=\"button is-light navbar-burger\" data-target=\"siteMenu4\">\r\n      <span></span>\r\n      <span></span>\r\n      <span></span>\r\n    </button>\r\n  </div>\r\n  <div id=\"siteMenu4\" class=\"navbar-menu\">\r\n    <div class=\"navbar-start\">\r\n      <a href=\"#\" class=\"navbar-item\">首页</a>\r\n      <div class=\"navbar-item has-dropdown is-hoverable\">\r\n        <a href=\"#\" class=\"navbar-link\">文档</a>\r\n        <div class=\"navbar-dropdown\">\r\n          <a href=\"#\" class=\"navbar-item\">JavaScript</a>\r\n          <a href=\"#\" class=\"navbar-item\">Vue.js</a>\r\n          <a href=\"#\" class=\"navbar-item\">Bulma</a>\r\n          <a href=\"#\" class=\"navbar-item\">Laravel</a>\r\n        </div>\r\n      </div>\r\n      <div class=\"navbar-item\">\r\n        <div class=\"field is-grouped\">\r\n          <div class=\"control\">\r\n            <a href=\"#\" class=\"button is-light\">\r\n              <span class=\"icon\">\r\n                <i class=\"fa fa-qq\"></i>\r\n              </span>\r\n              <span>QQ</span>\r\n            </a>\r\n          </div>\r\n          <div class=\"control\">\r\n            <a href=\"#\" class=\"button is-light\">\r\n              <span class=\"icon\">\r\n                <i class=\"fa fa-github\"></i>\r\n              </span>\r\n              <span>Github</span>\r\n            </a>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <div class=\"navbar-end\">\r\n        <div class=\"navbar-item\">\r\n          <a href=\"#\" class=\"button is-info\">\r\n            <span class=\"icon\">\r\n              <i class=\"fa fa-pencil\"></i>\r\n            </span>\r\n            <span>创作</span>\r\n          </a>\r\n        </div>\r\n        <a href=\"#\" class=\"navbar-item\">登录</a>\r\n        <a href=\"#\" class=\"navbar-item\">注册</a>\r\n    </div>\r\n  </div>\r\n</nav>\r\n```','2017-12-06 07:21:30','2017-12-06 07:21:30','bulma-learning-notes-the-navigation-bar-navbar-last'),(530,3,3,'Bulma 学习笔记：导航栏 .navbar（下篇）','接下来要讲的是 **固定导航栏**。固定导航栏分在顶部和底部的，只要在 `.navbar` 添加一个辅助类就可以了。\r\n\r\n```\r\n<nav class=\"navbar is-fixed-top\"></nav>\r\n\r\n<nav class=\"navbar is-fixed-bottom\"></nav>\r\n```\r\n\r\n对应的，再为 `<html>` 设置\r\n\r\n```html\r\n<html class=\"has-navbar-fixed-top\">\r\n\r\n<html class=\"has-navbar-fixed-bottom\">\r\n```\r\n\r\n这是为了给页面提供适当的 `padding` 值。\r\n\r\n有一点需要注意的是，当 `is-fixed-bottom` 下存在下拉框菜单项（`.navbar-item.has-dropdown`）时，要为其添加 `has-dropdown-up` 方能在 hover 时在 **上部显式** 下拉框内容。\r\n\r\n```html\r\n<nav class=\"navbar is-fixed-bottom is-light\">\r\n  <div class=\"navbar-brand\">\r\n    ...\r\n  </div>\r\n  <div id=\"siteMenu5\" class=\"navbar-menu\">\r\n    <div class=\"navbar-start\">\r\n      <a href=\"#\" class=\"navbar-item\">首页</a>\r\n      <!-- .has-dropdown-up: hover 时，在上部显式下拉框内容 -->\r\n      <div class=\"navbar-item has-dropdown has-dropdown-up is-hoverable\">\r\n        ...\r\n      </div>\r\n    </div>\r\n  </div>\r\n</nav>\r\n```\r\n\r\n在 [这里](https://codepen.io/zhangbao/pen/QOPzgG) 可以看到完整源码。','2017-12-06 07:43:26','2017-12-06 07:43:26','bulma-learning-notes-the-navigation-bar-navbar-next'),(531,3,3,'webpack 学习笔记：起步','接下来将创建两个项目，一个使用 webpack，一个没使用 webpack，来说明使用 webpack 的优势所在。\r\n\r\n## 从前\r\n\r\n我们先创建一个项目，按照以前的开发逻辑来写代码。这是项目结构：\r\n\r\n```\r\nwebpack-demo\r\n|- index.html\r\n|- /src\r\n  |- lodash.js\r\n  |- index.js\r\n```\r\n\r\n`index.html` 的内容如下，它引入了 [lodash.js](https://github.com/lodash/lodash) 库：\r\n\r\n```html\r\n<html>\r\n  <head>\r\n    <title>Getting Started</title>\r\n    <!-- 这里引入 lodash.js，是因为 index.js 中使用了它 -->\r\n    <script src=\"src/lodash.js\"></script>\r\n  </head>\r\n  <body>\r\n    <script src=\"src/index.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n下面再写 `index.js` 的内容：\r\n\r\n```javascript\r\nfunction component() {\r\n  var elem = document.createElement(\'div\');\r\n\r\n  // 这里使用了 lodash 的 _.join 方法，所以务必确保引入页面（这里就是指 index.html）包含 lodash.js。                  \r\n  elem.innerHTML = _.join([\'Hello\', \'World\'], \' \');\r\n\r\n  return elem;\r\n}\r\n\r\ndocument.body.appendChild(component());\r\n```\r\n\r\n最后直接打开 `index.html`，就能看到“Hello World”了。 但这样写是有缺点的。\r\n\r\n### 缺点\r\n\r\n1. 我们不能立即就能看明白 `index.js` 脚本文件里面依赖了 `lodash.js`。\r\n2. 如果引入脚本文件的页面中，没有把脚本依赖的库引入，或者引入顺序不对，就会导致脚本执行出错。对应到此例中，就是说 `index.html` 页面中，如果没有引入 `lodash.js` 或者引入的顺序不对，`index.js` 脚本在执行时就会出错。\r\n\r\n```html\r\n<html>\r\n  <head>\r\n    <title>Getting Started</title>\r\n    <!-- 第 1 种情况：没有引入 lodash.js 库 -->\r\n  </head>\r\n  <body>\r\n    <script src=\"src/index.js\"></script>\r\n  </body>\r\n</html>\r\n\r\n<html>\r\n  <head>\r\n    <title>Getting Started</title>\r\n  </head>\r\n  <body>\r\n    <script src=\"src/index.js\"></script>\r\n    <!-- 第 2 种情况：引入 lodash.js 的顺序不对 -->\r\n    <script src=\"src/lodash.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n3. 如果依赖库引入但是没有使用，那就相当于加载了无用的代码，还浪费了带宽。\r\n\r\n```html\r\n<html>\r\n  <head>\r\n    <title>Getting Started</title>\r\n    <!-- 第 3 种情况：引入 lodash.js，但是没有使用 -->\r\n    <script src=\"src/lodash.js\"></script>\r\n  </head>\r\n  <body>\r\n    <script src=\"src/index.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n这就是为什么使用 webpack 的原因。\r\n\r\n## 现在\r\n\r\n下面我们重新创建一个项目结构。\r\n\r\n```haskell\r\n$ mkdir webpack-demo && cd webpack-demo\r\n$ yarn init -y\r\n$ yarn global add webpack\r\n```\r\n\r\n然后创建下列的文件结构。\r\n\r\n```git\r\n  webpack-demo\r\n  |- package.json\r\n+ |- /dist\r\n+   |- index.html\r\n+ |- /src\r\n+   |- index.js\r\n```\r\n\r\n我们把 `index.html` 文件放在了 `dist` 目录下，下面是它的内容。\r\n\r\n```html\r\n<html>\r\n  <head>\r\n    <title>Getting Started</title>\r\n  </head>\r\n  <body>\r\n    <script src=\"bundle.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n`bundle.js` 是后面使用 webpack 生成，这里我们先引入进来。接着写我们的 `index.js` 的内容。\r\n\r\n```javascript\r\nimport _ from \"lodash\";\r\n\r\nfunction component() {\r\n	var elem = document.createElement(\'div\');\r\n\r\n	elem.innerHTML = _.join([\'Hello\', \'World!\'], \' \');\r\n\r\n	return elem;\r\n}\r\n\r\ndocument.body.appendChild(component());\r\n```\r\n\r\n这里与之前唯一不同的地方是使用了 ES6 `import` 语法显式引入了依赖库 lodash。\r\n\r\n接下来在 `webpack-demo` 目录中，下载咱们的依赖库。\r\n\r\n```haskell\r\n$ yarn add lodash\r\n```\r\n\r\n### 使用 webpack\r\n\r\n最后用 webpack 生成咱们的 `bundle.js` 文件。\r\n\r\n```haskell\r\n$ webpack src/index.js dist/bundle.js\r\nHash: 62c9e5dfb09247714f2f\r\nVersion: webpack 3.10.0\r\nTime: 609ms\r\n    Asset    Size  Chunks                    Chunk Names\r\nbundle.js  544 kB       0  [emitted]  [big]  main\r\n   [0] ./src/index.js 211 bytes {0} [built]\r\n   [2] (webpack)/buildin/global.js 509 bytes {0} [built]\r\n   [3] (webpack)/buildin/module.js 517 bytes {0} [built]\r\n    + 1 hidden module\r\n```\r\n\r\n我们使用了 `webpack` 指令将 `src/index.js` 处理成 `dist/bundle.js` 文件了。现在打开 `index.html`，就能看到“Hello World!”了。\r\n\r\n*注意这个过程没有涉及 `index.html`，之前我们在其中已经提前声明引入 `bundle.js` 脚本。*\r\n\r\n### 使用配置文件\r\n\r\n真正的项目开发要比咱们举的这个简单例子复杂多了，这就是为什么要有配置文件的原因。接下来我们添加一个配置文件。\r\n\r\n```git\r\n  webpack-demo\r\n  |- package.json\r\n+ |- webpack.config.js\r\n  |- /dist\r\n    |- index.html\r\n  |- /src\r\n    |- index.js\r\n```\r\n \r\n`webpack.config.js` 的内容。\r\n\r\n```javascript\r\nconst path = require(\'path\');\r\n\r\nmodule.exports = {\r\n  entry: \'./src/index.js\',\r\n  output: {\r\n    filename: \'bundle.js\',\r\n    path: path.resolve(__dirname, \'dist\')\r\n  }\r\n};\r\n```\r\n\r\n接下来使用配置文件构建咱们的项目\r\n\r\n```haskell\r\n$ webpack --config webpack.config.js\r\nHash: 62c9e5dfb09247714f2f\r\nVersion: webpack 3.10.0\r\nTime: 653ms\r\n    Asset    Size  Chunks                    Chunk Names\r\nbundle.js  544 kB       0  [emitted]  [big]  main\r\n   [0] ./src/index.js 211 bytes {0} [built]\r\n   [2] (webpack)/buildin/global.js 509 bytes {0} [built]\r\n   [3] (webpack)/buildin/module.js 517 bytes {0} [built]\r\n    + 1 hidden module\r\n```\r\n\r\n我们使用了 `--config` 选项，显示指定咱们的配置文件是 `webpack.config.js`，其实 webpack 默认文件名就是 `webpack.config.js`，就是说\r\n\r\n```haskell\r\n$ webpack --config webpack.config.js\r\n\r\n# 等同于\r\n$ webpack\r\n```\r\n\r\n不过使用 `--config` 选项的一个好处是，可以指定使用哪个配置文件来构建项目。\r\n\r\n### npm 脚本\r\n\r\n我们还可以使用 npm 脚本执行咱们的 `webpack` 指令。\r\n\r\npackage.json\r\n\r\n```javascript\r\n{\r\n  ...\r\n  \"scripts\": {\r\n    \"build\": \"webpack\"\r\n  },\r\n  ...\r\n}\r\n```\r\n\r\n下面你就可以用 `npm run build` 执行 webpack 构建了。使用这种方式的好处之一是，对于本地安装的依赖包，可以直接使用包命令不用使用全路径查找到命令，并且还可以在执行命令时传递参数。\r\n\r\n## 总结\r\n\r\n至此，“webpack 起步”一节讲完了。现在你的项目结构应该是这样的。\r\n\r\n```\r\nwebpack-demo\r\n|- package.json\r\n|- webpack.config.js\r\n|- /dist\r\n  |- bundle.js\r\n  |- index.html\r\n|- /src\r\n  |- index.js\r\n|- /node_modules\r\n```','2017-12-07 01:41:05','2017-12-07 02:13:40','webpack-learning-notes-start'),(532,3,3,'webpack 学习笔记：资产管理（CSS 和图片）','webpack 除了能够处理 JavaScript 脚本，还可以处理其他类型的资产，比如 CSS 和图片等，但是需要依赖额外的 Loader，因为这些资源不像 JavaScript 是被 webpack 天然支持的。\r\n\r\n*tip: 其实在 webpack 中，每个“JavaScript 脚本”都被看做是一个独立的模块，这就是为什么在这些脚本文件里可以使用 ES6 `import` 和 `export` 语法的原因。*\r\n\r\n让我们先从处理 CSS 脚本开始说起。整个过程是在 [之前项目](http://baooab.com/forum/discussion/webpack-learning-notes-start) 的基础上修改的。\r\n\r\n## 加载 CSS\r\n\r\ndist/index.html\r\n\r\n```git\r\n<html>\r\n  <head>\r\n-    <title>Getting Started</title>\r\n+    <title>Asset Management</title>\r\n  </head>\r\n  <body>\r\n    <script src=\"./bundle.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n为了在 JavaScript 模块中能引入 CSS 文件，还需要安装和添加 `style-loader` 和 `css-loader`。\r\n\r\n```haskell\r\n$ yarn add style-loader css-loader --dev\r\n```\r\n\r\n在 webpack.config.js 中添加两个 loader。\r\n\r\n```git\r\n  const path = require(\'path\');\r\n\r\n  module.exports = {\r\n    entry: \'./src/index.js\',\r\n    output: {\r\n      filename: \'bundle.js\',\r\n      path: path.resolve(__dirname, \'dist\')\r\n    },\r\n+   module: {\r\n+     rules: [\r\n+       {\r\n+         test: /\\.css$/,\r\n+         use: [\r\n+           \'style-loader\',\r\n+           \'css-loader\'\r\n+         ]\r\n+       }\r\n+     ]\r\n+   }\r\n  };\r\n```\r\n\r\n以上规则定义，使用 `style-loader` 和 `css-loader` 来处理以 `css` 结尾的文件。这样就可以使用 `import \'./style.css\'` 在 JavaScritp 模块中引入依赖的样式表文件。当执行模块构建时，在 `<head>` 标签中就会插入一个 `<style>` 标签，标签里面是模块中使用到的所有 CSS 样式。\r\n\r\n然后为咱们的项目添加样式文件 `style.css`。\r\n\r\n```git\r\n  webpack-demo\r\n  |- package.json\r\n  |- webpack.config.js\r\n  |- /dist\r\n    |- bundle.js\r\n    |- index.html\r\n  |- /src\r\n+   |- style.css\r\n    |- index.js\r\n  |- /node_modules\r\n```\r\n\r\nsrc/style.css\r\n\r\n```css\r\n.hello {\r\n  color: red;\r\n}\r\n```\r\n\r\nsrc/index.js\r\n\r\n```git\r\n  import _ from \'lodash\';\r\n+ import \'./style.css\';\r\n\r\n  function component() {\r\n    var element = document.createElement(\'div\');\r\n\r\n    // Lodash, now imported by this script\r\n    element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\r\n+   element.classList.add(\'hello\');\r\n\r\n    return element;\r\n  }\r\n\r\n  document.body.appendChild(component());\r\n```\r\n\r\n最后执行构建。\r\n\r\n```haskell\r\n$ yarn run build\r\nyarn run v1.3.2\r\n$ webpack\r\nHash: e9d9a1ef29134747427a\r\nVersion: webpack 3.10.0\r\nTime: 1352ms\r\n    Asset    Size  Chunks                    Chunk Names\r\nbundle.js  561 kB       0  [emitted]  [big]  main\r\n   [0] ./src/index.js 258 bytes {0} [built]\r\n   [2] (webpack)/buildin/global.js 509 bytes {0} [built]\r\n   [3] (webpack)/buildin/module.js 517 bytes {0} [built]\r\n   [4] ./src/style.css 1.01 kB {0} [built]\r\n   [5] ./node_modules/css-loader!./src/style.css 193 bytes {0} [built]\r\n    + 4 hidden modules\r\nDone in 2.76s.\r\n```\r\n\r\n现在打开 `index.html` 文件，能看到红色的“Hello World”，而且在 `index.html` 中插入了一个 `<style>` 标签。\r\n\r\n```html\r\n<style type=\"text/css\">.hello {\r\n	color: red;\r\n}</style>\r\n```\r\n\r\n## 加载图片\r\n\r\n构建时如果需要处理图片，就需要安装 `file-loader`。\r\n\r\n```haskell\r\n$ yarn add file-loader --dev\r\n```\r\n\r\nwebpack.config.js\r\n\r\n```git\r\n  const path = require(\'path\');\r\n\r\n  module.exports = {\r\n    entry: \'./src/index.js\',\r\n    output: {\r\n      filename: \'bundle.js\',\r\n      path: path.resolve(__dirname, \'dist\')\r\n    },\r\n    module: {\r\n      rules: [\r\n        {\r\n          test: /\\.css$/,\r\n          use: [\r\n            \'style-loader\',\r\n            \'css-loader\'\r\n          ]\r\n        },\r\n+       {\r\n+         test: /\\.(png|svg|jpg|gif)$/,\r\n+         use: [\r\n+           \'file-loader\'\r\n+         ]\r\n+       }\r\n      ]\r\n    }\r\n  };\r\n```\r\n\r\nproject\r\n\r\n```git\r\n  webpack-demo\r\n  |- package.json\r\n  |- webpack.config.js\r\n  |- /dist\r\n    |- bundle.js\r\n    |- index.html\r\n  |- /src\r\n+   |- icon.png\r\n    |- style.css\r\n    |- index.js\r\n  |- /node_modules\r\n```\r\n\r\nsrc/index.js\r\n\r\n```git\r\n  import _ from \'lodash\';\r\n  import \'./style.css\';\r\n+ import Icon from \'./icon.png\';\r\n\r\n  function component() {\r\n    var element = document.createElement(\'div\');\r\n\r\n    // Lodash, now imported by this script\r\n    element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\r\n    element.classList.add(\'hello\');\r\n\r\n+   // Add the image to our existing div.\r\n+   var myIcon = new Image();\r\n+   myIcon.src = Icon;\r\n+\r\n+   element.appendChild(myIcon);\r\n\r\n    return element;\r\n  }\r\n\r\n  document.body.appendChild(component());\r\n```\r\n\r\nsrc/style.css\r\n\r\n```git\r\n  .hello {\r\n    color: red;\r\n+   background: url(\'./icon.png\');\r\n  }\r\n```\r\n\r\n通过 `import Icon from \'./icon.png\'` 引入的图片会被处理添加到输出目录（即 `dist`），并且变量 `myIcon` 包含的图片地址是最终处理后的。\r\n\r\n同样，在 CSS 中出现 `url(\'./my-image.png\')` 的地方，css-loader 会识别这是一个本地文件，并替换图片路径 `\'./my-image.png\'` 为输出目录中的处理后的图片路径。\r\n\r\n\r\n\r\n接下来，构建项目：\r\n\r\n```haskell\r\n$ yarn run build\r\nyarn run v1.3.2\r\n$ webpack\r\nHash: 5abfae882a720ff2a5c5\r\nVersion: webpack 3.10.0\r\nTime: 1375ms\r\n                               Asset     Size  Chunks                    Chunk Names\r\n0873b41292cd64ba4d16e83e88deee02.png  10.9 kB          [emitted]\r\n                           bundle.js   561 kB       0  [emitted]  [big]  main\r\n   [0] ./src/water_icon.png 82 bytes {0} [built]\r\n   [1] ./src/index.js 403 bytes {0} [built]\r\n   [3] (webpack)/buildin/global.js 509 bytes {0} [built]\r\n   [4] (webpack)/buildin/module.js 517 bytes {0} [built]\r\n   [5] ./src/style.css 1.01 kB {0} [built]\r\n   [6] ./node_modules/css-loader!./src/style.css 252 bytes {0} [built]\r\n    + 4 hidden modules\r\nDone in 2.82s.\r\n```\r\n\r\n可以看到，`src/water_icon.png` 图片处理成 `dist/0873b41292cd64ba4d16e83e88deee02.png` 了。','2017-12-07 03:04:25','2017-12-07 03:04:25','webpack-learning-notes-asset-management-css-and-images'),(533,3,3,'Vue.js 学习笔记：在组件中使用 v-for 指令','在自定义组件中，我们可以像在任何普通元素上使用 `v-for` 指令。\r\n\r\n*2.2.0+ 的版本里，当在组件中使用 `v-for` 时，`key` 是必须要提供的。*\r\n\r\n```html\r\n<my-component v-for=\"item in items\" :key=\"item.id\"></my-component>\r\n```\r\n\r\n**任何数据都不会被自动传递到组件** 里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用 `props`。\r\n\r\n```html\r\n<my-component\r\n  v-for=\"(item, index) in items\"\r\n  v-bind:item=\"item\"\r\n  v-bind:index=\"index\"\r\n  v-bind:key=\"item.id\"\r\n></my-component>\r\n\r\n// 在子组件中显式接收要使用的数据\r\nprops: [\'item\', \'index\'];\r\n```\r\n\r\n之所以不将 `item`/`index` 自动注入到组件的原因是，这会使得组件与 `v-for` 的运作紧密耦合，明确组件数据的来源能够使组件在其他场合重复使用。','2017-12-07 03:44:30','2017-12-07 03:44:30','vue-js-learning-notes-using-v-in-component-for-instructions'),(534,3,3,'Vue.js 学习笔记 - Todo List','接下来完成一个 Todo List，两种方案。\r\n\r\n1. 一个组件。\r\n2. 两个组件，即父子组件。父组件添加 Todo，子组件触发删除 Todo 操作。\r\n\r\n## 一个组件\r\n\r\n```html\r\n<div id=\"todo-list-example\">\r\n  <input v-model=\"newTodoText\" @keyup.enter=\"addNewTodo\">\r\n  <ul>\r\n    <li v-for=\"(todo, index) in todos\">{{ todo.title }} <button @click=\"deleteTodo(index)\">X</button></li>\r\n  </ul>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#todo-list-example\',\r\n  data: {\r\n    newTodoText: \'\',\r\n    todos: [\r\n      {\r\n        id: 1,\r\n        title: \'Do the dishes\',\r\n      },\r\n      {\r\n        id: 2,\r\n        title: \'Take out the trash\',\r\n      },\r\n      {\r\n        id: 3,\r\n        title: \'Mow the lawn\'\r\n      }\r\n    ],\r\n    nextTodoId: 4\r\n  },\r\n  methods: {\r\n    addNewTodo: function () {\r\n      this.todos.push({\r\n        id: this.nextTodoId++,\r\n        title: this.newTodoText\r\n      });\r\n\r\n      this.newTodoText = \'\';\r\n    },\r\n    deleteTodo: function (index) {\r\n      this.todos.splice(index, 1);\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## 两个组件\r\n\r\n```html\r\n<div id=\"todo-list-example\">\r\n  <input v-model=\"newTodoText\" @keyup.enter=\"addNewTodo\" placeholder=\"Add a todo\">\r\n  <ul>\r\n    <li is=\"todo-item\" v-for=\"(todo, index) in todos\" :title=\"todo.title\" :key=\"todo.id\" @remove=\"todos.splice(index, 1)\"></li> \r\n  </ul>\r\n</div>\r\n\r\n<script>\r\nVue.component(\'todo-item\', {\r\n  props: [\'title\'],\r\n  template: \'\\\r\n    <li>\\\r\n      {{ title }}\\\r\n      <button @click=\"$emit(\\\'remove\\\')\">X</button>\\\r\n    </li>\\\r\n  \'\r\n});\r\n\r\nnew Vue({\r\n  el: \'#todo-list-example\',\r\n  data: {\r\n    newTodoText: \'\',\r\n    todos: [\r\n      {\r\n        id: 1,\r\n        title: \'Do the dishes\',\r\n      },\r\n      {\r\n        id: 2,\r\n        title: \'Take out the trash\',\r\n      },\r\n      {\r\n        id: 3,\r\n        title: \'Mow the lawn\'\r\n      }\r\n    ],\r\n    nextTodoId: 4\r\n  },\r\n  methods: {\r\n    addNewTodo: function () {\r\n      this.todos.push({\r\n        id: this.nextTodoId++,\r\n        title: this.newTodoText\r\n      });\r\n\r\n      this.newTodoText = \'\';\r\n    }\r\n  }\r\n});\r\n</script>\r\n```','2017-12-07 03:57:03','2017-12-07 03:57:03','vue-js-learning-notes-the-todo-list'),(535,3,3,'Vue.js 学习笔记：事件处理','## `v-on` 指令\r\n\r\n使用 `v-on` 指令（或者其简写形式 `@`）监听 DOM 事件，在此指令后可直接指定要执行的 JavaScript 代码。\r\n\r\n```html\r\n<button @click=\"counter += 1\">加 1</button>\r\n<p>已然点击了 {{ counter }} 次。</p>\r\n\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    counter: 0\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## 事件处理方法\r\n\r\n直接把事件处理逻辑写在 `v-on` 指令里有时不太合适，特别是在事件处理逻辑非常复杂的时候，这种情况，选择使用事件处理方法是更明智的做法。事件处理方法是在 Vue 的 `methods` 属性里定义的。\r\n\r\n```html\r\n<button @click=\"counterFn\">加 1</button>\r\n<p>已然点击了 {{ counter }} 次。</p>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    counter: 0\r\n  },\r\n  methods: {\r\n    counterFn: function () {\r\n      this.counter += 1;\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n在事件处理方法中要注意的是：\r\n\r\n1. 方法里 `this` 总是指向当前的 Vue 实例。\r\n2. 直接绑定到一个方法（即直接写事件处理方法名，而没有向其传递参数）会在方法调用时，默认传递给一个原生 DOM 事件对象.\r\n\r\n```javascript\r\nnew Vue({\r\n  ...\r\n  methods: {\r\n    // event 是原生 DOM 事件对象\r\n    counterFn: function (event) {\r\n      // this 指向当前的 Vue 实例\r\n      this.counter += 1;\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n### 参数\r\n\r\n除了直接绑定到一个方法，也可以在调用方法时传递参数，如果还要访问原始的 DOM 事件对象，需要用特殊变量 `$event` 把它传入进去。\r\n\r\n```html\r\n<button @click=\"warn(\'Hi!\', $event)\">打招呼</button>\r\n\r\n<script>\r\nnew Vue({\r\nel: \'#app\',\r\nmethods: {\r\n  warn: function (msg, event) {\r\n    alert(msg + \' \' + event.type);\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n## 事件修饰符\r\n\r\nVue.js 为事件提供了“事件修饰符”，它是由 `. + 后缀` 的形式表示的。\r\n\r\n- `.stop`\r\n- `.prevent`\r\n- `.capture`\r\n- `.self`\r\n- `.once`\r\n\r\n### 按键修饰符\r\n\r\nVue.js 为事件提供了“按键修饰符”，它也是由「. + 后缀」的形式表示的。\r\n\r\n下面一段代码是只有在按下 Enter 键（对应 `keyCode· 值为 13）的时候调用 `submit` 方法。\r\n\r\n```html\r\n<input v-on:keyup.13=\"submit\">\r\n```\r\n\r\n记住所有的 `keyCode` 比较困难，所以 Vue 为最常用的按键提供了别名：\r\n\r\n- `.enter`\r\n- `.tab`\r\n- `.delete` (捕获「删除」和「退格」键)\r\n- `.esc`\r\n- `.space`\r\n- `.up`\r\n- `.down`\r\n- `.left`\r\n- `.right`\r\n\r\n我们还可以通过全局 `config.keyCodes` 对象自定义按键修饰符别名:\r\n\r\n```\r\nVue.config.keyCodes.f1 = 112;\r\n\r\n// 现在可以使用 `v-on:keyup.f1` 了\r\n```\r\n\r\n下面举一个例子：\r\n\r\n```html\r\n<input placeholder=\"捕获方向键 up、down、left 和 right\" @keyup.up.down.left.right=\"monitor\">\r\n<input placeholder=\"捕获 F1 按键\" @keyup.f1=\"monitor\">\r\n\r\n<script>\r\nVue.config.keyCodes.f1 = 112;\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  methods: {\r\n    monitor: function (event) {\r\n      console.log(event.keyCode);\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n### 鼠标事件修饰符\r\n\r\n鼠标按妞修饰符包括：\r\n\r\n- `.left`\r\n- `.middle`\r\n- `.right`\r\n\r\n```html\r\n<div id=\"app\">\r\n  <button @click.left=\"monitor(\'左键\')\">点击鼠标左键时触发</button>\r\n  <button @click.middle=\"monitor(\'滚轮按键\')\">点击鼠标滚轮按键时触发</button>\r\n  <button @click.right.prevent=\"monitor(\'右键\')\">点击鼠标右键时触发</button>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  methods: {\r\n    monitor(msg) {\r\n      console.log(msg);\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n### 系统修饰键\r\n\r\n系统修饰键包括：\r\n\r\n- `.ctrl`\r\n- `.alt`\r\n- `.shift`\r\n- `.meta`\r\n\r\n与常规按键不同，在和 `keyup` 事件一起用时，事件触发时系统修饰键也必须处于按下状态。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <!-- Ctrl + Enter -->\r\n  <input @keyup.ctrl.enter=\"clear\" placeholder=\"Ctrl + Enter\">\r\n\r\n  <!-- Ctrl + Click（ 即使 Alt 或 Shift 被一同按下时也会触发） -->\r\n  <div @click.ctrl=\"doSomething\">「Ctrl + Click」 Do something</div>\r\n\r\n  <!-- 仅在 Ctrl 被按下 + Click 的情况下才会触发 -->\r\n  <button @click.ctrl.exact=\"onCtrlClick\">A</button>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n\r\n  },\r\n  methods: {\r\n    clear: function () {\r\n      console.log(\'OK, cleared!\');\r\n    },\r\n    doSomething: function () {\r\n      console.log(\'OK, I am really doing something...\');\r\n    },\r\n    onCtrlClick: function () {\r\n      console.log(\'click exact 「Ctrl」 key\');\r\n    }\r\n  }\r\n});\r\n</script>\r\n```','2017-12-07 05:45:53','2017-12-07 05:45:53','vue-js-learning-notes-event-handling'),(536,3,3,'Vue.js 学习笔记：表单元素绑定','表单元素绑定更常使用 `v-model` 指令，本质上 `v-model` 指令不过是一个语法糖----在用户触发输入事件时更新数据，以及对某些边缘情况的特殊处理。\r\n\r\n需要注意的是：`v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` 特性的初始值，而用 Vue 实例数据来作为具体的值。所以，你应该通过 JavaScript 在组件的 `data` 选项中声明绑定表单元素的初始值。\r\n\r\n```html\r\n<input v-model=\"msg\">\r\n```\r\n\r\n## 绑定复选框\r\n\r\n绑定复选框分两种情况：单个复选框和一组复选框。单个复选框的例子是“是否同意协议”之类的勾选条件；一组复选框就是可多选的一个字段，比如文章标签。\r\n\r\nVue.js 处理单个复选框和一组复选框的底层数据结构是不一样的。\r\n\r\n1. 单个复选框的情况下，底层对应一个布尔值。\r\n    - 布尔值为 `true` 的时候，复选框显示为选中状态。\r\n    - 布尔值为 `false` 的时候，复选框显示为非选中状态。\r\n2. 一组复选框的情况下，底层对应一个数组，数组里每个元素对应拥有此值、被选中的复选框。需要注意的是：如果多个复选框拥有一样的 value 值，那么在勾选/取消勾选时，这多个复选框会同时发生状态改变，并且数组里改变且唯一改变的 **只是一个值**。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p><input type=\"checkbox\" v-model=\"checked\"></p>\r\n  <p>checked: {{ checked }}</p>\r\n\r\n  <p>\r\n    <input type=\"checkbox\" value=\"foo\" v-model=\"checkes\">\r\n    <input type=\"checkbox\" value=\"bar\" v-model=\"checkes\">\r\n    <input type=\"checkbox\" value=\"lala\" v-model=\"checkes\">\r\n  </p>\r\n  <p>{{ checkes }}</p>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    checked: true,\r\n    checkes: []\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## 绑定单选框\r\n\r\n与复选框不同的是，单选按钮绑定的底层数据既不是一个布尔值，也不是一个数组，而是 **字符串**，字符串的值对应单选按钮的 `value` 值。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <input type=\"radio\" value=\"secret\" v-model=\"picked\"><label for=\"secret\">保密</label>\r\n  <input type=\"radio\" value=\"male\" v-model=\"picked\"><label for=\"male\">男</label>\r\n  <input type=\"radio\" value=\"female\" v-model=\"picked\"><label for=\"female\">女</label>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    picked: \'secret\'\r\n  }\r\n}); \r\n</script>\r\n```\r\n\r\n## 绑定选择列表框\r\n\r\n选择列表框还要分两种情况：\r\n\r\n1. 仅可选单个选项：与 v-model 绑定的那个数据是一个字符串。\r\n2. 可选多个选项：与 v-model 绑定的那个数据是一个数组。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <h3>选择单个选项</h3>\r\n  <select v-model=\"selected\" class=\"select\">\r\n    <option disabled value=\"\">请选择</option>\r\n    <option>A</option>\r\n    <option>B</option>\r\n    <option>C</option>\r\n  </select>\r\n  <p>选择的：{{ selected }}</p>\r\n  \r\n  <h3>选择单多个选项</h3>\r\n  <select v-model=\"selected2\" multiple>\r\n    <option disabled value=\"\">请选择</option>\r\n    <option>A</option>\r\n    <option>B</option>\r\n    <option>C</option>\r\n  </select>\r\n  <p>选择的：{{ selected2 }}</p>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    selected: \'\',\r\n    selected2: []\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n下面使用 `v-for` 动态生成 `<option>` 选项，再用 `v-model` 绑定选择框默认选中的值。 \r\n\r\n```html\r\n<div id=\"app\">\r\n  <select v-model=\"selected\" multiple>\r\n    <option disabled value=\"\">请选择</option>\r\n    <option v-for=\"opt in opts\" :value=\"opt.value\">{{ opt.text }}</option>\r\n  </select>\r\n  <p>选择的：{{ selected }}</p>\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\nel: \'#app\',\r\ndata: {\r\n  opts: [\r\n    { text: \'One\', value: \'A\' },\r\n    { text: \'Two\', value: \'B\' },\r\n    { text: \'Three\', value: \'C\' }\r\n  ],\r\n  selected: [\'A\', \'B\']\r\n}\r\n</script>\r\n```\r\n\r\n这里 `value` 值是 `A` 和 `B` 的选项初始化时被选中了。\r\n\r\n## 将表单元素的 value 值绑定到动态属性上\r\n\r\n这要根据表单元素类型来分情况:\r\n\r\n1. 对于单个复选按钮，默认不是 `true` 或者 `false` 吗，如果要把 `true` 和 `false` 分别替换为我们想要的值，就得绑定 `true-value` 和 `false-value` 这两个特性了。对于一组复选按钮，直接在绑定 `value` 属性的时候指定绑定变量即可。\r\n\r\n2. 对于单选按钮，直接在绑定 `value` 属性的时候指定绑定变量即可。\r\n\r\n3. 对于选择框，直接在绑定 `value` 属性的时候指定绑定变量即可。\r\n\r\n总体来看，绑定到动态属性这一功能对「单个复选框」的作用比较大，可以自定义取值不为 `true` 和 `false`，而是自定义数据类型。\r\n\r\n```html\r\n<div id=\"app\">\r\n      <!-- 针对单个复选框 ，绑定动态属性 -->\r\n      <input type=\"checkbox\" id=\"aCheckbox\" v-model=\"checked\" \r\n        :true-value=\"a\"\r\n        :false-value=\"b\"\r\n        ><label for=\"aCheckbox\">勾选表示接受《使用协议》</label> | {{ checked }}\r\n      \r\n     <br>\r\n     \r\n     <!-- 一组复选框 -->\r\n     <input type=\"checkbox\" v-model=\"checked3\" :value=\"f\"> \r\n     <input type=\"checkbox\" v-model=\"checked3\" :value=\"g\"> \r\n     <input type=\"checkbox\" v-model=\"checked3\" :value=\"h\"> \r\n     | {{ checked3 }}\r\n     \r\n     <br>\r\n     \r\n     <!-- 针对单选按钮 ，绑定动态属性 -->\r\n    <input type=\"radio\" id=\"aRadio\" v-model=\"checked2\" :value=\"c\"><label for=\"aRadio\">男</label>\r\n    <input type=\"radio\" id=\"aRadio2\" v-model=\"checked2\" :value=\"d\"><label for=\"aRadio2\">女</label>\r\n    <input type=\"radio\" id=\"aRadio3\" v-model=\"checked2\" :value=\"e\"><label for=\"aRadio3\">保密</label> | {{ checked2 }}\r\n    \r\n    <br>\r\n    \r\n     <select v-model=\"selected\">\r\n        <option disabled value=\"\">请选择</option>\r\n        <!-- 内联对象字面量 -->\r\n        <option v-bind:value=\"{ number: 123 }\">123</option>\r\n        <option v-bind:value=\"{ number: 456 }\">123</option>\r\n     </select>\r\n     {{ selected }}\r\n</div>\r\n\r\n<script>\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    checked: \'√\',\r\n    checked2: \'(>^ω^<)\',\r\n    checked3: [],\r\n    selected: \'\',\r\n    a: \'√\',\r\n    b: \'×\',\r\n    c: \'♂\',\r\n    d: \'♀\',\r\n    e: \'(>^ω^<)\',\r\n    f: \'吃蛋\',\r\n    g: \'游泳\',\r\n    h: \'睡觉\'\r\n  }\r\n});\r\n</script>\r\n```','2017-12-07 06:53:09','2017-12-07 06:53:09','vue-js-learning-notes-form-element-binding'),(537,3,3,'Vue.js 学习笔记：组件','## 全局组件和局部组件\r\n\r\n组件分全局组件和局部组件。全局组件注册好后，在任何 Vue 应用中都可使用；局部组件只在注册的组件作用域中有效。\r\n\r\n1. 全局组件使用 `Vue.component(tagName, options)` 方法注册。\r\n2. 局部组件在组件实例的 `components` 属性中注册。\r\n\r\n```javascript\r\n// 1. 注册全局组件\r\nVue.component(\'my-componnet\', {\r\n  template: \'<div>A custom component</div>\'\r\n});\r\n\r\n// 2. 注册局部组件\r\nvar MyComponent = {\r\n  template: \'<div>A custom component</div>\'\r\n};\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  components: {\r\n    \'my-component\': MyComponent\r\n  }\r\n});\r\n```\r\n\r\n需要注意的是，组件也可以表现为用 `is` 特性进行扩展了的原生 HTML 元素。之后解释为什么。\r\n\r\n## `is` 特性\r\n\r\n下面解释为什么要用 is 特性来扩展原生 HTML 元素来渲染组件。直接使用自定义组件不就完了吗？是这样的----\r\n\r\n当使用 DOM 作为模板时，会受到 HTML 本身的一些规则限制，因为 Vue 只会在浏览器解析、规范化模板之后才能获取其内容。而像 `<ul>`、`<ol>`、`<table>` 和 `<select>` 这样的元素包含的元素是有限制的，而像另一些像 `<option>` 元素标签只能出现在特定元素的内部。\r\n\r\n如果像这样\r\n\r\n```html\r\n<table>\r\n  <my-row>...</my-row>\r\n</table>\r\n```\r\n\r\n在 `<table>` 元素中直接包含我们的自定义组件 `<my-row>`。`<my-row>` 就会被当做无效内容，会导致错误的渲染结果。因此就出来了一个变通的方案：`is` 特性。\r\n\r\n```html\r\n<table>\r\n  <tr is=\"my-row\"></tr>\r\n</table>\r\n```\r\n\r\n这里的 `<tr>` 既能保证元素标签嵌套的合理性，也能保证以 `my-row` 组件的方式正确渲染。\r\n\r\n当然，如果使用的是来自以下来源之一的字符串模板，则不受这个限制：\r\n\r\n- `<script type=\"text/x-template\">`。\r\n- JavaScript 内联模板字符串。\r\n- `.vue` 组件。\r\n\r\n## `data` 是个函数\r\n\r\n注册组件时，`data` 属性要写成函数的形式----这是为了保证每个组件实例的数据都是相互独立的，而不会因为指向同一个对象发生数据擦除和修改的情况。\r\n\r\n```javascript\r\n// Bad\r\nvar data = { a: 2 };\r\n\r\nVue.component(\'my-componnet\', {\r\n  data: function () {\r\n    return data;\r\n  }\r\n});\r\n\r\n// Good\r\nVue.component(\'my-componnet\', {\r\n  data: function () {\r\n    return { a: 2 };\r\n  }\r\n});\r\n```\r\n\r\n## 组件组合\r\n\r\n组件组合最常见的关系是父子组件关系。这时就要涉及到两者的通信了。\r\n\r\n1. 父组件下发数据给子组件。\r\n2. 子组件告知父组件它内部发生的事情。\r\n\r\n在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据（Pass props），子组件通过事件给父组件发送消息（Emit Events）。\r\n\r\n### 下发数据\r\n\r\n在子组件中显式地用 `props` 选项声明它预期的数据，`props` 选项中的每一项称为一个 prop。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <!-- 父组件给子组件附加了一个 my-message 特性，值为字符串 \"hello!\" -->\r\n  <child my-message=\"hello from parent.\"></child>\r\n</div>\r\n\r\n<script>\r\nVue.component(\'child\', {\r\n  // 子组件中，在 props 选项中显式接收它要用的数据\r\n  props: [\'myMessage\'],\r\n  template: \'<span>{{ myMessage }}</span>\'\r\n})\r\n\r\nnew Vue({\r\n  el: \'#app\'\r\n});\r\n</script>\r\n```\r\n\r\n因为 HTML 不区分大小写，所以 kebab-case 的形式为子组件附加特性；在子组件中显式接收数据时，因为在 JavaScript 中，`-` 不是有效的标识符字符，所以最好用 camelCase 的形式接收。\r\n\r\n#### 传输整个对象\r\n\r\n如果你想把「一个对象的所有属性」作为 prop 进行传递，可以使用不带任何参数的 `v-bind` 指令。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <child v-bind=\"todo\"></child> \r\n  <!--\r\n    这种写法等同于\r\n    \r\n    <child v-bind:text=\"todo.text\" v-bind:is-completed=\"todo.isCompleted\"></child> \r\n  -->\r\n</div>\r\n\r\n<script>\r\nVue.component(\'child\', {\r\n  props: [\'text\', \'isCompleted\'],\r\n  template: \'\\\r\n    <span>text: {{ text }}, isCompleted: {{ isCompleted }}</span>\\\r\n  \'\r\n});\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    todo: {\r\n      text: \'Learn Vue.js\',\r\n      isCompleted: false\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n#### 传输一个数值\r\n\r\n使用字面量语法传递数值是办不到的，因为传递过去的是字符串而不是数值。如果想传递一个真正的 JavaScript 数值，则需要使用 `v-bind` 指令。\r\n\r\n```html\r\n<div id=\"app\">\r\n   <child digital=\"1\" :digital2=\"11\" :digital3=\"number\"></child>\r\n</div>\r\n\r\n<script>\r\n// ...\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    number: 22\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n1. `digital` 是一个字面量 prop，它的值是字符串 \"1\" 而不是一个数值。\r\n2. 使用 `v-bind`，`digital2` 绑定的 \"11\" 被作为 JavaScript 表达式计算。\r\n3. `digital3` 更不用说了，它绑定的变量 `number` 本来就是一个数值。\r\n\r\n### 下发数据是单向的\r\n\r\n下发数据（即 prop 绑定）是单向的----当父组件的属性变化时，将传导给子组件，但是反过来不会。每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。\r\n\r\n在两种情况下，我们很容易忍不住想去修改 prop 中数据：\r\n\r\n1. prop 作为初始值传入后，子组件想把它当作局部数据来用。\r\n2. prop 作为原始数据传入，由子组件处理成其它数据输出。\r\n\r\n针对这两种需求，我们都要对应的应对策略：\r\n\r\n1. 针对第一种情况：定义一个局部变量，并用 prop 的值初始化它。\r\n2. 针对第二种情况：定义一个计算属性，处理 prop 的值并返回。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <child :initial-counter=\"counter\" :size=\"size\"></child>\r\n</div>\r\n\r\n<script>\r\nVue.component(\'child\', {\r\n  props: [\'initialCounter\', \'size\'],\r\n  data: function () {\r\n    return {\r\n      counter: this.initialCounter\r\n    }\r\n  },\r\n  computed: {\r\n    normalizedSize: function () {\r\n      return this.size.trim().toLowerCase();\r\n    }\r\n  },\r\n  template: \'\\\r\n    <div class=\"container\">\\\r\n      <div class=\"content\">\\\r\n        <p><strong>下面两个变量全部来自于父级组件：</strong></p>\\\r\n        <p>子组件<code>&lt;child&gt;</code>中的局部变量<code>counter</code>的值：{{ counter }}</p>\\\r\n        <p>子组件<code>&lt;child&gt;</code>中的计算变量<code>normalizedSize</code>的值：{{ normalizedSize }}</p>\\\r\n      </div>\\\r\n    </div>\\\r\n  \'\r\n});\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    counter: 22,\r\n    size: \'    29PX\'\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n### prop 规则验证\r\n\r\n如果要对 prop 进行规则验证的话，那么在子组件里接收 prop 的 props 属性就不能是数组类型了，而是对象类型了。对象的属性时接收的 prop，对象的属性值就是一个验证规则，可以是一个函数、数组或者对象。\r\n\r\n一旦使用了 prop 规则验证后，没有规则限制的字段，也要务必给予值 `null`，指允许任何类型的值。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p>\r\n    编辑 pA 的值（接收 Number 类型）：<input type=\"text\" v-model.number=\"pA\"><br>\r\n    编辑 pB 的值（可接收 Number 或者 String 类型）：<input type=\"text\" v-model=\"pB\"><br>\r\n    编辑 pC 的值（必传且为 String 类型）：<input type=\"text\" v-model=\"pC\"><br>\r\n    编辑 pD 的值（接收 Number 类型，在子组件中设定了默认值 100）：<input type=\"text\" v-model.number=\"pD\"><br>\r\n    编辑 pF 的值（输入的值需要大于 10）：<input type=\"text\" v-model.number=\"pF\"><br>\r\n  </p>\r\n  <example :prop-a=\"pA\" :prop-b=\"pB\" :prop-c=\"pC\" :prop-d=\"pD\" :prop-f=\"pF\"></example>    \r\n</div>\r\n\r\n<script>\r\nvar Example = {\r\n  props: {\r\n    // 基础类型检测 (`null` 指允许任何类型)\r\n    propA: Number,\r\n    // 可以是多种类型\r\n    propB: [Number, String],\r\n    // 必传且是字符串\r\n    /*\r\ntype 可以是下面原生构造器：\r\n\r\nString\r\nNumber\r\nBoolean\r\nFunction\r\nObject\r\nArray\r\nSymbol\r\n*/\r\n    propC: {\r\n      type: String,\r\n      required: true // 默认是 false\r\n    },\r\n    // 数值且有默认值\r\n    propD: {\r\n      type: Number,\r\n      default: 100\r\n    },\r\n    // 数组/对象的默认值应当由一个工厂函数返回\r\n    propE: {\r\n      type: Object,\r\n      default: function () {\r\n        return { message: \'hello\' }\r\n      }\r\n    },\r\n    // 自定义验证函数\r\n    propF: {\r\n      validator: function (value) {\r\n        return value > 10\r\n      }\r\n    }\r\n  },\r\n  template: \'\\\r\n    <div>\\\r\n      <p>子组件 propA 的值: {{ propA }}({{ typeof propA }})</p>\\\r\n      <p>子组件 propB 的值: {{ propB }}({{ typeof propB }})</p>\\\r\n      <p>子组件 propC 的值: {{ propC }}({{ typeof propC }})</p>\\\r\n      <p>子组件 propD 的值: {{ propD }}({{ typeof propD }})</p>\\\r\n      <p>子组件 propE 的值: {{ propE }}({{ typeof propE }})</p>\\\r\n      <p>子组件 propF 的值: {{ propF }}({{ typeof propF }})</p>\\\r\n    </div>\\\r\n  \' \r\n};\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    pA: 12,\r\n    pB: \'baooab\',\r\n    pC: \'天天向上\',\r\n    pD: 1,\r\n    pF: 2\r\n  },\r\n  components: {\r\n    \'example\': Example\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n### 非 prop 特性\r\n\r\n在父组件调用子组件的地方，传递给子组件的特性如果没被子组件的 `props` 特性接收，就被称为是“非 prop 特性”。\r\n\r\n#### prop 特性\r\n\r\nprop 特性分两种：\r\n\r\n1. 静态 prop\r\n\r\n    - 向子组件中传递数据时，使用的是普通特性的形式。下例中，借助特性 `my-message`，传给子组件的实际上是一个普通的字符串“hello!”。\r\n    - 然后，子组件中显式地用 props 选项接收它。\r\n\r\n```\r\n<child my-message=\"hello!\"></child>\r\n\r\n// 子组件中显式接收数据\r\nprops: [\'myMessage\'],\r\n```\r\n    \r\n2. 动态 prop\r\n\r\n    - 向子组件中传递数据时，使用了 `v-bind` 指令将特性的值绑定给了父组件的一个数据。在下例中，借助特性 `my-message`，传给子组件的实际上是一个动态值。因为特性 `my-message` 绑定到父组件 `parentMsg` 数据，这样父组件中 `parentMsg` 的更新会同步到子组件。\r\n    - 组件中显式地用 props 选项接收它。\r\n\r\n```\r\n<child :my-message=\"parentMsg\"></child>\r\n\r\n// 父组件中的数据\r\ndata: {\r\n  parentMsg: \'massege from parent!\'\r\n}\r\n\r\n// 子组件中显式接收数据\r\nprops: [\'myMessage\'],\r\n```\r\n\r\n#### 非 prop 特性\r\n\r\n已经说过，非 prop 特性就是传递给子组件的特性如果没有被子组件显式使用 props 属性接收。那么会有发生什么呢？答案是 **特性会直接传入到组件的根元素上**。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <bs-date-input data-3d-date-picker=\"true\" class=\"date-picker-theme-dark\"></bs-date-input>\r\n</div>\r\n\r\n<script>\r\n Vue.component(\'bs-date-input\', {\r\n  template: \'\\\r\n    <input type=\"text\" class=\"form-control\">\\\r\n  \'\r\n})\r\n\r\nnew Vue({\r\n  el: \'#app\'\r\n});\r\n</script>\r\n```\r\n\r\n最终生成的数据结构是这样的：\r\n\r\n```html\r\n<div id=\"app\">\r\n  <input type=\"date\" class=\"form-control date-picker-theme-dark\" data-3d-date-picker=\"true\">\r\n</div>\r\n```\r\n\r\n对于多数特性来说，传递给组件的值会覆盖组件本身设定的值。即例如传递 `type=\"large\"` 将会覆盖 `type=\"date\"` 这就可能破坏了这个组件了！\r\n\r\n但是 Vue 对待 `class` 和 `style` 特性会更聪明一些，这两个特性的值都会做“合并（merge）操作”。\r\n\r\n下面我们来分析下，前面最终渲染出来的效果代码：\r\n\r\n1. `type`：原子组件中的 type=\"text\"，这里被覆盖为 type=\"date\"。\r\n2. `class`：给子组件传递过去的 `date-picker-theme-dark` class 与原子组件中的 `form-control class` 合并（并放在之后）。\r\n3. `data-3d-date-picker=\"true\"` 这是为子组件添加的新的特性。\r\n4. `style`：也发生了合并操作：\r\n    - `font-size` 从原来的 `12px` 覆盖成 `32px`。\r\n    - 添加了背景颜色样式 `background: pink;`。','2017-12-08 05:15:47','2017-12-08 05:38:09','vue-js-learning-notes-component'),(538,3,3,'Vue.js 学习笔记：自定义事件','父组件通过 prop 传递数据给子组件。子组件怎么跟父组件通信呢？自定义事件就是其中一种方式。\r\n\r\n每个 Vue 实例都支持：\r\n\r\n1. 使用 `$on(eventName)` 监听事件。\r\n2. 使用 `$emit(eventName)` 触发事件。\r\n\r\n在父组件使用子组件的地方直接用 `v-on` 来监听子组件触发的事件（不能用 `$on`，必须在模板里使用 `v-on` 绑定）。\r\n\r\n## 自定义组件上注册的事件都是自定义事件\r\n\r\n值得注意的是，在自定义组件上监听的事件名全部都是自定义事件名（即使像 click、keyup），因为说到底自定义组件是 Vue 实例，而不是原生的 DOM 对象，所以我们只能通过 Vue 实例实现的事件接口，手动监听和触发咱们的所有事件了。\r\n\r\n## 例子\r\n\r\n```html\r\n<div id=\"app\">\r\n  <p>{{ total }}</p>\r\n  <p>\r\n    <button-counter @increment=\"incrementTotal\"></button-counter>\r\n    <br>\r\n    <button-counter @increment=\"incrementTotal\"></button-counter>\r\n  </p>\r\n</div>\r\n\r\n<script>\r\nVue.component(\'button-counter\', {\r\n  template: \'\\\r\n    <button @click=\"incrementCounter\">{{ counter }}</button>\\\r\n  \',\r\n  data: function () {\r\n    return  {\r\n      counter: 0\r\n    };\r\n  },\r\n  methods: {\r\n    incrementCounter: function () {\r\n      this.counter += 1;\r\n      this.$emit(\'increment\');\r\n    }\r\n  }\r\n});\r\n\r\nnew Vue({\r\n  el: \'#counter-event-example\',\r\n  data: {\r\n    total: 0\r\n  },\r\n  methods: {\r\n    incrementTotal: function () {\r\n      this.total += 1;\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n在子组件中，使用 `this.$emit(\'increment\')` 就触发了在父组件中注册的 `increment` 事件，然后 `incrementTotal` 方法被调用，`total` 数量加 1。\r\n\r\n## 注册原生事件\r\n\r\n在使用子组件时，在注册事件时如果提供了修饰符 `.native`，那么这将会是一个原生事件的注册，不过这个原生事件注册在了组件的根元素上。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <my-component :txt=\"txt\" @click.native=\"doTheThing\"></my-component>\r\n</div>\r\n\r\n<script>\r\nVue.component(\'my-component\', {\r\n  template: \'\\\r\n    <div class=\"box\">\\\r\n      <button class=\"button\">{{ txt }}点击</button>\\\r\n    </div>\\\r\n  \',\r\n  props: [\'txt\']\r\n});\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    txt: \'未\'\r\n  },\r\n  methods: {\r\n    doTheThing: function () {\r\n      this.txt = (this.txt === \'未\' ? \'已\' : \'未\');\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n上面的案例中，我们为子组件 `my-component` 注册了 `@click.native`，这就等同于在 `.box` 上使用了 `click` 事件。','2017-12-10 05:55:10','2017-12-10 05:55:10','vue-js-learning-notes-custom-events'),(539,3,3,'JavaScript 复合数据类型转换','JavaScript 中的数据类型包括：基本数据类型和复合数据类型。\r\n\r\n1. 基本数据类型：数字、字符串、布尔值、`null`、`undefined`。\r\n2. 复合数据类型：对象、数组和函数。\r\n\r\n复合数据类型转换就是转换为基本数据类型。包含  3 类情况：\r\n\r\n1. 转换成布尔值。\r\n2. 转换成数字。\r\n3. 转换成字符串。\r\n\r\n## 1 转换为布尔值\r\n\r\n复合数据类型转换为布尔值都为 `true`。\r\n\r\n```javascript\r\nBoolean({}); // true\r\nBoolean([]); // true\r\nBoolean(function () {}); // true\r\n```\r\n\r\n## 2 转换成数字\r\n\r\n### 2.1 对象&函数转换成数字\r\n\r\n对象、函数都会转换成 `NaN`。\r\n\r\n```javascript\r\nNumber({}); // NaN\r\nNumber(function () {}); // NaN\r\n```\r\n\r\n### 2.2 数组转换成数字\r\n\r\n数组转换分 3 类情况：\r\n\r\n1. 空数组。\r\n	* 转换成 `0`。\r\n2. 包含一个成员的数组。\r\n	* 成员值能转换成数字，则数组最终转为这个数字。\r\n	* 否则，转换成 `NaN`。\r\n3. 其他情况。\r\n	* 转换成 `NaN`。\r\n\r\n```javascript\r\nNumber([]); // 0\r\nNumber([\'18\']); // 18\r\nNumber([\'18x\']); // NaN\r\nNumber([\'18\', \'18x\']); // NaN\r\n```\r\n \r\n## 3 转换成字符串\r\n\r\n### 3.1 数组转换成字符串\r\n\r\n数组转换为字符串的原理是调用了数组对象内部的 `.join(\',\')` 方法。所以结果是用 `,` 连接地、包含所有数组元素的一个字符串值。\r\n\r\n```javascript\r\nString([1,2,3]); // \"1,2,3\"\r\n```\r\n\r\n### 3.2 对象转换成字符串\r\n\r\n除了日期对象（`Date`），其它情况都转换为 `\"[object Object]\"`。\r\n\r\n```javascript\r\nString({}); // \"[object Object]\"\r\n```\r\n\r\n### 3.3 函数转换成字符串\r\n\r\n函数转为字符串的结果是把函数的整个内容作为字符串原样输出了。\r\n\r\n```javascript\r\nString(function () { console.log(\'keep\'); });\r\n// 输出：\"function () { console.log(\'keep\'); }\"\r\n\r\nfunction foo() {\r\n  return ;\r\n}\r\nString(foo);\r\n// 输出：\r\n// \"function foo() {\r\n//   return ;\r\n// }\"\r\n```','2017-12-11 01:17:09','2017-12-16 08:45:34','javascript-composite-data-type-conversion'),(540,3,3,'Vue.js 学习笔记：插槽','“插槽”使用 `<slot>` 标签定义，位于子组件中。\r\n\r\n## 匿名插槽\r\n\r\n在父组件引入子组件时，子组件标签之间的内容就是插入到插槽中的内容，并且这些内容会替换掉插槽标签本身。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <h1>我是父组件的标题</h1>\r\n  <my-component>\r\n    <p>这是一些初始内容</p>\r\n    <p>这是更多的初始内容</p>\r\n  </my-component>\r\n</div>\r\n\r\n<script>\r\nVue.component(\'my-component\', {\r\n  template: \'\\\r\n    <div>\\\r\n      <h2>我是子组件的标题</h2>\\\r\n      <slot>\\\r\n        只有在没有要分发的内容时才会显示\\\r\n      </slot>\\\r\n    </div>\\\r\n  \'\r\n});\r\n\r\nnew Vue({\r\n  el: \'#app\'\r\n});\r\n</script>\r\n```\r\n\r\n这个例子的最终渲染结果是\r\n\r\n```html\r\n<h1>\r\n  我是父组件的标题\r\n</h1>\r\n<div>\r\n  <h2>我是子组件的标题</h2> \r\n  <p>这是一些初始内容</p> \r\n  <p>这是更多的初始内容</p>\r\n</div>\r\n```\r\n\r\n如果是这样使用子组件的\r\n\r\n```html\r\n<div id=\"app\">\r\n  <h1>我是父组件的标题</h1>\r\n  <my-component></my-component>\r\n</div>\r\n```\r\n\r\n打印出来的结果是\r\n\r\n```html\r\n<h1>我是父组件的标题</h1> \r\n<div>\r\n  <h2>我是子组件的标题</h2>               \r\n  只有在没有要分发的内容时才会显示            \r\n</div>\r\n```\r\n\r\n这种直接在子组件中使用 `<slot>` 标签定义的是一个匿名插槽，也就是默认的、没有名字的插槽。还有具名插槽。\r\n\r\n## 具名插槽\r\n\r\n在定义插槽的时候，也就是 `<slot>...</slot>` 的时候，这其实是一个匿名插槽。同样我们在定义插槽的时候，如果给插槽标签一个 `name` 特性，就是在定义具名插槽了。\r\n\r\n在父组件中向指定插槽插入内容的方式是：为插入的标签赋予一个 `slot=\"slotName\"` 的特性，如果没有指定 `slot` 特性，那么内容会被全部插入到匿名插槽中。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <app-layout>\r\n    <h1 slot=\"header\">这是标题</h1>\r\n    <p>主要内容的一个段落。</p>\r\n    <p>另一个主要段落。</p>\r\n    <p slot=\"footer\">这里有一些联系信息</p>\r\n    <p>遗落在最后的主要段落里的内容。</p>\r\n  </app-layout>\r\n</div>\r\n\r\n<script>\r\nVue.component(\'app-layout\', {\r\n  template: \'\\\r\n    <div class=\"container\">\\\r\n      <header>\\\r\n        <slot name=\"header\"></slot>\\\r\n      </header>\\\r\n      <main>\\\r\n        <slot></slot>\\\r\n      </main>\\\r\n      <footer>\\\r\n        <slot name=\"footer\"></slot>\\\r\n      </footer>\\\r\n    </div>\\\r\n  \'\r\n});\r\n\r\nnew Vue({\r\n  el: \'#app\'\r\n});\r\n</script>\r\n```\r\n\r\n这个例子的最终渲染结果是\r\n\r\n```html\r\n<div class=\"container\">\r\n  <header>\r\n    <h1>这是标题</h1>\r\n  </header>\r\n  <main>\r\n    <p>主要内容的一个段落。</p>\r\n    <p>另一个主要段落。</p>\r\n    <p>遗落在最后的主要段落里的内容。</p>\r\n  </main>\r\n  <footer>\r\n    <p>这里有一些联系信息</p>\r\n  </footer>\r\n</div>\r\n```\r\n\r\n## 作用域插槽\r\n\r\n作用域插槽就是，在子组件中定义插槽的时候，为 `<slot>` 标签赋予一些特性（比如 `text=\"hello from child\"`）。\r\n\r\n```html\r\n<div class=\"child\">\r\n  <slot text=\"hello from child.\"></slot>\r\n</div>\r\n```\r\n\r\n然后在父组件中引入子组件的地方的内部使用 `<template slot-scope=\"props\">` 将在 `<slot>` 标签中定义的所有特性赋值给 `props` 变量（可以不叫 `props`，随意）。接下来，就可以在 `<template>` 中使用 `props` 取得在子组件中插槽上的特性值了。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <my-awesome-list :items=\"items\">\r\n    <template slot=\"item\" slot-scope=\"props\">\r\n      <li>{{ props.text }}</li>\r\n    </template>    \r\n  </my-awesome-list>\r\n</div>\r\n\r\n<script>\r\nVue.component(\'my-awesome-list\', {\r\n  props: [\'items\'],\r\n  template: \'\\\r\n    <ul>\\\r\n      <slot name=\"item\" v-for=\"item in items\" :text=\"item.text\"></slot>\\\r\n    </ul>\\\r\n  \'\r\n});\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    items: [\r\n      { id: 1, text: \'q\' },\r\n      { id: 2, text: \'w\' },\r\n      { id: 3, text: \'x\' }\r\n    ]\r\n  }\r\n});\r\n</script>\r\n```','2017-12-11 03:18:11','2017-12-11 03:18:11','vue-js-learning-notes-slot'),(541,3,3,'Vue.js 学习笔记：动态组件','动态组件使用 `<component>` 标签（这是 Vue 提供给我们的）实现，还要结合使用它的 `is` 特性，来完成不同组件之间的切换。\r\n\r\n## 例子\r\n\r\n下面举一个例子：默认显示 Home 组件，可选的切换组件包括 Blog 和 Photos，最终的实现 demo 如下：\r\n\r\n```html\r\n<div id=\"app\">\r\n  <a href=\"#\" @click.prevent=\"changeView(\'home\')\">Home</a>\r\n  <a href=\"#\" @click.prevent=\"changeView(\'blog\')\">Blog</a>\r\n  <a href=\"#\" @click.prevent=\"changeView(\'photos\')\">Photos</a>\r\n  \r\n  <hr>\r\n  \r\n  <component v-bind:is=\"currentView\"></component> \r\n</div>\r\n\r\n<script>\r\nvar app = new Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    currentView: \'home\'\r\n  },\r\n  components: {\r\n    home: {\r\n      template: \'<p>Home</p>\'\r\n    },\r\n    blog: {\r\n      template: \'<p>Blog</p>\'\r\n    },\r\n    photos: {\r\n      template: \'<p>Photos</p>\'\r\n    }\r\n  },\r\n  methods: {\r\n    changeView: function (view) {\r\n      this.currentView = view;\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## keep-alive\r\n\r\n每一次组件切换，都伴随着旧组件的销毁和新组建的创建。如果要阻止组件的重新渲染，保留组件数据，可以在 `<component>` 外部使用 `<keep-alive>` 标签办到。\r\n\r\n```html\r\n<keep-alive>\r\n	<component v-bind:is=\"currentView\"></component> \r\n</keep-alive>\r\n```','2017-12-11 03:53:30','2017-12-19 07:25:43','vue-js-learning-notes-dynamic-components'),(542,3,3,'诗经·国风·小戎','> 这可能是《诗经·国风》里最难读的一篇了，很多字都不认识。大多是对战车兵器的描写，表现了秦人的尚武精神！\r\n> \r\n> 原文地址：[这儿][1]。\r\n\r\n\r\n\r\n小戎俴收，五楘梁辀。游环胁驱，阴靷鋈续。文茵畅毂，驾我骐馵。\r\n\r\n言念君子，温其如玉。在其板屋，乱我心曲。\r\n\r\n四牡孔阜，六辔在手。骐骝是中，騧骊是骖。龙盾之合，鋈以觼軜。\r\n\r\n言念君子，温其在邑。方何为期，胡然我念之。\r\n\r\n俴驷孔群，厹矛鋈錞。蒙伐有苑，虎韔镂膺。交韔二弓，竹闭绲縢。\r\n\r\n言念君子，载寝载兴。厌厌良人，秩秩德音。\r\n\r\n1. 小戎：小兵车。\r\n2. 俴收（jiàn shōu）：古代兵车车箱底部的横木。因较常车为短，故谓之浅轸（收）也。\r\n3. 五楘（wǔ mù）：交错缠绕（的绳索）。\r\n2. 梁辀（liáng zhōu）：古代车上用以驾马的曲辕。突出车前为穹隆形，如屋梁，故名。\r\n3. 游环：古代马车驾具的一部分。用皮革制造，滑动在四驾马车的当中两匹马的背上，中穿旁边两匹骖（cān）马的缰绳，其作用是防止骖马外逸。\r\n4. 胁驱：胁驱者以一条皮上系于衡，后系于轸，当服马之胁。骖马欲入，则此皮约之，所以止入也。\r\n5. 阴靷（yǐn）：引车前行的皮带。\r\n6. 鋈续（wù xù）：给马车饰以白色金属的革带环。\r\n7. 文茵（wén yīn）：车中的虎皮坐褥。\r\n8. 畅毂（chàng gū）：指兵车。\r\n9. 骐馵（qí zhù）：身有青黑斑纹而左足白的马。\r\n10. 骐骝（qí liú）：青身骊文而黑鬣的马。\r\n11. 騧骊（guā lí）：黑嘴的黄马、纯黑色的马。\r\n12. 觼軜（jué nà）：觼，有舌之环；軜，两骖内侧的辔绳。觼用以系軜，因称。\r\n13. 厹矛（qiú máo）：有三棱锋刃的长矛。\r\n14. 鋈錞（wù duì）：给矛柄下端饰以白色金属的平底金属套。\r\n15. 绲縢（gǔn téng）：绳束，即束绳。\r\n\r\n[1]: https://sou-yun.com/poemindex.aspx?path=%e8%a9%a9%e6%96%87%e8%a7%80%e6%ad%a2/%e8%a9%a9%e7%b6%93%ef%bc%88%e9%9b%86%e6%b3%a8%e7%89%88%ef%bc%89/%e5%b0%8f%e6%88%8e&poemId=236','2017-12-13 02:09:53','2017-12-13 02:10:20','the-book-of-songs-huai-small-si'),(543,3,3,'把我忘记（小诗）','一直以来\r\n\r\n我好像把情感都给了空气\r\n\r\n但我并不觉得难为情\r\n\r\n跑步\r\n\r\n就能把我忘记了\r\n\r\n我也会尝试忘记你的','2017-12-13 13:34:19','2017-12-13 13:34:19','i-forget-poem'),(544,3,3,'【纪录片】宫崎骏电影创作','1. [不了之人 宫崎骏][1]\r\n2. [千与千寻诞生的秘密][2]\r\n3. [幽灵公主的制作实录][3]\r\n\r\n[1]: https://www.bilibili.com/video/av9312405/\r\n[2]: https://www.bilibili.com/video/av10234593/\r\n[3]: https://www.bilibili.com/video/av5756119/','2017-12-14 05:08:11','2017-12-14 05:22:34','documentary-hayao-miyazaki-film-creation'),(545,3,3,'10 Things I Learned from the jQuery Source','2010 年 6 月 24 日，[Paul Irish][paul-irish-blog] 在 YouTube 上传了一个视频，题目为 [《10 Things I Learned from the jQuery Source》][video-address]，我今天看完了。看到视频底下有评论说，“都 2017 年了，现在看，还要竖起大拇指！”----这也正是我的想法。\r\n\r\nPaul Irish 解读的源码基于 jQuery [1.4.2][jquery-1.4.2-cdn]，此时还未引入 [Deferred 对象][deferred-object-explanation]，库代码还足够简单，所以对于初步尝试阅读 jQuery 源码的程序员来说，很友好。这也是我感觉长久以来，这段视频还具有价值的原因。 \r\n\r\n闲言少叙，下面分条列出 Paul Irish 从 jQuery 源码中学到的 10 件事。\r\n\r\n## 1. 立即执行函数和 `undefined`\r\n\r\njQuery 的基础架构如下。\r\n\r\n```javascript\r\n(function (window, undefined) {\r\n  // ...\r\n})(window);\r\n```\r\n\r\n这里有两个知识点：\r\n\r\n1. 立即执行函数。\r\n2. 在 ECMAScript 中，[`undefined` 不是保留字][global-objects/undefined]。\r\n\r\n### 立即执行函数\r\n\r\n顾名思义，立即执行函数在声明时就立即调用了。它分为两个部分：\r\n\r\n```javascript\r\n(function () {\r\n  // ...\r\n})\r\n```\r\n\r\n和\r\n\r\n```javascript\r\n();\r\n```\r\n\r\n第一部分----即包含在 `()` 中的匿名函数，本质是一个函数表达式；第二部分的 `()` 就是在调用函数，当然是可以传入参数的，jQuery 就传入了全局 `window` 对象。\r\n\r\n你也可以这样写\r\n\r\n```javascript\r\n!function () {\r\n  // ...\r\n}();\r\n\r\n+function () {\r\n  // ...\r\n}();\r\n```\r\n\r\n#### 好处\r\n\r\n立即执行函数的好处有两个：\r\n\r\n1. 外界不能访问此函数中的变量。\r\n2. 此函数中的变量也不会污染全局环境。\r\n\r\n简单总结，一个立即执行函数就是一个独立模块。\r\n\r\n### `undefined` 不是保留字\r\n\r\n`undefined` 不是保留字，就是说 `undefined` 可以作为变量名使用。\r\n\r\n```javascript\r\n// DON\'T DO THIS\r\n\r\n(function() { \r\n  var undefined = \'foo\'; \r\n  console.log(undefined, typeof undefined); // \"foo string\"\r\n})();\r\n\r\n(function(undefined) { \r\n  console.log(undefined, typeof undefined); // \"foo string\"\r\n})(\'foo\');\r\n```\r\n\r\n`undefined` 值被修改，可就不好了。\r\n\r\n立即执行函数执行时，第二个参数不传入，函数中第二个参数 `undefined` 就能保证是确确实实的 `undefined` 了。  \r\n\r\n```javascript\r\n// 再看一下 :)\r\n(function (window, undefined) {\r\n  // ...\r\n})(window);\r\n```\r\n\r\n## 2. 寻找 jQuery 上的方法\r\n \r\n在 [源码][jquery-1.4.2-cdn] 中，如果我们要找 `method` 方法的源码，只要搜索 `method:`，就能有 90% 的命中率了。\r\n\r\n### `jQuery.noConflict` 方法\r\n\r\n在 jQuery 中，当你使用 `$.noConflict()` 后，`$` 就不在保存 jQuery 引用了，因为其他 JavaScript 库（或者你）也会用到这个变量。\r\n\r\n它的源码实现如下：\r\n\r\n```javascript\r\nfunction (deep) {\r\n  window.$ = _$;\r\n\r\n  if (deep) {\r\n      window.jQuery = _jQuery;\r\n  }\r\n\r\n  return jQuery;\r\n}\r\n```\r\n\r\n`_$` 和 `_jQuery` 是 jQuery 函数返回前保存的初始 `window.$` 和 `window.jQuery` 的值。\r\n\r\n可以看到，调用了 `$.noConflict()` 后，jQuery 不再持有全局变量 `$`，如果在调用的时候我们还传入了参数 `true`，jQuery 连全局变量 `jQuery` 都不再持有了。\r\n\r\n### `jQuery.props` 对象\r\n\r\n`jQuery.props` 是为 jQuery 实例方法 `.attr` 服务的。\r\n\r\n```javascript\r\njQuery.props = {\r\n  \"for\": \"htmlFor\",\r\n  \"class\": \"className\",\r\n  readonly: \"readOnly\",\r\n  maxlength: \"maxLength\",\r\n  // ...\r\n};\r\n\r\n// 使用\r\nattr: function( elem, name, value, pass ) {\r\n  // Try to normalize/fix the name\r\n  name = notxml && jQuery.props[ name ] || name;\r\n}\r\n```\r\n\r\n比如我们将 `class` 映射到了 `className`，在我们用 `$(\'#app\').attr(\'class\')` 的时候，底层使用了 `elem.className` 来获得属性值。\r\n\r\n这样一来，你也可以自定义属性映射了。\r\n\r\n```javascript\r\n$.props[\'foo\'] = \'aria-xxx\';\r\n\r\n$(\'#app\').attr(\'foo\', \';)\');\r\n$(\'#app\').attr(\'foo\'); // \";)\"\r\n```\r\n\r\n## 3. 动画速度\r\n\r\n使用动画效果时，我们可以使用 `\'fast\'`、`\'slow\'` 或者默认，那时间是多久呢？这是在 `$.fx.speeds` 对象上定义的。\r\n\r\n```javascript\r\nspeeds: {\r\n  slow: 600,\r\n  fast: 200,\r\n  // Default speed\r\n  _default: 400\r\n},\r\n```\r\n\r\n默认是 400 毫秒，在 IE6、7 上可能不太流畅，我们重置下。\r\n\r\n```javascript\r\njQuery.fx.speeds._default = ($.browser.msie && $.browser.version < 8) ? 800 : 400;\r\n```\r\n\r\n*注意，`$.browser` 已在 1.9 版本移除了。*\r\n\r\n## 4. `$(document).ready(function () {})` 方法\r\n\r\n```javascript\r\n$(document).ready(funciton () {\r\n  // ...                  \r\n});\r\n```\r\n\r\n`ready` 中的函数在文档发生 `DOMContentLoaded` 事件后就触发，比 `load` 更早。`DOMContentLoaded` 事件是在浏览器处理好 DOM 结构后触发的，而不要向 `load` 一样等到其他资源（图片、视频、外部脚本）完全加载完毕后才触发。以下是源码：\r\n\r\n```javascript\r\nready: function( fn ) {\r\n  // Attach the listeners\r\n  jQuery.bindReady();\r\n\r\n  // If the DOM is already ready\r\n  if ( jQuery.isReady ) {\r\n    // Execute the function immediately\r\n    fn.call( document, jQuery );\r\n\r\n  // Otherwise, remember the function for later\r\n  } else if ( readyList ) {\r\n    // Add the function to the wait list\r\n    readyList.push( fn );\r\n  }\r\n\r\n  return this;\r\n},\r\n```\r\n\r\n继续跟踪到 `jQuery.bindReady` 方法。\r\n\r\n```javascript\r\n// Mozilla, Opera and webkit nightlies currently support this event\r\nif ( document.addEventListener ) {\r\n  // Use the handy event callback\r\n  document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\r\n\r\n  // A fallback to window.onload, that will always work\r\n  window.addEventListener( \"load\", jQuery.ready, false );\r\n\r\n// If IE event model is used\r\n} else if ( document.attachEvent ) {\r\n  // ensure firing before onload,\r\n  // maybe late but safe also for iframes\r\n  document.attachEvent(\"onreadystatechange\", DOMContentLoaded);\r\n\r\n  // A fallback to window.onload, that will always work\r\n  window.attachEvent( \"onload\", jQuery.ready );\r\n\r\n  // If IE and not a frame\r\n  // continually check to see if the document is ready\r\n  var toplevel = false;\r\n\r\n  try {\r\n    toplevel = window.frameElement == null;\r\n  } catch(e) {}\r\n\r\n  if ( document.documentElement.doScroll && toplevel ) {\r\n    doScrollCheck();\r\n  }\r\n}\r\n```\r\n\r\n针对 IE 和所有现代浏览器，优先使用 `DOMContentloaded` 事件，否则都用注册得 `load` 事件作为回退方案。 \r\n\r\n## 5. `$.getJSON` 和 `$.getScript`\r\n\r\n`$.getJSON` 和 `$.getScript` 使用 `$.get()` 实现，`$.get()` 底层使用 `$.ajax` 实现。\r\n\r\n```javascript\r\nget: function( url, data, callback, type ) {\r\n  // shift arguments if data argument was omited\r\n  if ( jQuery.isFunction( data ) ) {\r\n    type = type || callback;\r\n    callback = data;\r\n    data = null;\r\n  }\r\n\r\n  return jQuery.ajax({\r\n    type: \"GET\",\r\n    url: url,\r\n    data: data,\r\n    success: callback,\r\n    dataType: type\r\n  });\r\n},\r\n\r\ngetScript: function( url, callback ) {\r\n  return jQuery.get(url, null, callback, \"script\");\r\n},\r\n\r\ngetJSON: function( url, data, callback ) {\r\n  return jQuery.get(url, data, callback, \"json\");\r\n},\r\n```\r\n\r\n下面厉害了，咱提取出 jQuery `.ajax` 方法中 [处理 JSONP 的代码](https://github.com/jquery/jquery/blob/1.4.4/src/ajax.js#L294)，写好一个自己的 `getScript()` 函数。\r\n\r\n```javascript\r\nfunction getScript(url, callback) {\r\n  var head = document.getElementsByTagName(\"head\")[0] || document.documentElement;\r\n  var script = document.createElement(\"script\");\r\n\r\n  script.src = url;\r\n\r\n  var done = false;\r\n\r\n  // Attach handlers for all browsers\r\n  script.onload = script.onreadystatechange = function() {\r\n    if ( !done && (!this.readyState ||\r\n            this.readyState === \"loaded\" || this.readyState === \"complete\") ) {\r\n      done = true;\r\n\r\n      callback();\r\n\r\n      // Handle memory leak in IE\r\n      script.onload = script.onreadystatechange = null;\r\n      if ( head && script.parentNode ) {\r\n          head.removeChild( script );\r\n      }\r\n    }\r\n  };\r\n\r\n  // Use insertBefore instead of appendChild  to circumvent an IE6 bug.\r\n  // This arises when a base node is used (#2709 and #4378).\r\n  head.insertBefore( script, head.firstChild );\r\n}\r\n\r\ngetScript(\'https://www.cornify.com/js/cornify.js\', function () {\r\n  var times = 28;\r\n\r\n  while(--times) {\r\n    cornify_add();\r\n  }\r\n});\r\n```\r\n\r\n## 6. 选择器性能\r\n\r\n```javascript\r\n$(\'#id tag:thing\') // 全程使用了 Sizzle\r\n\r\n// 和\r\n$(\'#id\').find(\'tag:thing\') // 先使用 getElementById\r\n```\r\n\r\n哪一个性能会好些呢？是后者。如果是传入的 ID，jQuery 会直接使用 `getElementById` 获取元素。\r\n\r\n```javascript\r\n// HANDLE: $(html) -> $(array)\r\nif ( match[1] ) {\r\n  // ...  \r\n// HANDLE: $(\"#id\")\r\n} else {\r\n  elem = document.getElementById( match[2] );\r\n}\r\n```\r\n\r\n### 类型判断 `:type`\r\n\r\n`$(\':password\')` 表示选择所有的密码框，其底层是这样实现的。\r\n\r\n```javascript\r\npassword: function(elem){\r\n    return \"password\" === elem.type;\r\n},\r\n```\r\n\r\n这是在 `Sizzle.selectors` 的 `filters` 对象上定义的。是按照元素的 `type` 属性值判断的。\r\n\r\n## 7. `$.parseJSON` 方法\r\n\r\n`parseJSON` 定义在 jQuery 对象上，内容很简单。将传入的 JSON 字符串转换为 JavaScript 对象。[源码](https://github.com/jquery/jquery/blob/1.4.4/src/core.js#L545) 如下：\r\n\r\n```javascript\r\nparseJSON: function( data ) {\r\n  if ( typeof data !== \"string\" || !data ) {\r\n    return null;\r\n  }\r\n\r\n  // Make sure leading/trailing whitespace is removed (IE can\'t handle it)\r\n  data = jQuery.trim( data );\r\n\r\n  // Make sure the incoming data is actual JSON\r\n  // Logic borrowed from http://json.org/json2.js\r\n  if ( /^[\\],:{}\\s]*$/.test(data.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, \"@\")\r\n      .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \"]\")\r\n      .replace(/(?:^|:|,)(?:\\s*\\[)+/g, \"\")) ) {\r\n\r\n    // Try to use the native JSON parser first\r\n    return window.JSON && window.JSON.parse ?\r\n      window.JSON.parse( data ) :\r\n      (new Function(\"return \" + data))();\r\n\r\n  } else {\r\n    jQuery.error( \"Invalid JSON: \" + data );\r\n  }\r\n},\r\n```\r\n\r\n其实就是对 `JSON.parse` 方法的疯转，如果浏览器不支持该方法，就使用 \r\n\r\n```javascript\r\n(new Function(\'return \' + data))();\r\n```\r\n\r\n将我们的字符串转换为 JavaScript 对象，十分巧妙。\r\n\r\n## 8. `jQuery.unique()` 方法\r\n\r\n`jQuery.unique` 就是 `Sizzle.uniqueSort`。\r\n\r\n```javascript\r\njQuery.unique = Sizzle.uniqueSort;\r\n```\r\n\r\n来看 `Sizzle.uniqueSort` 的内容：\r\n\r\n```javascript\r\nSizzle.uniqueSort = function(results){\r\n  if ( sortOrder ) {\r\n    hasDuplicate = baseHasDuplicate;\r\n    results.sort(sortOrder);\r\n\r\n    if ( hasDuplicate ) {\r\n      for ( var i = 1; i < results.length; i++ ) {\r\n        if ( results[i] === results[i-1] ) {\r\n            results.splice(i--, 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return results;\r\n};\r\n```\r\n\r\n先对数组排序，然后删除多余的。\r\n\r\n```javascript\r\nfor ( var i = 1; i < results.length; i++ ) {\r\n  if ( results[i] === results[i-1] ) {\r\n    results.splice(i--, 1);\r\n  }\r\n}\r\n```\r\n\r\n嗯，这块代码很好。\r\n\r\n但是这一个方法有局限性----只能应用在 DOM 数组元素上，对字符串和数字数组无能为力，这里写个 [升级版本](https://www.paulirish.com/2010/duck-punching-with-jquery/)。\r\n\r\n```javascript\r\n(function($){\r\n\r\n  var _old = $.unique;\r\n\r\n  $.unique = function(arr){\r\n\r\n      // do the default behavior only if we got an array of elements\r\n      if (!!arr[0].nodeType){\r\n        return _old.apply(this,arguments);\r\n      } else {\r\n        // reduce the array to contain no dupes via grep/inArray\r\n        return $.grep(arr,function(v,k){\r\n          return $.inArray(v,arr) === k;\r\n        });\r\n      }\r\n  };\r\n})(jQuery);\r\n\r\n// in use..\r\nvar arr = [\'first\',7,true,2,7,true,\'last\',\'last\'];\r\n$.unique(arr); // [\"first\", 7, true, 2, \"last\"]\r\n\r\nvar arr = [1,2,3,4,5,4,3,2,1];\r\n$.unique(arr); // [1, 2, 3, 4, 5]\r\n```\r\n\r\n`$.inArray(v,arr)` 计算元素 `v` 在 `arr` 出现的第一个索引位置，如果后来出现了同样的元素值，会因为 `k` 与该值出现的第一个索引位置不同，而被 `grep` 掉。 \r\n\r\n## 9. 万一 `$` 用不了\r\n\r\n```javascript\r\n$( document ).ready(function() {\r\n  // Handler for .ready() called.\r\n});\r\n\r\n// 可以简写为\r\n$(function() {\r\n  // Handler for .ready() called.\r\n});\r\n```\r\n\r\n如果 `$` 被占用，不用担心，用 `.noConflict` 解决，同时为了能够还能使用畅快的使用 `$`，在函数的第一个参数位置指定。\r\n\r\n```javascript\r\nvar jq2 = jQuery.noConflict();\r\njq2(function( $ ) {\r\n  // 在这里看可以正常使用 jQuery 的 $，这里的 $ 就是 jq2 的别名，只在该函数作用域内有效\r\n});\r\n\r\n// 如果还需要传入值，按照顺序放在之后就行\r\njq2(function( $, window, undefined ) {\r\n  // ...\r\n});\r\n```\r\n\r\n## 10. 分模块开发\r\n\r\njQuery 的最终代码是由一个个 [小模块组成](https://github.com/jquery/jquery/tree/1.4.4/src) 的。查看仓库代码能看到，所有模块都是在 `Makefile` 文件中组织起来的。\r\n\r\n```\r\nBASE_FILES = ${SRC_DIR}/core.js\\\r\n	${SRC_DIR}/support.js\\\r\n	${SRC_DIR}/data.js\\\r\n	${SRC_DIR}/queue.js\\\r\n	${SRC_DIR}/attributes.js\\\r\n	${SRC_DIR}/event.js\\\r\n	${SRC_DIR}/selector.js\\\r\n	${SRC_DIR}/traversing.js\\\r\n	${SRC_DIR}/manipulation.js\\\r\n	${SRC_DIR}/css.js\\\r\n	${SRC_DIR}/ajax.js\\\r\n	${SRC_DIR}/effects.js\\\r\n	${SRC_DIR}/offset.js\\\r\n	${SRC_DIR}/dimensions.js\r\n\r\nMODULES = ${SRC_DIR}/intro.js\\\r\n	${BASE_FILES}\\\r\n	${SRC_DIR}/outro.js\r\n```\r\n\r\n根据 `BASE_FILES` 中定义的模块顺序，我们就能清楚模块之间的依赖关系----后面引入（可能）会依赖前面的。比如：`core.js` 是基础，所有模块依赖。\r\n\r\n`MODULES` 指定 jQuery 库输出时的最终代码组成。在 `BASE_FILES` 前后分别加了 `intro.js` 和 `outro.js`，下面是它们的内容。\r\n\r\nintro.js。\r\n\r\n```javascript\r\n/*!\r\n * jQuery JavaScript Library v@VERSION\r\n * http://jquery.com/\r\n *\r\n * Copyright 2010, John Resig\r\n * Dual licensed under the MIT or GPL Version 2 licenses.\r\n * http://jquery.org/license\r\n *\r\n * Includes Sizzle.js\r\n * http://sizzlejs.com/\r\n * Copyright 2010, The Dojo Foundation\r\n * Released under the MIT, BSD, and GPL Licenses.\r\n *\r\n * Date: \r\n */\r\n(function( window, undefined ) {\r\n\r\n// Use the correct document accordingly with window argument (sandbox)\r\nvar document = window.document;\r\n```\r\n\r\noutro.js\r\n\r\n```javascript\r\n})(window);\r\n```\r\n\r\n[paul-irish-blog]: https://www.paulirish.com/blog/archives/\r\n[video-address]: https://www.youtube.com/watch?v=i_qE1iAmjFg\r\n[jquery-1.4.2-cdn]: http://lib.sinaapp.com/js/jquery/1.4.2/jquery.js\r\n[deferred-object-explanation]: http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html\r\n[global-objects/undefined]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined','2017-12-16 08:39:30','2017-12-16 08:39:30','10-things-i-learned-from-the-jquery-source'),(546,3,3,'??12 月下雪了（小诗）','12 月\r\n\r\n整整下了一个月的雪\r\n\r\n雪风中\r\n\r\n我的睫毛上\r\n\r\n都是细小晶莹的冰屑\r\n\r\n我还是等候你\r\n\r\n楚楚动人\r\n\r\n这样的你\r\n\r\n走开了\r\n\r\n我看\r\n\r\n想\r\n\r\n我忍住\r\n\r\n也走开了\r\n\r\n吱呀吱呀的声音\r\n\r\n白皑皑的雪地上\r\n\r\n两痕没有交集的脚印\r\n\r\n像一行情诗 一行浅浅的脚注\r\n\r\n雪窸窸窣窣地下','2017-12-16 09:17:05','2017-12-16 13:15:25','12-yuexiaxuele'),(547,3,3,'Simplest jQuery Slideshow','本篇译文源自程序员 Jonathan Snook 2009 年发表在它博客上的 [一篇文章][1]。教\r\n你怎样用 jQuery 实现一个最简单的幻灯片功能。\r\n\r\n最终效果在 [这里][2] 可以看到。下面讲述实现过程。\r\n\r\n## HTML 和 CSS\r\n\r\nHTML 非常简单：一个 `<div>`，三个 `<img>`。\r\n\r\n```html\r\n<div class=\"fadein\">\r\n  <img src=\"https://farm3.static.flickr.com/2610/4148988872_990b6da667.jpg\">\r\n  <img src=\"https://farm3.static.flickr.com/2597/4121218611_040cd7b3f2.jpg\">\r\n  <img src=\"https://farm3.static.flickr.com/2531/4121218751_ac8bf49d5d.jpg\">\r\n</div>\r\n```\r\n\r\n接下来添加必要的一些 CSS 样式。\r\n\r\n```css\r\n.fadein {\r\n  position: relative;\r\n  width: 500px;\r\n  height: 332px;\r\n  margin: 0 auto;\r\n}\r\n\r\n.fadein img {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n}\r\n```\r\n\r\n`<img>` 元素使用绝对定位放在同一个地方。\r\n\r\n## jQuery Slideshow\r\n\r\n首先，我们要隐藏除第一个以外的所有图片。\r\n\r\n```javascript\r\n$(\'.fadein img:gt(0)\').hide();\r\n```\r\n\r\n启动一个定时器，每 3 秒执行一次。\r\n\r\n```javascript\r\nsetInterval(function(){ },3000);\r\n```\r\n\r\n在定时器里面，我们首先要做的是让第一张图片渐渐消失。\r\n\r\n```javascript\r\n$(\'.fadein img:eq(0)\').fadeOut()\r\n```\r\n\r\n接着，让下一张图片渐渐出现。\r\n\r\n```javascript\r\n.next(\'img\').fadeIn()\r\n```\r\n\r\n然后把当前第一张图片移动到 `.fadein` 的最后一个位置，因此，当前第二张图片成为下一次定时器执行时的第一张图片，依次类推。\r\n\r\n好了，就这么多。最终代码如下：\r\n\r\n```javascript\r\n$(function() {\r\n  $(\'.fadein img:gt(0)\').hide();\r\n  setInterval(function() {  \r\n    $(\'.fadein :eq(0)\').fadeOut()\r\n       .next(\'img\').fadeIn()\r\n       .end().appendTo(\'.fadein\');\r\n  }, 3000);\r\n});\r\n```\r\n\r\n## 评论区\r\n\r\n这里翻译原文章底下的评论区，同样精彩。\r\n\r\n### #1\r\n\r\n在大多数场景下，我会使用 `eq(0)` 而不是 `:first-child`；`next(\'img\')` 可修改为 `next()`，这样你的幻灯片切换的元素更加灵活了。\r\n\r\n### #2\r\n\r\nJonathan，你的这个代码，可以做成一个 [插件][3] 啦，哈哈。\r\n\r\n```javascript\r\n$.fn.slideShow = function (timeout) {\r\n  var $elem = this;\r\n  this.children(\':gt(0)\').hide();\r\n  setInterval(function () {\r\n    $elem.children(\':eq(0)\').fadeOut().next().fadeIn().end().appendTo($elem);\r\n  }, timeout || 3000);\r\n};\r\n\r\n// 使用\r\n$(\'.fadein\').slideShow();\r\n```\r\n\r\n### #3\r\n\r\n哈哈，我还加上了一个速度参数！\r\n\r\n```javascript\r\n(function($){\r\n  $.fn.simplestSlideShow = function(settings){\r\n    var config = {\r\n      \'timeOut\': 3000,\r\n      \'speed\': \'normal\'\r\n    };\r\n    if (settings) $.extend(config, settings);\r\n    this.each(function(){\r\n      var $elem = $(this);\r\n      $elem.children(\':gt(0)\').hide();\r\n      setInterval(function(){\r\n        $elem.children().eq(0).fadeOut(config[\'speed\'])\r\n        .next().fadeIn(config[\'speed\'])\r\n        .end().appendTo($elem);\r\n      }, config[\'timeOut\']);\r\n    });\r\n    return this;\r\n  };\r\n})(jQuery);\r\n\r\n// 使用\r\n$(\".fadein\").simplestSlideShow({\'timeOut\': 5000, \'speed\': 1000});\r\n```\r\n\r\n### #4\r\n\r\n1. 幻灯片初始化时，为 `.fadein` 添加一个 js-dependent css，区分受 JS 操作的代码。\r\n2. 获取 `.fadein` 直接子元素更合理些。\r\n3. 为啥不使用闭包存储 ` $(\'.fadein\')` 呢？\r\n\r\n```css\r\n.fadein-js > * { position: absolute; top: 0; left: 0; }\r\n```\r\n\r\n```javascript\r\n$(function(){\r\n  var fadein = $(\'.fadein\').addClass(\'fadein-js\');\r\n  fadein.children().slice(1).hide();\r\n  setInterval(function(){\r\n    fadein.children().eq(0).fadeOut()\r\n    .next().fadeIn()\r\n    .end().appendTo(fadein);\r\n  }, 3000);\r\n});\r\n```\r\n\r\n\r\n[1]: https://snook.ca/archives/javascript/simplest-jquery-slideshow\r\n[2]: https://codepen.io/zhangbao/full/opjQyM\r\n[3]: https://codepen.io/zhangbao/pen/dJYQBw','2017-12-17 04:06:14','2017-12-17 04:06:14','simplest-jquery-slideshow'),(548,3,3,'More Simple jQuery Slideshows','[这篇文章](https://snook.ca/archives/javascript/more-simple-slideshow) 是 Jonathan Snook 2014 年对 2009 年发布文章 [《Simplest jQuery Slideshow》](https://snook.ca/archives/javascript/simplest-jquery-slideshow) 的补充，修正了部分代码，并且实现了 3 中效果：\r\n\r\n1. 随机播放幻灯片\r\n2. 带链接的幻灯片\r\n3. 多个幻灯片\r\n\r\n这里是 [demo 页](https://snook.ca/technical/fade/fade.html)。\r\n\r\n## 随机播放\r\n\r\n```javascript\r\n$(\'.fadein > :gt(0)\').hide();\r\n	\r\nsetInterval(function () {\r\n  var seeder = Math.floor(Math.random() * ($(\'.fadein\').children().length - 1));\r\n  $(\'.fadein > :eq(0)\').appendTo($(\'.fadein\')).fadeOut();\r\n  $(\'.fadein > *\').eq(seeder).prependTo($(\'.fadein\')).fadeIn();\r\n}, 3000);\r\n```\r\n\r\n这里我们先生成一个随机数 `seeder`；再把当前第一个直接子元素移到 `.fadein` 最后一个位置，开始消失；根据随机数选择显示直接子元素、并放在 `.fadein` 的第一个位置，开始出现。\r\n\r\n*需要注意的是，两个元素的消失和出现效果是同时进行的。*\r\n\r\n## 带链接\r\n\r\n```javascript\r\n$(\'.fadein > :gt(0)\').hide();\r\n  setInterval(function(){\r\n    $(\'.fadein > eq(0)\').fadeOut()\r\n     .next().fadeIn()\r\n     .end().appendTo(\'.fadein\');\r\n  }, 3000);\r\n});\r\n```\r\n\r\n再稍微修改下 CSS 即可。\r\n\r\n```css\r\n.fadein {\r\n  position: relative;\r\n  width: 500px;\r\n  height: 332px;\r\n  margin: 0 auto;\r\n}\r\n\r\n/* 这里改为对所有直接子元素应用样式 */\r\n/* .fadein img { */\r\n.fadein > * {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n}\r\n```\r\n\r\n## 多个幻灯片\r\n\r\n之前的代码只适应于页面中一个幻灯片的场景的情况。如果同时存在多个，就有问题。我们来看这条语句：\r\n\r\n```javascript\r\n$(\'.fadein > :eq(0)\').appendTo($(\'.fadein\'));\r\n```\r\n\r\n当我们的页面同时存在多个 `.fadein` 的结构时，这样一条语句会引发什么效果呢？\r\n\r\n正解：`$(\'.fadein > :eq(0)\')` 会选择第一个出现的 `.fadein` 的第一个直接子元素。`.appendTo($(\'.fadein\'))` 语句会将之前获得的这个子元素 append 到页面中所有 `.fadein` 元素的末尾！\r\n\r\n这可不是我们想要的，所以针对多个幻灯片的情况，我们要遍历、分别启动其中的每个幻灯片。\r\n\r\n```javascript\r\n$(\'.fadein\').each(function () {\r\n  var $this = this;\r\n  $(\'> :gt(0)\', $this).hide();\r\n  setInterval(function () {\r\n    $(\'> :eq(0)\', $this).fadeOut()\r\n      .next().fadeIn()\r\n      .end().appendTo($this);\r\n  }, 3000);\r\n});\r\n```','2017-12-17 05:08:14','2017-12-17 05:13:30','more-simple-jquery-slideshow'),(549,3,3,'《理解 ES6》 ：块级绑定','> 最近在读 Nicholas C. Zakas 的 [《Understanding ECMAScript 6》](https://leanpub.com/understandinges6)，这是一本开源书籍，介绍 ES6 语法。由浅入深，触发思考。下面是我看完第一章的笔记。\r\n>\r\n> 笔记的章节与原文并不同，是按照我的理解编排的。有我学习到的，也有我自己总结的，贴出在这里。\r\n\r\nECMAScript 6 引入了块级绑定，在此之前，我们都使用 `var` 声明。\r\n\r\n## `var` 声明\r\n\r\nJavaScript `var` 声明有两个特点：\r\n\r\n1. 声明提升：JavaScript 代码编译时，会将所有 `var` 声明----不管在什么地方的----统一放到函数作用域或全局作用域的顶部----即当前作用域的顶部。\r\n\r\n```javascript\r\nfunction getValue(condition) {\r\n  if (condition) {\r\n    var v = \'light\';\r\n    return v;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nconsole.log(n);\r\nvar n = 2;\r\n```\r\n\r\n经过编译后，实际执行的代码\r\n\r\n```javascript\r\nfunction getValue(condition) {\r\n  var v;                              \r\n  if (condition) {\r\n    v = \'light\';\r\n    return v;\r\n  } else {\r\n    // v 的值是 undefined\r\n    return null;\r\n  }\r\n  // v 的值是 undefined\r\n}\r\nvar n;\r\nconsole.log(n); // n 的值是 undefined\r\nn = 2;\r\n```\r\n\r\n2. 可重复声明：同一个变量名，可使用 `var` 重复声明。因为编译时，除第一个 `var` 声明之外的其他声明前的 `var` 都会被去掉。\r\n\r\n```javascript\r\nvar n = 2;\r\nvar n;\r\nvar n = 18;\r\n```\r\n\r\n经过编译后，实际执行的代码\r\n\r\n```javascript\r\nvar n = 2;\r\nn; // 什么都没做\r\nn = 18; // n 被赋值 18\r\n// 此时 n 的值是 18 了\r\n```\r\n\r\n## `let` 声明和 `const` 声明\r\n\r\n`let` 声明就是为避免 `var` 声明的两个特点才创造出来的。\r\n\r\n1. `let` 声明不会提升。所以使用之前必须先声明，否则报错。\r\n\r\n```\r\nconsole.log(n); // ReferenceError: n is not defined.\r\nlet n = 2;\r\n```\r\n\r\n2. 不可使用 `let` 重复声明同一变量。\r\n\r\n```javascript\r\nlet n = 2;\r\nlet n = 18; // SyntaxError: Identifier \'n\' has already been declared.\r\n```\r\n\r\n`const` 声明与 `let` 声明唯一不同的地方是：`const` 声明常量，一旦赋值，就不可修改，否则报错。\r\n\r\n```javascript\r\nconst c = 18;\r\nc = 22; // TypeError: Assignment to constant variable.\r\n```\r\n\r\n## 块级作用域\r\n\r\n在 ES5 中，没有块级作用域，只有全局作用域和函数作用域。ES6 引入了 块级作用域。那么，什么是块级作用域呢？就是包围在 `{ }` 中的区域，但为了先前兼容，块级作用域对 `var` 声明仍不起作用。\r\n\r\n```javascript\r\nif (true) {\r\n  // 这是一个块级作用域，对 let、const 声明有效，对 var 无效\r\n  var s = \'yy\';\r\n  let n = 18;\r\n}\r\n\r\nconsole.log(s); // \"yy\"\r\nconsole.log(n); // ReferenceError: n is not defined.\r\n```\r\n\r\n**块级作用域对 `var` 声明仍不起作用，意味着什么呢？**\r\n\r\n如果 `{ }` 中只用 `var` 声明变量，那么这等同于再写 ES5 代码，块级作用域形同虚设。\r\n\r\n**什么是“块级声明”呢？**\r\n\r\n在 `{ }` 中，使用了 `let` 和（或）`const` 声明变量，那么 `{ }` 就形成了一个块级作用域。块级作用域中使用 `let` 和（或）`const` 声明变量的地方就是“块级声明”了。\r\n\r\n**什么是“块级绑定”呢？**\r\n\r\n块级绑定就是块级变量，就是使用 `let` 和（或）`const` 声明的变量。之所以称这些变量是块级变量，是因为只有这些变量才让 `{ }` 有了块级作用域的作用。\r\n\r\n## 循环中的块级绑定\r\n\r\n### 循环中的 `let` 声明\r\n\r\n`let` 声明让原来需要 IIFE 解决问题的地方简单了。\r\n\r\n以前这样写（使用闭包保存每一次迭代中 `i` 的值）\r\n\r\n```javascript\r\nvar funcs = [];\r\n\r\nfor (let i = 0; i < 10; i++) {\r\n  funcs.push((function (i) {\r\n    return function() {\r\n      console.log(i);\r\n    }\r\n  })(i));\r\n}\r\n\r\nfuncs.forEach(function(func) {\r\n  func();     // outputs 0, then 1, then 2, up to 9\r\n})\r\n```\r\n\r\n现在只要这样写\r\n\r\n```javascript\r\nvar funcs = [];\r\n\r\nfor (let i = 0; i < 10; i++) {\r\n  funcs.push(function() {\r\n    console.log(i);\r\n  });\r\n}\r\n\r\nfuncs.forEach(function(func) {\r\n  func();     // outputs 0, then 1, then 2, up to 9\r\n})\r\n```\r\n\r\n变得简单了，不需在使用 IIFE 了，也无需关心闭包不闭包的了。这要归因于循环中 `let` 的行为。\r\n\r\n**循环中 `let` 的行为是什么样的呢？**\r\n\r\n是这样，在循环的每一次迭代中，都会重新声明变量 `i` 并且给他赋值，类似这样：\r\n\r\n```javascript\r\nlet funcs = [];\r\n\r\n// 在 for 循环中\r\nlet _i = 0;\r\n\r\n// 第一次迭代\r\n{\r\n  let i = _i;\r\n  funcs.push(function() {\r\n    console.log(i);\r\n  });\r\n  _i++;\r\n}\r\n\r\n// 第二次迭代\r\n{\r\n  let i = _i;\r\n  funcs.push(function() {\r\n    console.log(i);\r\n  });\r\n  _i++;\r\n}\r\n\r\n// ...\r\n\r\n```\r\n\r\n当然，对于 `for-in` 和 `for-of` 循环中的 `let` 行为也是一样的。\r\n\r\n### 循环中的 `const` 声明\r\n\r\n与 `let` 不同的是，在 `for` 循环中使用 `const` 声明会出错。\r\n\r\n```javascript\r\nvar funcs = [];\r\n\r\n// throws an error after one iteration\r\nfor (const i = 0; i < 10; i++) {\r\n    funcs.push(function() {\r\n        console.log(i);\r\n    });\r\n}\r\n```\r\n\r\n这是因为不能对常量值是不能修改的。\r\n\r\n```javascript\r\n// 在 for 循环中\r\nconst _i = 0;\r\n\r\n// 第一次迭代\r\n{\r\n  let i = _i;\r\n  funcs.push(function() {\r\n    console.log(i);\r\n  });\r\n  _i++; // TypeError: Assignment to constant variable.\r\n}\r\n```\r\n\r\n当在 `for-in` 和 `for-of` 循环中使用 `const` 是没问题的。\r\n\r\n```javascript\r\nvar funcs = [],\r\n    object = {\r\n      a: true,\r\n      b: true,\r\n      c: true\r\n    };\r\n\r\n// 这里不会有问题\r\nfor (const key in object) {\r\n  funcs.push(function() {\r\n    console.log(key);\r\n  });\r\n}\r\n\r\nfuncs.forEach(function(func) {\r\n  func();     // outputs \"a\", then \"b\", then \"c\"\r\n});\r\n```\r\n\r\n## 全局块级绑定\r\n\r\n我们知道，在浏览器环境，使用 `var` 在全局环境里声明变量时，等同于设置 `window` 对象属性。\r\n\r\n```javascript\r\n// in a browser\r\nvar RegExp = \"Hello!\";\r\nconsole.log(window.RegExp);     // \"Hello!\"\r\n\r\nvar ncz = \"Hi!\";\r\nconsole.log(window.ncz);        // \"Hi!\"\r\n```\r\n\r\n它的缺点很明显，就是可能会覆盖掉原生对象或者原生对象的方法。但使用了 `let`、`const` 声明变量就不会有这个问题。\r\n\r\n```javascript\r\n// in a browser\r\nlet RegExp = \"Hello!\";\r\nconsole.log(RegExp);                    // \"Hello!\"\r\nconsole.log(window.RegExp === RegExp);  // false\r\n\r\nconst ncz = \"Hi!\";\r\nconsole.log(ncz);                       // \"Hi!\"\r\nconsole.log(\"ncz\" in window);           // false\r\n```\r\n\r\n原因是什么呢？在于，使用 `let`、`const` 声明的变量，会形成一个全局块级作用域，全局对象还要在全局块级作用域之外。\r\n\r\n所以，在全局作用域中使用 `let` 和 `const` 声明变量更加安全些。','2017-12-18 04:05:47','2017-12-18 04:05:47','understand-es6-block-level-binding'),(550,3,3,'jQuery 的构造函数其实是 jQuery.fn.init','jQuery 的构造函数不是 `jQuery`，而是 `jQuery.fn.init`，且看结构（基于 1.4.2）。\r\n\r\n```javascript\r\n(function (window, undefined) {\r\n  \r\n  var jQuery = function (selector, context) {\r\n    return new jQuery.fn.init(selector, context);\r\n  };\r\n                               \r\n  jQuery.fn = jQuery.prototype = {\r\n    init: function (selector, context) {\r\n      return this;\r\n    }\r\n  };\r\n \r\n  jQuery.fn.init.prototype = jQuery.fn;\r\n                               \r\n  window.jQuery = window.$ = jQuery;\r\n})(window);\r\n```\r\n\r\n`jQuery.fn` 是 `jQuery.protortype` 的别名，之所以不用后者，是因为太长了，所以在 jQuery 的源码里一直使用得是 `jQuery.fn`。\r\n\r\n**现在问题是：为什么要用 `jQuery.fn.init` 作为 jQuery 的构造函数，而不是使用 `jQuery` ？**\r\n\r\n回答这个问题之前，先看如果使用 `jQuery` 作为构造函数的情况。在这种情况下，库务必这样写。\r\n\r\n```javascript\r\n(function (window, undefined) {\r\n  \r\n  var jQuery = function () {\r\n  };\r\n                               \r\n  jQuery.fn = jQuery.prototype = {\r\n    init: function (selector, context) {\r\n      return this;\r\n    }\r\n  };\r\n                               \r\n  window.jQuery = window.$ = jQuery;\r\n})(window);\r\n```\r\n\r\n实现代码确实少了，那我们怎么使用呢？\r\n\r\n```javascript\r\nvar box = $().init(\'#box\');\r\n```\r\n\r\n这很麻烦，我们希望在第一步调用时，就取得实例对象。所以就需要在调用构造函数时，给我返回实例。\r\n\r\n那么，这样呢？\r\n\r\n```javascript\r\n(function (window, undefined) {\r\n  \r\n  var jQuery = function (selector, context) {\r\n    // 不行，这会导致堆栈溢出\r\n    return new jQuery().init(selector, context);\r\n  };\r\n                               \r\n  jQuery.fn = jQuery.prototype = {\r\n    init: function (selector, context) {\r\n      \r\n    }\r\n  };\r\n                               \r\n  window.jQuery = window.$ = jQuery;\r\n})(window);\r\n```\r\n\r\n不行，这会导致堆栈溢出，我们分析原因\r\n\r\n1. `$(\'#box\')` 调用。\r\n2. 执行代码 `new jQuery().init(selector, context)` 代码...\r\n3. ...报错了，堆栈溢出。原因是 `new jQuery()` 这一步----不停的自己调用自己，死循环了，根本就到不了 `.init(selector, context)` 这一步。\r\n\r\n自己调用自己，死循环了，那我们还想用 `$(\'#box\')` 创建实例怎么办----借助别的函数，jQuery 就选择了 `jQuery.fn.init`。\r\n\r\n```javascript\r\n(function (window, undefined) {\r\n  \r\n  var jQuery = function (selector, context) {\r\n    return new jQuery.fn.init(selector, context);\r\n  };\r\n                               \r\n  jQuery.fn = jQuery.prototype = {\r\n    init: function (selector, context) {\r\n      return this;\r\n    }\r\n  };\r\n \r\n  jQuery.fn.init.prototype = jQuery.fn;\r\n                               \r\n  window.jQuery = window.$ = jQuery;\r\n})(window);\r\n```\r\n\r\n选择了 `jQuery.fn.init` 做构造函数，就需要把 `jQuery` 的原型也给 `jQuery.fn.init`。\r\n\r\n```javascript\r\njQuery.fn.init.prototype = jQuery.fn;\r\n```\r\n\r\n这样创建出来的 `jQuery.fn.init` 实例对象就可以使用 `jQuery` 原型上的方法了。','2017-12-18 07:22:57','2017-12-18 07:22:57','jquery-constructor-is-jquery-fn-init'),(552,3,3,'Vue.js 学习笔记：自定义指令','在 Vue.js 中，我们可以自定义指令，比如 `v-rainbow`。\r\n\r\n```javascript\r\nVue.directive(\'rainbow\', {\r\n	bind(el) {\r\n		el.style.color = \'#\' + Math.random().toString().slice(2, 8);	\r\n	}\r\n});\r\n```\r\n\r\n这样使用\r\n\r\n```html\r\n<h1>All Article List</h1>\r\n<div v-for=\"blog in blogs\" class=\"single-blog\">\r\n  <h2 v-rainbow>{{ blog.title }}</h2>\r\n  <article>{{ blog.body }}</article>\r\n</div>\r\n```\r\n\r\n这里博客标题的颜色现在是随机设置的了。\r\n\r\n## 指令行为函数\r\n\r\n`Vue.directive` 接受的第一个参数就是指令名（不带 `v-` 前缀）；第二个参数是一个对象，指定指令的具体行为，可包含下列的函数属性。\r\n\r\n1. `bind`（常用）\r\n2. `inserted`\r\n3. `update`\r\n4. `componentUpdated`\r\n5. `unbind`\r\n\r\n我们最常用 `bind`，所以其他不谈论。\r\n\r\n## `bind` 行为函数\r\n\r\n`bind` 钩子函数，能接受下列主要参数（具体参数看 [这里](https://vuejs.org/v2/guide/custom-directive.html#Directive-Hook-Arguments)）：\r\n\r\n1. `el`：指令绑定的 DOM 元素。\r\n2. `binding`：包含下列常用属性：\r\n	- `name`：指令名（不带 `v-` 前缀）。\r\n	- `value`：传递给指令的（表达式）值。比如：`v-my-directive=\"\'foo\'\"`，传递的是字符串 `\'foo\'`；`v-my-directive=\"1 + 1\"` 传递的值是 `2`。 \r\n	- `arg`：传递给指令的参数。比如：`v-my-directive:foo` 传递的参数值是 `\"foo\"`。\r\n3. `vnode`： 由 Vue 编译器产生的虚拟节点。\r\n\r\n## 深入使用\r\n\r\n现在我们再定义一个 `v-theme` 指令，设定组件主题。这样使用\r\n\r\n```javascript\r\n<div v-theme:column=\"\'wide\'\" id=\"show-blogs\">\r\n	<h1>All Article List</h1>\r\n	<div v-for=\"blog in blogs\" class=\"single-blog\">\r\n		<h2 v-rainbow>{{ blog.title }}</h2>\r\n		<article>{{ blog.body }}</article>\r\n	</div>\r\n</div>\r\n```\r\n\r\n定义如下：\r\n\r\n```javascript\r\nVue.directive(\'theme\', {\r\n	bind(el, binding) {\r\n		switch (binding.value) {\r\n			case \'wide\':\r\n				el.style.maxWidth = \'1200px\';\r\n				break;\r\n			case \'narrow\':\r\n				el.style.maxWidth = \'560px\';\r\n				break;\r\n			default:;\r\n		}\r\n		\r\n		switch (binding.arg) {\r\n			case \'column\':\r\n				el.style.background = \'#ddd\';\r\n				el.style.padding = \'20px\';\r\n				break;\r\n			default:;\r\n		}		\r\n	}\r\n});\r\n```\r\n\r\n对于指令 `v-theme:column=\"\'wide\'\"`。`\"column\"` 这个值可以通过  `binding.arg` 拿到；`\"wide\" ` 可以通过 `binding.value` 拿到。\r\n\r\n可在这里查看 [完整代码实现](https://codepen.io/zhangbao/pen/ZvWwej)。','2017-12-20 02:34:22','2017-12-20 02:34:22','vue-js-learning-notes-custom-commands'),(553,3,3,'Vue.js 学习笔记：过滤器','Vue.js 过滤器用 `|` 分隔使用，可以用在两个地方：`{{ }}` 和 `v-bind` 指令中。\r\n\r\n```javascript\r\n<!-- in mustaches -->\r\n{{ message | capitalize }}\r\n\r\n<!-- in v-bind -->\r\n<div v-bind:id=\"rawId | formatId\"></div>\r\n```\r\n\r\n`capitalize` 和 `formatId` 就是两个过滤器。\r\n\r\n以 `capitalize` 为例，来介绍过滤器是如何定义的。定义过滤器的地方有两个：在组件里；在全局中。\r\n\r\n\r\n1. 在组件里\r\n\r\n```javascript\r\nfilters: {\r\n  capitalize: function (value) {\r\n    if (!value) return \'\'\r\n    value = value.toString()\r\n    return value.charAt(0).toUpperCase() + value.slice(1)\r\n  }\r\n}\r\n```\r\n\r\n在组件里定义过滤器，是在 `filters` 属性中。这里的 `value` 就是要处理的值，即 `|` 前面的那个值。\r\n\r\n2. 在全局中\r\n\r\n```javascript\r\nVue.filter(\'capitalize\', function (value) {\r\n  if (!value) return \'\'\r\n  value = value.toString()\r\n  return value.charAt(0).toUpperCase() + value.slice(1)\r\n})\r\n```\r\n \r\n定义全局过滤器使用 `Vue.filter` 方法。这里的 `value` 就是要处理的值。\r\n\r\n全局过滤器与组件过滤器唯一不同的地方就是作用域范围不同而已。','2017-12-20 02:49:38','2017-12-20 02:49:38','vue-js-learning-notes-filter'),(554,3,3,'ES6：对象属性的简洁表示法','ES6 允许直接在对象里写入变量和函数，作为对象的属性和方法。\r\n\r\n```javascript\r\nlet variable = \'value\';\r\nlet fn = function () {};\r\n\r\nlet obj = {\r\n	variable,\r\n	fn\r\n};\r\n```\r\n\r\n能看懂吗？这等价于\r\n\r\n```javascript\r\nlet variable = \'value\';\r\nlet fn = function () {};\r\n\r\nlet obj = {\r\n	variable: variable\r\n	fn: fn\r\n};\r\n```\r\n\r\n在对象里定义函数属性，同样可以简写成\r\n\r\n```javascript\r\nlet obj = {\r\n	fn() {\r\n		// ...\r\n	}\r\n};\r\n```\r\n\r\n这等价于\r\n\r\n```javascript\r\nlet obj = {\r\n	fn: function () {\r\n		// ...\r\n	}\r\n};\r\n```\r\n\r\n是不是很方便啊。','2017-12-20 04:33:03','2017-12-20 04:33:03','concise-representation-es6-object-properties'),(555,3,3,'Vue.js 学习笔记：Mixins','Mixins 就是指可重用代码块。适应场景是：当多个组件使用了同一个功能，而且代码一样的话，就不需要重复书写了，而是引入 Minxin。\r\n\r\nMinxin 可定义在组件作用域范围，也可以定义在全局作用域范围：\r\n\r\n1. 在组件作用域范围定义 Minxin。\r\n\r\n```javascript\r\nvar mixin = {\r\n  created: function () {\r\n    console.log(\'mixin hook called\')\r\n  }\r\n}\r\n\r\nnew Vue({\r\n  mixins: [mixin],\r\n  created: function () {\r\n    console.log(\'component hook called\')\r\n  }\r\n})\r\n\r\n// => \"mixin hook called\"\r\n// => \"component hook called\"\r\n```\r\n\r\n可以看到，Mixin 就是一个对象，在组件中使用 `mixins` 选项引入它。本质上 Mixin 会与组件 option 对象发生 Merge，不过这种 Merge 不是属性级别的覆盖，而是对属性内容的补充。用上例来讲，组件与 Mixin `mixin` Merge 了 `created` 函数后的结果等价于。\r\n\r\n```javascript\r\nnew Vue({\r\n  created: function () {\r\n    console.log(\'mixin hook called\')\r\n    console.log(\'component hook called\')\r\n  }\r\n})\r\n```\r\n\r\n而且 Mixin 的内容总是 Merge 在前面的。\r\n\r\n2. 在全局作用域范围定义 Minxin。\r\n\r\n定义全局作用域范围的 Mixin 使用 `Vue.mixin` 函数。\r\n\r\n```javascript\r\n// inject a handler for `myOption` custom option\r\nVue.mixin({\r\n  created: function () {\r\n    var myOption = this.$options.myOption\r\n    if (myOption) {\r\n      console.log(myOption)\r\n    }\r\n  }\r\n})\r\n\r\nnew Vue({\r\n  myOption: \'hello!\'\r\n})\r\n// => \"hello!\"\r\n```\r\n\r\n**全局 Minxin 无需引入，创建组件时就会自动使用**，所以使用起来要小心。','2017-12-20 05:14:55','2017-12-20 07:41:24','vue-js-learning-notes-mixins'),(556,3,3,'学习 Node.js：追根溯源','Node.js 提供了可以在服务器端执行 JavaScript 代码的平台，使用 C++ 编写，基于 Google V8 引擎。\r\n\r\n## Node.js 可以\r\n\r\n1. 在电脑上/服务器端执行 JavaScript 脚本。\r\n2. 读、删和修改文件。\r\n3. 可以操作数据库。\r\n\r\n##  V8 引擎\r\n\r\nV8 引擎 Google Chrome 浏览器使用的解析引擎，非常快，并且代码开源。那么 V8 引擎的作用是什么呢？这里解释。\r\n \r\n其实电脑并不认识 JavaScript， V8 引擎就是将 JavaScript 代码转换为机器代码，这样才能顺利实现在服务器级别上的操作，而不是浏览器级别的。整个转换过程如下：\r\n\r\n1. JavaScript\r\n2. C++\r\n3. 汇编语言\r\n4. 机器语言\r\n\r\n## 所以，Node.js 是\r\n\r\n1. 用 C++ 写的。\r\n2. 核心是 V8 引擎。\r\n3. V8 引擎将我们的 JavaScript 代码转换为机器码。','2017-12-20 08:19:58','2017-12-20 08:19:58','learning-node-js-traced-back'),(557,3,3,'学习 Node.js：全局对象','在浏览器环境环境中，全局对象是 `window`，在 Node.js 中就不同了，是 `global`。\r\n\r\n虽然 `global` 与 `window` 有着一些一样的属性，比如\r\n\r\n1. `console`。\r\n2. `setInterval`。\r\n3. `setTimeout`。\r\n\r\n\r\n\r\n```javascript\r\n// 下列代码在浏览器和 Node.js 环境中皆可运行。\r\n\r\n// Example 1\r\nsetTimeout(function () {\r\n  console.log(\'3 seconds have passed.\');\r\n}, 3000);\r\n\r\n\r\n// Example 2\r\nvar time = 0, step = 2, timer;\r\n\r\ntimer = setInterval(function () {\r\n  time += step;\r\n  if (time > 5) {\r\n      clearInterval(timer);\r\n  }\r\n  console.log(time + \' seconds have passed.\');\r\n}, step * 2000)\r\n```\r\n\r\n但 `global` 能控制的范围比 `window` 多多了。比如本地文件访问，模块输出引入等等。\r\n\r\n以 `index.js` 文件为例，它的路径地址是 `C:\\Users\\zhangb\\Documents\\My Web Sites\\nodejs-playlist\\index.js`。下列是在 Node.js 环境中运行的结果。\r\n\r\n```javascript\r\nsetInterval === global.setInterval // true\r\n\r\n__dirname // C:\\Users\\zhangb\\Documents\\My Web Sites\\nodejs-playlist\r\n\r\n__filename // C:\\Users\\zhangb\\Documents\\My Web Sites\\nodejs-playlist\\index.js\r\n```','2017-12-20 08:50:17','2017-12-20 08:50:17','learning-node-js-global-objects'),(558,3,3,'学习 Node.js：模块和 require','在 Node.js 中，模块就是指独有独立作用域的一块 JavaScript 代码，可以简单看成就是一个 `.js` 文件。引入模块使用 `require()`，输出模块使用 `module.exports`。\r\n\r\n我们定义一个模块 `counter.js`。\r\n\r\n```javascript\r\nvar counter = function (arr) {\r\n  console.log(\'There are \' + arr.length + \' elements in this array\');\r\n};\r\n\r\nmodule.exports = counter;\r\n```\r\n\r\n在同级 `index.js` 文件中引入该模块并且使用。\r\n\r\n```javascript\r\nvar counter = require(\'./counter\');\r\n\r\ncounter([1,2,3]); // There are 3 elements in this array\r\n```\r\n\r\n使用 `require` 引入模块时，不用显示添加模块后缀 `.js`，默认就是这个后缀。另外 `./counter` 表明是在 `index.js` 所在的同级目录下，寻找一个名为 `counter.js` 的文件。\r\n\r\nOK，先到这里！','2017-12-21 00:35:12','2017-12-21 00:35:12','learning-node-js-module-and-the-require'),(559,3,3,'学习 Node.js：module.exports','Node.js 中引入和输出模块的语法使用的是 CommonJS 标准。即：\r\n\r\n1. `module.exports` 输出模块。\r\n2. `require` 引入模块。\r\n\r\n在 [上一小节](http://baooab.com/forum/discussion/learning-node-js-module-and-the-require) 内容中。我们用 `module.exports` 输出了一个（函数）变量 `counter`，在 `index.js` 中使用。\r\n\r\n`module.exports` 默认就是一个空对象。\r\n\r\n```javascript\r\nmodule.exports // {}\r\n```\r\n\r\n我们也可以在模块中输出整个对象，也就是重写了 `module.exports` 对象。\r\n\r\nstuff.js\r\n\r\n```javascript\r\nlet counter = function (arr) {\r\n  console.log(\'There are \' + arr.length + \' elements in this array\');\r\n};\r\n\r\nlet add = function (a, b) {\r\n	console.log(`The sum is ${ a + b }`)\r\n};\r\n\r\nconst PI = 3.1415926;\r\n\r\nmodule.exports = {\r\n	counter,\r\n	add,\r\n	PI\r\n};\r\n```\r\n\r\nindex.js\r\n\r\n```javascript\r\nvar stuff = require(\'./stuff\');\r\n\r\nstuff.counter([1,2,3]);\r\nstuff.add(4,5);\r\nconsole.log(stuff.PI);\r\n\r\n// There are 3 elements in this array\r\n// The sum is 9\r\n// 3.1415926\r\n```','2017-12-21 01:24:03','2017-12-21 01:24:03','learning-node-js-module-exports'),(560,3,3,'ES6：Class 继承','子类必须在 `constructor` 方法中调用 `super` 方法，否则新建实例时会报错。这是因为子类没有自己的 `this` 对象，而是继承父类的 `this` 对象，然后对其进行加工。如果不调用 `super` 方法，子类就得不到 `this` 对象。\r\n\r\n```javascript\r\nconst EventEmitter = require(\'events\');\r\n\r\nclass People extends EventEmitter {\r\n  constructor(name) {\r\n    this.name = name; // Error: this is not defined!\r\n    this.on(\'speak\', function (msg) {\r\n      console.log(this.name + \' said: \' + msg);\r\n    })\r\n  }\r\n}\r\n\r\nclass People extends EventEmitter {\r\n  constructor(name) {\r\n	super()\r\n    this.name = name; // Right\r\n    this.on(\'speak\', function (msg) {\r\n      console.log(this.name + \' said: \' + msg);\r\n    })\r\n  }\r\n}\r\n```','2017-12-21 02:05:29','2017-12-21 02:05:29','es6-the-class-inheritance'),(561,3,3,'学习 Node.js：事件系统','在 Node.js 中使用事件系统，需要引入事件模块。\r\n\r\n```javascript\r\nconst EventEmitter = require(\'events\');\r\n```\r\n\r\n所谓事件系统就是定义自定义事件和触发这个自定义事件。自定义事件使用 `eventEmitter.on`，触发自定义事件使用 `eventEmitter.emit`。\r\n\r\n```javascript\r\nconst EventEmitter = require(\'events\');\r\n\r\nlet myEmitter = new EventEmitter();\r\n\r\nmyEmitter.on(\'customEventName\', function (msg) {\r\n  console.log(\'It Works! Received Message is \"\' + msg + \'\"\');\r\n});\r\n\r\nmyEmitter.emit(\'customEventName\', \':)\'); // It Works! Received Message is \":)\"\r\n```\r\n\r\n当然这样缺乏灵活性。比如，我们想在一个对象实例上使用这个事件触发器怎么办呢？继承，咱们只要继承这个 `EventEmitter` 就可以了。\r\n\r\n```javascript\r\nconst EventEmitter = require(\'events\');\r\n\r\nclass MyEmitter extends EventEmitter {}\r\n\r\nlet myEmitter = new MyEmitter();\r\n\r\nmyEmitter.on(\'customEventName\', function (msg) {\r\n  console.log(\'It Works! Received Message is \"\' + msg + \'\"\');\r\n});\r\n\r\nmyEmitter.emit(\'customEventName\', \':)\'); // It Works! Received Message is \":)\"\r\n```\r\n\r\n这里的继承就是指：将 `MyEmitter` 内部原型链指向 `EventEmitter.prototype` 对象（`EventEmitter` 原型）上了。\r\n\r\n下面再举一个例子：\r\n\r\n```javascript\r\nconst EventEmitter = require(\'events\');\r\n\r\nclass People extends EventEmitter {\r\n  constructor(name) {\r\n    super();\r\n\r\n    this.name = name;\r\n\r\n    this.on(\'speak\', function (msg) {\r\n      console.log(this.name + \' said: \' + msg);\r\n    })\r\n  }\r\n}\r\n\r\n(new People(\'Zhang\')).emit(\'speak\', \'Hello\'); // Zhang said: Hello\r\n\r\n```','2017-12-21 02:06:57','2017-12-21 02:06:57','learning-node-js-the-event-system'),(562,3,3,'学习 Node.js：读和写文件','在 Node.js 中读、写文件需要引入文件系统模块。\r\n\r\n```javascript\r\nconst fs = require(\'fs\');\r\n```\r\n\r\n接下来，我们读一个文件 `readMe.txt` 的内容。\r\n\r\n```javascript\r\nlet readMe = fs.readFileSync(\'readMe.txt\', \'utf8\');\r\n\r\nconsole.log(readMe);\r\n\r\n// 输出内容：\r\n// Ha, you read me!\r\n// \r\n// 哈，你读到我了！\r\n```\r\n\r\n指定 `utf8` 编码读文件，这样我们就能看到正确的文字显示。下面在将读出来的内容写入 `writeMe.txt`。\r\n\r\n```javascript\r\nfs.writeFileSync(\'writeMe.txt\', readMe);\r\n```\r\n\r\n这会顺利创建一个 `writeMe.txt`，并将我们读取到的内容写入其中。\r\n\r\n`readFileSync` 和 `writeFileSync` 都是同步操作文件的方法，执行时会造成阻塞。如果需要异步读取和写入文件，请使用 `readFile` 和 `writeFile` 方法，现在我们改写上面的代码：\r\n\r\n```javascript\r\nfs.readFile(\'readMe.txt1\', \'utf8\', function (err, data) {\r\n  if (err) throw err;\r\n  \r\n  console.log(data);\r\n});\r\n```\r\n\r\n既然是异步读取的文件，那么读取到文件数据后的操作就放在回调函数中处理了。然后写入文件 `writeMe.txt` 中。\r\n\r\n```javascript\r\nfs.readFile(\'readMe.txt\', \'utf8\', function (err, data) {\r\n  if (err) throw err;\r\n\r\n  fs.writeFile(\'writeMe.txt\', data);\r\n});\r\n\r\n\r\n// 后面的代码不会被阻塞了 :)\r\n```\r\n\r\n删除文件使用 `unlink` 方法。\r\n\r\n```\r\nfs.unlink(\'writeMe.txt\');\r\n```','2017-12-21 02:35:19','2017-12-21 02:39:39','learning-node-js-read-and-write-files'),(563,3,3,'学习 Node.js：创建和删除目录','创建目录使用 `mkdirSync` 或 `mkdir`；删除目录使用 `rmdirSync` 或 `rmdir`。\r\n\r\n顾名思义，`mkdirSync` 和 `rmdirSync` 是同步创建、删除目录的逻辑，这里我们就不讲了。就讲 `mkdir` 和 `rmdir` 方法。\r\n\r\n首先，我们创建一个目录 `stuff`。\r\n\r\n```javascript\r\nconst fs = require(\'fs\');\r\n\r\nfs.mkdir(\'stuff\', function () {\r\n \r\n});\r\n```\r\n\r\n然后在这个目录里，新建一个 `wirteMe.txt` 文件，把读取到的 `readMe.txt` 文件内容存入进去。\r\n\r\n```javascript\r\nfs.mkdir(\'stuff\', function () {\r\n  fs.readFile(\'readMe.txt\', \'utf8\', function (err, data) {\r\n    if (err) throw err;\r\n\r\n    fs.writeFile(\'./stuff/writeMe.txt\', data);\r\n  });\r\n});\r\n```\r\n\r\n现在 `stuff` 目录下已经有个 `writeMe.txt` 文件了。此时，如果用 `rmdir` 删除此目录，就会报错，因为目录不为空。\r\n\r\n```\r\nfs.rmdir(\'stuff\');\r\n\r\n// 报错了：\r\n// Error: ENOTEMPTY: directory not empty\r\n```\r\n\r\n所以在删除目录之前，务必保证目录是空的。\r\n\r\n```javascript\r\nfs.unlink(\'./stuff/writeMe.txt\', function (err) {\r\n  if (err) throw err;\r\n  \r\n  fs.rmdir(\'stuff\');\r\n})\r\n```','2017-12-21 03:03:23','2017-12-21 03:03:23','learning-node-js-create-and-delete-directory'),(564,3,3,'学习 Node.js：启动一个服务器','## 客户端和服务器\r\n\r\n客户端（Client）和服务器（Server）是这样交互的：\r\n\r\n1. 客户端 **请求（Request）** 服务器。\r\n2. 服务器 **响应（Response）** 客户端。\r\n\r\n## 协议\r\n\r\n协议（Protocol）是定义的一组交流规则，要求交流双方都支持的一套规则。\r\n\r\n## 端口\r\n\r\n端口（Ports）用来监听和区分从客户端分送过来的请求。http 协议默认 80，https 协议默认 443。\r\n\r\n## 启动一个服务器\r\n\r\n启动服务器，需要用到 `http` 模块，用 `createServer` 创建服务。\r\n\r\n```\r\nconst http = require(\'http\');\r\n\r\nconst sever = http.createServer(function (req, res) {\r\n  console.log(\'req.url\', req.url);\r\n\r\n  res.writeHead(200, { \'Content-Type\': \'text/plain\' });\r\n  res.end(\'Wooo, world\');\r\n});\r\n\r\nsever.listen(3000, \'127.0.0.1\');\r\nconsole.log(\'OK, server is listeing in port 3000.\');\r\n```\r\n\r\n上面的例子里，我们定义了一个服务 `server`，监听了 127.0.0.1 上的 3000 端口。  `server` 处理的逻辑如下：\r\n\r\n1. 打印请求地址。如：请求地址是 `http://127.0.0.1:3000/api`，那么打印结果是 `/api`。\r\n2. 设置响应头。`200` 是状态码，`{ .. }` 设置请求头属性，比如这里设置了 `Content-Type` 是 `\"text/plain\"`。\r\n3. 发送响应和数据。这里给出的响应数据是 `Wooo, world`。','2017-12-21 03:44:04','2017-12-21 03:44:04','learning-node-js-start-a-server'),(565,3,3,'学习 Node.js：Streams 和 Buffers','Streams 就是（数据）流，Buffers 就是缓冲区。\r\n\r\n数据从一端传输到另一端，不是一下就传输过去了，而是以数据流的形式传输的，就像水从这边流到那边。\r\n\r\n有了缓冲区，就可以在没有完全接收到完整数据的情况下，就能使用数据。\r\n\r\n缓冲区中保存了一块（chunk）的数据，就像视频加载，加载足够就可以现在播放了，不必等到所有视频全部加载完毕，这能大大地提高数据的使用效率和体验。\r\n\r\n## 读流\r\n\r\n读流就是从文件中读取数据，是作为流读取的。使用文件系统的 `createReadStream` 方法。\r\n\r\n```\r\nconst fs = require(\'fs\');\r\n\r\nlet myReadStream = fs.createReadStream(__dirname + \'/readMe.txt\', \'utf8\');\r\n\r\nmyReadStream.on(\'data\', function (chunk) {\r\n  console.info(\'New chunk recived!\');\r\n  console.log(chunk);\r\n});\r\n```\r\n\r\n我们将 `readMe.txt` 的文件内容读取为流，并以 utf8 编码了。\r\n\r\n读流的时候，会触发 `myReadStream` 对象上的 `data` 事件，回调函数种每一个此读取到的一块（Chunk）数据。\r\n\r\n## 写流\r\n\r\n现在我们将读到的数据流写入一个文件 `writeMe.txt` 中。\r\n\r\n```\r\nconst fs = require(\'fs\');\r\n\r\nlet myReadStream = fs.createReadStream(__dirname + \'/readMe.txt\', \'utf8\');\r\nlet myWriteStream = fs.createWriteStream(__dirname + \'/writeMe.txt\');\r\n\r\nmyReadStream.on(\'data\', function (chunk) {\r\n  console.info(\'New chunk recived!\');\r\n  myWriteStream.write(chunk);\r\n});\r\n```\r\n\r\n我们选择 `writeMe.txt` 文件作为流数据写入对象，使用 ` myWriteStream.write` 方法将现在获得的流数据写入进去。\r\n\r\n### pipe\r\n\r\n使用 Pipes 的方式，写入流数据更加简单。\r\n\r\n```javascript\r\nmyReadStream.pipe(myWriteStream);\r\n```\r\n\r\n内部数据库流处理已经对我们隐藏了。\r\n\r\n### 服务器返回流数据\r\n\r\n```javascript\r\nconst http = require(\'http\');\r\nconst fs = require(\'fs\');\r\n\r\nconst sever = http.createServer(function (req, res) {\r\n  res.writeHead(200, { \'Content-Type\': \'text/plain;\' });\r\n  res.charset = \'utf-8\';\r\n\r\n  let myReadStream = fs.createReadStream(__dirname + \'/readMe.txt\', \'utf8\');\r\n  myReadStream.pipe(res);\r\n});\r\n\r\nsever.listen(3000, \'127.0.0.1\');\r\nconsole.log(\'OK, server is listeing in port 3000.\');\r\n```\r\n\r\n我们直接 pipe 了 `res`，就能将数据推送出去了 。','2017-12-21 04:41:31','2017-12-21 05:54:53','learning-node-js-streams-and-buffers'),(566,3,3,'学习 Node.js：服务器返回 HTML 和 JSON 数据','1. 返回 HTML 数据。\r\n\r\n```javascript\r\nconst http = require(\'http\');\r\nconst fs = require(\'fs\');\r\n\r\nconst sever = http.createServer(function (req, res) {\r\n  res.writeHead(200, { \'Content-Type\': \'text/html\' });\r\n\r\n  let myReadStream = fs.createReadStream(__dirname + \'/index.html\', \'utf8\');\r\n  myReadStream.pipe(res);\r\n});\r\n\r\nsever.listen(3000, \'127.0.0.1\');\r\nconsole.log(\'OK, server is listeing in port 3000.\');\r\n```\r\n\r\n`index.html` 的内容如下：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n	<head>\r\n		<meta charset=\"utf-8\">\r\n		<style>\r\n			body{background:skyblue;font-size:16px;color:#fff;text-align:center}\r\n			h1{font-size:48px;text-transform:uppercase}\r\n		</style>\r\n	</head>\r\n	<body>\r\n		<h1>\r\n			哈哈，欢迎欢迎:)\r\n		</h1>\r\n		<p>\r\n			可能没有比这更好的网站了\r\n		</p>\r\n	</body>\r\n</html>\r\n```\r\n\r\n2. 返回 JSON 数据。\r\n\r\n```javascript\r\nconst http = require(\'http\');\r\nconst fs = require(\'fs\');\r\n\r\nconst sever = http.createServer(function (req, res) {\r\n  res.writeHead(200, { \'Content-Type\': \'application/json\' });\r\n  let myObj = {\r\n    id: 1,\r\n    name: \'@baooab\',\r\n    website: \'baooab.com\'\r\n  };\r\n  res.end(JSON.stringify(myObj));\r\n});\r\n\r\nsever.listen(3000, \'127.0.0.1\');\r\nconsole.log(\'OK, server is listeing in port 3000.\');\r\n```','2017-12-21 06:14:33','2017-12-21 06:14:33','learning-node-js-html-and-json-data-from-server'),(567,3,3,'学习 Node.js：实现简单路由','下列代码实现了简单路由功能，实现两种类型的内容展示（html 和 JSON）。路由请逻辑如下：\r\n\r\n\r\n1. `/` 或 `/home`： Home 页面。\r\n2. `/about`：关于页面。\r\n3. `/api/json`：JSON 数据接口。\r\n4. 其他路由地址跳转到 404 页面。\r\n\r\n这里是代码实现：\r\n\r\n```javascript\r\nconst http = require(\'http\');\r\nconst fs = require(\'fs\');\r\n\r\nconst sever = http.createServer(function (req, res) {\r\n  switch (req.url) {\r\n    case \'/\':\r\n    case \'/home\':\r\n      res.writeHead(200, { \'Content-Type\': \'text/html\' });\r\n      fs.createReadStream(__dirname + \'/home.html\', \'utf8\').pipe(res);\r\n      break;\r\n    case \'/about\':\r\n      res.writeHead(200, { \'Content-Type\': \'text/html\' });\r\n      fs.createReadStream(__dirname + \'/about.html\', \'utf8\').pipe(res);\r\n      break;\r\n    case \'/api/json\':\r\n      res.writeHead(200, { \'Content-Type\': \'text/html\' });\r\n      res.end(JSON.stringify({ code: 0, messsage: \'successful\', status: 200 }));\r\n      break;\r\n    default:\r\n      res.writeHead(200, { \'Content-Type\': \'text/html\' });\r\n      fs.createReadStream(__dirname + \'/404.html\', \'utf8\').pipe(res);\r\n  }\r\n});\r\n\r\nsever.listen(3000, \'127.0.0.1\');\r\nconsole.log(\'OK, server is listeing in port 3000.\');\r\n```','2017-12-21 07:05:14','2017-12-21 07:05:14','learning-node-js-implement-a-simple-routing'),(568,3,3,'NPM 常用命令参考','> 参考： https://docs.npmjs.com/\r\n\r\n1. Updating global packages\r\n\r\n```\r\nnpm update vue-cli -g\r\n```','2017-12-21 09:01:41','2017-12-21 09:02:16','npm-commonly-used-command-reference'),(569,3,3,'学习 Node.js：使用 Express','[Express](http://expressjs.com/) 是一个 Node.js Web 框架。使用它改写我们之前使用 [原生 Node.js 库实现的简单路由](http://baooab.com/forum/discussion/learning-node-js-implement-a-simple-routing) 会更加简洁。 \r\n\r\n首先下载\r\n\r\n```\r\n$ npm install express\r\n```\r\n\r\n使用\r\n\r\n```javascript\r\nconst express = require(\'express\');\r\n\r\nlet app = express();\r\n\r\napp.get(\'/\', function (req, res) {\r\n  res.sendFile(__dirname + \'/home.html\');\r\n});\r\n\r\napp.get(\'/about\', function (req, res) {\r\n  res.sendFile(__dirname + \'/about.html\');\r\n});\r\n\r\napp.get(\'/api/json\', function (req, res) {\r\n  res.json({ code: 0, messsage: \'successful\', status: 200 });\r\n});\r\n\r\napp.get(\'/users/:name\', function (req, res) {\r\n   res.send(\'Profile of \' + req.params.name);\r\n});\r\n\r\napp.use(function(req, res, next) {\r\n  res.status(404).sendFile(__dirname + \'/404.html\');\r\n});\r\n\r\napp.listen(3000);\r\nconsole.log(\'OK, server is listeing in port 3000.\');\r\n```\r\n\r\n就这么简单。','2017-12-22 02:46:48','2017-12-22 02:46:48','learning-node-js-use-express'),(570,3,3,'学习 Node.js：为 Express 使用模块引擎 EJS','模板引擎 EJS 使用起来很简单，首先安装。\r\n\r\n```\r\n$ npm install ejs\r\n```\r\n\r\n## 使用\r\n\r\n在 `index.js` 中使用。\r\n\r\n```\r\nconst express = require(\'express\');\r\n\r\nlet app = express();\r\n\r\napp.set(\'view engine\', \'ejs\');\r\n```\r\n\r\n设置的 `app` 的 `view engine` 的值为 `ejs` 即可。现在需要在 `index.js` 的同级目录创建一个 `views` 目录。\r\n\r\n```\r\nindex.js\r\nviews/\r\n```\r\n\r\n在 `views` 目录中创建一个文件 `home.ejs`。\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n	<head>\r\n		<meta charset=\"utf-8\">\r\n		<style>\r\n			body { background: skyblue; font-size: 16px; color: #fff; text-align:center; }\r\n      h1 { font-size: 48px; text-transform: uppercase; }\r\n		</style>\r\n	</head>\r\n	<body>\r\n		<h1>\r\n			主页 :)\r\n		</h1>\r\n		<p>\r\n			可能没有比这更好的网站了\r\n		</p>\r\n	</body>\r\n</html>\r\n```\r\n\r\n为了定位到 `home.ejs` 文件，我们需要使用 `res` 的 `render` 方法，**`render` 方法默认读取同级 `views` 目录下的文件**。\r\n\r\n```\r\napp.get(\'/\', function (req, res) {\r\n  res.render(\'home\');\r\n});\r\n```\r\n\r\n现在就可以了。\r\n\r\n我们也可以向模板文件中传输数据。用 `<%= %>` 符号解析\r\n\r\n```\r\napp.get(\'/\', function (req, res) {\r\n  var data = {\r\n    age: 18,\r\n    job: \'Developer\',\r\n    hobbies: [\'eating\', \'fighting\', \'fishing\']\r\n  };\r\n\r\n  res.render(\'Profile\', { data: data });\r\n});\r\n```\r\n\r\n然后在模板里使用 \r\n\r\n```\r\n<h1>\r\n	Profile of <%= person %>\r\n</h1>\r\n<p>\r\n	<strong>Age: </strong><%= data.age %>\r\n</p>\r\n<p>\r\n	<strong>Job: </strong><%= data.job %>\r\n</p>\r\n<h2>Hobbies</h2>\r\n<ul>\r\n  <% data.hobbies.forEach(function(hobby){ %>\r\n	<li><%= hobby %></li>\r\n  <% }); %>\r\n</ul>\r\n```\r\n\r\n`<%= ` 是直接输出变量值的指令；而在 `<%` 指令中可以写 JavaScript 代码逻辑。 \r\n\r\n## 部件模板\r\n\r\n一个网站里的多个页面，有时具有多个相同的 HTML 结构，比如：页脚、页眉、导航栏等。\r\n\r\n我们以导航栏为例，在 `views` 目录下创建一个 `partials` 目录存放我们的部件模板 `_nav.ejs`。\r\n\r\n```\r\nindex.js\r\nviews/\r\n  partials/\r\n    _nav.ejs\r\n```\r\n\r\n\\_nav.ejs\r\n\r\n```\r\n<ul>\r\n  <li> <a href=\"/\">Home</a> </li>\r\n  <li> <a href=\"/contact\">Contact</a> </li>\r\n</ul>\r\n```\r\n\r\n下面在 `home.ejs` 中引入\r\n\r\n```\r\n<% include partials/_nav %>\r\n```','2017-12-22 03:45:56','2017-12-22 03:45:56','learning-node-js-use-ejs-module-engine-for-express'),(571,3,3,'学习 Node.js：中间件和静态文件','如果在 `index.html` 中引入静态文件，并返回给客户端，那么静态文件将会获取不到。\r\n\r\n```\r\napp.get(\'/\', function (req, res) {\r\n  res.sendFile(__dirname + \'index.html\');\r\n});\r\n```\r\n\r\nindex.html\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n	<head>\r\n		<meta charset=\"utf-8\">\r\n		<link rel=\"stylesheet\" href=\"/assets/common.css\">\r\n	</head>\r\n	<body>\r\n		<!--  -->\r\n	</body>\r\n</html>\r\n```\r\n\r\n如果在本地 3000 端口开启服务，那么这个地址 → http://127.0.0.1:3000/assets/common.css 就会报错。原因在于 express 将 `common.css` 静态文件作为请求路径访问，而不是静态资源的请求。所以，为了让本地 `assets` 目录作为静态文件访问就要使用中间件。\r\n\r\n## 访问静态资源\r\n\r\n```\r\napp.use(\'/assets\', express.static(\'assets\'));\r\n```\r\n\r\n上面设置，**将 `/assets` 路径下的访问请求，全部对应到本地静态目录 `assets`、并且看做是静态文件的访问**。\r\n\r\n## 中间件\r\n\r\n上例中的 `app.use` 就是在使用中间件。中间件的回调函数中接收 3 个参数：req、res 和 next。\r\n\r\n```\r\napp.use(\'/assets\', function (req, res, next) {\r\n  // 中间件处理逻辑\r\n  next(); // 将请求继续传递\r\n});\r\n```\r\n\r\n中间件用来对请求加工的。在中间件中调用了 `.next` 即使将请求进一步派发，如果没有调用 `next`，那么请求到这里就停止了。','2017-12-22 04:12:14','2017-12-22 04:12:14','learning-node-js-middleware-and-static-files'),(572,3,3,'学习 Node.js：使用 body-parser 处理 POST 请求','如果向 Express 发送 POST 请求，`req` 对象的 `body` 属性值是 `undefined`。\r\n\r\n```\r\n<form action=\"/\" method=\"post\">\r\n	<label for=\"who\">Who</label>\r\n	<input type=\"text\" name=\"who\">\r\n	<label for=\"department\">Department</label>\r\n	<input type=\"text\" name=\"department\">\r\n	<label for=\"email\">Email</label>\r\n	<input type=\"text\" name=\"email\">\r\n	<input type=\"submit\" value=\"提交\">\r\n</form>\r\n\r\napp.post(\'/\', function (req, res) {\r\n  req.body； // Oops! undefined！！\r\n});\r\n```\r\n\r\n那么怎么获得请求体里面的数据呢？答案是使用 [`body-parser`](https://www.npmjs.com/package/body-parser) 包。\r\n\r\n1. 安装 \r\n\r\n```\r\n$ npm install body-parser\r\n```\r\n\r\n2. 注册\r\n\r\n```\r\nconst express = require(\'express\');\r\nconst bodyParser = require(\'body-parser\')\r\n\r\nconst app = express();\r\n\r\n// parse application/x-www-form-urlencoded\r\napp.use(bodyParser.urlencoded({ extended: false }))\r\n \r\n// parse application/json\r\napp.use(bodyParser.json())\r\n```\r\n\r\n我们在 Express 中注册了 bodyParser 了，注册了两种表单请求方式：`application/x-www-form-urlencoded` 和 `application/json`。\r\n\r\n现在我们这里只使用了 `application/x-www-form-urlencoded` 方式。\r\n\r\n3. 使用\r\n\r\n```\r\napp.post(\'/\', function (req, res) {\r\n  console.log(req.body);  // 现在就能直接获取数据了\r\n  res.render(\'home\', { data: req.body }); // 还可以把获得的数据传递给别的视图页面呢\r\n});\r\n```','2017-12-22 06:54:14','2017-12-22 06:54:48','learning-node-js-use-the-body-parser-handle-a-post-request'),(573,3,3,'\\r\\n , \\r , \\n 的区别','> https://stackoverflow.com/questions/15433188/r-n-r-n-what-is-the-difference-between-them\r\n\r\n\\r = CR (Carriage Return) // Used as a new line character in Mac OS before X\r\n\r\n\\n = LF (Line Feed) // Used as a new line character in Unix/Mac OS X\r\n\r\n\\r\\n = CR + LF // Used as a new line character in Windows','2017-12-25 12:08:12','2017-12-25 12:08:12','r-n-r-n-the-difference'),(574,3,3,'代码段：markdown 格式解析器','写了一个小型的 markdown 格式解析器。支持的语法有：\r\n\r\n| 样式 | 语法 | 结果 |\r\n| -------- | -------- | -------- |\r\n| 加粗     | `__x__`     | `<strong>x</strong>`     |\r\n| 斜体     | `_x_`     | `<em>x</em>`     |\r\n| 代码     | <code>`x`</code>     | `<code>x</code>`     |\r\n\r\n代码：\r\n\r\n```javascript\r\n;(function (window) {\r\n\r\nfunction escape (html) {\r\n  return html\r\n    .replace(/&/g, \'&\')\r\n    .replace(/</g, \'<\')\r\n    .replace(/>/g, \'>\')\r\n    .replace(/\"/g, \'\"\')\r\n    .replace(/\'/g, \'&apos;\');\r\n};\r\n\r\nwindow.marked = function(str) {\r\n  \r\n   str = str.replace(/\\r\\n?/g, \'\\n\')\r\n   .replace(/\\t/g, \'    \')\r\n   .replace(/__([^_]+)__/g, \'<strong>$1</strong>\')\r\n   .replace(/_([^_]+)_/g, \'<em>$1</em>\')\r\n   .replace(/`([^`]+)`/g, function (_, s) {\r\n       return \'<code>\' + escape(s) + \'</code>\';\r\n   });\r\n\r\n   return str.split(\'\\n\\n\').map(function (item) {\r\n   	return \'<p>\' + item.trim() + \'</p>\';\r\n   }).join(\'\');\r\n};\r\n\r\n})(window);\r\n```\r\n\r\n使用\r\n\r\n```\r\nvar res = marked(`\r\nsd_j_sd \\`<div>\\` mdfdf dfdf\r\n\r\nsd_j_sd\r\n\r\nsd__sd__ds\r\n\r\nsd\r\n`);\r\n```\r\n\r\n渲染结果\r\n\r\n```\r\n<p>sd<em>j</em>sd <code><div></code> mdfdf dfdf</p><p>sd<em>j</em>sd</p><p>sd<strong>sd</strong>ds</p><p>sd</p>\r\n```\r\n\r\n参考链接：\r\n\r\n1. http://eloquentjavascript.net/1st_edition/chapter6.html#p90fad98\r\n2. https://github.com/chjj/marked/blob/v0.0.1/lib/marked.js#L241','2017-12-25 13:10:23','2017-12-25 13:20:19','the-parser-code-markdown-format'),(575,3,3,'阅读笔记：你不知道的 JavaScript（中卷·第一部分）','## 第一章 类型\r\n\r\n### 类型\r\n\r\n对 JavaScript 引擎来说，类型是值的内部特征，它定义了值的行为。一种类型对应一类值的相同行为。拿 22 和 \"22\" 来说，它们是不同的类型：一个是数字，一个是字符串。\r\n\r\n### 内置类型\r\n\r\nJavaScript 有七种内置类型：\r\n\r\n1. 空值 null\r\n2. 未定义 undefiend\r\n3. 布尔值 boolean\r\n4. 数字 number\r\n5. 字符串 string\r\n6. 对象 obejct\r\n7. Symbol symbol（ES6 新增）\r\n\r\n除“对象”外，其他都称“基本类型”。\r\n\r\ntypeof null 的结果是 `\"object\"`，这是一个也许永远也不会修复的 bug。\r\n\r\n数组和函数都是 object 的子类型，不是内置类型。\r\n\r\n### 值和类型\r\n\r\nJavaScript 中变量没有类型（因为变量可以是任意类型的值），只有值才有。\r\n\r\n#### undefined 和 undeclared\r\n\r\n声明但没有赋值的变量，（默认）值是 `undefined`。没有声明的变量是 undeclared。\r\n\r\n```javascript\r\nvar a;\r\na; // undefined\r\nb; // ReferenceError: b is not defined\r\n```\r\n\r\n`x is not defined` 并不准确，`x is not declared` 或 `x is not found` 会更准确。\r\n\r\n### typeof Undeclared\r\n\r\ntypeof 处理 undeclared 变量，返回的结果是 `\"undefined\"`。这算是一种安全防范机制，至少能避免某些抛错出现。\r\n\r\n```javascript\r\n// 这样会抛出错误\r\nif (DEBUG) {\r\n  console.log( \"Debugging is starting\" );\r\n}\r\n\r\n// 这样是安全的\r\nif (typeof DEBUG !== \"undefined\") {\r\n  console.log( \"Debugging is starting\" );\r\n}\r\n```\r\n\r\n###  小结\r\n\r\n类型定义了值的行为。JavaScript 有七种内置类型。\r\n\r\n变量没有类型，但变量值是有类型的。\r\n\r\n`undefined` 和 undeclared 是不一样的。前者是声明没赋值，后者是压根没声明。\r\n\r\ntypeof Undeclared 返回 `undefiend` 算是一个安全防范机制。\r\n\r\n## 第二章 值\r\n\r\n### 数组\r\n\r\n在 JavaScript 中，不需要设定数组大小，就可以向数组中插入值。\r\n\r\n使用 delete 运算符删除数组元素，并不会改变数组的 length 属性。\r\n\r\n数组空位不是 undefined。\r\n\r\n#### 类数组\r\n\r\n类数组就是 [具有 `length` 属性、且属性值是正整数][link1] 的普通对象。它不具有数组方法，但能转化为数组，主要两种方式：\r\n\r\n1. Array.prototype.slice\r\n2. Array.from\r\n\r\n[link1]: https://github.com/hanzichi/underscore-analysis/issues/14\r\n\r\n### 字符串\r\n\r\n字符串具有 length 属性以及 indexOf() 和 concat() 方法，但与数组并不是一回事。\r\n\r\n字符串也可以借用数组的 **非变异方法** 处理字符串。\r\n\r\n```javascript\r\nvar a = \'foo\'; \r\n\r\nvar c = [].join.call( a, \'-\' );\r\nvar d = [].map.call( a, function(v){\r\n  return v.toUpperCase() + \'.\';\r\n} ).join(\'\');\r\n\r\nc; // \"f-o-o\"\r\nd; // \"F.O.O.\"\r\n```\r\n\r\n### 数字\r\n\r\nJavaScript 中的数字包括整数和浮点数。\r\n\r\ntofixed(..) 方法指定小数部分的显示位数。\r\n\r\n```javascript\r\nvar a = 42.59;\r\na.toFixed( 0 ); // \"43\"\r\na.toFixed( 1 ); // \"42.6\"\r\na.toFixed( 2 ); // \"42.59\"\r\na.toFixed( 3 ); // \"42.590\"\r\na.toFixed( 4 ); // \"42.5900\"\r\n```\r\n\r\ntoPrecision(..) 方法用来指定有效数位的显示位数。\r\n\r\n```javascript\r\na.toPrecision( 1 ); // \"4e+1\"\r\na.toPrecision( 2 ); // \"43\"\r\na.toPrecision( 3 ); // \"42.6\"\r\na.toPrecision( 4 ); // \"42.59\"\r\na.toPrecision( 5 ); // \"42.590\"\r\na.toPrecision( 6 ); // \"42.5900\"\r\n```\r\n\r\n### 特殊数值\r\n\r\nundefined 类型只有一个值，就是 `undefined`；null 类型也只有一个值，就是 `null`。\r\n\r\n#### void 运算符\r\n\r\n表达式 `void xx` 没有返回值，因此结果是 `undefined`。\r\n\r\n#### NaN\r\n\r\nNaN 是 JavaScript 中唯一一个不等于自身的值。\r\n\r\n#### 值和引用\r\n\r\n基本类型值总是通过 **值复制** 的方式来赋值/传递参数；复合类型值（对象、数组和函数）总是通过 **引用复制** 的方式来赋值/传递参数。\r\n\r\n### 小结\r\n\r\nJavaScript 数组中可以包含任意类型的值。\r\n\r\nJavaScript 中的数字包括整数和浮点数。\r\n\r\nnull 类型只有一个值 `null`， undefined 类型也只有一个值 `undefined`。所有变量在赋值之前默认值都是 `undefined`。 \r\n\r\n`void` 运算符返回 `undefined`。\r\n\r\n基本类型值总是通过值复制的方式来赋值/传递参数；复合类型值（对象、数组和函数）总是通过引用复制的方式来赋值/传递参数。\r\n\r\n## 第三章 原生函数\r\n\r\n原生函数就是内建函数。常用原生函数包括：\r\n\r\n- Boolean()\r\n- Number()\r\n- String()\r\n- Object()\r\n- Array()\r\n- Function()\r\n- RegExp()\r\n- Date()\r\n- Error()\r\n- Symbol()（ES6 新增）\r\n\r\n### 内部属性 [[Class]]\r\n\r\n所有 typeof 返回值是 `\"object\"` 的对象都包含一个内部属性 [[Class]]。一般可以通过 `Object.prototype.toString()` 来查看。\r\n\r\n```javascript\r\nObject.prototype.toString.call([1,2,3]);\r\n// \"[object Array]\"\r\nObject.prototype.toString.call(/regex-literal/i);\r\n// \"[object RegExp]\"\r\n```\r\n\r\n对 null 和 undefined 使用 `Object.prototype.toString()`：\r\n\r\n```\r\nObject.prototype.toString.call(null);\r\n// \"[object Null]\"\r\nObject.prototype.toString.call(undefined);\r\n// \"[object Undefined]\"\r\n```\r\n\r\n再看 `Object.prototype.toString()` 对基本类型值的判断：\r\n\r\n```javascript\r\nObject.prototype.toString.call(\'abc\');\r\n// \"[object String]\"\r\nObject.prototype.toString.call(42);\r\n// \"[object Number]\"\r\nObject.prototype.toString.call(true);\r\n// \"[object Boolean]\r\n```\r\n\r\n上例中基本类型值其实发生了**自动装箱**----基本类型值被各自的封装对象自动包装，所以它们的内部 [[Class]] 属性值分别为 \"String\"、 \"Number\" 和 \"Boolean\"。\r\n\r\n### valueOf()\r\n\r\n如果从封装对象中获得基本类型值，可以使用 `valueOf` 方法。\r\n	\r\n```javascript\r\nvar a = new String( \"abc\" );\r\nvar b = new Number( 42 );\r\nvar c = new Boolean( true );\r\na.valueOf(); // \"abc\"\r\nb.valueOf(); // 42\r\nc.valueOf(); // true\r\n```\r\n\r\n### 原生函数作为构造函数\r\n\r\n应该尽量避免使用构造函数，除非十分必要。\r\n\r\n### Date() 和 Error()\r\n\r\nES5 引入了一个获得当前 Unix 时间戳的更简单方法，即静态函数 `Date.now()`。对 ES5 之前的版本我们可\r\n以使用下面的 polyfill：\r\n\r\n```javascript\r\nif (!Date.now) {\r\n  Date.now = function(){\r\n    return (new Date()).getTime();\r\n  };\r\n}\r\n```\r\n\r\nError 对象通常与 throw 一起使用。\r\n\r\n```javascript\r\nfunction foo(x) {\r\n  if (!x) {\r\n    throw new Error( \"x wasn’t provided\" );\r\n  }\r\n  // ..\r\n}\r\n```\r\n\r\n###  Symbol(..)\r\n\r\nSymbol 是 ES6 新加入的一个基本数据类型。用来创建唯一值，用来命名对象属性不容易导致重名。\r\n\r\nES6 中有一些预定义符号，以 Symbol 的静态属性形式出现，如 `Symbol.create`、 `Symbol.\r\niterator`。\r\n\r\n我们也可以自定义符号（不需要带 `new`）：\r\n\r\n```javascript\r\nSymbol( \"my own symbol\" );\r\n```\r\n\r\n### 小结\r\n\r\nJavaScript 为基本类型值提供了封装对象，称为原生函数。\r\n\r\n## 第四章 强制类型转换\r\n\r\n将一个值从一种类型转换成另一种类型称为 **类型转换**。JavaScript 中的类型转换分 **隐式强制类型转换** 和 **显式强制类型转换**。\r\n\r\n```javascript\r\nvar a = 42;\r\nvar b = a + \"\"; // 隐式强制类型转换\r\nvar c = String( a ); // 显式强制类型转换\r\n```\r\n\r\n对变量 b 而言，强制类型转换是隐式的；而 `String(..)` 则是将 a 显式强制类型转换为字符串。\r\n\r\n### 抽象操作\r\n\r\n“抽象操作”（即“仅供内部使用的操作”，包含转换规则）规定了字符串、数字和布尔值之间类型转换的基本规则。这里着重介绍 `ToString`、 `ToNumber` 和 `ToBoolean`，附带讲一讲 `ToPrimitive`。\r\n\r\n#### ToBoolean\r\n\r\nJavaScript 规范具体定义了一小撮可以被 Boolean() 强制类型转换为 false 的值，称为假值，包括：\r\n\r\n- undefiend\r\n- null\r\n- false\r\n- +0、-0 和 NaN\r\n- \"\"\r\n\r\n假值的布尔强制类型转换结果为 `false`。与假值对应的是真值，真值的布尔强制类型转换结果都 `true`。\r\n\r\n#### ToString\r\n\r\nToString 负责处理非字符串到字符串的操作。规则如下：\r\n\r\n- null 转换为 \"null\"\r\n- undefined 转换为 \"undefined\"\r\n- true 转换为 \"true\"\r\n- 数字的字符串化则遵循通用规则\r\n- 对普通对象来说，除非自行定义，否则 toString()（`Object.prototype.toString()`）返回\r\n内部属性 [[Class]] 的值。\r\n\r\ntoString() 可以被显式调用，或者在需要字符串化时自动调用。\r\n\r\n#### ToNumber\r\n\r\nToNumber 负责处理非数字到数字的操作。规则如下：\r\n\r\n- true 转换为 1\r\n- false 转换为 0\r\n- undefined 转换为 NaN\r\n- null 转换为 0。\r\n\r\nToNumber 对字符串的处理基本遵循数字常量的相关规则 / 语法，处理失败时返回 NaN，否则返回数值。\r\n\r\n**对象转换为数值的规则稍微复杂些：**\r\n\r\n首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循 `ToNumber` 规则将其强制转换为数字。\r\n\r\n将对象转换为相应的基本类型值需要用到抽象操作 `ToPrimitive`：\r\n\r\n- 先检查该值是否有 valueOf() 方法；\r\n- 如果没有就使用 toString() 的返回值\r\n- 如果返回值存在，就进行强制类型转换（ToString、ToNumber 或者 ToBoolean）。\r\n- 如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。\r\n\r\n### 显式强制类型转换\r\n\r\n- String() 遵循 ToString 规则\r\n- Number() 遵循 ToNumber 规则\r\n- Boolean() 遵循 ToBoolean 规则。\r\n\r\n对于布尔值类型转换，建议使用显示转换的方式：使用 Boolean(a) 和 !!a 来进行显式强制类型转换。\r\n\r\n### 隐式强制类型转换\r\n\r\n#### 转换为数字/字符串\r\n\r\n如果 `+` 的其中一个操作数是字符串，则进行字符串拼接，否则执行数字加法。对象与对象，对象与字符串之间执行字符串拼接。布尔与数字、布尔与布尔之间执行数字加法。\r\n\r\n`-`、`*` 和 `/` 这 3 个运算符只适用于数字计算，为了进行数字运算，如果需要就会对操作数做数字转换。\r\n\r\n#### 转换为布尔值\r\n\r\n下面几种情况会发生隐式转换为布尔值：\r\n\r\n1. if(..)\r\n2. for(..;..;..)\r\n3. while(..) 和 do..while(..)\r\n4. ? :\r\n5. || 和 &&\r\n\r\n需要注意的是，在 JavaScript 中，&& 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值，这是与  在 C 和 PHP 语言中不同的。\r\n\r\n### 相等比较 ==\r\n\r\n不同类型间做相等比较的转换方式：\r\n\r\n1. 字符串与数字比较，字符串转换为数字，再进行比较。\r\n2. 布尔类型与其它类型比较，布尔值转化为数字，再进行比较。\r\n3. 对象与基本类型值比较，对对象做 ToPrimitive 运算，再进行比较。\r\n\r\n安全使用 == 的规则：\r\n\r\n1. 如果两边的值中有 true 或者 false，千万不要使用 ==。\r\n2. 如果两边的值中有 []、\"\" 或者 0，尽量不要使用 ==。','2017-12-27 05:42:42','2018-01-05 07:42:03','in-the-reading-notes-you-dont-know-javascript-volume'),(576,3,3,'Ubuntu 16.04  下安装 Node.js（v8.9.3）','很简单，两条命令：\r\n\r\n```\r\ncurl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -\r\nsudo apt-get install -y nodejs\r\n```\r\n\r\n然后\r\n\r\n```\r\nsudo apt-get install nodejs\r\n```\r\n\r\n即可。\r\n\r\n参考链接：https://nodejs.org/en/download/package-manager/','2017-12-28 07:55:09','2017-12-28 07:55:09','ubuntu-1604-installation-node-js-v893'),(577,3,3,'让 node.js 程序后台运行','使用软件 forever。\r\n\r\n```\r\n//全局安装\r\nnpm install forever -g \r\n//启动       \r\nforever start app.js \r\n//关闭         \r\nforever stop app.js      \r\n```\r\n\r\n参考链接：http://fengliner.github.io/2014/11/20/node.js%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/','2017-12-28 08:39:55','2017-12-28 08:39:55','let-the-node-js-application-background'),(578,3,3,'ES6：Promise 对象','ES6 提供了 `Promise` 构造函数，用来创建 Promise 对象。Promise 对象是异步编程的一种解决方案，相比回调函数和和事件监听，更强大。\r\n\r\nPromise 对象只有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。\r\n\r\nPromise 对象的状态改变只有两种可能：从 pending 变为 fulfilled，从 pending 变为 rejected。\r\n\r\n下面创建 Promise 对象：\r\n\r\n```javascript\r\nconst promise = new Promise(function (resolve, reject) {\r\n  if (/* 异步操作成功 */) {\r\n    resolve(value); \r\n  } else {\r\n    reject(error);                          \r\n  }\r\n}); \r\n```\r\n\r\n`Promise` 构造函数接收一个函数作为参数，函数中的两个参数 `resolve` 和 `reject` 是固定写法，由 JavaScript 引擎提供。\r\n\r\n`resolve` 函数将 Promise 对象状态从 pending 变为 fulfilled；`reject` 函数将 Promise 对象状态从 pending 变为 rejected。\r\n\r\nPromise 对象创建完毕后，通过 `then` 方法指定 Promise 对象的状态变为 fulfilled 和 rejected 后的回调函数。 \r\n\r\n```javascript\r\npromise.then(function (value) {\r\n  // Promise 对象状态变为 fulfilled 后的回调函数\r\n}, function (error) {\r\n  // Promise 对象状态变为 rejected 后的回调函数\r\n});\r\n```\r\n\r\n需要注意的是，这里的回调函数参数 `value` 和 `error` 就是上面在调用 `resolve` 和 `reject` 函数时传入的。\r\n\r\n下面是一个使用 Primise 对象封装 Ajax 请求的例子。\r\n\r\n```javascript\r\nconst getJSON = function(url) {\r\n  const promise = new Promise(function(resolve, reject){\r\n    const handler = function() {\r\n      if (this.readyState !== 4) {\r\n        return;\r\n      }\r\n      if (this.status === 200) {\r\n        resolve(this.response);\r\n      } else {\r\n        reject(new Error(this.statusText));\r\n      }\r\n    };\r\n    const client = new XMLHttpRequest();\r\n    client.open(\"GET\", url);\r\n    client.onreadystatechange = handler;\r\n    client.responseType = \"json\";\r\n    client.setRequestHeader(\"Accept\", \"application/json\");\r\n    client.send();\r\n\r\n  });\r\n\r\n  return promise;\r\n};\r\n\r\ngetJSON(\"/posts.json\").then(function(json) {\r\n  console.log(\'Contents: \' + json);\r\n}, function(error) {\r\n  console.error(\'出错了\', error);\r\n});\r\n```\r\n\r\n如果调用 resolve 函数和 reject 函数时提供的参数是另一个 Promise 对象，那么就会发生状态传递。函数里的 Promise 对象状态会决定调用该函数的 Promise 对象状态。\r\n\r\n```javascript\r\nconst p1 = new Promise(function (resolve, reject) {\r\n  setTimeout(() => reject(new Error(\'fail\')), 3000)\r\n})\r\n\r\nconst p2 = new Promise(function (resolve, reject) {\r\n  setTimeout(() => resolve(p1), 1000)\r\n})\r\n\r\np2\r\n  .then(result => console.log(result))\r\n  .catch(error => console.log(error))\r\n// Error: fail\r\n```\r\n\r\n上例里，`p1` 的状态在 3 秒之后改变，`p2` 的状态在 1 秒之后改变。由于 `p2` 的状态依赖于 `p1` 的状态，所以 `p2` 后面的 `then` 语句就变成为 `p1` 指定的了，最终 `p1` 状态变为 rejected，触发了 catch 方法指定的回调函数。\r\n\r\n还需要注意的是：立即 resolved 的 Promise 对象是在本轮事件循环的末尾执行，也就是总会晚于本轮循环中的其他同步任务。\r\n\r\n```javascript\r\nnew Promise((resolve, reject) => {\r\n  resolve(1);\r\n  console.log(2);\r\n}).then(r => {\r\n  console.log(r);\r\n});\r\n// 2\r\n// 1\r\n```\r\n\r\n先打印出 2，后打印出 1。因为 resolve(1) 是在本轮事件循环的末尾执行的。\r\n\r\n一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 方法里面，而不应该直接写在 resolve 或reject 的后面。所以，最好在它们前面加上 return 语句，这样就不会有意外。\r\n\r\n```javascript\r\nnew Promise((resolve, reject) => {\r\n  return resolve(1);\r\n  // 后面的语句不会执行\r\n  console.log(2);\r\n})\r\n```\r\n\r\n## Promise.prototype.catch()\r\n\r\n`Promise.prototype.catch` 方法是 `.then(null, rejection)` 的别名，用于指定发生错误时的回调函数。\r\n\r\n下面看个代码例子：\r\n\r\n```javascript\r\ngetJSON(\'/post/1.json\').then(function(post) {\r\n  return getJSON(post.commentURL);\r\n}).then(function(comments) {\r\n  // some code\r\n}).catch(function(error) {\r\n  // 处理前面三个Promise产生的错误\r\n});\r\n```\r\n\r\n上面代码中，一共有三个 Promise 对象：一个由 `getJSON` 产生，两个由 `then` 产生。它们之中任何一个抛出的错误，都会被最后一个 `catch` 捕获。\r\n\r\n建议总是使用 `catch` 方法，而不使用 `then` 方法的第二个参数。\r\n\r\n## Promise.all()\r\n\r\nPromise.all 方法用于将多个 Promise 对象，包装成一个新的 Promise 对象。\r\n\r\n```\r\nconst p = Promise.all([p1, p2, p3]);\r\n```\r\n\r\np 的状态由 p1、p2、p3 决定，分成两种情况。\r\n\r\n（1）只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。\r\n\r\n（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的 Promise 对象的返回值，会传递给 p 的回调函数。\r\n\r\n```\r\n// 生成一个Promise对象的数组\r\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\r\n  return getJSON(\'/post/\' + id + \".json\");\r\n});\r\n\r\nPromise.all(promises).then(function (posts) {\r\n  // ...\r\n}).catch(function(reason){\r\n  // ...\r\n});\r\n```\r\n\r\n上面代码中，`promises` 是包含 6 个 Promise 实例的数组，当这 6 个实例的状态都变成 fulfilled，或者其中有一个变为 rejected，就会调用 `Promise.all` 方法后面的对应回调函数。\r\n\r\n## Promise.race()\r\n\r\nromise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 对象。\r\n\r\n```\r\nconst p = Promise.race([p1, p2, p3]);\r\n```\r\n\r\n上面代码中，只要 p1、p2、p3 之中有一个对象率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数了。\r\n\r\n```\r\nconst p = Promise.race([\r\n  fetch(\'/resource-that-may-take-a-while\'),\r\n  new Promise(function (resolve, reject) {\r\n    setTimeout(() => reject(new Error(\'request timeout\')), 5000)\r\n  })\r\n]);\r\np.then(response => console.log(response));\r\np.catch(error => console.log(error));\r\n```\r\n\r\n上面代码中，如果 5 秒之内 fetch 方法无法返回结果，变量p的状态就会变为  rejected，从而触发 catch 方法指定的回调函数。','2017-12-29 06:54:13','2017-12-29 07:21:15','es6-promise-object'),(579,3,3,'手机的设备独立像素、分辨率和设备像素比到底是什么？','本篇文章介绍移动端网页开发中要遇到的一些概念，理解了这些概念，你就可以快速入门移动端网页开发了。\r\n\r\n*需要注意的是：电脑上并没有设备独立像素的概念，这里也不会做介绍。*\r\n\r\n在这之前，我先介绍一下我用的手机，我用它来说明这些概念。\r\n\r\n## 我有一台坚果 Pro\r\n\r\n[坚果 Pro](https://dn-phphub.qbox.me/uploads/images/201712/30/17319/waZpf3wuMM.jpg) 的一些参数信息如下：\r\n\r\n- 设备独立像素：360 * 640。\r\n- 分辨率：1080 * 1920。\r\n- 设备像素比：3。\r\n\r\n## 设备像素比\r\n\r\n设备像素比，英文名是 Device Pixel Ratio，简称 DPR。但我想说的重点不是这个，我想说：设备像素比 = 分辨率 / 设备独立像素。\r\n\r\n我们可以用 JavaScript 的 `window.devicePixelRatio` 接口获得这个值。\r\n\r\n## 分辨率\r\n\r\n我写了一个网页，里面有一个 div，长 360px，宽 640px。\r\n\r\n我们用手机打开来 [看一下](https://dn-phphub.qbox.me/uploads/images/201712/30/17319/Mnnr6m95uE.jpg) 。\r\n\r\n能看到，div 占据了手机水平宽度的 1/3，手机垂直高度的 1/3（上下 bar 的高度计算在内）。\r\n\r\n这里就得出一个结论：1 CSS 像素等于 1 单位的分辨率。\r\n\r\n> 需要注意的是，我们并没有能够获得手机分辨率的 JavaScript 接口。\r\n\r\n但如果把这样的网页直接在手机上浏览，[看起来就不是很方便](https://dn-phphub.qbox.me/uploads/images/201712/30/17319/wQHlbo1768.jpg)。\r\n\r\n把整个网页都显示在手机小小的一方屏幕上，看起来字太小了，为了看清，我们势必要放大来看。\r\n\r\n如果 [是这样的，就好了](https://dn-phphub.qbox.me/uploads/images/201712/30/17319/TCeXV2iPo2.jpg)。\r\n\r\n为了能做到这样，就要知道设备独立像素了。\r\n\r\n## 设备独立像素\r\n\r\n为了让网页适配移动端，我们通常要在网页的 head 里头加上这样一个 meta 标签。\r\n\r\n```\r\n<meta name=\"viewport\" content=\"width=device-width\">\r\n```\r\n\r\n这样的结果是：1 CSS 像素等于 1 单位的设备独立像素，等于 3  个单位（针对坚果 Pro）的分辨率了。\r\n\r\n此时再打开页面 [查看](https://dn-phphub.qbox.me/uploads/images/201712/30/17319/X9krxIBJQo.jpg)。\r\n\r\n可以看到，div 的宽度刚好充满手机宽度（而在高度上富裕出来的空间是因为有上下 bar 占据手机屏幕高度的原因，否则也是刚好充满屏幕高度的）。\r\n\r\n使用 JavaScript 的 `window.screen.width` 和 `window.screen.height` 就能获得设备独立像素。\r\n\r\n## 图片渲染的问题 \r\n\r\n设置好适配移动端的 meta 标签后，网页里的文字和颜色之类的渲染是没有问题的，但是图片渲染就会有问题。\r\n\r\n举个例子，网页里有一个设定宽 128px、高 85px 的图片\r\n\r\n```\r\nimg {\r\n	width: 128px;\r\n	height: 85px;\r\n}\r\n```\r\n\r\n如果我们直接采用 128px * 85px 大小的图片，那么在 [手机上看就会模糊](https://dn-phphub.qbox.me/uploads/images/201712/30/17319/VBkYVEVjWW.jpg)。\r\n\r\n根本原因是：**图片的 1 像素始终等于 1 单位分辨率**，但是坚果 Pro 却用 3 * 3  的分辨率阵容渲染图片上的每块像素----也就是把图片放大了 3 倍显示。\r\n\r\n所以针对坚果 Pro 这种设备像素比是 3 的手机，网页里插入的图片尺寸总要是网页中设定宽高的 3  倍，才能保证图片在消耗最少带宽的情况下 [保证图片的清晰度](https://dn-phphub.qbox.me/uploads/images/201712/30/17319/l919X0mTgM.jpg)。\r\n\r\n右面图片的尺寸是 384px * 255px，可以看到是清晰的。','2017-12-30 04:34:49','2017-12-30 04:38:06','mobile-devices-independent-pixels-resolution-and-pixel-than-what'),(580,3,3,'Vagrant 常用命令参考','> 参考地址：https://www.vagrantup.com/docs/cli/\r\n\r\n## 添加 box\r\n\r\n根据 `.json` 文件添加 box.\r\n\r\n```\r\nvagrant box add metadata.json\r\n```\r\n\r\nmetadata.json 内容\r\n\r\n```\r\n{\r\n    \"name\": \"laravel/homestead\",\r\n    \"versions\":\r\n    [\r\n        {\r\n            \"version\": \"3.0.0\",\r\n            \"providers\": [\r\n                {\r\n                  \"name\": \"virtualbox\",\r\n                  \"url\": \"homestead-virtualbox-3.0.0.box\"\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n## 删除 box\r\n\r\n删除根据指定版本的 box\r\n\r\n```\r\nvagrant box remove laravel/homestead --box-version 3.0.0\r\n```\r\n \r\n删除指定 box 的所有版本\r\n\r\n```\r\nvagrant box remove laravel/homestead --all\r\n```\r\n\r\n## 查询\r\n\r\n列举当前所有的 box\r\n\r\n```\r\nvagrant box list\r\n```','2018-01-02 02:41:29','2018-01-02 02:42:13','vagrant-commonly-used-command-reference'),(581,3,3,'代码段：chunk data','```\r\nlet data = [...]; // 有很多数据的一维数组\r\nlet poems = [];\r\n\r\n// chunk data.\r\nfor (let i = 0, j = data.length, chunk = 2; i < j; i += chunk) {\r\n  poems.push(data.slice(i , i + chunk));\r\n}\r\n\r\npoems // get chunk data!\r\n```','2018-01-05 06:19:11','2018-01-05 06:19:11','code-the-chunk-of-data'),(582,3,3,'索引：JavaScript 接口的 IE 兼容性','1. `Element.classList`：IE10+。\r\n\r\n2. `Object.getOwnPropertyNames(obj)`：IE9+\r\n\r\n获得对象自身的所有属性（包括不可枚举属性，排除 Symbol 属性）。\r\n\r\n3. `Object.assign(target, ...sources)`：✘\r\n\r\n将源对象自身的所有的可枚举属性复制到目标对象（属于浅复制），复制的属性名包括 String 和 Symbol 类型的。\r\n\r\n4. `for...in` 语句：IE6+\r\n\r\n遍历对象（包括原型链上的）的所有可枚举属性（排除 Symbol 属性）。\r\n\r\n5. `obj.hasOwnProperty(prop)`：✔\r\n\r\n返回一个布尔值，表示对象 `obj` 本身是否包含指定属性 `prop`，包含返回 `true`，否则返回 `false`。改方法源自：`Object.prototype.hasOwnProperty()`。\r\n\r\n6. `Object.keys(obj)`：IE9+\r\n\r\n返回对象 `obj` 自身的所有可遍历属性（名）组成的数组。\r\n\r\n7. `Object.create(proto[, propertiesObject])`：IE9+\r\n\r\n创建一个新对象，指定这个新对象内部的 `[[Prototype]]` 属性（即原型对象）是对象 `proto`。\r\n\r\n8. `Object.getPrototypeOf(obj)`：IE9+\r\n\r\n```\r\nObject.getPrototypeOf({}) === Object.prototype; // true\r\nObject.getPrototypeOf(function () {}) === Function.prototype; // true\r\n```\r\n\r\n9. `Object.setPrototypeOf(obj, prototype)`：IE11\r\n\r\n不建议使用，可用 `Object.create` 代替。\r\n\r\n10. `prototypeObj.isPrototypeOf(object)`：✔\r\n\r\n```javascript\r\nObject.prototype.isPrototypeOf({}); // true\r\nFunction.prototype.isPrototypeOf(function () {}); // true\r\n```\r\n\r\n11. `Object.is(value1, value2)`：✘\r\n\r\n此方法与严格相等运算符 `===` 唯一不同的两点：一是 `+0` 不等于 `-0`，二是 `NaN` 等于自身。\r\n\r\n```\r\n+0 === -0 //true\r\nNaN === NaN // false\r\n\r\nObject.is(+0, -0) // false\r\nObject.is(NaN, NaN) // true\r\n```\r\n\r\n12. `Date.now()`：IE9+\r\n\r\nshim：\r\n\r\n```\r\nif (!Date.now) {\r\n  Date.now = function now() {\r\n    return new Date().getTime();\r\n  };\r\n}\r\n```\r\n\r\n---\r\n\r\nBOM 接口\r\n\r\n1. ` window.pageYOffset`：IE9+\r\n\r\n只读属性。是 `window.scrollY` 的别名。\r\n\r\n2. `window.scrollY`：✘\r\n\r\n3. `window.innerWidth`：IE9+\r\n\r\n视口宽度（包含滚动条）。','2018-01-05 06:58:09','2018-01-10 09:23:25','index-javascript-interface-ie-compatibility'),(583,7,7,'Redis安装','##安装环境\r\nCentos 7.2\r\n\r\n##安装命令\r\n```\r\nsudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\r\nsudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\r\nsudo yum install epel-release\r\nsudo yum install redis\r\nsystemctl start redis.service（启动redis）\r\nsudo systemctl enable redis.service（开机自动自动）\r\n```','2018-01-05 07:44:18','2018-01-05 08:08:29','redis-installation'),(584,3,3,'JavaScript 类型转换','> 翻译、演绎自：http://javascript.info/type-conversions\r\n\r\n多数时间，运算符和函数会自动将一个值转换到正确的类型，这称为“类型转换”。\r\n\r\n例如：`alert` 会自动将任何类型的值转化为字符串显示，数学运算符则将值转换为数字。\r\n\r\nECMAScript 内部定义了一些“抽象操作”，定义了各种值类型的转换规则，包括：`ToNumber`、`ToBoolean`、`ToString` 和 `ToPrimitive`。\r\n\r\n`ToNumber`、`ToBoolean` 和`ToString` 是针对一种基本类型值转换为另一种基本类型值，定义的转换规则；`ToPrimitive` 是针对对象类型转换为一种基本类型值，定义的转换规则，而且在必要时从对象类型值转换出来的基本类型值还要在进行一次转换到另一个基本类型值的换算。\r\n\r\n> 这节内容并不介绍对象类型转换（即 `ToPrimitive`），而是介绍基本类型值的转换规则。关于对象类型转换，会在《将对象转换为基本类型值》一文中介绍。\r\n\r\n## ToString\r\n\r\n当一次运算的期望值是字符串的时候，就会发生 `ToString` 转换。\r\n\r\n例如：用 `alert(value)` 显示的 `value`，最终就会转换为字符串显示。\r\n\r\n当然，我们也可以调用 `String(value)` 函数显式将 `value` 转换为字符串。\r\n\r\n```\r\nlet value = true;\r\nalert(typeof value); // boolean\r\n\r\nvalue = String(value); // 现在 value 的值是字符串 \"true\"\r\nalert(typeof value); // string\r\n```\r\n\r\n`ToString` 的转化规则比较符合直觉：\r\n\r\n| 值 | 转换为…… |\r\n| -------- | -------- |\r\n| null | \"null\" |\r\n| undefined | \"undefined\" |\r\n| true 和 false | \"true\" 和 \"false\" |\r\n| Symbol() 和 Symbol(\'foo\') | \"Symbol()\" 和 \"Symbol(foo)\" |\r\n| 数字 | 转换为对应的字符串形式。例如：0 转换为 \"0\" |\r\n\r\n## ToNumber\r\n\r\n数字转换会自动发生于数学函数和表达式中。\r\n\r\n例如：除号 `/` 两边的非数字类型值就会自动转换为数字。\r\n\r\n```\r\nconsole.log(\'6\' / \'2\'); // 3\r\nconsole.log(typeof (\'6\' / \'2\')); // number\r\n```\r\n\r\n除了 `/`，`-`、`*` 和 `%` 运算都会将操作数自动转换为数字。\r\n\r\n当然，如果字符串不是一个可以有效转为数字的值，结果就是 `NaN`。\r\n\r\n```\r\nlet age = Number(\'an arbitrary string instead of a number\');\r\nconsole.log(age); // NaN\r\n```\r\n\r\n总结一下数字转换规则：\r\n\r\n| 值 | 转换为…… |\r\n| -------- | -------- |\r\n| null | 0 |\r\n| undefined | NaN |\r\n| true 和 false | 1 和 0 |\r\n| Symbol值 | NaN |\r\n| 字符串 | 首先去除字符串两边的空格。如果剩下的是空字符串，结果就是 `0`；如果字符串是一个可以有效转为数字的值，就转为对应数字，否则结果就是 `NaN`。 |\r\n\r\n例子：\r\n\r\n```\r\nconsole.log(Number(\' 123 \')); // 123\r\nconsole.log(Number(\'123z\')); // NaN\r\nconsole.log(true); // 1\r\nconsole.log(false); // 0\r\n```\r\n\r\n**`+` 运算符**\r\n\r\n几乎所有的数学运算符都会将操作数转换为数字进行运算。\r\n\r\n但 `+` 运算符有一些例外：如果 `+` 运算符的一边是字符串，那么另一边的值也会自动转换为字符串再相加。\r\n\r\n```\r\nconsole.log(1 + \'2\'); // \"12\"\r\nconsole.log(\'1\' + 2); // \"12\"\r\n```\r\n\r\n当然，这种情况只发生在操作数之一是字符串；如果两边都是非字符串的情况，那么就都转换为数字，然后进行加法运算。\r\n\r\n## ToBoolean\r\n\r\n布尔值转换是最简单的了，它发生在逻辑运算中：\r\n\r\n- if(..)\r\n- for(..;..;..)\r\n- while(..) 和 do..while(..)\r\n- ?:\r\n- || 和 &&\r\n\r\n但是也可以通过手动调用 `Boolean(value)` 实现。\r\n\r\n转换规则如下：\r\n\r\n| 值 | 转换为…… |\r\n| -------- | -------- |\r\n| 0, null, undefined, NaN, \'\' | false |\r\n| 其它值 | true |\r\n\r\n例如：\r\n\r\n```\r\nconsole.log(Boolean(1)); // true\r\nconsole.log(Boolean(0)); // false\r\n\r\nconsole.log(Boolean(\'Hello\')); // true\r\nconsole.log(Boolean(\'\')); // false\r\n```\r\n\r\n**需要注意的是：`\"0\"` 会转换为 `true`。**\r\n\r\n一些编程语言（比如 PHP）会把 `\"0\"` 作为 `false` 对待。但在 JavaScript 中，所有非空字符串都是 `true`。\r\n\r\n```\r\nconsole.log(Boolean(\'0\')); // true\r\nconsole.log(Boolean(\' \')); // true\r\n```\r\n\r\n## 总结\r\n\r\n这里有 3 个最为常用的类型转换：`ToString`、`ToNumber` 和 `ToBoolean`。\r\n\r\n**`ToString`**：当做输出操作（如 `alert`），或显式调用 `String(value)` 发生。基本类型值转换为字符串是比较符合直觉的。\r\n\r\n转换规则如下：\r\n\r\n| 值 | 转换为…… |\r\n| -------- | -------- |\r\n| null | \"null\" |\r\n| undefined | \"undefined\" |\r\n| true 和 false | \"true\" 和 \"false\" |\r\n| Symbol() 和 Symbol(\'foo\') | \"Symbol()\" 和 \"Symbol(foo)\" |\r\n| 数字 | 转换为对应的字符串形式。例如：0 转换为 \"0\" |\r\n\r\n**`ToNumber`**：发生数学运算，或者显式调用 `String(value)` 的情况。\r\n\r\n转换规则如下：\r\n\r\n| 值 | 转换为…… |\r\n| -------- | -------- |\r\n| null | 0 |\r\n| undefined | NaN |\r\n| true 和 false | 1 和 0 |\r\n| Symbol值 | NaN |\r\n| 字符串 | 首先去除字符串两边的空格。如果剩下的是空字符串，结果就是 `0`；如果字符串是一个可以有效转为数字的值，就转为对应数字，否则结果就是 `NaN`。 |\r\n\r\n**`ToBoolean`**：转换规则是最简单的，它发生在逻辑运算，或者显式调用 `Boolean(value)` 的地方。\r\n\r\n遵循以下规则：\r\n\r\n| 值 | 转换为…… |\r\n| -------- | -------- |\r\n| 0, null, undefined, NaN, \'\' | false |\r\n| 其它值 | true |\r\n\r\n大多数的规则都是容易理解和记忆的。最经常记错是这两个点：\r\n\r\n- `undefined` 转换为数字结果是 `NaN`，而不是 `0`。\r\n- `\"0\"` 和仅包含空格的字符串（像 `\" \"`）转换为布尔值的结果都是 `true`，而不是 `false`。\r\n\r\n对象转换在这里没有提及，会在下一篇《将对象转换为基本类型值》一文中介绍，敬请期待……','2018-01-06 03:46:33','2018-01-06 03:46:33','javascript-type-conversion'),(585,3,3,'Bulma 学习笔记：布局元素 Tile','使用 Tile 元素可以轻松实现像 Metro 这样的网格布局效果。\r\n\r\nTile 元素用 `.tile` 类修饰。最基本的的 Tile 布局包含 3 个元素：`.tile.is-ancestor`、`.tile.is-parent` 和 `.tile.is-child`。\r\n\r\n```\r\n.tile.is-ancestor\r\n	[.tile]\r\n		.tile.is-parent\r\n			.tile.is-child\r\n```\r\n\r\n`.is-child` 必须是 `.is-parent` 的直接子元素。`.is-parent` 不必须是 `.is-ancestor` 的子元素，也可以是单纯 `.tile` 的直接子元素。\r\n\r\n对应 HTML 结构如下：\r\n\r\n```\r\n<div class=\"tile is-ancestor\">\r\n	<div class=\"tile is-parent\">\r\n		<div class=\"tile is-child box\"></div>\r\n	</div>\r\n</div>\r\n```\r\n\r\n一般 Tile 元素的内容都是写在 `.is-child` 里的，这里为了能够看到效果，我给它加了 `.box` 样式（还可以加 `.card` 等样式）。\r\n\r\n## 水平 & 垂直排列\r\n\r\n如果要水平排列连个 Tile，可以这样做。\r\n\r\n```\r\n.tile.is-ancestor\r\n	.tile.is-parent\r\n		.tile.is-child\r\n	.tile.is-parent\r\n		.tile.is-child\r\n```\r\n\r\n对应 HTML 结构如下：\r\n\r\n```\r\n<div class=\"tile is-ancestor\">\r\n	<div class=\"tile is-parent\">\r\n		<div class=\"tile is-child box\"></div>\r\n	</div>\r\n	<div class=\"tile is-parent\">\r\n		<div class=\"tile is-child box\"></div>\r\n	</div>	\r\n</div>\r\n```\r\n\r\n这里之所以又启用一个新的 `.is-parent` 隔开 `.is-child` 是为了在水平方向上隔开两个 Child Tile----默认 Child Tile 之间是没有水平间隔的。\r\n\r\n可以看到，默认 Child Tile 元素是水平排列的，如果需要垂直排列的话，需要给 Parent Tile 添加 **`.is-vertical`** 修饰符。\r\n\r\n```\r\n.tile.is-ancestor\r\n	.tile.is-parent.is-vertical\r\n		.tile.is-child\r\n		.tile.is-child\r\n```\r\n\r\n对应的 HTML 结构如下：\r\n\r\n```\r\n<div class=\"container\">\r\n	<div class=\"tile is-ancestor\">\r\n		<div class=\"tile is-parent is-vertical\">\r\n			<div class=\"tile is-child box\"></div>\r\n			<div class=\"tile is-child box\"></div>\r\n		</div>\r\n	</div>\r\n</div>\r\n```\r\n\r\n这里没有启用一个新的 `.is-parent` 来隔开两个 Child Tile 是因为垂直排列的 Tile 默认是有间隔的。\r\n\r\n## 水平排列大小\r\n\r\n默认多个 Tile 在水平上排列时，是等宽的。为了实现能够定制 Tile 在水平方向上占据的大小，Bulma 提供了从 `.is-1` 至 `.is-12` 的修饰符：`.is-1` 占据宽度的 1/12，`.is-12` 占据整个宽度。\r\n\r\n以左 `.is-8` 右 `is-4` 为例。对应 HTML 结构如下：\r\n\r\n```\r\n<div class=\"container\">\r\n	<div class=\"tile is-ancestor\">\r\n		<div class=\"tile is-parent is-8\">\r\n			<div class=\"tile is-child box\"></div>\r\n		</div>\r\n		<div class=\"tile is-parent\">\r\n			<div class=\"tile is-child box\"></div>\r\n		</div>\r\n	</div>\r\n</div>\r\n```\r\n\r\n第二个 Parent Tile 没有显式添加 `.is-4`，是因为第一个 Parent Tile 已经指定为 `.is-8` 了，而且水平方向只有这两个 Tile，自然就占据剩下 `.is-4` 的宽度了。\r\n\r\n## 深层次 Tile 嵌套\r\n\r\n之前我们学习的都是简单的父子嵌套结构。 `.tile.is-parent` 下直接就是 `.tile.is-child`，如果 Child Tile 需要垂直排列，那么给 Parent Tile 添加 `.is-vertical` 修饰类就 OK 了。\r\n\r\n那么现在问题来了，如果这里的 Child Tile 不再是单纯 `.tile.is-child` 一个 HTML 元素，而是一个包含两个 Tile 怎么破？\r\n\r\n答案是：首先去掉 Child Tile 的 `.is-child` 修饰类，然后去掉父元素的 `.is-parent` 修饰类。根据情况，为 Child Tile 添加或者不添加 `.is-parent`：添加 `.is-parent` 就是一个崭新的 Parent Tile；不添加就是另一个\"Ancestor Tile\"。当然，Child Tile 的兄弟元素也要按照这个规则选择添加或者不添加 `.is-parent` 修饰类（有的话，就不做任何操作）。','2018-01-06 07:56:29','2018-01-06 07:56:29','bulma-learning-notes-tile-layout-element'),(586,3,3,'JavaScript 中将对象转换到基本类型值','> 翻译、演绎自：http://javascript.info/object-toprimitive\r\n\r\n将两个对象在一起相加（`obj1 + obj2`）、相减（`obj1 - obj2`）或者用 `alert` 弹出（`alert(obj)`），会是什么结果呢？\r\n\r\n在对象里，为了实现对象到基本类型值的转换，提供了几个特别的方法。\r\n\r\n在《JavaScript 类型转换》一节，我们学习了将基本类型值转换成数字、字符串和布尔值的规则。现在我们就来讲将对象转换为基本类型值的规则。\r\n\r\n对于对象运算，没有到布尔值的转换（所有对象转换为布尔值，都是 `true`）----最终对象不是转换成字符串，就是转换成数字。\r\n\r\n对象转换成数字的情况发生在对象相减或者应用了数学函数的时候。拿 `Date` 举例，`date1 - date2` 就得到两个时间的（时间戳）差。\r\n\r\n对象转换成字符串的情况发生在输出（`alert(obj)`）或者其他类似的场景下。\r\n\r\n## ToPrimitive\r\n\r\n当一个对象处于一个期望值是基本类型值的场景下，就会发生对象转换为基本类型值。这里会用到 `ToPrimitive` 算法（[规格][spec]）。\r\n\r\n这个算法允许我们自定义对象的转换规则，但这要依赖环境，用所谓的 `hint` 表示，它可能的取值有 3 个。\r\n\r\n**`\"string\"`**\r\n\r\n当操作的期望值是字符串的时候。这样的操作包括输出对象或者将对象作为属性使用。\r\n\r\n```\r\nlet obj = {},\r\n	anotherObj = {};\r\n\r\n// 输出操作\r\nalert(obj); // [object Object]\r\n\r\n// 将对象作为属性名使用\r\nanotherObj[obj] = 123;\r\n// 等同于\r\nanotherObj[\'[object Object]\'] = 123;\r\n```\r\n\r\n**`\"number\"`**\r\n\r\n当操作的期望值是数字的时候。比如数学运算：\r\n\r\n```\r\n// 显式转换\r\nlet num = Number(obj);\r\n\r\n// 数学运算（除了二元加号）\r\nlet n = +obj; // 一元加号\r\nlet delta = date1 - date2;\r\n\r\n// 大于/小于比较\r\nlet greater = user1 > user2;\r\n```\r\n\r\n**`\"default\"`**\r\n\r\n适应于运算结果“不确定”的操作中。\r\n\r\n比如：二元加号既可以用来连接两个字符串，也可以用来把两个数字相加，二元加号也可以用在对象上。还有当一个对象使用 `==` 与字符串、数字、布尔值或者 Symbol 值比较的时候。\r\n\r\n```\r\n// 二元加号\r\nlet total = car1 + car2;\r\n\r\n// obj == string/number/boolean/symbol\r\nif (user == 1) {}\r\n```\r\n\r\n大于/小于运算符 `<>` 也能作用在字符串和数字。但是由于历史原因，它是 `\"number\"` hint 环境，而不是 `\"default\"`。\r\n\r\n在实践中，所有内置对象（除了 `Date`）对于 `\"default\"` hint 和 `\"number\"` hint 的处理，都遵循同一套转换规则。\r\n\r\n请注意，`hint` 可能的取值共 3 个，没有 `\"boolean\"` hint（所有对象转换为布尔值都为 `true`）。如果单就几乎所有内置对象对于 `\"default\"` hint 和 `\"number\"` hint 的处理遵循同一套规则来看的话，hint 相当于只有两种可能取值。\r\n\r\n**对象转换过程中，会尝试查找和调用的方法有 3 个：**\r\n\r\n1. 如果 `obj[Symbol.toPrimitive](hint)` 方法存在，就调用。\r\n2. 否则，如果 hint 是 `\"string\"`\r\n	- 不论是否存在，尝试调用 `obj.toString()` 和 `obj.valueOf()`。\r\n3. 否则，如果 hint 是 `number` 或者 `default`\r\n	- 不论是否存在，尝试调用 `obj.valueOf()` 和 `obj.toString()`。\r\n\r\n## Symbol.toPrimitive\r\n\r\nJavaScript 有一个预先定义的 Symbol 值 `Symbol.toPrimitive`，定义对象发生转换时调用的方法名。\r\n\r\n```\r\nobj[Symbol.toPrimitive] = function (hint) {\r\n	// 返回一个基本类型值，否则报错。\r\n	// hint 的值取 \"string\"、\"number\" 和 `default` 之一\r\n};\r\n```\r\n\r\n下面我们定义一个对象 `user` 实现这个方法：\r\n\r\n```\r\nlet user = {\r\n	name: \'John\',\r\n	money: 1000,\r\n	\r\n	[Symbol.toPrimitive](hint) {\r\n		alert(`hint: ${hint}`);\r\n		return hint == \'string\' ? `{name: \"${this.name}\"}` : this.money;\r\n	}\r\n};\r\n\r\nalert(user); // hint: string -> {name: \"John\"}\r\nalert(+user); // hint: number -> 1000\r\nalert(user + 500); // hint: default -> 1500\r\n```\r\n\r\n可以看到，当 `user` 对象发生转换时，`user[Symbol.toPrimitive]` 处理了所有可能的 3 种情况。\r\n\r\n## toString/valueOf\r\n\r\n在 ES6 引入 Symbol 之前，对象转换依赖的是 `toString` 和 `valueOf` 方法，它们会按照这样的顺序调用。\r\n\r\n- 对于 hint 等于 `\"string\"` 的情况：`toString -> valueOf`。\r\n- 否则（即 hint 等于 `\"number\"` 和 `\"default\"` 的情况）：`valueOf -> toString`。\r\n\r\n*需要注意的是：如果先调用的方法返回了一个基本类型值，就不再调用后面的方法。例如，对于 hint 等于 `\"string\"` 的情况，如果先调用的 `toString` 方法返回了一个基本类型值，那么 `valueOf` 就不再被调用。*\r\n\r\n```\r\nlet user = {\r\n  name: \"John\",\r\n  money: 1000,\r\n\r\n  // 针对 hint 等于 \"string\" 的情况\r\n  toString() {\r\n    return `{name: \"${this.name}\"}`;\r\n  },\r\n\r\n  // 针对 hint 等于 \"number\" 或 \"default\" 的情况\r\n  valueOf() {\r\n    return this.money;\r\n  }\r\n\r\n};\r\n\r\n\r\nalert(user); //（ 调用 toString ）{name: \"John\"}\r\nalert(+user); // （调用 valueOf ）1000\r\nalert(user + 500); //（调用  valueOf）1500\r\n```\r\n\r\n如果我们不提供 `valueOf` 方法，那么 `toString` 方法就成为对象转换的唯一通道了。\r\n\r\n```\r\nlet user = {\r\n  name: \"John\",\r\n\r\n  toString() {\r\n    return this.name;\r\n  }\r\n};\r\n\r\nalert(user); // （调用 toString）\"John\"\r\nalert(user + 500); // （还是调用 toString）\"John500\"\r\n```\r\n\r\n## ToPrimitive 和 ToString/ToNumber\r\n\r\n值得注意的是，并不要求 `toString()` 必须返回一个字符串，针对 hint 是 `\"number\"` 的情况，`Symbol.toPrimitive` 方法必须返回一个数字。\r\n\r\n**唯一的强制要求是：`toString()` 和 `Symbol.toPrimitive` 必须返回一个基本类型值。**\r\n\r\n例如：\r\n\r\n- 数学操作（除了两元 `+` 操作符）会触发 `ToNumber` 转换：\r\n\r\n```\r\nlet obj = {\r\n  toString() { // 在其他方法缺席的情况下，toString 处理所有情况下的转换\r\n    return \"2\";\r\n  }\r\n};\r\n\r\nconsole.log(obj * 2); // 4\r\n```\r\n\r\n上面的输出结果是 4，转换步骤如下：`\"2\" * 2 -> 2 * 2 -> 4`。\r\n\r\n- 当两元 `+` 操作符中的一个操作数是字符串，执行的是字符串连接运算；否则触发 `ToNumber` 转换：\r\n\r\n字符串连接运算：\r\n\r\n```\r\nlet obj = {\r\n  toString() {\r\n    return \"2\";\r\n  }\r\n};\r\n\r\nalert(obj + 2); // \"22\"\r\n```\r\n\r\n`obj` 对象转换结果是 `\"2\"`，`\"2\" + 2` 结果就是 `\"22\"` 了。\r\n\r\n `ToNumber` 转换：\r\n \r\n```\r\nlet obj = {\r\n  toString() {\r\n    return true;\r\n  }\r\n};\r\n\r\nalert(obj + 2); // 3\r\n```\r\n\r\n`obj` 对象转换结果是 `true`，`true + 2` 触发的是 `ToNumber` 转换，而不是字符串连接。`true` 转换成数字是 `1`，`1 + 2` 就是 `3` 了。\r\n\r\n注意，`toString` 和 `valueOf` 方法 **应该 ** 返回一个基本类型值，但由于历史原因，如果返回了一个对象，也不会报错，而是会忽略这个方法（就像这个方法不存在一样）。\r\n\r\n与此相反，`Symbol.toPrimitive` **必须** 返回一个基本类型值，否则会报错。\r\n\r\n## 总结\r\n\r\n对象到基本类型值的转换是自动调用内置的几个方法实现的。一共有 3 种场景（hint）：\r\n\r\n- `\"string\"`\r\n- `\"number\"`\r\n- `\"default\"`\r\n\r\n在规范中明确定义了在每一个 hint 场景下，转换过程会调用的内置方法的顺序，其算法如下：\r\n\r\n1. 如果 `obj[Symbol.toPrimitive](hint)` 方法存在，就调用。\r\n2. 否则，如果 hint 是 `\"string\"`\r\n	- 不论是否存在，尝试调用 `obj.toString()` 和 `obj.valueOf()`。\r\n3. 否则，如果 hint 是 `number` 或者 `default`\r\n	- 不论是否存在，尝试调用 `obj.valueOf()` 和 `obj.toString()`。\r\n\r\n在实践中，通常仅实现 `obj.toString()` 方法作为所有转换场景的唯一处理通道就足够了。\r\n\r\n\r\n[spec]: https://tc39.github.io/ecma262/#sec-toprimitive','2018-01-06 10:04:03','2018-01-08 03:44:08','javascript-objects-in-the-transformation-of-the-basic-type-value'),(587,7,7,'Nginx 安装（yum）','在 CentOS 7 中，直接使用 yum 安装 Nignx 会提示无下载源。因此，需要添加 Nginx 的下载源到 yum：\r\n\r\n```\r\nsudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\r\n```\r\n\r\n指定了下载源后，就可以使用 yum 命令来安装 Nginx 了：\r\n```\r\nsudo yum install -y nginx\r\n```\r\n\r\n安装完成的 Nginx 并不会立刻启动，需要我们手动执行命令来开启它:\r\n\r\n```\r\nsudo systemctl start nginx.service\r\n```\r\n\r\n还可以输入以下命令，让 Nginx 可以随系统自动启动：\r\n\r\n```\r\nsudo systemctl enable nginx\r\n```\r\n\r\n---\r\n\r\n接下来打开浏览器，访问本地地址 http://localhost 就可以看到 Nginx 的欢迎页面了~\r\n\r\n**相关补充：**\r\n\r\n开启 Nginx\r\n\r\n```\r\nservice nginx start\r\n```\r\n\r\n 停止 Nginx\r\n \r\n```\r\nservice nginx stop\r\n```\r\n重启 Nginx\r\n\r\n```\r\nservice nginx restart\r\n```\r\n\r\n查看 Nginx 状态\r\n\r\n```\r\nservice nginx status\r\n```\r\n\r\nNginx 的默认站点根目录为\r\n\r\n```\r\n/usr/share/nginx/html/\r\n```\r\n\r\n默认站点配置在\r\n\r\n```\r\n/etc/nginx/conf.d/default.conf\r\n```\r\nNginx 主配置如下\r\n\r\n```\r\n/etc/nginx/nginx.conf\r\n```','2018-01-08 07:23:54','2018-01-11 08:41:20','nginx-installation-yum'),(588,3,3,'Ubuntu 16.04  下安装 Laravel 项目的依赖环境','环境要求：\r\n\r\n- 系统：Ubuntu 16.04 LTS\r\n- PHP： >= 7.0\r\n- Nginx： >= 1.10.3\r\n- MySQL： >= 5.7\r\n\r\n## 安装 Nginx\r\n\r\n```\r\n$ sudo apt install nginx\r\n```\r\n\r\n查看是否开启：\r\n\r\n```\r\n$ sudo systemctl status nginx\r\n\r\nActive: active (running) since Mon 2018-01-08 18:43:12 PST; 5min ago\r\n```\r\n\r\n此时访问地址 `http://192.168.1.225/` 就能看到 Nginx 的欢迎界面，表示 Nginx 安装成功。\r\n\r\n> Nginx 默认 Web 目录在 `/var/www/html`；配置文件在 `/etc/nginx` 目录下。 \r\n\r\n## 安装 PHP\r\n\r\n```\r\n$ sudo apt install php7.0\r\n```\r\n\r\n检查是否正确输出版本号：\r\n\r\n```\r\n$ php -v\r\n\r\nPHP 7.0.22-0ubuntu0.16.04.1 (cli) ( NTS )\r\n```\r\n\r\n安装依赖包：\r\n\r\n```\r\n$ sudo apt install php7.0-fpm php7.0-cli php7.0-common php7.0-mbstring php7.0-gd php7.0-intl php7.0-xml php7.0-mysql php7.0-mcrypt php7.0-zip\r\n```\r\n\r\n查看所有已安装依赖包：\r\n\r\n```\r\n$ php -m\r\n```\r\n\r\n## 安装 Composer\r\n\r\nComposer 是 PHP 包管理工具。在安装之前，先下载 `curl`。\r\n\r\n```\r\n$ sudo apt install curl\r\n```\r\n\r\n然后，安装 Composer。\r\n\r\n```\r\n$ curl -sS https://getcomposer.org/installer | php\r\n$ mv composer.phar /usr/local/bin/composer\r\n```\r\n\r\n现在即可使用全局命令 `composer` 了。\r\n\r\n```\r\n$ composer\r\n\r\n   ______\r\n  / ____/___  ____ ___  ____  ____  ________  _____\r\n / /   / __ \\/ __ `__ \\/ __ \\/ __ \\/ ___/ _ \\/ ___/\r\n/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /\r\n\\____/\\____/_/ /_/ /_/ .___/\\____/____/\\___/_/\r\n                    /_/\r\nComposer version 1.6.2 2018-01-05 15:28:41\r\n```\r\n\r\n## 安装 MySQL\r\n\r\n```\r\n$ sudo apt install mysql-server\r\n```\r\n\r\n安装过程中为 root 用户设置密码，按下回车键，即可完成安装。\r\n\r\n连接 MySQL：\r\n\r\n```\r\n$ mysql -uroot -p\r\nEnter password:\r\n\r\nServer version: 5.7.20-0ubuntu0.16.04.1 (Ubuntu)\r\n\r\nmysql> \r\n```\r\n\r\n## 部署网站\r\n\r\n下面介绍运维平台部署流程。\r\n\r\n下载辅助工具 `rz`：\r\n\r\n```\r\n$ sudo apt install lrzsz\r\n$ sudo apt install unzip\r\n```\r\n\r\n将本地项目上传到服务器：\r\n\r\n```\r\n$ rz\r\n```\r\n\r\n将项目解压到 `yunwei` 目录。\r\n\r\n```\r\n$ sudo unzip yunwei.zip -d yunwei\r\n```\r\n\r\n**还原数据库**：\r\n\r\n```\r\n$ sudo mysql -u root -p < yunwei/yunwei_180109.sql \r\n```\r\n\r\n移动项目到 `/var/www/yunwei`。\r\n\r\n```\r\n$ sudo mv yunwei /var/www/yunwei\r\n$ cd /var/www/yunwei\r\n```\r\n\r\n进入项目，给予一些文件权限：\r\n\r\n```\r\n$ cd /var/www/yunwei\r\n$ sudo chmod -R 777 storage\r\n$ sudo chmod -R 777 bootstrap/cache\r\n$ php artisan storage:link\r\n```\r\n\r\n**添加网站**：\r\n\r\n编辑 Nginx  配置文件：\r\n\r\n```\r\n$ sudo vim /etc/nginx/sites-available/default\r\n```\r\n\r\n**将我们的网站挂载到 8080 端口**：\r\n\r\n```\r\nserver {\r\n        listen 8080;\r\n        listen [::]:8080;\r\n\r\n        root /var/www/yunwei/public;\r\n\r\n        # Add index.php to the list if you are using PHP\r\n        index index.php index.html index.htm index.nginx-debian.html;\r\n\r\n        server_name _;\r\n\r\n        location / {\r\n                try_files $uri $uri/ /index.php?$query_string;\r\n        }\r\n\r\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\r\n        #\r\n        location ~ \\.php$ {\r\n               include snippets/fastcgi-php.conf;\r\n\r\n               # With php7.0-fpm:\r\n               fastcgi_pass unix:/run/php/php7.0-fpm.sock;\r\n        }\r\n}\r\n```\r\n\r\n重启 Nginx 服务器：\r\n\r\n```\r\n$ sudo systemctl restart nginx\r\n```\r\n\r\n至此，网站部署完毕！\r\n\r\n访问 192.168.1.225:8080 即可看到网站了。\r\n\r\n---\r\n\r\n首先，自报家门：\r\n\r\n```\r\n$ lsb_release -a\r\n```\r\n\r\n更新系统：\r\n\r\n```\r\n$ apt update && apt upgrade\r\n```\r\n\r\n下载 PHP\r\n\r\n```\r\n$ sudo apt-get install php\r\n$ php -v\r\n\r\n$ sudo apt-get install php7.0-mbstring\r\n$ sudo apt-get install php7.0-xml\r\n$ sudo apt-get install php7.0-zip\r\n$ sudo apt-get install php7.0-mysql\r\n```\r\n\r\n查看 PHP 的所有模块\r\n\r\n```\r\n$ php -m\r\n```\r\n\r\n> 查找与 PHP 7.0 相关模块，使用 `apt-cache pkgnames | grep php7.0` 或者 `apt-cache search php7.0\r\n`。\r\n\r\n修改配置：\r\n\r\n```\r\n$ sudo vim /etc/php/7.0/cli/php.ini \r\n```\r\n\r\n启用（我们没使用 CGI，而是 fpm，所以这一步可以忽略）：\r\n\r\n```\r\n$ cgi.fix_pathinfo=0\r\n```\r\n\r\n下个辅助命令行工具 CURL\r\n\r\n```\r\n$ sudo apt-get install curl\r\n```\r\n\r\n安装 Composer\r\n\r\n```\r\n$ curl -sS https://getcomposer.org/installer | php\r\n$ mv composer.phar /usr/local/bin/composer\r\n$ composer\r\n```\r\n\r\n安装 Laravel 项目：\r\n\r\n```\r\n$ composer create-project --prefer-dist laravel/laravel blog \"5.5.*\"\r\n```\r\n\r\n> 如果报错“Do not run Composer as root/super user! See https://getcomposer.org/root for details\r\n”，则需要我们切换到普通用户账号去执行，而不是在 root 账号之中。\r\n\r\n添加用户\r\n\r\n```\r\n$ sudo adduser zhangb\r\n\r\n# 将 zhangb 添加到用户组 sudo \r\n$ usermod -aG sudo zhangb\r\n\r\n# 从 root 切换到 zhangb\r\n$ sudo zhangb\r\n```\r\n\r\n下载 Ngnix：\r\n\r\n```\r\n$ sudo apt install nginx\r\n```\r\n\r\n查看 Ngnix 服务器状态：\r\n\r\n```\r\n$ systemctl status nginx\r\n```\r\n\r\n打开的。下面直接访问 80 端口，就能看看到 Nginx 欢迎页面了。\r\n\r\n管理 Nginx\r\n\r\n```\r\n$ sudo systemctl stop nginx\r\n$ sudo systemctl start nginx\r\n$ sudo systemctl restart nginx\r\n```\r\n\r\nNgnix 默认安装的文件和目录信息如下：\r\n\r\nGet Familiar with Important Nginx Files and Directories\r\n\r\nNow that you know how to manage the service itself, you should take a few minutes to familiarize yourself with a few important directories and files.\r\n\r\nContent\r\n\r\n`/var/www/html`: The actual web content, which by default only consists of the default Nginx page you saw earlier, is served out of the /var/www/html directory. This can be changed by altering Nginx configuration files.\r\n\r\nServer Configuration\r\n\r\n- `/etc/nginx`: The Nginx configuration directory. All of the Nginx configuration files reside here.\r\n- `/etc/nginx/nginx.conf`: The main Nginx configuration file. This can be modified to make changes to the Nginx global configuration.\r\n- `/etc/nginx/sites-available/`: The directory where per-site \"server blocks\" can be stored. Nginx will not use the configuration files found in this directory unless they are linked to the sites-enabled directory (see below). Typically, all server block configuration is done in this directory, and then enabled by linking to the other directory.\r\n- `/etc/nginx/sites-enabled/`: The directory where enabled per-site \"server blocks\" are stored. Typically, these are created by linking to configuration files found in the sites-available directory.\r\n- `/etc/nginx/snippets`: This directory contains configuration fragments that can be included elsewhere in the Nginx configuration. Potentially repeatable configuration segments are good candidates for refactoring into snippets.\r\n\r\n在 Ngnix 中加入 Laravel 网站：\r\n\r\n```\r\n$ vim /etc/nginx/sites-available/default \r\n```\r\n\r\n修改配置：\r\n\r\n```\r\n# Add index.php to the list if you are using PHP\r\nindex index.html index.htm index.nginx-debian.html;\r\n\r\n改为\r\n\r\n# Add index.php to the list if you are using PHP\r\nindex.php  index index.html index.htm index.nginx-debian.html;\r\n```\r\n\r\n将注释打开\r\n\r\n```\r\nlocation ~ \\.php$ {\r\n	include snippets/fastcgi-php.conf;\r\n\r\n	# With php7.0-cgi alone:\r\n	# fastcgi_pass 127.0.0.1:9000;\r\n	# With php7.0-fpm:\r\n	fastcgi_pass unix:/run/php/php7.0-fpm.sock;\r\n}\r\n```\r\n\r\n下面部署 Laravel 项目\r\n\r\n```\r\n$ pwd\r\n/home/zhangb\r\n\r\n$ sudo composer create-project --prefer-dist laravel/laravel blog \"5.5.*\"\r\n$ sudo mv blog /var/www/html/blog\r\n\r\n$ sudo chmod -R 777 storage\r\n$ sudo chmod -R 777 bootstrap/cache\r\n```\r\n\r\n安装 MySQL\r\n\r\n```\r\n$ sudo apt install mysql-server\r\n\r\nCREATE DATABASE `blog` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\r\n```\r\n\r\n参考链接：\r\n\r\n1. [How To Create a Sudo User on Ubuntu][link1], by Mitchell Anicas.\r\n2. [Install Laravel on Ubuntu 16.04][link2], from rosehosting.com.\r\n3. [How to install Laravel 5.4 on Ubuntu 16.04 from scratch quickly][link3], by Renan Gabriel.\r\n4. [How To Install Nginx on Ubuntu 16.04][link4], by Justin Ellingwood.\r\n5. [How To Deploy a Laravel Application with Nginx on Ubuntu 16.04][link5], by Mateusz Papiernik.\r\n6. [How to Install and Configure PHP 7.0 or PHP 7.1 on Ubuntu 16.04][link6], from vultr.com.\r\n7. [Laravel 5.4 Migration Error][link7], from stackoverflow.com.\r\n\r\n[link1]: https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-ubuntu-quickstart\r\n[link2]: https://www.rosehosting.com/blog/install-laravel-on-ubuntu-16-04/\r\n[link3]: https://medium.com/@rgdev/how-to-install-laravel-5-4-on-ubuntu-16-04-from-scratch-quickly-29375e18e7ca\r\n[link4]: https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-16-04\r\n[link5]: https://www.digitalocean.com/community/tutorials/how-to-deploy-a-laravel-application-with-nginx-on-ubuntu-16-04\r\n[link6]: https://www.vultr.com/docs/how-to-install-and-configure-php-70-or-php-71-on-ubuntu-16-04\r\n[link7]: https://stackoverflow.com/questions/42167523/laravel-5-4-migration-error','2018-01-08 09:39:06','2018-01-09 04:34:20','ubuntu-1604-install-laravel-project-depends-on-the-environment'),(589,3,3,'Ubuntu 16.04 下安装部署运维平台（基于 Laravel）','环境要求：\r\n\r\n- 系统：Ubuntu 16.04 LTS\r\n- PHP： >= 7.0\r\n- Nginx： >= 1.10.3\r\n- MySQL： >= 5.7\r\n\r\n## 安装 Nginx\r\n\r\n```\r\n$ sudo apt install nginx\r\n```\r\n\r\n查看是否开启：\r\n\r\n```\r\n$ sudo systemctl status nginx\r\n\r\nActive: active (running) since Mon 2018-01-08 18:43:12 PST; 5min ago\r\n```\r\n\r\n此时访问地址 `http://192.168.1.225/` 就能看到 Nginx 的欢迎界面，表示 Nginx 安装成功。\r\n\r\n> Nginx 默认 Web 目录在 `/var/www/html`；配置文件在 `/etc/nginx` 目录下。 \r\n\r\n## 安装 PHP\r\n\r\n```\r\n$ sudo apt install php7.0\r\n```\r\n\r\n检查是否正确输出版本号：\r\n\r\n```\r\n$ php -v\r\n\r\nPHP 7.0.22-0ubuntu0.16.04.1 (cli) ( NTS )\r\n```\r\n\r\n安装依赖包：\r\n\r\n```\r\n$ sudo apt install php7.0-fpm php7.0-cli php7.0-common php7.0-mbstring php7.0-gd php7.0-intl php7.0-xml php7.0-mysql php7.0-mcrypt php7.0-zip\r\n```\r\n\r\n查看所有已安装依赖包：\r\n\r\n```\r\n$ php -m\r\n```\r\n\r\n## 安装 Composer\r\n\r\nComposer 是 PHP 包管理工具。在安装之前，先下载 `curl`。\r\n\r\n```\r\n$ sudo apt install curl\r\n```\r\n\r\n然后，安装 Composer。\r\n\r\n```\r\n$ curl -sS https://getcomposer.org/installer | php\r\n$ mv composer.phar /usr/local/bin/composer\r\n```\r\n\r\n现在即可使用全局命令 `composer` 了。\r\n\r\n```\r\n$ composer\r\n\r\n   ______\r\n  / ____/___  ____ ___  ____  ____  ________  _____\r\n / /   / __ \\/ __ `__ \\/ __ \\/ __ \\/ ___/ _ \\/ ___/\r\n/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /\r\n\\____/\\____/_/ /_/ /_/ .___/\\____/____/\\___/_/\r\n                    /_/\r\nComposer version 1.6.2 2018-01-05 15:28:41\r\n```\r\n\r\n## 安装 MySQL\r\n\r\n```\r\n$ sudo apt install mysql-server\r\n```\r\n\r\n安装过程中为 root 用户设置密码，按下回车键，即可完成安装。\r\n\r\n连接 MySQL：\r\n\r\n```\r\n$ mysql -uroot -p\r\nEnter password:\r\n\r\nServer version: 5.7.20-0ubuntu0.16.04.1 (Ubuntu)\r\n\r\nmysql> \r\n```\r\n\r\n## 部署网站\r\n\r\n下面介绍运维平台部署流程。\r\n\r\n下载辅助工具 `rz`：\r\n\r\n```\r\n$ sudo apt install lrzsz\r\n$ sudo apt install unzip\r\n```\r\n\r\n将本地项目上传到服务器：\r\n\r\n```\r\n$ rz\r\n```\r\n\r\n将项目解压到 `yunwei` 目录。\r\n\r\n```\r\n$ sudo unzip yunwei.zip -d yunwei\r\n```\r\n\r\n**还原数据库**：\r\n\r\n```\r\n$ sudo mysql -u root -p < yunwei/yunwei_180109.sql \r\n```\r\n\r\n移动项目到 `/var/www/yunwei`。\r\n\r\n```\r\n$ sudo mv yunwei /var/www/yunwei\r\n$ cd /var/www/yunwei\r\n```\r\n\r\n进入项目，给予一些文件权限：\r\n\r\n```\r\n$ cd /var/www/yunwei\r\n$ sudo chmod -R 777 storage\r\n$ sudo chmod -R 777 bootstrap/cache\r\n$ php artisan storage:link\r\n```\r\n\r\n**添加网站**：\r\n\r\n编辑 Nginx  配置文件：\r\n\r\n```\r\n$ sudo vim /etc/nginx/sites-available/default\r\n```\r\n\r\n**将我们的网站挂载到 8080 端口**：\r\n\r\n```\r\nserver {\r\n        listen 8080;\r\n        listen [::]:8080;\r\n\r\n        root /var/www/yunwei/public;\r\n\r\n        # Add index.php to the list if you are using PHP\r\n        index index.php index.html index.htm index.nginx-debian.html;\r\n\r\n        server_name _;\r\n\r\n        location / {\r\n                try_files $uri $uri/ /index.php?$query_string;\r\n        }\r\n\r\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\r\n        #\r\n        location ~ \\.php$ {\r\n               include snippets/fastcgi-php.conf;\r\n\r\n               # With php7.0-fpm:\r\n               fastcgi_pass unix:/run/php/php7.0-fpm.sock;\r\n        }\r\n}\r\n```\r\n\r\n重启 Nginx 服务器：\r\n\r\n```\r\n$ sudo systemctl restart nginx\r\n```\r\n\r\n至此，网站部署完毕！\r\n\r\n访问 192.168.1.225:8080 即可看到网站了。','2018-01-09 04:35:11','2018-01-09 04:35:11','ubuntu-1604-installation-deployment-operations-platform-based-on-laravel'),(590,7,7,'Python3 TCP端口扫描（内网）','```\r\nfrom socket import *\r\nimport threading\r\n \r\nlock = threading.Lock()\r\nopenNum = 0\r\nthreads = []\r\n \r\ndef portScanner(host,port):\r\n  global openNum\r\n  try:\r\n    s = socket(AF_INET,SOCK_STREAM)\r\n    s.connect((host,port))\r\n    lock.acquire()\r\n    openNum+=1\r\n    print(\'[+] %d open\' % port)\r\n    lock.release()\r\n    s.close()\r\n  except:\r\n    pass\r\n \r\ndef main():\r\n  setdefaulttimeout(1)\r\n  for p in range(1,1024):\r\n    t = threading.Thread(target=portScanner,args=(\'192.168.0.100\',p))\r\n    threads.append(t)\r\n    t.start()   \r\n \r\n  for t in threads:\r\n    t.join()\r\n \r\n  print(\'[*] The scan is complete!\')\r\n  print(\'[*] A total of %d open port \' % (openNum))\r\n \r\nif __name__ == \'__main__\':\r\n  main()\r\n```','2018-01-09 08:11:05','2018-01-09 08:11:05','python3-tcp-port-scan-network'),(591,3,3,'?我的阅读清单','## 散文\r\n\r\n1. 《到山中去》，by 张晓风等。2018年1月。\r\n\r\n## 小说\r\n\r\n1. ?《寻找一只鸟》，by 金文。2018年1月。\r\n1. 《躺下去会舒服点》，by 曹寇。2018年1月。\r\n\r\n## 技术\r\n\r\n1. [The Magic of CSS][link4]，by Adam Schwartz。2018年1月。\r\n1. [The Modern JavaScript Tutorial][link3]，from javascript.info。2018年1月。\r\n1. [Understanding ECMAScript 6][link2]，by Nicholas C. Zakas。2018年1月。\r\n1. [ECMAScript 6 入门][link1]，by 阮一峰。2018年1月。\r\n\r\n[link1]: http://es6.ruanyifeng.com/\r\n[link2]: https://leanpub.com/understandinges6\r\n[link3]: http://javascript.info/\r\n[link4]: http://adamschwartz.co/magic-of-css/','2018-01-10 03:55:11','2018-01-14 04:08:35','my-reading-list'),(592,3,3,'[口水贴]新版乱炖社区计划','> 计划实施日期不定。\r\n\r\n想到的设计想法有：\r\n\r\n1. 使用 Bulma 构建。\r\n2. 首页：显示 **最新文章（latest）** 和 **最近更新文章（recently-updated）**。','2018-01-10 07:42:26','2018-01-10 07:42:26','saliva-stick-the-new-stew-community-plan'),(593,3,3,'我的家乡浍沟镇','在百度百科上这样介绍到：\r\n\r\n>浍沟镇位于灵璧县城以北25公里，居灵璧县中心位置。302省道从浍沟镇中心街道穿过，与东西两侧的灵双路、灵房路各相距8公里，南与禅堂，东与大路，西与尹集，西北、东北分别与朱集、渔沟接壤，交通便利，北边有10公里山脉。中部有河流（濉河、托尾河），地理位置极为优越。浍沟镇现有人口5.1万余人，耕地面积6.6万余亩，行政村15个，49个自然村，户数11460户，村村通汽车，通电话。农村年用电量155万度。\r\n\r\n我早些时间（高中）就知道了，我们镇在灵璧中心位置。\r\n\r\n“北边有10公里山脉”应该指北山了。\r\n\r\n原来三岔河的北河叫“托尾河”。\r\n\r\n我在想“地理位置极为优越”有没有可以利用的呢？','2018-01-11 04:49:33','2018-01-11 04:50:41','my-hometown-hui-trench-town'),(594,7,7,'Docker 常用命令','容器相关操作\r\n```\r\ndocker create # 创建一个容器但是不启动它\r\ndocker run # 创建并启动一个容器\r\ndocker stop # 停止容器运行，发送信号SIGTERM\r\ndocker start # 启动一个停止状态的容器\r\ndocker restart # 重启一个容器\r\ndocker rm # 删除一个容器\r\ndocker kill # 发送信号给容器，默认SIGKILL\r\ndocker attach # 连接(进入)到一个正在运行的容器\r\ndocker wait # 阻塞到一个容器，直到容器停止运行\r\n```\r\n \r\n\r\n获取容器相关信息\r\n```\r\ndocker ps # 显示状态为运行（Up）的容器\r\ndocker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited)\r\ndocker inspect # 深入容器内部获取容器所有信息\r\ndocker logs # 查看容器的日志(stdout/stderr)\r\ndocker events # 得到docker服务器的实时的事件\r\ndocker port # 显示容器的端口映射\r\ndocker top # 显示容器的进程信息\r\ndocker diff # 显示容器文件系统的前后变化\r\n```\r\n \r\n导出容器\r\n```\r\ndocker cp # 从容器里向外拷贝文件或目录\r\ndocker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息\r\n```\r\n \r\n执行\r\n```\r\ndocker exec # 在容器里执行一个命令，可以执行bash进入交互式\r\n````\r\n \r\n镜像操作\r\n```\r\ndocker images # 显示本地所有的镜像列表\r\ndocker import # 从一个tar包创建一个镜像，往往和export结合使用\r\ndocker build # 使用Dockerfile创建镜像（推荐）\r\ndocker commit # 从容器创建镜像\r\ndocker rmi # 删除一个镜像\r\ndocker load # 从一个tar包创建一个镜像，和save配合使用\r\ndocker save # 将一个镜像保存为一个tar包，带layers和tag信息\r\ndocker history # 显示生成一个镜像的历史命令\r\ndocker tag # 为镜像起一个别名\r\n```\r\n \r\n镜像仓库(registry)操作\r\n```\r\ndocker login # 登录到一个registry\r\ndocker search # 从registry仓库搜索镜像\r\ndocker pull # 从仓库下载镜像到本地\r\ndocker push # 将一个镜像push到registry仓库中\r\n```\r\n \r\n获取Container IP地址（Container状态必须是Up）\r\n````\r\ndocker inspect id | grep IPAddress | cut -d \'\"\' -f 4\r\n```\r\n \r\n获取端口映射\r\n```\r\ndocker inspect -f \'{{range $p, $conf := .NetworkSettings.Ports}} {{$p}} -> {{(index $conf 0).HostPort}} {{end}}\' id\r\n```\r\n \r\n获取环境变量\r\n```\r\ndocker exec container_id env\r\n```\r\n \r\n杀掉所有正在运行的容器\r\n```\r\ndocker kill $(docker ps -q)\r\n```\r\n \r\n删除老的(一周前创建)容器\r\n```\r\ndocker ps -a | grep \'weeks ago\' | awk \'{print $1}\' | xargs docker rm\r\n``` \r\n删除已经停止的容器\r\n```\r\ndocker rm `docker ps -a -q`\r\n``` \r\n删除所有镜像，小心\r\n```\r\ndocker rmi $(docker images -q)\r\n``` \r\n\r\n通过Dockerfile构建image\r\n```\r\ndocker build csphere/nginx:1.7 .\r\n``` \r\n镜像仓库Registry\r\n部署registry\r\n```\r\nmkdir /registry\r\ndocker run  -p 80:5000  -e STORAGE_PATH=/registry  -v /registry:/registry  registry:2.0\r\n``` \r\n推送镜像保存到仓库\r\n```\r\n假设192.168.1.2是registry仓库的地址：\r\ndocker tag  csphere/nginx:1.7 192.168.1.2/csphere/nginx:1.7\r\ndocker push 192.168.1.2/csphere/nginx:1.7\r\n```','2018-01-11 08:08:53','2018-01-11 08:16:22','docker-common-commands'),(595,3,3,'前端面试题大全','---\r\n\r\n1. 打星星（1~5颗星星）。\r\n\r\n```\r\n\r\nfunction getStars(rate) {\r\n	return \'★★★★★☆☆☆☆☆\'.slice(5 - rate, 10 - rate);\r\n}\r\n\r\ngetStars(3); // \"★★★☆☆\"\r\n```\r\n\r\n2. 快速排序\r\n\r\n```\r\n// 快速排序：从小到大。\r\n// 参考链接：http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html\r\n// 1. 选出一个基准值（与原数组分离）\r\n// 2. 填充左右两个子集（小于基准值的放在左子集，否则放在右子集）\r\n// 3. 对左右子集分别执行上面的操作（递归调用）\r\n\r\nfunction quickSort(arr) {\r\n	if (arr.length <= 1) {\r\n		return arr;\r\n	}\r\n	\r\n	let pivotIndex = Math.floor(arr.length / 2);\r\n	let pivot = arr.splice(pivotIndex, 1)[0];\r\n	\r\n	let left = [];\r\n	let right = [];\r\n	\r\n	for (let i = 0; i < arr.length; i++) {\r\n		if (arr[i] < pivot) {\r\n			left.push(arr[i]);\r\n		} else {\r\n			right.push(arr[i]);\r\n		}\r\n	}\r\n	\r\n	return quickSort(left).concat(pivot, quickSort(right));\r\n}\r\n```\r\n\r\n3. 冒泡排序\r\n\r\n```\r\n// 冒泡排序：从小到大\r\n// 对一个数组重复排序\r\n// 从前往后两两比较数字大小，如果前面的比后面大，就交换位置。\r\n// 每一次循环的结果是最大的总是在最后面。\r\nfunction bubbleSort(arr) {\r\n	if (arr.length <= 1) {\r\n		return arr;\r\n	}\r\n	\r\n	for (let n = arr.length - 1; n > 0; n--) {\r\n		for (let i = 0; i < n; i++) {\r\n			if (arr[i] > arr[i + 1]) {\r\n					[ arr[i], arr[i + 1] ] = [ arr[i + 1], arr[i] ];\r\n			}\r\n		}\r\n	}\r\n	\r\n	return arr;\r\n}\r\n```\r\n\r\n4. 交换排序\r\n\r\n冒泡排序与快速排序都属于交换排序。\r\n\r\n交换排序的思想是：两两比较待排序的数据，发现两个数据的次序相反时就进行交换，直到没有反序的数据为止。\r\n\r\n时间复杂度：\r\n\r\n⑴ 冒泡排序：若数组初始就是正序的，此时时间复杂度最低，为 `O(n)`；若数组初始就是反序的，此时时间复杂度最高----进行 `n-1`  趟排序，每趟排序要进行 `n-i`  次数据交换，时间复杂度为 `O(n²)`。\r\n\r\n⑵ 快速排序：`O(n㏒n)`。\r\n\r\n5. 优雅地取随机字符串\r\n\r\n```\r\nMath.random().toString(16).substring(2) // 13位\r\nMath.random().toString(36).substring(2) // 11位\r\n```\r\n\r\n6. 数组去重\r\n\r\n```\r\n[...new Set([1, \'1\', 2, 1, 1, 3])]\r\n```\r\n\r\n7. JSON.parse 的另类实现\r\n\r\n```\r\nnew Function(\'return \' + data + \';\')();\r\n```','2018-01-11 09:29:48','2018-01-12 02:29:29','before-the-end-paper-books'),(596,3,3,'Git 工作流','在本机中安装好 Git 之后，就能使用 Git 对项目进行版本管理和团队协作了。\r\n\r\n下面介绍 Git 日常使用中的常用命令和技巧。\r\n\r\n## 全局设置\r\n\r\n1. 设置用户名和邮箱号\r\n\r\n```\r\n$ git config --global user.name \"Your Name\"\r\n$ git config --global user.email your@example.com\r\n```\r\n\r\n这样在查看代码提交日志时，可以看到署名信息。\r\n\r\n2. 设置默认推送分支\r\n\r\n```\r\n$ git config --global push.default simple\r\n```\r\n\r\n这样设置后，可以直接使用 `git push` 提交代码，代码默认推送到当前分支。\r\n\r\n## 操作项目\r\n\r\n1. 使用 Git 初始化项目\r\n\r\n```\r\n$ git init\r\n```\r\n\r\n2. 提交项目所有文件\r\n\r\n```\r\n$ git add -A\r\n```\r\n\r\n3. 查看 Git 暂存区文件\r\n\r\n```\r\n$ git status\r\n```\r\n\r\n4. 查看提交记录\r\n\r\n```\r\n$ git log\r\n```\r\n\r\n5. 恢复误删文件（这里的“文件”指已纳入到 Git 中的）\r\n\r\n```\r\n$ git checkout -f\r\n```\r\n\r\n这条命令用来丢弃本地更改----也就是将在暂存区的更改文件进行强制撤销，恢复到更改之前的状态。\r\n\r\n### Github\r\n\r\n1. 将本地项目挂在到 Github 上。\r\n\r\n```\r\n$ git remote add origin git@github.com:your_username/hello_laravel.git\r\n$ git push -u origin master\r\n```\r\n\r\n2. 项目提交到 Github 上后，每次修改只要执行下面 3 条命令就 OK 了。\r\n\r\n```\r\n$ git add -A\r\n$ git commit -m \"Say something\"\r\n$ git push\r\n```','2018-01-12 06:32:10','2018-01-12 06:32:10','git-workflow'),(597,3,3,'一起来天马行空地写','一个人如果一生活了八十岁，一年按照365天计算，一共是29,200天。\r\n\r\n我看了下，我已经活了9,400多天了。这样算，人生看起来很有限，在时间上。精力上，如果算持续到40岁，也就是14,600天。\r\n\r\n如果时间回到1992年3月5号，也就是我出生的那一天，会非常有趣和令我惊讶，那时我还没有自我意识，在之后的一段时间里，也不知道经历了什么。\r\n\r\n我从小成长到大，然后成年、成熟、变老和死亡。我体内的心脏一直跳动，鼓动我全身的血循环流动，皮肤温热。身体的各个系统保持着动态的平衡，我感到生命本身很了不起，活着就是一种奇迹的显现。\r\n\r\n什么神，什么社会，什么自然，都变得不那么重要，这是概念也是套子。\r\n\r\n什么两个人的爱情，多个人的团队？一个人的爱情，一个人的队才是真的。有谁好意思不承认人都是和自己谈恋爱耍脾气呢？而且一直以来都是处在跟自己过的情感状态。\r\n\r\n说战胜自己很难，当然难，因为根本战胜不了，所以要跟别人比，比别人做事情做得好而且要漂亮。\r\n\r\n这并不悲伤，你要坚强，虽然坚强本身都是值得怀疑的，因为有时也需要软弱，中庸是说来骗人的。','2018-01-13 16:26:42','2018-01-13 16:26:42','powerful-and-unconstrained-style-to-write-together'),(598,3,3,'[文学改编]到山里去','> 由我改编自张晓风的《到山中去》。\r\n\r\n从山里回来已经两天了，但不知怎的，行坐之间，恍惚以为自己就是山上的一块石头，溪边的一棵树。\r\n\r\n那天你不能去，真是可惜。德，人不到山里去，不到水里去。那真是活得冤枉。\r\n\r\n德，人间有许多道理，实在是讲不清的。譬如说吧，山山都是石头、都有树木，都有溪流。但它们是不同的，就像我们人和人不同一样。\r\n\r\n严格地说，常被人践踏观赏的已经算不得山，一切山的优美，尽在那一片未凿的天真。我真愿意做那一座山，那样沉郁、古朴和深邃。\r\n\r\n我们沿着原路返回，寻到大路已是满天繁星，稀疏的灯光和远星。行囊很轻，而带去看的报纸也在匆忙中做了火引子，事后想想，也觉好笑。\r\n\r\n那天我真是极困乏而又极有精神，极混沌而又极能深思。你能想象那夜吗？我真不相信人从大自然中归来，而仍然不相信上帝存在的。\r\n\r\n德，你愿意附和我吗？拨开你一桌的资料卡，拭净你尘封的眼镜片，让我们到山里去！','2018-01-14 02:50:18','2018-01-14 02:50:18','literary-adaptation-go-to-the-mountains'),(599,3,3,'如果可以，我希望可以继续写下去','在我住的地方，她默默地搬走了，我甚至都没有看清她的样子，就这么走了，真可惜。我知道她的名字，但也只是个名字罢了，连她放屁——我是说看她出糗的机会都没有，这也是可惜的一点。我会想象即使出糗，她也这么可爱。','2018-01-14 13:11:15','2018-01-14 13:12:43','if-you-can-i-hope-i-can-continue-to-write'),(600,3,3,'?The Modern JavaScript Tutorial: Window sizes and scrolling','在 DOM 中，`document.documentElement` 对应的是 `<html>` 元素。\r\n\r\n## 窗口的宽/高\r\n\r\n`document.documentElement` 的 `clientWidth/clientHeight` 表示窗口的宽/高。\r\n\r\n![](http://javascript.info/article/size-and-scroll-window/document-client-width-height@2x.png)\r\n\r\n⚠️为什么不用 `Window.innerWidth/Height`？\r\n\r\n因为 `Window.innerWidth/Height` 的宽/高是包含滚动条的（有的话），而 `document.documentElement` 的 `clientWidth/clientHeight` 是不包含的。\r\n\r\n大多数情况下，我们操作的都是实际内容区的宽高，这里不应该包含滚动条。所以不用 `Window.innerWidth/Height`。\r\n\r\n```javascript\r\nalert( window.innerWidth ); // full window width\r\nalert( document.documentElement.clientWidth ); // full window width 减去 scrollbar 的\r\n```\r\n\r\n## 文档的宽/高\r\n\r\n这也指页面的宽/高。`document.documentElement` 就是 `<html>`，所以它的 `scrollWidth/scrollHeight` 属性就能表示文档的宽/高。但这里有个问题。\r\n\r\n在 `Chrome/Safari/Opera` 中，如果页面没有包含滚动条，`documentElement.scrollHeight` 可能比 `documentElement.clientHeight` 还要小！当然，在页面包含滚动条的情况下，使用 `documentElement.scrollHeight` 是没有问题的。\r\n\r\n下面给出计算文档高的最佳实践代码：\r\n\r\n```javascript\r\nlet scrollHeight = Math.max(\r\n  document.body.scrollHeight, document.documentElement.scrollHeight,\r\n  document.body.offsetHeight, document.documentElement.offsetHeight,\r\n  document.body.clientHeight, document.documentElement.clientHeight\r\n);\r\n\r\nalert(\'Full document height, with scrolled out part: \' + scrollHeight);\r\n```\r\n\r\n## 当前滚动条滚动距离\r\n\r\n普通元素有 `elem.scrollLeft/scrollTop` 接口来计算元素的滚动距离。那么页面呢？\r\n\r\n许多浏览器提供了 `documentElement.scrollLeft/Top` 接口计算当前页面的滚动条滚动距离。但在 Chrome/Safari/Opera 中有 Bug，需要使用 `document.body` 来获得当前滚动条滚动距离。当然，这是特性怪癖，我们不用担心这个。\r\n\r\n因为我们有 `window.pageXOffset/pageYOffset` 接口可以使用。\r\n\r\n```javascript\r\nalert(\'Current scroll from the top: \' + window.pageYOffset);\r\nalert(\'Current scroll from the left: \' + window.pageXOffset);\r\n```\r\n\r\n`window.pageXOffset/pageYOffset` 属性是只读的。\r\n\r\n## 滚动方法：scrollTo、scrollBy、scrollIntoView\r\n\r\n普通元素可以通过设置 `scrollTop/scrollLeft` 属性来滚动指定距离。\r\n\r\n对于页面滚动：\r\n\r\n1. 对于 Chrome/Safari/Opera：使用 `document.body.scrollTop/Left`。\r\n2. 对于其他浏览器：使用 `document.documentElement.scrollTop/Left`。\r\n\r\n有浏览器兼容问题，不好对付，可别担心。\r\n\r\n因为我们有 `window.scrollBy(x,y)` 和 `window.scrollTo(pageX,pageY)` 方法可以用。\r\n\r\n- `scrollBy(x,y)` 针对当前位置进行滚动。\r\n- `scrollTo(pageX,pageY)` 方法相对文档的左上角滚动，效果等同于设置 `scrollTop/Left`。\r\n\r\n而且 `window.scrollBy(x,y)` 和 `window.scrollTo(pageX,pageY)` 方法兼容所有浏览器。\r\n\r\n### scrollIntoView\r\n\r\n为了完整性，我们才讲 `elem.scrollIntoView(top)` 方法。\r\n\r\n这里的参数 `top` 是个布尔值：\r\n\r\n1. `top` 值为 `true` 时（默认），滚动的最终效果是：元素顶端与窗口顶端对齐。\r\n2. `top` 值为 `false` 时），滚动的最终效果是：元素底端与窗口底端对齐。\r\n\r\n## 禁止滚动\r\n\r\n有时页面弹出弹框时，为了与弹框更好的交互，我们希望弹框层下面的长长的页面禁止滚动。\r\n\r\n这时，可以设置 `document.body.style.overflow = \"hidden\"` 来实现这个效果----滚动条消失，页面固定在当前滚动的距离。\r\n\r\n不仅 `document.body`，我们也可以在普通元素上使用这个方式，实现禁止滚动的效果。\r\n\r\n?有一个问题。\r\n\r\n是这样的，当使用 ``document.body.style.overflow = \"hidden\"`` 后，页面滚动条消失了。因为滚动条消失，之前占据的页面空间就没有了，所以页面内容可能就会往外拓展了。\r\n\r\n为了保证页面内容不动，我们可以给 `document.body` 添加一个 `padding` 来替代之前滚动条占据的空间。\r\n\r\n## 总结\r\n\r\n几何属性：\r\n\r\n- 窗口宽/高（即文档可视区的宽/高，也是不包含滚动条的内容区域）：`document.documentElement.clientWidth/Height`。\r\n- 文档宽/高（即页面宽高）：\r\n\r\n```\r\nlet scrollHeight = Math.max(\r\n  document.body.scrollHeight, document.documentElement.scrollHeight,\r\n  document.body.offsetHeight, document.documentElement.offsetHeight,\r\n  document.body.clientHeight, document.documentElement.clientHeight\r\n);\r\n```\r\n\r\n滚动距离：\r\n\r\n- 当前滚动条滚动距离：`window.pageYOffset/pageXOffset`。\r\n- 改变滚动距离：\r\n	- `window.scrollTo(pageX,pageY)`：绝对坐标（文档左上角）滚动。\r\n	- `window.scrollBy(x,y) `：相对（当前位置）位置滚动。\r\n	- `elem.scrollIntoView(top)`： 让元素 `elem` 元素滚动到可视区（与窗口顶端或者底端对齐）。\r\n\r\n（完）','2018-01-15 01:39:41','2018-01-15 08:50:16','the-modern-javascript-tutorial-window-sizes-and-scrolling'),(601,3,3,'?The Modern JavaScript Tutorial: Element size and scrolling','举一个例子：\r\n\r\n```html\r\n<div id=\"example\">\r\n  ...Text...\r\n</div>\r\n<style>\r\n  #example {\r\n    width: 300px;\r\n    height: 200px;\r\n    border: 25px solid #E8C48F;\r\n    padding: 20px;\r\n    overflow: auto;\r\n  }\r\n</style>\r\n```\r\n\r\n`#example` 这个元素包含宽、高、边框和内边距（没有外边距，是因为外边距不是元素的一部分）。\r\n\r\n用一张图来说明，是这样的。\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-css@2x.png)\r\n\r\n⚠️ 注意滚动条。\r\n\r\n`#example` 是有滚动条的，而且 **滚动条占据的是内容区的空间**，而不是内边距。\r\n\r\n来，我们说明一下：`#example` 的内容区宽度我们设置为 `300px`，但是滚动条占据了 16px 的宽度空间（当然，并不一定，要视具体的设备和浏览器限制），所有最终内容区的有效宽度是 `300 - 16 = 284px`。\r\n\r\n## 几何属性\r\n\r\n几何属性就是像宽、高啦这样的一些数值属性，单位都是像素。\r\n\r\n这有一张图，大致说明了这些属性。\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-all@2x.png)\r\n\r\n## offsetParent、offsetLeft/Top\r\n\r\n这些属性很少需要，但仍然是“最外层”的几何属性，所以我们将从这些属性开始。\r\n\r\n`offsetParent` 用来获得最近的祖先元素。包括：\r\n\r\n1. 定义元素（`position` 的值为 `absolute`、`relative` 或 `fixed`）。\r\n2. 或者 `<td>`、`<th>`、`</table>`。\r\n3. 或者 `<body>`。\r\n\r\n在大多数实际情况下，我们可以使用 `offsetParent` 来获取最近的定位祖先元素。 `offsetLeft` / `offsetTop` 提供相对于祖先元素左上角的 x/y 坐标。\r\n\r\n在下面的例子里，`<main>` 是内部 `div` 的 `offsetParent`，`offsetLeft/offsetTop` 是相对于 `<main>` 左上角的偏移距离（`180`）。\r\n\r\n```html\r\n<main style=\"position: relative\" id=\"main\">\r\n  <article>\r\n    <div id=\"example\" style=\"position: absolute; left: 180px; top: 180px\">...</div>\r\n  </article>\r\n</main>\r\n<script>\r\n  alert(example.offsetParent.id); // main\r\n  alert(example.offsetLeft); // 180 (note: a number, not a string \"180px\")\r\n  alert(example.offsetTop); // 180\r\n</script>\r\n```\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-offset-parent@2x.png)\r\n\r\n有几个场景下，`offsetParent` 的值为 `null`：\r\n\r\n1. 未显示元素（`display: none` 或者在不在文档中的）。\r\n2. `<body>` 和 `<html>`。\r\n3. 用 `position: fixed` 定位的元素。\r\n\r\n## offsetWidth/Height\r\n\r\n下面转向元素本身。\r\n\r\n元素的 `offsetWidth/Height` 属性值包含边框，可以认为是元素“外部”宽/高。\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-offset-width-height@2x.png)\r\n\r\n上图中，元素的 `offsetWidth` 是 `390`；`offsetHeight` 是 `290`。\r\n\r\n⚠️ **未显示元素几何属性值为 0/null**。\r\n\r\n几何属性只在显示属性上使用是有用的。\r\n\r\n如果一个元素（或任何祖先元素）的是 `display: none` 的，那么它的几何属性值是 0 或者 `null`。\r\n\r\n例如：`offsetParent` 值为 `null`，`offsetWidth` 和 `offsetHeight` 的值为 `0`。\r\n\r\n我们可以根据这个特性，检查一个元素是否是隐藏的。\r\n\r\n```javascript\r\nfunction isHidden(elem) {\r\n  return !elem.offsetWidth && !elem.offsetHeight;\r\n}\r\n```\r\n\r\n当然，空标签元素检查也会返回 `true`（比如一个空的 `div`）。\r\n\r\n## clientTop/Left\r\n\r\n`clientTop` 和 `clientLeft` 属性值可以认为是元素边框的大小。\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-client-left-top@2x.png)\r\n\r\n但也不全是，如果内部有滚动条的话……`clientLeft` 还包含滚动条的宽度。\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-client-left-top-rtl@2x.png)\r\n\r\n## clientWidth/Height\r\n\r\n`clientWidth/Height` 包含元素内容区宽度：包含内边距，但是不包含滚动条占据的空间。\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-client-width-height@2x.png)\r\n\r\n上图里，元素的宽是 300px，内边距是 20px，但是因为有滚动条，所以有效宽度是 `300-16=284px`。因此 `clientWidth` 的值是 `20 + 284 + 20 = 324px`。\r\n\r\n如果没有内边距的话，`clientWidth/Height` 就是指内容区（conetnt area）空间----边框内、但不包含滚动条（有的话）。\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-client-width-nopadding@2x.png)\r\n\r\n## scrollWidth/Height\r\n\r\n`scrollWidth/Height` 属性表示元素的完全的宽、高（包括隐藏部分的）。\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-scroll-width-height@2x.png)\r\n\r\n下面代码，让元素的高度设定为完全的高度值。\r\n\r\n```javascript\r\n// expand the element to the full content height\r\nelement.style.height = `${element.scrollHeight}px`;\r\n```\r\n\r\n## scrollLeft/scrollTop\r\n\r\n![](http://javascript.info/article/size-and-scroll/metric-scroll-top@2x.png)\r\n\r\n`scrollLeft/scrollTop` 并不是只读的，也可写。\r\n\r\n```\r\nelem.scrollTop += 10\r\n```\r\n\r\n让元素向下滚动 `10px`。将 `scrollTop` 设置为 `0` 或者 `Infinity` 让元素响应地滚动到文档顶部或者底部。\r\n\r\n## 不要用 getComputedStyle 获得元素宽高\r\n\r\n我们可以用 `getComputedStyle` 获得元素宽高，那为什么不用呢？\r\n\r\n```\r\nlet elem = document.body;\r\n\r\nalert( getComputedStyle(elem).width ); // show CSS width for elem\r\n```\r\n\r\n有两个原因，说明使用 `getComputedStyle` 带来的缺点：\r\n\r\n1. 首先，CSS `width/height` 属性的取值依赖于 `box-sizing` 属性，`box-sizing` 属性的改变可能会影响到程序运行。\r\n2. 其次，CSS `width/height` 可能是 `\"auto\"`，而不是一个数值。比如，行内元素的宽。\r\n\r\n```html\r\n<span id=\"elem\">Hello!</span>\r\n\r\n<script>\r\n  alert( getComputedStyle(elem).width ); // \"auto\"\r\n</script>\r\n```\r\n \r\n 而且 `getComputedStyle(elem).width` 在不同浏览器中行为还不一样：一些浏览器（像 Chrome）返回的是去掉滚动条的宽（不包含内边距），而另一些（FireFox）计算出来的宽是包含滚动条的（不包含内边距）。\r\n\r\n`getComputedStyle` 的的局限只是在 `width` 属性上，其他属性取值都是没问题的。\r\n\r\n## 总结\r\n\r\n元素具有以下一些几何属性：\r\n\r\n- `offsetParent`：最近的定位祖先元素或者 `<td>`、`<th>`、`<table>` 和 `<body>`。\r\n- `offsetLeft/offsetTop`：相对于 `offsetParent` 左上角的定位坐标。\r\n- `offsetWidth/offsetHeight`：包含元素边框的“外”宽高。\r\n- `clientLeft/clientTop`：（用太少，不说了）。\r\n- `clientWidth/clientHeight`：元素内容区宽/高，包含内边距，不包含滚动条。\r\n- `scrollWidth/scrollHeight`：元素的完整宽高（包含隐藏起来的部分），也是包含内边距，不包含滚动条的。\r\n- `scrollLeft/scrollTop`：元素相对于自身初始左上角的位置滚动的距离。\r\n\r\n除了 `scrollLeft/scrollTop` 其他属性都是只读的。\r\n\r\n（完）','2018-01-15 02:30:19','2018-01-15 08:50:24','the-modern-javascript-tutorial-element-sizes-and-scrolling'),(602,20,20,'现代 JavaScript 语言教程','> 本系列全面介绍现代 JavaScript 语言特性，从零到一。\r\n\r\n<p class=\"well\">\r\n需要注意的是：这是一个翻译自英文网站的教程，原始内容在 http://javascript.info 网站上可以看到。本系列翻译原则以“意到”为要，并不会拘泥于原文内容，特此告知。\r\n</p>\r\n\r\n翻译正在进行中……\r\n\r\n## 目录大纲\r\n\r\n### 一、JavaScript 语言\r\n\r\n### 二、浏览器：文档、事件和 Interfaces\r\n\r\n#### 2.1 文档\r\n\r\n1. [元素大小和滚动](http://www.baooab.com/forum/discussion/the-modern-javascript-tutorial-element-sizes-and-scrolling)。\r\n1. [窗口大小和滚动](http://baooab.com/forum/discussion/the-modern-javascript-tutorial-window-sizes-and-scrolling)。\r\n1. [坐标系统：窗口坐标系统和文档坐标系统](http://baooab.com/forum/discussion/modern-javascript-language-tutorial-coordinate-system)。\r\n\r\n#### 2.2 事件\r\n\r\n#### 2.3 深入事件\r\n\r\n#### 2.4 表单和表单事件\r\n\r\n### 三、拓展文章\r\n\r\n\r\n## 附录','2018-01-15 09:07:41','2018-01-16 02:28:05','the-modern-javascript-tutorial'),(603,20,20,'现代 JavaScript 语言教程：坐标系统','在 JavaScript 中，元素是在一个坐标系统里移动的。这些操作元素移动的方法包含在两类坐标系统中：\r\n\r\n1. 相对于窗口（或另一个视口）的 top/left。\r\n2. 相对于文档的 top/left。\r\n\r\n理解两类坐标系统的不同很重要。\r\n\r\n## 窗口坐标：getBoundingClientRect\r\n\r\n窗口坐标系统的坐标原点（0,0）在窗口的左上角。\r\n\r\n`elem.getBoundingClientRect` 方法返回元素 `elem` 在窗口坐标系统中的坐标信息，是一个对象，包含以下属性：\r\n\r\n1. `top`：元素顶部距离窗口顶部的距离。\r\n2. `left`：元素左边缘距离窗口左边缘的距离。\r\n3. `right`：元素右边缘距离窗口左边缘的距离。\r\n4. `bottom`：元素底部距离窗口顶部的距离。\r\n\r\n![](http://javascript.info/article/coordinates/coords@2x.png)\r\n\r\n这些属性值都是相对于窗口左上角计算的。\r\n\r\n如果滚动了页面，在 `elem` 再次使用 `getBoundingClientRect` 方法时，结果就不同了。\r\n\r\n而且：\r\n\r\n- 坐标点的值可能是个小数，不过并不影响 `style.position.left/top` 的设置。\r\n-  坐标点的值可能是个负值。例如，我们滚动页面，元素滚动到了页面顶部上面，`elem.getBoundingClientRect().top` 的结果就是负值。\r\n-  一些浏览器（像 Chrome）中 `getBoundingClientRect` 方法返回的结果中，还包含 `width` 和 `height` 属性。当然对于不支持这两个属性的浏览器，我们可以使用变通的方法：`height=bottom-top` 和 `width=right-left`。\r\n\r\n## elementFromPoint(x, y)\r\n\r\n`elementFromPoint(x, y)` 返回距离坐标 `(x, y)` 最近的元素。语法是：\r\n\r\n```javascript\r\nlet elem = document.elementFromPoint(x, y);\r\n```\r\n\r\n例如，如果我们要高亮窗口中心位置的元素，可以这样操作：\r\n\r\n```javascript\r\nlet centerX = document.documentElement.clientWidth / 2;\r\nlet centerY = document.documentElement.clientHeight / 2;\r\n\r\nlet elem = document.elementFromPoint(centerX, centerY);\r\n\r\nelem.style.background = \"red\";\r\nalert(elem.tagName);\r\n```\r\n\r\n⚠️ 对于窗口坐标系统以外的坐标，`elementFromPoint` 方法返回 `null`。所以使用时不检查，可能会出错的。\r\n\r\n```javascript\r\nlet elem = document.elementFromPoint(x, y);\r\n// if the coordinates happen to be out of the window, then elem = null\r\nelem.style.background = \'\'; // Error!\r\n```\r\n\r\n## position: fixed\r\n\r\n许多时候，我们需要用坐标来固定某个元素在窗口中某个位置不动。在 CSS 中，元素相对视口定位要使用 `position: fixed`，它与 `left/top`（或者 `right/bottom`）相互配合，就能达到固定位置的效果。\r\n\r\n比如，我们先使用 `getBoundingClientRect` 获取元素的窗口坐标，然后在元素附近显示一些信息。\r\n\r\n下面的 `createMessageUnder(elem, html)` 就实现了在 `elem` 下显示 `html` 的内容：\r\n\r\n```javascript\r\nlet elem = document.getElementById(\"coords-show-mark\");\r\n\r\nfunction createMessageUnder(elem, html) {\r\n  // create message element\r\n  let message = document.createElement(\'div\');\r\n  // better to use a css class for the style here\r\n  message.style.cssText = \"position:fixed; color: red\";\r\n\r\n  // assign coordinates, don\'t forget \"px\"!\r\n  let coords = elem.getBoundingClientRect();\r\n\r\n  message.style.left = coords.left + \"px\";\r\n  message.style.top = coords.bottom + \"px\";\r\n\r\n  message.innerHTML = html;\r\n\r\n  return message;\r\n}\r\n\r\n// Usage:\r\n// add it for 5 seconds in the document\r\nlet message = createMessageUnder(elem, \'Hello, world!\');\r\ndocument.body.append(message);\r\nsetTimeout(() => message.remove(), 5000);\r\n```\r\n\r\n但这种显示信息的方式有问题，当你滚动页面时，会发现元素 `elem` 会跟随滚动，但是信息不动。因为 `message` 是使用 `position:fixed` 相对窗口定位的。\r\n\r\n为了修正这个问题，我们需要使用基于文档坐标系统定位的 `position:absolute` 属性。\r\n\r\n## 文档坐标\r\n\r\n基于文档坐标系统定位是指以文档左上角为坐标原点（0,0）定位，而不是窗口的。\r\n\r\n在 CSS 中，窗口坐标定位对应 `position:fixed`，文档坐标定对应 `position:absolute`。\r\n\r\n我们可以使用 `position:absolute`  结合 `top/left` 将元素定位在文档的某个位置，这样即使页面滚动，因为元素相对文档定位，所以元素在文档中的位置始终是不变的。\r\n\r\n为了说明清楚，我们用窗口坐标 `(clientX, clientY)` 和 文档坐标 `(pageX, pageY)` 来解释。\r\n\r\n当页面没有滚动的时候，窗口坐标 `(clientX, clientY)` 和文档坐标 `(pageX, pageY)` 重合，因为它们的坐标原点是重合的。\r\n\r\n![](http://javascript.info/article/coordinates/document-window-coordinates-zero@2x.png)\r\n\r\n如果我们滚动窗口，`(clientX, clientY)` 就改变了，因为这个坐标是相对窗口坐标系统计算的，但是 `(pageX, pageY)`  保持不变。\r\n\r\n下图是在页面垂直滚动一段距离后的信息：\r\n\r\n![](http://javascript.info/article/coordinates/document-window-coordinates-scroll@2x.png)\r\n\r\n- 标题《From today\'s featured article》的 `clientY` 的值为 `0`，因为标题元素处于窗口顶端。\r\n-  `clientX` 的值没有改变，因为我们没有水平滚动。\r\n-  `(pageX, pageY)` 坐标是始终保持不变的，因为这是元素相对于文档的坐标。\r\n\r\n## 获得文档坐标\r\n\r\n\r\n关于获得元素文档坐标的方法，现在还没有一个标准的。但是可以很容易通过变通的方法实现：\r\n\r\n- pageY = clientY + 文档垂直滚动的距离。\r\n- pageX = clientX + 文档水平滚动的距离。\r\n\r\n下面我们来封装一个方法 `getCoords(elem)`，利用 `getCoords(elem)` 加上当前页面的滚动距离，计算出元素的文档坐标。\r\n\r\n```javascript\r\n// get document coordinates of the element\r\nfunction getCoords(elem) {\r\n  let box = elem.getBoundingClientRect();\r\n\r\n  return {\r\n    top: box.top + window.pageYOffset,\r\n    left: box.left + window.pageXOffset\r\n  };\r\n}\r\n```\r\n\r\n## 总结\r\n\r\n页面中任何点都有坐标：\r\n\r\n- 相对于窗口：`elem.getBoundingClientRect()`。\r\n- 相对于文档：`elem.getBoundingClientRect()` 加上当前页面的滚动距离。\r\n\r\n`positon: fixed` 实现元素相对于窗口坐标系统的定位；`positon: absolute` 实现元素相对于文档坐标系统的定位。','2018-01-16 01:39:41','2018-01-16 02:21:46','modern-javascript-language-tutorial-coordinate-system'),(604,20,20,'现代 JavaScript 语言教程：遍历 DOM（未完待续）','> http://javascript.info/dom-navigation\r\n\r\n所有的 DOM 操作起始于 `docuement` 对象。我们可以用它访问任何节点。\r\n\r\n下面图片显示了 DOM 节点之间的遍历关系。\r\n\r\n![](http://javascript.info/article/dom-navigation/dom-links@2x.png)\r\n\r\n下面我们详细讨论：\r\n\r\n## docuementElement 和 body\r\n\r\n节点树最顶端的节点可以直接从 `document` 属性上获得。\r\n\r\n`<html> = document.documentElement`\r\n\r\n`document.documentElement` 对应 `<html>` 标签元素。\r\n\r\n`<body> = document.body`\r\n\r\n另一个广泛使用的 DOM 节点 `document.bpdy`，对应 `<body>` 标签元素。\r\n\r\n`<head> = document.head`\r\n\r\n`<head>` 标签使用 `document.head` 获得。\r\n\r\n## 孩子节点：childNodes、firstChild 和 lastChild','2018-01-16 03:00:51','2018-01-16 04:47:25','modern-javascript-language-tutorial-traverse-the-dom');
/*!40000 ALTER TABLE `discussions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `links`
--

DROP TABLE IF EXISTS `links`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `links` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(10) unsigned NOT NULL,
  `title` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `url` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` text COLLATE utf8mb4_unicode_ci,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `links_title_unique` (`title`),
  UNIQUE KEY `links_url_unique` (`url`),
  KEY `links_user_id_foreign` (`user_id`),
  CONSTRAINT `links_user_id_foreign` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=81 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `links`
--

LOCK TABLES `links` WRITE;
/*!40000 ALTER TABLE `links` DISABLE KEYS */;
INSERT INTO `links` VALUES (1,3,'Laravel 中文语言包','https://github.com/caouecs/Laravel-lang/tree/master/src/zh-CN',NULL,'2017-06-18 20:35:42','2017-06-18 20:35:42'),(2,3,'An Introduction to Laravel Authorization Gates','https://laravel-news.com/authorization-gates',NULL,'2017-06-18 20:41:12','2017-06-18 20:41:12'),(3,3,'Building Your First Laravel Application','https://laravel-news.com/your-first-laravel-application',NULL,'2017-06-18 20:41:57','2017-06-18 20:41:57'),(4,3,'Learn to use Model Factories in Laravel','https://laravel-news.com/learn-to-use-model-factories-in-laravel-5-1',NULL,'2017-06-18 20:42:26','2017-06-18 20:42:26'),(5,3,'CDN 服务 - unpkg.com','https://unpkg.com/#/',NULL,'2017-06-18 20:42:53','2017-06-18 20:42:53'),(6,3,'Apache 多端口多站点配置方法','http://www.jb51.net/article/24430.htm',NULL,'2017-06-18 20:43:13','2017-06-18 20:43:13'),(7,3,'Laravel Forms & HTML','https://laravelcollective.com/docs/master/html',NULL,'2017-06-18 20:43:33','2017-06-18 20:43:33'),(8,3,'理解OAuth 2.0','http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html',NULL,'2017-06-18 20:43:56','2017-06-18 20:43:56'),(9,3,'A PHP HTTP client that makes it easy to send HTTP requests — Guzzle Documentation','http://docs.guzzlephp.org/en/stable/quickstart.html',NULL,'2017-06-18 20:44:15','2017-06-18 20:44:15'),(10,3,'Windows 7 下安装 Composer','http://www.imooc.com/article/15544',NULL,'2017-06-18 20:44:31','2017-06-18 20:44:31'),(11,3,'Rollback one migration in Laravel 5.3','https://laravel-news.com/laravel-5-3-rollback-one-migration',NULL,'2017-06-18 20:56:37','2017-06-18 20:56:37'),(12,3,'Flex 布局教程','http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html',NULL,'2017-06-18 20:58:09','2017-06-18 20:58:09'),(13,3,'How to add Tagging to your Laravel App','https://laravel-news.com/how-to-add-tagging-to-your-laravel-app',NULL,'2017-06-18 20:59:56','2017-06-18 20:59:56'),(14,3,'Utilizing Laravel’s Cache with Query Params','https://laravel-news.com/cache-query-params',NULL,'2017-06-18 21:05:26','2017-06-18 21:05:26'),(15,3,'selectize.js：useful for tagging, contact lists, country selectors, and so on','https://github.com/selectize/selectize.js',NULL,'2017-06-20 01:52:27','2017-06-20 01:52:27'),(16,3,'getemoji.com','http://getemoji.com/',NULL,'2017-06-20 18:34:57','2017-06-20 18:34:57'),(17,3,'Laravel-Mix：引入带版本号的静态文件','https://laravel.com/docs/5.4/mix#versioning-and-cache-busting',NULL,'2017-06-20 22:55:43','2017-06-20 22:55:43'),(18,3,'bootcdn.cn','http://www.bootcdn.cn/',NULL,'2017-06-21 20:38:52','2017-06-21 20:38:52'),(19,3,'potvpn.com','https://my.potvpn.com/',NULL,'2017-06-22 04:45:32','2017-06-22 04:45:32'),(20,3,'Designing a Robust JSON API','https://thinkster.io/tutorials/design-a-robust-json-api',NULL,'2017-06-23 19:54:25','2017-06-23 19:54:25'),(21,3,'Monica is an open-source web application to organize the interactions with your loved ones','https://github.com/monicahq/monica/blob/master/readme.md#introduction',NULL,'2017-06-23 20:09:56','2017-06-23 20:09:56'),(22,3,'Laravel.io Community Portal','https://github.com/laravelio/portal/blob/master/readme.md',NULL,'2017-06-23 20:27:46','2017-06-23 20:27:46'),(23,3,'MariaDB Release Criteria','https://mariadb.com/kb/en/mariadb/release-criteria/',NULL,'2017-06-24 03:29:39','2017-06-24 03:29:39'),(24,3,'Sublime插件：Markdown篇','http://www.jianshu.com/p/aa30cc25c91b',NULL,'2017-06-26 17:42:19','2017-06-26 17:42:19'),(25,3,'安装 Node.js 和 Git','https://github.com/ruanyf/jstraining/blob/master/docs/preparation.md',NULL,'2017-06-27 17:35:24','2017-06-27 17:35:24'),(26,3,'Free themes for Bootstrap','http://bootswatch.com',NULL,'2017-06-27 23:56:49','2017-06-27 23:56:49'),(27,3,'Voyager - The Missing Laravel Admin','https://github.com/the-control-group/voyager',NULL,'2017-07-02 17:30:06','2017-07-02 17:30:06'),(28,3,'Laravel IDE Helper','https://github.com/barryvdh/laravel-ide-helper',NULL,'2017-07-03 01:59:37','2017-07-03 01:59:37'),(29,3,'SublimeCodeIntel','https://github.com/SublimeCodeIntel/SublimeCodeIntel',NULL,'2017-07-03 02:04:50','2017-07-03 02:04:50'),(30,3,'PHP 密码哈希','https://laravel-china.github.io/php-the-right-way/#password_hashing',NULL,'2017-07-03 02:19:09','2017-07-03 02:19:09'),(31,3,'Why Laravel Queues Are Awesome','https://scotch.io/tutorials/why-laravel-queues-are-awesome',NULL,'2017-07-03 22:15:26','2017-07-03 22:15:26'),(32,3,'VM VirtualBox','https://www.virtualbox.org/manual/ch01.html',NULL,'2017-07-05 06:08:21','2017-07-05 06:08:21'),(33,3,'Vagrant error on Windows 10','https://github.com/scotch-io/scotch-box/issues/195',NULL,'2017-07-05 17:18:40','2017-07-05 17:18:40'),(34,3,'Generate a JSON Feed with Laravel','https://laravel-news.com/generate-a-json-feed-with-laravel',NULL,'2017-07-05 20:23:20','2017-07-05 20:23:20'),(35,3,'HackerNews 克隆','https://vue-hn.now.sh/top',NULL,'2017-07-05 23:41:53','2017-07-05 23:41:53'),(36,3,'Laravel 5.1 LTS 速查表','https://cs.laravel-china.org/',NULL,'2017-07-06 00:03:25','2017-07-06 00:03:25'),(37,3,'Mysql导出表结构及表数据 mysqldump用法','http://www.cnblogs.com/yuanyouqi/archive/2010/04/28/1722738.html',NULL,'2017-07-06 01:06:13','2017-07-06 01:06:13'),(38,3,'MySQL 5.7 Reference Manual','https://dev.mysql.com/doc/refman/5.7/en/',NULL,'2017-07-06 01:37:26','2017-07-06 01:37:26'),(39,3,'在 .env 中使用变量','https://laravel-news.com/using-variables-in-your-env-file',NULL,'2017-07-06 05:24:42','2017-07-06 05:24:42'),(40,3,'Task Scheduling','https://divinglaravel.com/task-scheduling/before-the-dive',NULL,'2017-07-13 16:26:54','2017-07-13 16:26:54'),(41,3,'Cron','https://en.wikipedia.org/wiki/Cron',NULL,'2017-07-13 16:27:06','2017-07-13 16:27:06'),(42,3,'certbot.eff.org','https://certbot.eff.org/#centosrhel7-nginx',NULL,'2017-07-13 16:27:36','2017-07-13 16:27:36'),(43,3,'algolia laravel install','https://www.algolia.com/doc/api-client/laravel/install/',NULL,'2017-07-13 20:08:56','2017-07-13 20:08:56'),(44,3,'socket.io get started','https://socket.io/get-started/chat/',NULL,'2017-07-14 01:18:41','2017-07-14 01:18:41'),(45,3,'Laravel 路由模块绑定','https://laravel.com/docs/5.4/routing#route-model-binding','Model 中的 getRouteKeyName 方法；RouteServiceProvider 中的 Route::model 方法。','2017-08-17 02:43:47','2017-08-17 02:43:47'),(46,3,'Laravel 文档资源控制器','https://laravel.com/docs/5.4/controllers#resource-controllers','Route::resource(\'photos\', \'PhotoController\');','2017-08-17 02:55:16','2017-08-17 02:55:16'),(47,3,'Laravel Eloquent Relationships Through Macros','https://laravel-news.com/relationship-macros','AppServiceProvider 中\r\n\r\nHasMany::macro(\'toHasOne\', function() {\r\n        return new HasOne(\r\n            $this->query,\r\n            $this->parent,\r\n            $this->foreignKey,\r\n            $this->localKey\r\n        );\r\n});','2017-08-17 07:56:23','2017-08-17 07:56:23'),(48,3,'CSS深入理解——慕课网（imooc）张鑫旭前端教程','http://www.imooc.com/u/197450/courses?sort=publish',NULL,'2017-08-18 09:32:57','2017-08-18 09:32:57'),(49,3,'MySQL 日期格式化','http://www.cnblogs.com/dest/p/4205371.html',NULL,'2017-08-20 01:35:59','2017-08-20 01:35:59'),(50,3,'Ubuntu下shadowsocks 安装与配置','https://my.oschina.net/lieefu/blog/500774',NULL,'2017-08-21 08:39:18','2017-08-21 08:39:18'),(51,3,'mysql 手册','https://dev.mysql.com/doc/refman/5.7/en/entering-queries.html',NULL,'2017-08-26 09:17:36','2017-08-26 09:17:36'),(52,3,'awesome-laravel','https://github.com/chiraggude/awesome-laravel',NULL,'2017-08-26 14:03:06','2017-08-26 14:03:06'),(53,3,'MySQL中的共享锁与排他锁','http://www.hollischuang.com/archives/923',NULL,'2017-08-27 05:03:17','2017-08-27 05:03:17'),(54,3,'渐变效果','https://uigradients.com/#Shrimpy',NULL,'2017-08-29 05:53:53','2017-08-29 05:53:53'),(55,3,'Bootstrap 组件系列','http://www.cnblogs.com/zhangbao/category/966207.html',NULL,'2017-08-30 09:40:01','2017-08-30 09:40:01'),(56,3,'备案信息查询','http://www.miitbeian.gov.cn',NULL,'2017-09-05 15:11:05','2017-09-05 15:11:05'),(57,3,'Laravel 5.4: JSON Based Language Files','https://laravel-news.com/json-based-translations',NULL,'2017-09-06 09:19:07','2017-09-06 09:19:07'),(58,3,'CSS3 2D 转换','http://www.w3school.com.cn/css3/css3_2dtransform.asp',NULL,'2017-09-12 07:53:57','2017-09-12 07:53:57'),(59,3,'CSS3 3D 转换','http://www.w3school.com.cn/css3/css3_3dtransform.asp',NULL,'2017-09-12 07:54:30','2017-09-12 07:54:30'),(60,3,'animate.css','https://github.com/daneden/animate.css',NULL,'2017-09-13 02:10:11','2017-09-13 02:10:11'),(61,3,'画流程网站','https://www.processon.com',NULL,'2017-09-15 04:56:08','2017-09-15 04:56:08'),(62,3,'Cross-site request forgery','https://en.wikipedia.org/wiki/Cross-site_request_forgery',NULL,'2017-09-17 04:33:37','2017-09-17 04:33:37'),(63,3,'MySQL Sample Databases','https://dev.mysql.com/doc/index-other.html',NULL,'2017-09-21 14:32:51','2017-09-21 14:32:51'),(64,3,'Bootstrap 免费主题','https://bootswatch.com',NULL,'2017-09-23 05:39:21','2017-09-23 05:39:21'),(65,3,'Laravel 项目开发规范','https://fsdhub.com/books/laravel-specification',NULL,'2017-10-13 08:38:04','2017-10-13 08:38:04'),(66,3,'这些充满『强烈画面感』的音乐','http://music.163.com/#/m/playlist?id=156934569&userid=303959751',NULL,'2017-10-22 01:41:02','2017-10-22 01:41:02'),(67,3,'Swiper','http://idangero.us/swiper/get-started/','Most Modern Mobile Touch Slider','2017-10-22 11:06:12','2017-10-22 11:06:12'),(68,3,'jQuery 浏览器支持','http://jquery.com/browser-support/','jquery 3.2.1：IE9+，如需支持 IE 6-8，选择 [jQuery 1.12](https://code.jquery.com/jquery/#jquery-all-1.x)。','2017-10-23 00:25:19','2017-10-23 00:25:19'),(69,3,'The Ultimate Guide To iPhone Resolutions','https://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions',NULL,'2017-10-24 08:15:31','2017-10-24 08:15:31'),(70,3,'IntersectionObserver API 使用教程','http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html',NULL,'2017-10-30 05:29:25','2017-10-30 05:29:25'),(71,3,'SweetAlert','https://sweetalert.js.org/',NULL,'2017-11-02 07:15:10','2017-11-02 07:15:10'),(72,3,'axios','https://github.com/axios/axios','Promise based HTTP client for the browser and node.js','2017-11-03 09:25:22','2017-11-03 09:25:22'),(73,3,'CSS image hover effects','https://www.nxworld.net/tips/css-image-hover-effects.html',NULL,'2017-11-10 04:10:59','2017-11-10 04:10:59'),(74,3,'WordPress Backups','https://codex.wordpress.org/WordPress_Backups',NULL,'2017-11-21 09:32:51','2017-11-21 09:32:51'),(75,3,'A technical references','https://hackmd.io/s/Hyq8C6gGf','written by zhangbao(@baooab).','2017-12-15 09:56:43','2017-12-15 09:56:43'),(76,3,'CSS自动换行、强制不换行、强制断行、超出显示省略号','http://blog.csdn.net/liuyan19891230/article/details/50969393',NULL,'2017-12-22 01:56:49','2017-12-22 01:56:49'),(77,3,'Linux中apt与apt-get命令的区别与解释','https://www.sysgeek.cn/apt-vs-apt-get/',NULL,'2018-01-02 01:19:56','2018-01-02 01:19:56'),(78,3,'Atom 的 Tree View 隐藏了 .gitignore 里列出的文件或目录','https://talk.ninghao.net/t/atom-de-tree-view-yin-cang-liao-gitignore-li-lie-chu-de-wen-jian-huo-mu-lu/601',NULL,'2018-01-03 08:07:12','2018-01-03 08:07:12'),(79,3,'JavaScript: Ordered like an object.','http://javascript.info/object#ordered-like-an-object','if we loop over an object,  all properties order we get follow this rule: integer properties are sorted order, others appear in creation order.','2018-01-05 06:30:50','2018-01-05 06:30:50'),(80,20,'Vue.js双向绑定的实现原理','http://www.cnblogs.com/kidney/p/6052935.html',NULL,'2018-01-16 03:03:55','2018-01-16 03:03:55');
/*!40000 ALTER TABLE `links` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `migrations`
--

DROP TABLE IF EXISTS `migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `migrations` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `migration` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `batch` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `migrations`
--

LOCK TABLES `migrations` WRITE;
/*!40000 ALTER TABLE `migrations` DISABLE KEYS */;
INSERT INTO `migrations` VALUES (1,'2014_10_12_000000_create_users_table',1),(2,'2014_10_12_100000_create_password_resets_table',1),(3,'2017_06_07_094146_create_discussions_table',1),(4,'2017_06_08_090923_create_comments_table',1),(5,'2017_06_13_125707_create_categories_table',1),(6,'2017_06_13_132342_create_discussion_category_tables',1),(7,'2017_06_19_103103_create_links_table',1);
/*!40000 ALTER TABLE `migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `password_resets`
--

DROP TABLE IF EXISTS `password_resets`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `password_resets` (
  `email` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `token` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  KEY `password_resets_email_index` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `password_resets`
--

LOCK TABLES `password_resets` WRITE;
/*!40000 ALTER TABLE `password_resets` DISABLE KEYS */;
INSERT INTO `password_resets` VALUES ('3183442656@qq.com','$2y$10$Tn6jA8woyZJP.dpji0miFOsxDTteqMXEQkE.h7FTvQ2h3n8vFL3Vq','2017-11-02 10:43:46');
/*!40000 ALTER TABLE `password_resets` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `avatar` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `username` varchar(40) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `confirmation_code` varchar(60) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `confirmed` tinyint(1) NOT NULL DEFAULT '0',
  `type` smallint(6) NOT NULL DEFAULT '1',
  `remember_token` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `users_username_unique` (`username`),
  UNIQUE KEY `users_email_unique` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (3,'/storage/uploads/avatars/YBT1VY7XA95PsqpPI9lcQdZA1TkIcLo5hTYrN6VB.png','张宝','3183442656@qq.com','$2y$10$Pt2UYs2K8XC6YwhMjsVVzewPr5G.odHnl3N3sbTP5BMJZcmp6EHrW',NULL,1,3,'Fl7ZyYiUxig2pCDf2FJFy2s8ayaajhwTGVXf8b6D1vSGwTDNl9GsnWxNLhbY','2017-06-13 22:05:43','2017-08-11 02:42:00'),(4,'/images/default-avatar.png','su123155','346949790@qq.com','$2y$10$5EZT1YqHfzifTOuNQkQGgOy74DuVyR0NLdpGKoV2H2xMbjBFTYC2S',NULL,1,1,NULL,'2017-06-13 22:45:54','2017-06-13 22:46:22'),(5,'storage/uploads/avatars/594b72035ccff.png','pythonboy','satisty231@163.com','$2y$10$Yo8A7ruZZAcHGPwC9vwEFeljSsBIhwSd1A7/ueUx9U47nELXDeyy.',NULL,1,1,'QzzgXnOYY1E9bifZi990Gayo00o8OfHrOxseTVGIP2OxgffPE5Y101XUYvXO','2017-06-13 23:41:18','2017-08-31 05:26:14'),(6,'/images/default-avatar.png','rosicky814','rosicky814@sina.com','$2y$10$0RsYhnwQZKr3YHoUUwBkOuPt4mGeHgp2r85qBQqNt6Qw8eDK0wDjq',NULL,1,1,'5EPtRdD4NRTYKgnEeNlHFwdC9Vv0kgmyX2obCwFcQASalrMhJHOrzqGH9LrF','2017-06-14 00:17:31','2017-06-14 00:19:10'),(7,'storage/uploads/avatars/5940f51a04ac4.png','kimi_sun','165019474@qq.com','$2y$10$3iXkdgxWsVZFbt0Ot5DsXel.QRYTFYXldQXfP2moYXbyNCNLb5FHe',NULL,1,1,NULL,'2017-06-14 00:24:41','2017-06-14 00:34:34'),(8,'storage/uploads/avatars/5940fd98a39cf.jpg','王者','1912699076@qq.com','$2y$10$aWpfRY31cwFbd387Yp05NOxy0JDvf9hDamsUOu7pJ2ncCFV1bn4Py',NULL,1,1,'AY0JsXNfbzleewp6W46TIyJQYjVlIdDdIuye3pa0T8RI9ghc3g5w80R1nvlG','2017-06-14 01:02:07','2017-06-14 01:10:48'),(9,'storage/uploads/avatars/59413920229b2.jpg','Mr耿','genglulu97@163.com','$2y$10$M2RYKOCfRw.Fl2z5fVVUCebic4RdU6YCwjVRc2m3UhgQMgy8nAnaG',NULL,1,1,'6ov6t7XTz43vCVIz6WF55jvPAX72aMAt6eY4sY6zSdp2iMdxfKHC0C5kqqOE','2017-06-14 05:19:11','2017-09-05 13:21:56'),(10,'storage/uploads/avatars/59414ac8eb880.jpg','meng','1280041182@qq.com','$2y$10$wMM2VSxOxngEHG62z9EUjeTImPe2xPHqLqj2lBULLxfUoXcdUMVzC',NULL,1,1,NULL,'2017-06-14 06:33:10','2017-06-14 06:40:08'),(12,'/images/default-avatar.png','蓝也','snn406107490@qq.com','$2y$10$rYetJx8Z01hgovf6ToL0huD9opt3RN3PxBrn4.v7nc6nygGILEb5y','b4YeUiE2MgdDl4A246r7EZh3nWQcJu92xbbGgprgWpn8WncZv4RVmaFbsgIB',0,1,NULL,'2017-08-11 02:30:46','2017-08-11 02:30:46'),(13,'/images/default-avatar.png','Ford Wang','653134879@qq.com','$2y$10$nO6wTVOuIRb/j1Qqclok..JZF9ymAOafIDU1oYzW7qfmDNqfnUr3G',NULL,1,1,NULL,'2017-08-11 02:52:30','2017-08-11 02:52:42'),(15,'/storage/uploads/avatars/9KxNLKB6Eq8YqXUjfkY8XmwylYIovzERpI5kuTCF.jpeg','zhouxiaoshuai3','zhouxiaoshuai3@gmail.com','$2y$10$8d5mnNCcPlkYUe7exHMRa.fc5rdmUSbJQ6GfpQU9wAi1KM9Otn4i2','nJihyuGAQKcFw5m5EALzh9V3HrtDwA2EIMKY7nziML3n5pCWUcGU7IBuDpNR',0,1,NULL,'2017-08-31 06:21:41','2017-08-31 06:23:48'),(20,'/storage/uploads/avatars/9dHWbmFFVg9xtTdyqCE8tfAjavaGlDUfQwjt5bgL.jpeg','zhangbao','zhangbao90s@qq.com','$2y$10$HjPR8/4pbRg.pD96dKVygu3gGy/C/ES4kKfnb5vWZicuz8yAbOo42',NULL,1,1,'JiGPtUC0c7SuN3Ef1OkPswBMkVxIx2YbAUosO9Q6hI2QA4Zi8zWLFvacT1pB','2018-01-15 08:51:51','2018-01-15 08:57:54');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-01-17 14:26:26
